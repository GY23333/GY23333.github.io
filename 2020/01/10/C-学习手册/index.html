<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://gy23333.github.io').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="​    C++学习手册，主要是在C的基础上写出一些C++不同于C的点，部分C语言相通部分就不再赘述。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++学习手册">
<meta property="og:url" content="https://gy23333.github.io/2020/01/10/C-%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html">
<meta property="og:site_name" content="GuoYi的博客">
<meta property="og:description" content="​    C++学习手册，主要是在C的基础上写出一些C++不同于C的点，部分C语言相通部分就不再赘述。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2020/01/10/DT7fHNvbGzyVXIM.png">
<meta property="og:image" content="https://i.loli.net/2020/01/15/Sl2ne7PQgsriDfO.png">
<meta property="og:image" content="https://i.loli.net/2020/01/15/opaRJDAg7B2nd54.png">
<meta property="article:published_time" content="2020-01-09T18:36:52.000Z">
<meta property="article:modified_time" content="2024-11-11T03:57:58.131Z">
<meta property="article:author" content="GuoYi">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="入门">
<meta property="article:tag" content="Xcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/01/10/DT7fHNvbGzyVXIM.png">

<link rel="canonical" href="https://gy23333.github.io/2020/01/10/C-%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>C++学习手册 | GuoYi的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="GuoYi的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">GuoYi的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-music">

    <a href="/music/" rel="section"><i class="fa fa-fw fa-music"></i>music</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://gy23333.github.io/2020/01/10/C-%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://res.cloudinary.com/dh7ramrlh/image/upload/v1576578789/gy/IMG_0324_o40dwv.jpg">
      <meta itemprop="name" content="GuoYi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GuoYi的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++学习手册
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-10 02:36:52" itemprop="dateCreated datePublished" datetime="2020-01-10T02:36:52+08:00">2020-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-11 11:57:58" itemprop="dateModified" datetime="2024-11-11T11:57:58+08:00">2024-11-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/01/10/C-%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/01/10/C-%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>​    C++学习手册，主要是在C的基础上写出一些C++不同于C的点，部分C语言相通部分就不再赘述。</p>
<a id="more"></a>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="使用-VS-Code-搭建C-开发环境（MAC）"><a href="#使用-VS-Code-搭建C-开发环境（MAC）" class="headerlink" title="使用 VS Code 搭建C++开发环境（MAC）"></a>使用 VS Code 搭建C++开发环境（MAC）</h2><p><a href="https://www.bilibili.com/video/BV1sW411v7VZ?p=2" target="_blank" rel="noopener">参考视频</a></p>
<ol>
<li>在VS Code上安装好相应插件：C/C++、CodeLLDB</li>
<li>新建工作目录，编写C++文件</li>
<li>在Debug中创建launch.json文件，选择LLDB</li>
<li>将<code>&lt;your program&gt;</code>替换为<code>${fileBasenameNoExtension}</code></li>
<li>选择cpp文件，建立Build文件，Shift+Command+P切出面板，选择Tasks:Configure Task -&gt; C/C++ clang++ build active file</li>
<li>在”args”中添加C++标准<code>&quot;-std=c++2a&quot;</code></li>
<li>在launch.json中的”configurations”中添加<code>&quot;preLaunchTask&quot;: &quot;C/C++: clang++ build active file&quot;</code>(与tasks.json中的label一致)</li>
</ol>
<h2 id="Xcode引入iostream库失败"><a href="#Xcode引入iostream库失败" class="headerlink" title="Xcode引入iostream库失败"></a>Xcode引入iostream库失败</h2><p>提示 ‘iostream’ file not found的解决办法：</p>
<p>在Build Settings -&gt; Search paths -&gt;System Header Search Paths中添加路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Toolchains&#x2F;XcodeDefault.xctoolchain&#x2F;usr&#x2F;include&#x2F;c++&#x2F;v1&#x2F;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/01/10/DT7fHNvbGzyVXIM.png" alt=""></p>
<p>添加后，C++库引入成功。</p>
<h1 id="从C到C"><a href="#从C到C" class="headerlink" title="从C到C++"></a>从C到C++</h1><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>C++输入输出需使用iostream库</p>
<h3 id="标准输出cout"><a href="#标准输出cout" class="headerlink" title="标准输出cout"></a>标准输出cout</h3><p>std :: cout 是输出内容，&lt;&lt; 是输出运算符，std :: endl 结束改行，相当于一个”\n”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, World!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, World!\n"</span> ;</span><br></pre></td></tr></table></figure>
<h3 id="标准输入cin"><a href="#标准输入cin" class="headerlink" title="标准输入cin"></a>标准输入cin</h3><p>std :: cin 是输入内容，&gt;&gt; 是输入运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Input a and b."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of a and b is "</span> &lt;&lt; a+b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用标准库中的名字"><a href="#使用标准库中的名字" class="headerlink" title="使用标准库中的名字"></a>使用标准库中的名字</h3><p>​     std::表示cout和cin是定义在名为std的<strong>命名空间</strong>中的，可以通过<strong>using namespace</strong>来进行命名空间的缩略。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><p>​    while语句反复执行一段代码，直至条件判断为错误。</p>
<h4 id="读取数量不定的输入数据"><a href="#读取数量不定的输入数据" class="headerlink" title="读取数量不定的输入数据"></a>读取数量不定的输入数据</h4><p>​    利用std::cin进行输入不定的输入。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    不断输入数字求和，直至输入不是数字结束</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, value = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Input number."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; value) &#123; <span class="comment">//当输入不为数字时判断为false</span></span><br><span class="line">        sum += value;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Input number."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sum is "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    已经定义了value为int型，所以在 cin&gt;&gt;value 输入不为int型时，则判断为false。</p>
<p>​    也可用文件结束符，输入Ctrl+D</p>
<h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><p>​    for(初始化语句; 循环条件; 表达式)</p>
<h4 id="遍历数组中的元素"><a href="#遍历数组中的元素" class="headerlink" title="遍历数组中的元素"></a>遍历数组中的元素</h4><ol>
<li><p>​    一维数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> scores[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : scores) &#123; <span class="comment">//遍历数组scores中的元素</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多维数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ia[<span class="number">2</span>][<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;row : ia) &#123; <span class="comment">//遍历二维数组ia外层数组的每一个元素（这里相当于遍历每行）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;col : row) &#123; <span class="comment">//遍历二维数组ia内层数组的每一个元素</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; col;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>同一作用域内，可以有同名函数，给函数多个定义，但形参必须不同，加以区分。</p>
<p>形参不同，指参数的类型、参数的个数和参数的顺序，至少有一个不同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三个形参不同的print函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2.5</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h1><h1 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a>变量和基本类型</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>​    相当于把各种数据打包组成了一个集合来调用。</p>
<p>​    下面以建立和使用一个书籍销售单类Sales_data为例。</p>
<h3 id="建立头文件"><a href="#建立头文件" class="headerlink" title="建立头文件"></a>建立头文件</h3><p>​    为保障各文件中的类的定义一致，类通常被定义在头文件中。这里我们建立一个名为Sales_data.h的头文件来转载Sales_data类的定义。</p>
<p>​    头文件一般最好进行预处理，添加头文件保护符：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>#define</th>
<th style="text-align:left">把名字设定为预处理变量</th>
</tr>
</thead>
<tbody>
<tr>
<td>#ifdef</td>
<td style="text-align:left">当且仅当变量已定义时为真</td>
</tr>
<tr>
<td>#ifndef</td>
<td style="text-align:left">当且仅当变量未被定义时为真</td>
</tr>
<tr>
<td>#endif</td>
<td style="text-align:left">判断为真后，执行到#endif结束</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> Sales_data_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Sales_data_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo; <span class="comment">// 书籍编号</span></span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>; <span class="comment">// 销售数量</span></span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>; <span class="comment">// 销售收入</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="使用类定义"><a href="#使用类定义" class="headerlink" title="使用类定义"></a>使用类定义</h3><p>​    调用该.h文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Sales_data.h"</span></span></span><br></pre></td></tr></table></figure>
<p>​    定义类变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sales_data data1;</span><br></pre></td></tr></table></figure>
<p>​    利用.来访问类中的对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Sales_data.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Sales_data data1;</span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">0.0</span>; <span class="comment">// 书籍单价</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Input book_No, sold_num and price."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; data1.bookNo &gt;&gt; data1.units_sold &gt;&gt; price;</span><br><span class="line">    data1.revenue = price * data1.units_sold;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Book "</span> &lt;&lt; data1.bookNo &lt;&lt; <span class="string">"'s revenue is "</span> &lt;&lt; data1.revenue &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>​    迭代器是一种检查容器内元素并遍历元素的数据类型。可以替代下标访问vector对象的元素。可以理解为指向容器内元素的指针。</p>
<h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><p>​    begin 返回指向第一个元素的迭代器，end 返回指向容器尾元素的下一个位置的迭代器（实际上是不存在的）。当begin和end返回的为同一迭代器，则该容器为空。</p>
<p>​    不在意迭代器的类型，一般定义为auto。</p>
<h4 id="迭代器运算符"><a href="#迭代器运算符" class="headerlink" title="迭代器运算符"></a>迭代器运算符</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>*iter</td>
<td>返回迭代器iter所指的元素的引用</td>
</tr>
<tr>
<td>Iter-&gt;mem</td>
<td>解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem</td>
</tr>
<tr>
<td>++iter</td>
<td>令iter指示容器中的下一个元素</td>
</tr>
<tr>
<td>—iter</td>
<td>令iter指示容器中的上一个元素</td>
</tr>
<tr>
<td>iter1 == iter2 / iter1 != iter2</td>
<td>判断两迭代器是否相等。如两迭代器指示的是同一个元素或者它们是同一个容器或者它们是同一个容器的尾后迭代器，则相等。</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    将首单词的首字母大写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"hello world."</span>;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">begin</span>() != s.<span class="built_in">end</span>()) &#123; <span class="comment">// s不为空</span></span><br><span class="line">        <span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); <span class="comment">// 指向首单词的迭代器</span></span><br><span class="line">        *it = <span class="built_in">toupper</span>(*it); <span class="comment">// 将it迭代器所指的元素的引用首字母大写</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代器运算"><a href="#迭代器运算" class="headerlink" title="迭代器运算"></a>迭代器运算</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>iter + n / iter - n</td>
<td>加或减n个位置得到一个迭代器</td>
</tr>
<tr>
<td>iter += n / iter -= n</td>
<td>加或减n个位置得到一个迭代器赋给iter本身</td>
</tr>
<tr>
<td>iter1 - iter2</td>
<td>iter1与iter2之间的位置差</td>
</tr>
<tr>
<td>&gt; 、&gt;=、&lt;、&lt;=</td>
<td>比较位置</td>
</tr>
</tbody>
</table>
</div>
<h2 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a>try语句块和异常处理</h2><h3 id="throw表达式"><a href="#throw表达式" class="headerlink" title="throw表达式"></a>throw表达式</h3><p>​    throw表达式，异常检测部分使用throw表达式来<strong>表示</strong>它遇到了无法处理的问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    检验输入是否是数字，不是则抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Input a number."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">char</span> input;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; input;</span><br><span class="line">    <span class="keyword">if</span> (input &gt;= <span class="string">'0'</span> &amp;&amp; input &lt;= <span class="string">'9'</span>) &#123; <span class="comment">//输入为数字</span></span><br><span class="line">        number = input - <span class="string">'0'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//输入不为数字</span></span><br><span class="line">        <span class="keyword">throw</span> runtime_error(<span class="string">"Input not number."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当输入不为数字时，运行到throw语句时卡住，并输出异常信息。</p>
<p><img src="https://i.loli.net/2020/01/15/Sl2ne7PQgsriDfO.png" style="zoom:50%;" /></p>
<p><img src="https://i.loli.net/2020/01/15/opaRJDAg7B2nd54.png" style="zoom: 50%;" /></p>
<h3 id="try语句块"><a href="#try语句块" class="headerlink" title="try语句块"></a>try语句块</h3><p>​    try语句块，异常处理部分使用try语句块<strong>处理</strong>异常。try尝试一个代码块，如有异常通常会被catch捕捉处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">//测试的代码块</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(exception-declaration) &#123; <span class="comment">//exception-declaration异常声明</span></span><br><span class="line">	<span class="comment">//异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-面向对象"><a href="#C-面向对象" class="headerlink" title="C++面向对象"></a>C++面向对象</h1><p>C++面向对象的三大特性：封装、继承、多态。</p>
<p>万事万物都是对象，具有相同属性的对象可以抽象成一个类。</p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="类和对象的定义"><a href="#类和对象的定义" class="headerlink" title="类和对象的定义"></a>类和对象的定义</h3><p>把类的所有成员（变量和函数）封装起来，并加以权限限制。</p>
<ul>
<li>语法：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名 &#123;</span></span><br><span class="line">访问权限:</span><br><span class="line">    成员变量</span><br><span class="line">    成员函数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>示例：设计一个圆类，求圆的周长</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个圆类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//访问权限</span></span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">double</span> r; <span class="comment">//半径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员函数</span></span><br><span class="line">    <span class="comment">//计算周长</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calculate_circumference</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * PI * r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Circle c1; <span class="comment">//声明一个圆对象</span></span><br><span class="line">    c1.r = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"周长为："</span> &lt;&lt; c1.calculate_circumference() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>成员函数也可在类的外部，使用范围解析运算符<code>::</code>定义</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员函数声明</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calculate_circumference</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Circle::calculate_circumference</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * PI * r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>类成员的访问限制共三种：<code>public</code>、<code>private</code>、<code>protected</code></p>
<ul>
<li>公共权限 <code>public</code><ul>
<li>类内、类外都可访问</li>
</ul>
</li>
<li>保护权限 <code>protected</code><ul>
<li>类内可访问，派生类可访问，类外不可访问</li>
</ul>
</li>
<li>私有权限 <code>private</code><ul>
<li>只允许类内访问</li>
<li>如果没有使用任何访问修饰符，默认为私有权限</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>访问权限</th>
<th>public</th>
<th>protected</th>
<th style="text-align:left">private</th>
</tr>
</thead>
<tbody>
<tr>
<td>类内</td>
<td>可访问</td>
<td>可访问</td>
<td style="text-align:left">可访问</td>
</tr>
<tr>
<td>派生类</td>
<td>可访问</td>
<td>可访问</td>
<td style="text-align:left">不可访问</td>
</tr>
<tr>
<td>类外</td>
<td>可访问</td>
<td>不可访问</td>
<td style="text-align:left">不可访问</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><code>struct</code>和<code>class</code>的区别：<br><code>struct</code>和<code>class</code>都可以表示类，但默认的权限不同。<br>如果成员没有使用任何访问修饰符，<code>struct</code>默认为公共成员，<code>class</code>默认为私有成员。</p>
</blockquote>
<p><strong>类内访问 &amp; 类外访问</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//公共成员</span></span><br><span class="line">    <span class="comment">//类内可访问，类外可访问</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getPassword</span><span class="params">()</span></span>; <span class="comment">//读函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(<span class="built_in">string</span> pass)</span></span>; <span class="comment">//写函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//保护成员</span></span><br><span class="line">    <span class="comment">//类内可访问，类外不可访问</span></span><br><span class="line">    <span class="built_in">string</span> address;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//私有成员</span></span><br><span class="line">    <span class="comment">//类内可访问，类外不可访问</span></span><br><span class="line">    <span class="built_in">string</span> password;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Person::getPassword</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> password; <span class="comment">//类内访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person::setPassword</span> <span class="params">(<span class="built_in">string</span> pass)</span> </span>&#123;</span><br><span class="line">    password = pass; <span class="comment">//类内访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正确，类外可访问公共成员</span></span><br><span class="line">    p1.name = <span class="string">"ZhangSan"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p1.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误，类外不可访问保护/私有成员</span></span><br><span class="line">    <span class="comment">// p1.password = "123456";</span></span><br><span class="line"></span><br><span class="line">    p1.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p1.getPassword() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一般都把成员变量设置为<code>private</code>权限，然后在<code>public</code>中设置读写函数，以便控制读写权限。</p>
</blockquote>
<h3 id="构造函数-析构函数"><a href="#构造函数-析构函数" class="headerlink" title="构造函数/析构函数"></a>构造函数/析构函数</h3><p>构造函数/析构函数是两个特殊的成员函数，分别在创建对象/销毁对象时被自动调用，用于完成对象初始化/清理工作。</p>
<p>即使不主动编辑构造函数/析构函数，编译器也会自动提供两个空函数作为构造函数/析构函数。</p>
<ul>
<li>构造函数<ul>
<li>创建对象时，自动调用一次，用于完成对象初始化</li>
<li>函数名与类名相同 <code>类名() {}</code></li>
<li>可以有参数，不会有返回值，也不会返回<code>void</code></li>
</ul>
</li>
<li><p>析构函数</p>
<ul>
<li>销毁对象时，自动调用一次，用于完成清理工作</li>
<li>函数名与类名相同，加个前缀<code>~</code>， <code>~类名() {}</code></li>
<li>不能有参数，不会有返回值，也不会返回<code>void</code></li>
</ul>
</li>
<li><p>语法框架</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    类名(<span class="comment">/* args */</span>); <span class="comment">//构造函数，可以有参数</span></span><br><span class="line">    ~类名(); <span class="comment">//析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">类名::类名(<span class="comment">/* args */</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">类名::~类名()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Line(); <span class="comment">//构造函数</span></span><br><span class="line">    ~Line(); <span class="comment">//析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Line::Line() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Line::~Line() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用析构函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Line <span class="built_in">line</span>; <span class="comment">//创建对象，自动调用构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//销毁对象时，自动调用析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="构造函数的分类和调用方式"><a href="#构造函数的分类和调用方式" class="headerlink" title="构造函数的分类和调用方式"></a>构造函数的分类和调用方式</h3><h4 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h4><ul>
<li><p>函数结构</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">className() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用方法（定义对象）</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">className c;</span><br></pre></td></tr></table></figure>
<p>  定义无参构造的对象的错误写法<code>className c();</code>，不能加<code>()</code>，不然会与函数的声明弄混。</p>
</li>
</ul>
<h4 id="有参构造"><a href="#有参构造" class="headerlink" title="有参构造"></a>有参构造</h4><p>以<code>int</code>型参数为例</p>
<ul>
<li><p>函数结构</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">className(<span class="keyword">int</span> x) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用方法（定义对象）</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">className <span class="title">c</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//方法一：括号法</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">className c = className(<span class="number">10</span>); <span class="comment">//方法二：显示法</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">className c = <span class="number">10</span>; <span class="comment">//方法三：隐式转换法</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>示例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Line::Line(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">    A = a;</span><br><span class="line">    B = b;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用初始化列表来初始化字段，两种方法等效</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Line::Line(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : A(a), B(b)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h4><p>拷贝构造函数，即复制一个对象，生成新对象。</p>
<ul>
<li><p>函数结构</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">className(<span class="keyword">const</span> className &amp;obj) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <code>const</code>防止被拷贝的数据obj被修改，且须用引用传递，而不能用值传递。</p>
</li>
<li><p>调用方法（定义对象）</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">className <span class="title">c</span><span class="params">(obj)</span></span>; <span class="comment">//方法一：括号法</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">className c = className(obj); <span class="comment">//方法二：显示法</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">className c = obj; <span class="comment">//方法三：隐式转换法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用时机</p>
<ul>
<li><p>使用一个对象，拷贝出一个新对象</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Line <span class="title">l1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Line <span class="title">l2</span><span class="params">(l1)</span></span>; <span class="comment">//调用拷贝构造</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>值方式传递参数时，复制副本</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Line l)</span> </span>&#123; <span class="comment">//值传递，复制原对象l，调用拷贝构造</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>值方式返回局部对象时，复制副本</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">( &#123; </span></span></span><br><span class="line"><span class="function"><span class="params">    ...</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> l; <span class="comment">//复制原对象l，返回副本，调用拷贝构造</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>无参/有参/拷贝构造示例</strong></p>
<p>定义<code>line</code>类，分别用无参/有参构造函数，定义两个<code>length</code>相同的对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Line(); <span class="comment">//无参构造函数</span></span><br><span class="line">    Line(<span class="keyword">int</span> len); <span class="comment">//有参构造函数</span></span><br><span class="line">    Line(<span class="keyword">const</span> Line &amp;obj); <span class="comment">//拷贝构造函数</span></span><br><span class="line">    ~Line();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">int</span> len)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无参构造函数</span></span><br><span class="line">Line::Line() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"无参构造函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line">Line::Line(<span class="keyword">int</span> len) &#123;</span><br><span class="line">    length = len;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"有参构造函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line">Line::Line(<span class="keyword">const</span> Line &amp;obj) &#123;</span><br><span class="line">    length = obj.length;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"拷贝构造函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Line::~Line() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"析构函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Line::setLength</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    length = len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Line::getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Line l1; <span class="comment">//无参构造</span></span><br><span class="line">    l1.setLength(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">Line <span class="title">l2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//有参构造</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Line <span class="title">l3</span><span class="params">(l2)</span></span>; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造函数的调用规则"><a href="#构造函数的调用规则" class="headerlink" title="构造函数的调用规则"></a>构造函数的调用规则</h4><p>默认情况下，编译器会自动给一个类添加3个函数：</p>
<ul>
<li>默认构造函数（无参，空函数）</li>
<li>默认析构函数（空函数）</li>
<li>默认拷贝构造函数（对属性进行值拷贝）</li>
</ul>
<p>如用户自行定义了有参构造函数，编译器将不再提供默认无参构造函数，但依旧提供默认拷贝构造函数；</p>
<p>如用户自行定义了拷贝构造函数，编译器将不再提供其他构造函数。</p>
<h3 id="对象参数的引用传递"><a href="#对象参数的引用传递" class="headerlink" title="对象参数的引用传递"></a>对象参数的引用传递</h3><ul>
<li><p>传递对象参数时，最好用引用传递<code>void func(className &amp;obj);</code></p>
<p>  如为值传递，即<code>void func(className obj);</code>，调用该函数时，要复制生成新的对象，调用拷贝构造函数，结束时，还需要调用析构函数来做清理工作。时间效率低。</p>
<p>  如为引用传递，即<code>void func(className &amp;obj);</code>，调用该函数时，直接用原对象，不需要生成新对象。</p>
<p>  当不修改对象时，应当将参数声明为const引用。</p>
</li>
<li><p>拷贝构造函数的参数必须是引用，且最好用const引用<code>className(const className &amp;obj);</code></p>
<p>  如果使用值传递，即<code>className(className obj);</code>，则传值时会调用拷贝构造函数，会出现无穷递归调用拷贝构造函数的情况，所以拷贝构造函数的参数不能使用值传递。</p>
</li>
</ul>
<h3 id="深拷贝-浅拷贝"><a href="#深拷贝-浅拷贝" class="headerlink" title="深拷贝/浅拷贝"></a>深拷贝/浅拷贝</h3><p>浅拷贝，即简单的赋值拷贝，默认拷贝构造即是浅拷贝。</p>
<p>如定义一个类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> m_age) &#123;</span><br><span class="line">        age = m_age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>编译器会自动生成默认拷贝构造函数，即</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person(<span class="keyword">const</span> Person &amp;obj) &#123;</span><br><span class="line">    age = obj.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用拷贝构造函数，即可进行简单拷贝，也就是浅拷贝。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br></pre></td></tr></table></figure>
<p>浅拷贝可以处理一般的对象拷贝，所以不需要额外写拷贝构造函数，直接用默认的拷贝构造函数，即可进行浅拷贝。</p>
<p>但一旦类带有指针变量，用浅拷贝就会出现错误。</p>
<p>如下面的类中，带有指针变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">height</span>; <span class="comment">//指针变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> m_age, <span class="keyword">int</span> m_height) &#123;</span><br><span class="line">        age = m_age;</span><br><span class="line">        <span class="built_in">height</span> = <span class="keyword">new</span> <span class="keyword">int</span>(m_height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        <span class="comment">//析构函数，释放堆区动态分配的空间</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">height</span> != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">height</span>;</span><br><span class="line">            <span class="built_in">height</span> = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果使用编译器的默认拷贝构造函数，进行浅拷贝</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person(<span class="keyword">const</span> Person &amp;obj) &#123;</span><br><span class="line">    age = obj.age;</span><br><span class="line">    <span class="built_in">height</span> = obj.<span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>p2</code>的<code>height</code>与<code>p1</code>的<code>height</code>完全相同，都是指向堆区同一地址的指针。</p>
<p>在析构函数释放空间时，先释放完<code>p1</code>的<code>height</code>，对<code>p2</code>析构时，<code>height</code>已经释放，无法重新释放，发生错误。</p>
<p>所以类带有指针变量，并有动态内存分配，则必须自行定义拷贝构造函数，进行深度拷贝。</p>
<p>深拷贝，即在堆区重新申请空间，内容相同，但是不同的地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">height</span>; <span class="comment">//指针变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> m_age, <span class="keyword">int</span> m_height) &#123;</span><br><span class="line">        age = m_age;</span><br><span class="line">        <span class="built_in">height</span> = <span class="keyword">new</span> <span class="keyword">int</span>(m_height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(<span class="keyword">const</span> Person &amp;obj) &#123;</span><br><span class="line">        age = obj.age;</span><br><span class="line">        <span class="comment">//深拷贝</span></span><br><span class="line">        <span class="built_in">height</span> = <span class="keyword">new</span> <span class="keyword">int</span>(*obj.<span class="built_in">height</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        <span class="comment">//析构函数，释放堆区动态分配的空间</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">height</span> != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">height</span>;</span><br><span class="line">            <span class="built_in">height</span> = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>每一个对象都能通过<code>this</code>指针来访问自己的地址，<code>this</code>指针指向被调用成员函数的所属对象。</p>
<p>主要用途：</p>
<ul>
<li>形参和成员变量同名时，用<code>this</code>指针加以区分</li>
<li>返回对象本身</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>在类成员前加上<code>static</code>，称为静态成员。当声明成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本，静态成员在类的所有对象中是共享的。</p>
<h4 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h4><ul>
<li>该类的所有对象共享同一份数据</li>
<li>编译阶段分配内存</li>
<li>类内声明，类外初始化</li>
<li>访问静态成员，可以用<code>p1.A</code>或者<code>Person::A</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> A; <span class="comment">//类内声明静态成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Person::A = <span class="number">10</span>; <span class="comment">//类外初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p1.A &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有对象共享同一份数据，所以修改p2的A，p1的A也会相应变化</span></span><br><span class="line">    Person p2;</span><br><span class="line">    p2.A = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p1.A &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h4><ul>
<li><p>该类的所有对象共享同一个函数</p>
</li>
<li><p>静态成员函数只能访问静态成员</p>
</li>
<li><p>静态成员函数与普通成员函数的根本区别在于：</p>
<ul>
<li>普通成员函数有<code>this</code>指针，可以访问类中的任意成员</li>
<li>静态成员函数没有<code>this</code>指针，只能访问静态成员（包括静态成员变量和静态成员函数）</li>
</ul>
</li>
</ul>
<p>静态成员函数的作用：方便调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用<code>func1()</code>时，需要先生成类对象，才能调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Solution s;</span><br><span class="line">s.func1();</span><br></pre></td></tr></table></figure>
<p>调用静态成员函数<code>func2()</code>时，可以直接调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Solution::func2();</span><br></pre></td></tr></table></figure>
<h3 id="const常函数和常对象"><a href="#const常函数和常对象" class="headerlink" title="const常函数和常对象"></a>const常函数和常对象</h3><p>如果不希望数据被修改，可以加上<code>const</code>关键字来修饰成员变量、成员函数、对象。</p>
<h4 id="常函数"><a href="#常函数" class="headerlink" title="常函数"></a>常函数</h4><ul>
<li>成员函数后加<code>const</code></li>
<li>常函数内不能修改成员变量</li>
<li>如果成员变量前加<code>mutable</code>，则可在常函数内改变该变量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">//常函数</span></span><br><span class="line">        m_A = <span class="number">100</span>; <span class="comment">//错误，常函数中普通成员变量无法修改</span></span><br><span class="line">        m_B = <span class="number">100</span>; <span class="comment">//正确，mutable变量可在常函数中修改</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> m_B; <span class="comment">//加入mutable后，可在常函数中修改</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>成员函数中调用<code>m_A</code>，实际是调用了<code>this -&gt; m_A</code></p>
<p>成员函数的<code>this</code>指针，本质是指针常量，也就是指针本身是一个常量，地址不变，即<code>Person * const this;</code>，此时<code>this</code>一直指向对象本身</p>
<p>如果为常函数，<code>const</code>修饰的是<code>this</code>指针的指向，<code>this</code>指针的指向的值内容不变，即<code>const Person * const this;</code>，此时<code>this</code>指向对象的内容不能被修改</p>
<p><code>get</code>类型的成员函数一般都采用常函数，只需获取，不需修改</p>
</blockquote>
<h4 id="常对象"><a href="#常对象" class="headerlink" title="常对象"></a>常对象</h4><ul>
<li>对象前加<code>const</code></li>
<li>不能修改一般的成员变量，但可以修改<code>mutable</code>的成员变量</li>
<li>常对象只能调用<code>const</code>常函数（不能调用普通函数，因为普通的成员函数可能会修改成员变量）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">get_name</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">//常函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_age</span><span class="params">(<span class="keyword">int</span> age)</span></span>; <span class="comment">//普通成员函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> m_b;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> m_age; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person::Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) : m_name(name), m_age(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Person::get_name</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person::set_age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    m_age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Person <span class="title">p</span><span class="params">(<span class="string">"Job"</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p.get_name() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//正确，常对象只能调用常函数</span></span><br><span class="line">    p.set_age(<span class="number">30</span>); <span class="comment">//错误，常对象无法调用普通成员函数</span></span><br><span class="line">    </span><br><span class="line">    p.m_a = <span class="number">100</span>; <span class="comment">//错误，常对象无法修改普通成员变量</span></span><br><span class="line">    p.m_b = <span class="number">100</span>; <span class="comment">//正确，常对象能修改mutable成员变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>友元定义在类的外部，不属于类的成员，但有访问<code>private</code>和<code>protected</code>的权限，在类中用关键字<code>friend</code>声明函数/类，即可将其设定为友元。</p>
<h4 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h4><p>将全局函数加上关键字<code>friend</code>，在类中声明为友元，即可使其能够访问<code>private</code>和<code>protected</code>的权限成员。</p>
<p>尽管在类中有声明，但友元函数并不是成员函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//将全局函数设置为友元，允许其访问私有成员</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">print_age</span><span class="params">(Person &amp;p)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_age</span><span class="params">(<span class="keyword">int</span> age)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person::set_age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    m_age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_age</span><span class="params">(Person &amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p.m_age &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//允许访问私有成员m_age</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    p.set_age(<span class="number">18</span>);</span><br><span class="line">    print_age(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h4><p>将类加上关键字<code>friend</code>，在类中声明为友元，即可使其能够访问<code>private</code>和<code>protected</code>的权限成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="comment">//将类设置为友元，允许其访问私有成员</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonFriend</span>;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person()&#123;</span><br><span class="line">        m_age = <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonFriend</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line">    PersonFriend();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Person *p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PersonFriend::PersonFriend()&#123;</span><br><span class="line">    p = <span class="keyword">new</span> Person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PersonFriend::visit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p-&gt;m_age &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//可以访问Person类对象的私有成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    PersonFriend pf;</span><br><span class="line">    pf.visit();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。</p>
<p>函数重载和普通的函数重载一致，利用形参的不同加以区分。</p>
<p>运算符重载，则是重新定义运算符，以适应类的运算。</p>
<p>运算符重载是通过函数实现的，它本质上是函数重载。可以作为类的成员函数，还可以作为全局函数。</p>
<p>在运算符前加上关键词<code>operator</code>，作为声明时的函数名。</p>
<ul>
<li>可重载的运算符</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td>双目算术运算符</td>
<td>+ (加)，-(减)，*(乘)，/(除)，% (取模)</td>
</tr>
<tr>
<td>关系运算符</td>
<td>==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于)，&lt;=(小于等于)，&gt;=(大于等于)</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>\</td>
<td>\</td>
<td>(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)</td>
</tr>
<tr>
<td>单目运算符</td>
<td>+ (正)，-(负)，*(指针)，&amp;(取地址)</td>
</tr>
<tr>
<td>自增自减运算符</td>
<td>++(自增)，—(自减)</td>
</tr>
<tr>
<td>位运算符</td>
<td>\</td>
<td>(按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>=, +=, -=, *=, /= , % = , &amp;=,</td>
<td>=, ^=, &lt;&lt;=, &gt;&gt;=</td>
</tr>
<tr>
<td>空间申请与释放</td>
<td>new, delete, new[ ] , delete[]</td>
</tr>
<tr>
<td>其他运算符</td>
<td>()(函数调用)，-&gt;(成员访问)，,(逗号)，[](下标)</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>不可重载的运算符<ul>
<li><code>.</code>：成员访问运算符</li>
<li><code>.*</code>, <code>-&gt;*</code>：成员指针访问运算符</li>
<li><code>::</code>：域运算符</li>
<li><code>sizeof</code>：长度运算符</li>
<li><code>?:</code>：条件运算符</li>
<li><code>#</code>： 预处理符号</li>
</ul>
</li>
</ul>
<h3 id="负号-重载（一元）"><a href="#负号-重载（一元）" class="headerlink" title="负号-重载（一元）"></a>负号<code>-</code>重载（一元）</h3><ul>
<li>作为类的成员函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex (<span class="keyword">int</span> i, <span class="keyword">int</span> j);</span><br><span class="line">    <span class="comment">//重载-，作为类的成员函数</span></span><br><span class="line">    Complex <span class="keyword">operator</span>- ();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_i;</span><br><span class="line">    <span class="keyword">int</span> m_j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex :: Complex (<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">    m_i = i;</span><br><span class="line">    m_j = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载-</span></span><br><span class="line">Complex Complex :: <span class="keyword">operator</span>- () &#123;</span><br><span class="line">    m_i = -m_i;</span><br><span class="line">    m_j = -m_j;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>还可以作为全局函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">    <span class="comment">//重载-，在全局范围内重载运算符，设置为友元函数</span></span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>- (Complex &amp;c);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex (<span class="keyword">int</span> i, <span class="keyword">int</span> j);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_i;</span><br><span class="line">    <span class="keyword">int</span> m_j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex :: Complex (<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">    m_i = i;</span><br><span class="line">    m_j = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载-</span></span><br><span class="line">Complex <span class="keyword">operator</span>- (Complex &amp;c) &#123;</span><br><span class="line">    c.m_i = -c.m_i;</span><br><span class="line">    c.m_j = -c.m_j;</span><br><span class="line">    <span class="keyword">return</span> Complex(c.m_i, c.m_j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>-c</code>，即可将<code>m_i</code>、<code>m_j</code>取反</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">-c;</span><br></pre></td></tr></table></figure>
<h3 id="加号-重载"><a href="#加号-重载" class="headerlink" title="加号+重载"></a>加号<code>+</code>重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex (<span class="keyword">int</span> i, <span class="keyword">int</span> j);</span><br><span class="line">    <span class="comment">//重载+</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex &amp;b);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_i;</span><br><span class="line">    <span class="keyword">int</span> m_j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex :: Complex (<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">    m_i = i;</span><br><span class="line">    m_j = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载+</span></span><br><span class="line">Complex Complex :: <span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex &amp;b) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="keyword">this</span>-&gt;m_i + b.m_i;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="keyword">this</span>-&gt;m_j + b.m_j;</span><br><span class="line">    <span class="keyword">return</span> Complex(i, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>a+b</code>，即可将<code>m_i</code>、<code>m_j</code>相加</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Complex a(1,2), b(2,3);</span><br><span class="line">Complex c = a + b;</span><br></pre></td></tr></table></figure>
<h3 id="关系运算符-重载"><a href="#关系运算符-重载" class="headerlink" title="关系运算符==重载"></a>关系运算符<code>==</code>重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex (<span class="keyword">int</span> i, <span class="keyword">int</span> j);</span><br><span class="line">    <span class="comment">//重载==</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>== (<span class="keyword">const</span> Complex &amp;b) <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_i;</span><br><span class="line">    <span class="keyword">int</span> m_j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex :: Complex (<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">    m_i = i;</span><br><span class="line">    m_j = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载==</span></span><br><span class="line"><span class="keyword">bool</span> Complex :: <span class="keyword">operator</span>== (<span class="keyword">const</span> Complex &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (m_i == b.m_i &amp;&amp; m_j == b.m_j) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>类与类之间可以有继承关系，已有一个基类，可以用一个派生类来继承基类</p>
<ul>
<li>语法：<code>class 派生类 : 继承方式 基类</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Dog</code>就是<code>Animal</code>的派生类，可以继承基类的成员。</p>
<p>派生类可以继承基类的所有成员，但只有<code>public</code>和<code>protected</code>成员能被访问到，<code>private</code>成员可以继承，但无法访问。</p>
<h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>继承方式分为三种：公共继承<code>public</code>、保护继承<code>protected</code>、私有继承<code>private</code></p>
<p>例如一个基类<code>A</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类<code>B</code>按不同继承方式，成员会继承为不同的权限</p>
<ul>
<li><p>公共继承<code>public</code></p>
<p>  原<code>public</code>、<code>protected</code>依旧以<code>public</code>、<code>protected</code>继承，不可访问<code>private</code>。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">不可访问:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>保护继承<code>protected</code></p>
<p>  原<code>public</code>、<code>protected</code>以<code>protected</code>继承，不可访问<code>private</code>。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">protected</span> A &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">不可访问:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>私有继承<code>private</code></p>
<p>  原<code>public</code>、<code>protected</code>以<code>private</code>继承，不可访问<code>private</code>。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">private</span> A &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">不可访问:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>一个派生类继承了多个基类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;派生类名&gt;:</span>&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例如，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Mother, <span class="keyword">public</span> Father &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="构造和析构顺序"><a href="#构造和析构顺序" class="headerlink" title="构造和析构顺序"></a>构造和析构顺序</h3><p>构造顺序、析构顺序镜像相反，先构造的后析构，先析构的后构造。</p>
<ul>
<li><p>继承关系中，</p>
<p>  构造顺序：基类构造 -&gt; 派生类构造</p>
<p>  析构顺序：派生类析构 -&gt; 基类析构</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Father() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Father构造"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Father() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Father析构"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Son() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Son构造"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Son() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Son析构"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  输出：</p>
<blockquote>
<p>Father构造<br>Son构造<br>Son析构<br>Father析构</p>
</blockquote>
</li>
<li><p>当其他类作为本类成员时，</p>
<p>  构造顺序：成员类构造 -&gt; 本类构造</p>
<p>  析构顺序：本类析构 -&gt; 成员类析构</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A构造"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A析构"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B构造"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~B() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B析构"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  输出：</p>
<blockquote>
<p>A构造<br>B构造<br>B析构<br>A析构</p>
</blockquote>
</li>
</ul>
<h3 id="同名成员处理"><a href="#同名成员处理" class="headerlink" title="同名成员处理"></a>同名成员处理</h3><p>如果派生类和基类中有相同成员重名，那么就会遮蔽从基类继承过来的成员，使用派生类成员。</p>
<p>如基类<code>Father</code>和派生类<code>Son</code>中都有成员变量<code>m_A</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Son s;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.m_A; <span class="comment">//默认调用的是派生类Son中的m_A</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.Father::m_A; <span class="comment">//加作用域可调用基类Father中的m_A</span></span><br></pre></td></tr></table></figure>
<p>基类成员函数和派生类成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Son s;</span><br><span class="line">s.func(); <span class="comment">//默认调用的是派生类Son中的func函数</span></span><br><span class="line">s.Father::func(<span class="number">100</span>); <span class="comment">//加作用域可调用基类Father中的func函数</span></span><br></pre></td></tr></table></figure>
<h3 id="派生类赋值给基类（向上转型）"><a href="#派生类赋值给基类（向上转型）" class="headerlink" title="派生类赋值给基类（向上转型）"></a>派生类赋值给基类（向上转型）</h3><p>派生类赋值给基类，称为向上转型。相应地，将基类赋值给派生类，称为向下转型。</p>
<p>向上转型非常安全，可以由编译器自动完成；向下转型有风险，需要程序员手动干预。</p>
<ul>
<li><p>派生类对象赋值给基类对象</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Father f = Son();</span><br></pre></td></tr></table></figure>
</li>
<li><p>派生类指针赋值给基类指针</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Father *f = <span class="keyword">new</span> Son();</span><br></pre></td></tr></table></figure>
</li>
<li><p>派生类引用赋值给基类引用</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Son s;</span><br><span class="line">Father &amp;f = s;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>赋值只包含成员变量，不包含成员函数。所以调用同名成员函数时，<code>f</code>依旧调用的是原本基类<code>Father</code>的成员函数。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态，即函数多种形态，分为两类：</p>
<ul>
<li>静态多态<ul>
<li>函数重载、运算符重载</li>
<li>静态：编译阶段绑定函数地址</li>
</ul>
</li>
<li>动态多态<ul>
<li>派生类和虚函数实现运行时的多态</li>
<li>动态：运行阶段绑定函数地址</li>
</ul>
</li>
</ul>
<p>当基类和派生类中有相同成员函数时，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"动物发声"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"喵喵喵"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类调用，会遮蔽基类中的所有同名函数，直接调用派生类的函数，所以<code>c.speak();</code>输出了“喵喵喵”。</p>
<p>派生类赋值给基类后，只改变成员变量，不改变成员函数，基类调用，依旧调用的是原本基类的成员函数，所以<code>a-&gt;speak();</code>输出了“动物发声”。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Cat c;</span><br><span class="line">c.speak(); <span class="comment">//喵喵喵，调用派生类函数</span></span><br><span class="line">    </span><br><span class="line">Animal *a = &amp;c;</span><br><span class="line">a-&gt;speak(); <span class="comment">//动物发声，调用基类函数</span></span><br></pre></td></tr></table></figure>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>如果希望<code>a-&gt;speak();</code>调用的是派生类函数的“喵喵喵”，则应将基类的<code>speak()</code>设置为<strong>虚函数</strong>，添加关键字<code>virtual</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"动物发声"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"喵喵喵"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cat c;</span><br><span class="line">    c.speak(); <span class="comment">//喵喵喵，调用派生类函数</span></span><br><span class="line">    </span><br><span class="line">    Animal *a = &amp;c;</span><br><span class="line">    a-&gt;speak(); <span class="comment">//喵喵喵，调用派生类函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如不是虚函数，在编译时就会静态链接，将<code>a-&gt;speak();</code>早绑定到基类函数上。</p>
<p>如是虚函数，在运行时才会动态链接，如此，便可将<code>a-&gt;speak();</code>绑定到派生类函数上。</p>
</blockquote>
<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>如果基类中的虚函数没有实际意义，可以定义为纯虚函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> 返回值类型 函数名 (函数参数) = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>纯虚函数没有函数体，只有函数声明，在虚函数声明的结尾加上<code>=0</code>，表明此函数为纯虚函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h1><p>C++泛型编程，主要技术就是模版。使变量变成通用变量，如<code>vector&lt;int&gt;</code>的利用模版技术，可以输入不同的数据类型。</p>
<h2 id="函数模版-类模版"><a href="#函数模版-类模版" class="headerlink" title="函数模版/类模版"></a>函数模版/类模版</h2><ul>
<li><p>定义</p>
<p>  分为建立一个通用函数/类，返回值和形参的类型可以不具体制定，而用一个虚拟类型来表示。<br>  函数模版例如<code>swap</code>函数，输入的两个参数都是模版，所有可以交换两个<code>int</code>，也可以交换两个<code>string</code>。<br>  类模版例如<code>vector&lt;int&gt;</code>，其中的成员类型可变换。</p>
</li>
<li><p>语法</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数/类声明或定义</span><br></pre></td></tr></table></figure>
<ul>
<li>template表明声明一个模版</li>
<li>typename可以换成class，效果相同</li>
<li>T为通用数据类型名，告诉编译器不要报错</li>
</ul>
</li>
<li><p>函数模版例子</p>
<p>  自行定义一个交换函数模版</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  调用模版函数，可以自动类型推导</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">Swap(a, b);</span><br></pre></td></tr></table></figure>
<p>  也可以指定类型</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">Swap&lt;<span class="keyword">int</span>&gt;(a, b);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>类模版</p>
<p>定义一个模版类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> NameType, <span class="keyword">typename</span> AgeType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    NameType m_name;</span><br><span class="line">    AgeType m_age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(NameType name, AgeType age) &#123;</span><br><span class="line">        m_name = name;</span><br><span class="line">        m_age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用模版类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person&lt;string, int&gt; p("Job", 10);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><p>STL（Standard Template Library），即标准模板库。</p>
<p>STL由三大组件构成：容器、算法、迭代器。</p>
<ul>
<li><p><strong>容器</strong>：特定的数据结构，如 向量（vector）、双端队列（deque）、链表（list）、集合（set）、多重集合（multiset）、映射（map）和多重映射（multimap）等</p>
</li>
<li><p><strong>算法</strong>：常用的各种算法，如 sort、find、copy、for_each等</p>
</li>
<li><p><strong>迭代器</strong>：检查容器内元素并遍历元素的数据类型</p>
</li>
</ul>
<h2 id="vector（向量）"><a href="#vector（向量）" class="headerlink" title="vector（向量）"></a>vector（向量）</h2><blockquote>
<p>向量（vector）是一个封装了动态大小数组的顺序容器</p>
</blockquote>
<h3 id="函数方法"><a href="#函数方法" class="headerlink" title="函数方法"></a>函数方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>v.front()</td>
<td>返回第一个数据</td>
</tr>
<tr>
<td>v.back()</td>
<td>返回最后一个数据</td>
</tr>
<tr>
<td>v.pop_back()</td>
<td>删除最后一个数据</td>
</tr>
<tr>
<td>v.push_back(element)</td>
<td>在尾部加一个数据</td>
</tr>
<tr>
<td>v.size()</td>
<td>返回元素个数</td>
</tr>
<tr>
<td>v.clear()</td>
<td>清除所有元素</td>
</tr>
<tr>
<td>v.resize(n,v)</td>
<td>改变数组大小为n，n个空间数值赋为v，如果没有默认赋值为0</td>
</tr>
<tr>
<td>v.insert(it,x)</td>
<td>向任意迭代器it插入一个元素x</td>
</tr>
<tr>
<td>v.erase(first,last)</td>
<td>删除[first,last)的所有元素</td>
</tr>
<tr>
<td>v.begin()</td>
<td>返回首元素的迭代器</td>
</tr>
<tr>
<td>v.end()</td>
<td>返回最后一个元素后一个位置的迭代器</td>
</tr>
<tr>
<td>v.empty()</td>
<td>判断是否为空，为空返回真，反之返回假       </td>
</tr>
</tbody>
</table>
</div>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>运用vector容器需要引用vector头文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>vector初始化</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>vector<T> v</td>
<td>默认初始化一个空vector</td>
</tr>
<tr>
<td>vector<T> v2(v1)</td>
<td>v2中包含有v1所有元素的副本</td>
</tr>
<tr>
<td>vector<T> v2 = v1</td>
<td>等价于 v2(v1)</td>
</tr>
<tr>
<td>vector<T> v(n, val)</td>
<td>n个重复的元素val</td>
</tr>
<tr>
<td>vector<T> v(n)</td>
<td>n个重复的默认</td>
</tr>
<tr>
<td>vector<T> v {a, b, c….}</td>
<td>赋值</td>
</tr>
<tr>
<td>vector<T> v = {a, b, c….}</td>
<td>等价于 v{a, b, c….}</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>二维vector初始化</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化10*5的二维vector，元素值都为1</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>, <span class="number">1</span>))</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>尾部插入元素</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.push_back(x);</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入元素</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.insert(v.<span class="built_in">begin</span>() + <span class="number">2</span>, x); <span class="comment">//在第3个位置插入x</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除元素</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v.erase(v.<span class="built_in">begin</span>() + <span class="number">2</span>); <span class="comment">//删除第3个位置的元素</span></span><br><span class="line">v.erase(v.<span class="built_in">begin</span>() + i, v.<span class="built_in">begin</span>() + j); <span class="comment">//删除第[i, j)位置的元素</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历vector集合</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器遍历访问</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种遍历访问方式</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : s)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="set（集合）"><a href="#set（集合）" class="headerlink" title="set（集合）"></a>set（集合）</h2><blockquote>
<p>set（集合）的每个元素只出现一次，且默认升序排列。</p>
</blockquote>
<h3 id="函数方法-1"><a href="#函数方法-1" class="headerlink" title="函数方法"></a>函数方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.begin()</td>
<td>返回set容器的第一个元素的地址（迭代器）</td>
</tr>
<tr>
<td>s.end()</td>
<td>返回set容器的最后一个元素的下一个地址（迭代器）</td>
</tr>
<tr>
<td>s.rbegin()</td>
<td>返回逆序迭代器，指向容器元素最后一个位置</td>
</tr>
<tr>
<td>s.rend()</td>
<td>返回逆序迭代器，指向容器第一个元素前面的位置</td>
</tr>
<tr>
<td>s.clear()</td>
<td>删除set容器中的所有的元素,返回unsigned int类型O(N)</td>
</tr>
<tr>
<td>s.empty()</td>
<td>判断set容器是否为空</td>
</tr>
<tr>
<td>s.insert()</td>
<td>插入一个元素</td>
</tr>
<tr>
<td>s.size()</td>
<td>返回当前set容器中的元素个数O(1)</td>
</tr>
<tr>
<td>erase(iterator)</td>
<td>删除定位器iterator指向的值</td>
</tr>
<tr>
<td>erase(first,second）</td>
<td>删除定位器first和second之间的值</td>
</tr>
<tr>
<td>erase(key_value)</td>
<td>删除键值key_value的值</td>
</tr>
<tr>
<td>s.find(元素)</td>
<td>查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器，即s.end()</td>
</tr>
<tr>
<td>s.lower_bound(k)</td>
<td>返回大于等于k的第一个元素的迭代器</td>
</tr>
<tr>
<td>s.upper_bound(k)</td>
<td>返回大于k的第一个元素的迭代器</td>
</tr>
</tbody>
</table>
</div>
<h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>运用set容器需要引用set头文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>set构造函数</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s; <span class="comment">//默认按键值升序</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt;&gt; p; <span class="comment">//降序</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历set集合</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器遍历访问</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种遍历访问方式</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : s)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="map（映射）"><a href="#map（映射）" class="headerlink" title="map（映射）"></a>map（映射）</h2><blockquote>
<p>map（映射）的每个元素都是一个pair，包含 &lt;键值，实值&gt;，map不允许两个元素有相同的键值，所有元素根据键值自动排序。</p>
</blockquote>
<h3 id="函数方法-2"><a href="#函数方法-2" class="headerlink" title="函数方法"></a>函数方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>mp.find(key)</td>
<td>返回键为key的映射的迭代器，当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回mp.end()</td>
</tr>
<tr>
<td>mp.erase(it)</td>
<td>删除迭代器对应的键和值</td>
</tr>
<tr>
<td>mp.erase(key)</td>
<td>根据映射的键删除键和值</td>
</tr>
<tr>
<td>mp.erase(first,last)</td>
<td>删除左闭右开区间迭代器对应的键和值</td>
</tr>
<tr>
<td>mp.size()</td>
<td>返回映射的对数</td>
</tr>
<tr>
<td>mp.clear()</td>
<td>清空map中的所有元素</td>
</tr>
<tr>
<td>mp.insert()</td>
<td>插入元素，插入时要构造键值对</td>
</tr>
<tr>
<td>mp.empty()</td>
<td>如果map为空，返回true，否则返回false</td>
</tr>
<tr>
<td>mp.begin()</td>
<td>返回指向map第一个元素的迭代器（地址）</td>
</tr>
<tr>
<td>mp.end()</td>
<td>返回指向map尾部的迭代器（最后一个元素的下一个地址）</td>
</tr>
<tr>
<td>mp.rbegin()</td>
<td>返回指向map最后一个元素的反向迭代器（地址）</td>
</tr>
<tr>
<td>mp.rend()</td>
<td>返回指向map第一个元素前面(上一个）的反向迭代器（地址）</td>
</tr>
<tr>
<td>mp.count(key)</td>
<td>查看元素是否存在，因为map中键是唯一的，所以存在返回1，不存在返回0</td>
</tr>
<tr>
<td>mp.lower_bound()</td>
<td>返回一个迭代器，指向键值&gt;= key的第一个元素</td>
</tr>
<tr>
<td>mp.upper_bound()</td>
<td>返回一个迭代器，指向键值&gt; key的第一个元素</td>
</tr>
</tbody>
</table>
</div>
<h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><p>运用map容器需要引用map头文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>map构造函数</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mp; <span class="comment">//键值为string，实值为int</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加元素</p>
<ul>
<li><p>方法一：通过数组的方式插入值</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mp[<span class="string">"a"</span>] = <span class="number">1</span>; <span class="comment">//mp[key]，如果不存在对应的key时，会自动创建一个键值对</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二：通过pair的方式插入对象</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mp.insert(&#123;<span class="string">"a"</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    </span><br><span class="line">mp.insert(make_pair(<span class="string">"a"</span>, <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">mp.insert(&#123;<span class="string">"a"</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    </span><br><span class="line">mp.insert(pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; (<span class="string">"a"</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>访问元素</p>
<ul>
<li><p>通过下标访问</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; mp[<span class="string">"a"</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过find函数访问</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it = mp.<span class="built_in">find</span>(<span class="string">"a"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>遍历元素</p>
<ul>
<li><p>通过迭代器遍历</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正向遍历（利用begin和end函数）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逆向遍历（利用rbegin和rend函数）</span></span><br><span class="line"><span class="keyword">auto</span> it = mp.rbegin();</span><br><span class="line"><span class="keyword">while</span> (it != mp.rend()) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    it++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>范围for语句遍历</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只能访问，无法改变容器中的值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : mp)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i.first &lt;&lt; <span class="string">" "</span> &lt;&lt; i.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如需改变值，则用引用</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : mp)&#123;</span><br><span class="line">    i.second *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过迭代器遍历时，迭代器<code>it</code>可以理解为指向元素的指针，指针用<code>-&gt;</code>访问，即<code>it-&gt;first</code>，或用<code>(*it).first</code>，可改变容器中的值</p>
<p>范围for语句遍历时，<code>i</code>是一个pair对象，直接用<code>.</code>访问，即<code>it.first</code>。只访问时，用<code>auto i : mp</code>，当需要改变值时，用<code>auto &amp;i : mp</code></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="deque（双端队列）"><a href="#deque（双端队列）" class="headerlink" title="deque（双端队列）"></a>deque（双端队列）</h2><blockquote>
<p>deque（双端队列）首尾都可以插入和删除的队列。</p>
</blockquote>
<h3 id="函数方法-3"><a href="#函数方法-3" class="headerlink" title="函数方法"></a>函数方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>push_back(x)</td>
<td>把x压入后端</td>
</tr>
<tr>
<td>push_front(x)</td>
<td>把x压入前端</td>
</tr>
<tr>
<td>back()</td>
<td>访问(不删除)后端元素</td>
</tr>
<tr>
<td>front()</td>
<td>访问(不删除)前端元素</td>
</tr>
<tr>
<td>pop_back()</td>
<td>删除后端元素</td>
</tr>
<tr>
<td>pop_front()</td>
<td>删除前端元素</td>
</tr>
<tr>
<td>erase(iterator it)</td>
<td>删除双端队列中的某一个元素</td>
</tr>
<tr>
<td>erase(iterator first,iterator last)</td>
<td>删除双端队列中（first,last）中的元素</td>
</tr>
<tr>
<td>empty()</td>
<td>判断deque是否空</td>
</tr>
<tr>
<td>size()</td>
<td>返回deque的元素数量</td>
</tr>
<tr>
<td>clear()</td>
<td>清空deque</td>
</tr>
</tbody>
</table>
</div>
<h3 id="基本用法-3"><a href="#基本用法-3" class="headerlink" title="基本用法"></a>基本用法</h3><p>运用deque容器需要引用deque头文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>deque构造函数</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="stack（栈）"><a href="#stack（栈）" class="headerlink" title="stack（栈）"></a>stack（栈）</h2><blockquote>
<p>stack（栈），先进后出的数据结构。</p>
</blockquote>
<h3 id="函数方法-4"><a href="#函数方法-4" class="headerlink" title="函数方法"></a>函数方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.push(x)</td>
<td>将x压入栈顶</td>
</tr>
<tr>
<td>s.top()</td>
<td>返回栈顶的元素</td>
</tr>
<tr>
<td>s.pop()</td>
<td>删除栈顶的元素</td>
</tr>
<tr>
<td>s.size()</td>
<td>返回栈中元素的个数</td>
</tr>
<tr>
<td>s.empty()</td>
<td>检查栈是否为空,若为空返回true,否则返回false</td>
</tr>
</tbody>
</table>
</div>
<h3 id="基本用法-4"><a href="#基本用法-4" class="headerlink" title="基本用法"></a>基本用法</h3><p>运用stack容器需要引用stack头文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>stack构造函数</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="string（字符串）"><a href="#string（字符串）" class="headerlink" title="string（字符串）"></a>string（字符串）</h2><p>string是C++中的一个类，专门实现字符串的相关操作。数据类型为string，字符串结尾没有<code>\0</code>字符。</p>
<p>与之相比，C语言字符串（C-string），用char数组实现，字符串结尾以<code>\0</code>结尾。</p>
<h3 id="基本用法-5"><a href="#基本用法-5" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>初始化</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str1; <span class="comment">//生成空字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str2</span><span class="params">(<span class="string">"12345678"</span>)</span></span>; <span class="comment">//结果为"12345678"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str3</span><span class="params">(<span class="string">"12345678"</span>, <span class="number">1</span>, <span class="number">3</span>)</span></span>; <span class="comment">//结果为"234"，从1号开始，长度为3的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str4</span><span class="params">(<span class="string">"12345678"</span>, <span class="number">3</span>)</span></span>; <span class="comment">//结果为"123"，从0号开始，长度为3的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str4</span><span class="params">(<span class="number">5</span>, <span class="string">'2'</span>)</span></span>; <span class="comment">//结果为"22222"，5个'2'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str4</span><span class="params">(str2, <span class="number">3</span>)</span></span>; <span class="comment">//结果为"45678"，从3号开始的字符串</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>读入</p>
<ul>
<li><p><code>cin &gt;&gt; str</code> 读入字符串，遇到空格或回车结束</p>
</li>
<li><p><code>getline(cin, str)</code>，读入一行字符串，包括空格，遇到回车结束</p>
</li>
<li><p>注意：<code>cin</code>输入回车结束后，回车仍在输入流中，<code>getline</code>会获取前一个输入的换行符，所以需要在前面添加读取换行符的语句：<code>getchar()</code> 或 <code>cin.get()</code></p>
<p>  错误读取方式</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str1, str2;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str1;</span><br><span class="line">getline(<span class="built_in">cin</span>, str2); <span class="comment">//此处getline只能读到上一个cin的换行符</span></span><br></pre></td></tr></table></figure>
<p>  正确读取方式</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str1, str2;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str1;</span><br><span class="line">getchar(); <span class="comment">//或者cin.get()，用于接收上一个换行符</span></span><br><span class="line">getline(<span class="built_in">cin</span>, str2); <span class="comment">//此处getline只能读到上一个cin的换行符</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>获取长度</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.size()或s.length()</td>
<td>返回string对象的字符个数</td>
</tr>
<tr>
<td>s.max_size()</td>
<td>返回string对象最多包含的字符数，超出会抛出length_error异常</td>
</tr>
<tr>
<td>s.capacity()</td>
<td>重新分配内存之前，string对象能包含的最大字符数</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>插入</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.push_back(element)</td>
<td>在末尾插入一个字符element</td>
</tr>
<tr>
<td>s.insert(iterator it,element)</td>
<td>在迭代器it处插入一个字符element</td>
</tr>
<tr>
<td>s.append(str)</td>
<td>在s字符串结尾添加str字符串</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"123456"</span>;</span><br><span class="line">s.push_back(<span class="string">'a'</span>); <span class="comment">//结果：123456a，在末尾插入一个字符'a'</span></span><br><span class="line">s.insert(s.<span class="built_in">begin</span>(), <span class="string">'b'</span>); <span class="comment">//结果：b123456a，在开头插入一个字符'b'</span></span><br><span class="line">s.append(<span class="string">"cdef"</span>); <span class="comment">//结果：b123456acdef，在末尾添加字符串“cdef”</span></span><br></pre></td></tr></table></figure>
<ul>
<li>删除</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.erase(iterator it)</td>
<td>删除字符串中it所指的字符</td>
</tr>
<tr>
<td>s.erase(iterator first, iterator last)</td>
<td>删除字符串中迭代器区间[first,last)上所有字符</td>
</tr>
<tr>
<td>s.erase(pos, len)</td>
<td>删除字符串中从索引位置pos开始的len个字符</td>
</tr>
<tr>
<td>s.clear()</td>
<td>删除字符串中所有字符</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"123456789"</span>;</span><br><span class="line">s.erase(s.<span class="built_in">begin</span>()); <span class="comment">//结果：23456789，删除开头的一个字符</span></span><br><span class="line">s.erase(s.<span class="built_in">end</span>()<span class="number">-1</span>); <span class="comment">//结果：2345678，删除结尾的一个字符</span></span><br><span class="line">s.erase(s.<span class="built_in">begin</span>()+<span class="number">2</span>, s.<span class="built_in">end</span>()<span class="number">-2</span>); <span class="comment">//结果：2378，删除[first,last)上所有字符，不删last</span></span><br><span class="line">s.erase(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//结果：28，删除从1号位开始的2个字符</span></span><br><span class="line">s.<span class="built_in">clear</span>(); <span class="comment">//结果：空</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字符替换</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.replace(pos,n,str)</td>
<td>把当前字符串从索引pos开始的n个字符替换为str</td>
</tr>
<tr>
<td>s.replace(pos,n,n1,c)</td>
<td>把当前字符串从索引pos开始的n个字符替换为n1个字符c</td>
</tr>
<tr>
<td>s.replace(iterator first,iterator last,str)</td>
<td>把当前字符串[first,last)区间替换为str</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"123456789"</span>;</span><br><span class="line">s.replace(<span class="number">0</span>, <span class="number">3</span>, <span class="string">"abcd"</span>); <span class="comment">//结果：abcd456789，将从0号位开始的3个字符替换为"abcd"</span></span><br><span class="line">s.replace(<span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">'e'</span>); <span class="comment">//结果：abcd45ee9，将从6号位开始的3个字符替换为2个'e'</span></span><br><span class="line">s.replace(s.<span class="built_in">begin</span>()+<span class="number">2</span>, s.<span class="built_in">end</span>()<span class="number">-2</span>, <span class="string">"fff"</span>); <span class="comment">//结果：abfffe9，将ab‘cd45e’e9中间替换为"fff"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>分割</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.substr(pos,n)</td>
<td>截取从pos索引开始的n个字符</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"123456789"</span>;</span><br><span class="line"><span class="built_in">string</span> sub = s.substr(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">//结果：345，截取从2号位开始的3个字符</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查找</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.find (str, pos)</td>
<td>在当前字符串的pos索引位置(默认为0)开始，查找子串str，返回找到的位置索引，-1表示查找不到子串</td>
</tr>
<tr>
<td>s.find (c, pos)</td>
<td>在当前字符串的pos索引位置(默认为0)开始，查找字符c，返回找到的位置索引，-1表示查找不到字符</td>
</tr>
<tr>
<td>s.rfind (str, pos)</td>
<td>在当前字符串的pos索引位置开始，反向查找子串s、str，返回找到的位置索引，-1表示查找不到子串</td>
</tr>
<tr>
<td>s.rfind (c,pos)</td>
<td>在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到字符</td>
</tr>
<tr>
<td>s.find_first_of (str, pos)</td>
<td>在当前字符串的pos索引位置(默认为0)开始，查找子串str的字符，返回找到的位置索引，-1表示查找不到字符</td>
</tr>
<tr>
<td>s.find_first_not_of (str,pos)</td>
<td>在当前字符串的pos索引位置(默认为0)开始，查找第一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</td>
</tr>
<tr>
<td>s.find_last_of(str, pos)</td>
<td>在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</td>
</tr>
<tr>
<td>s.find_last_not_of (str, pos)</td>
<td>在当前字符串的pos索引位置开始，查找最后一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到子串</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"This is a string."</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//从首位开始，查找字符的第一个出现的位置</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.<span class="built_in">find</span>(<span class="string">'s'</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//结果：3，Thi's'</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//从首位开始，查找字符串第一个出现的位置，返回首字符位置</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.<span class="built_in">find</span>(<span class="string">"is"</span>)&lt;&lt; <span class="built_in">endl</span>; <span class="comment">//结果：2，Th'i's</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//从4号位开始，查找字符串第一个出现的位置</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.<span class="built_in">find</span>(<span class="string">"is"</span>, <span class="number">4</span>)&lt;&lt; <span class="built_in">endl</span>; <span class="comment">//结果：5，'i's a</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//从尾部开始，反向查找字符，即正序的最后一个位置</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.rfind(<span class="string">'s'</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//结果：10，'s'tring</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//从尾位开始，反向查找字符串，即正序的最后一个位置，返回首字符位置</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.rfind(<span class="string">"is"</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//结果：5，'i's a</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//从4号位开始，反向查找字符串</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.rfind(<span class="string">"is"</span>, <span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//结果：2，Th'i's</span></span><br></pre></td></tr></table></figure>
<ul>
<li>排序</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"349725618"</span>;</span><br><span class="line">sort(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>()); <span class="comment">//结果：123456789，默认升序</span></span><br><span class="line">sort(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), greater&lt;<span class="keyword">char</span>&gt;()); <span class="comment">//结果：987654321</span></span><br></pre></td></tr></table></figure>
<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><p>C++ 内存分为以下几个部分：</p>
<ul>
<li><p>栈区（stack）</p>
<ul>
<li>存放函数的参数值、局部变量、返回值、返回地址等</li>
<li>由编译器自动分配和释放</li>
</ul>
</li>
<li><p>堆区（heap）</p>
<ul>
<li>存放动态分配的内存，如 <code>new</code> 、 <code>malloc</code> 分配的动态变量</li>
<li>STL（除 <code>pair</code>）也都是存放在堆区</li>
<li>堆区大小不固定，由程序手动分配和释放</li>
</ul>
</li>
<li><p>全局区/静态区（static）</p>
<ul>
<li>存放全局变量、静态变量 <code>static</code></li>
<li>分为 <code>data</code> 段和 <code>bss</code> 段，已初始化的全局变量和静态变量存放在 <code>data</code> 段，未初始化或者初始化为0的全局变量和静态变量存放在 <code>bss</code> 段</li>
<li>程序启动时被分配，直到程序结束时自动释放</li>
</ul>
</li>
<li><p>常量区</p>
<ul>
<li>存放常量，不允许修改</li>
<li>程序启动时被分配，直到程序结束时自动释放</li>
</ul>
</li>
<li><p>代码区</p>
<ul>
<li>存放指令代码</li>
<li>程序启动时被分配，直到程序结束时自动释放</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1; <span class="comment">//全局区的bss段</span></span><br><span class="line"><span class="keyword">int</span> a2 = <span class="number">0</span>; <span class="comment">//全局区的bss段</span></span><br><span class="line"><span class="keyword">int</span> a3 = <span class="number">1</span>; <span class="comment">//全局区的data段</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">1</span>; <span class="comment">//全局区的data段</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="comment">//栈区</span></span><br><span class="line">    <span class="keyword">int</span> d1 = <span class="number">1</span>; <span class="comment">//栈区</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> d2 = <span class="number">1</span>; <span class="comment">//栈区</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> d3 = <span class="number">1</span>; <span class="comment">//全局区的data段</span></span><br><span class="line">    <span class="keyword">return</span> d1; <span class="comment">//栈区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>隐式转换，即在类型不统一时，系统自动进行的类型转换</p>
<p>何时发生隐式转换？</p>
<ul>
<li>算术运算中，低类型转换为高类型</li>
<li>赋值表达式中，右边的表达式的值自动转化为左边变量的类型</li>
<li>函数传参时，将实参转化为形参的类型</li>
<li>函数返回时，将返回表达式转化为返回值的类型</li>
</ul>
<h3 id="算数转换"><a href="#算数转换" class="headerlink" title="算数转换"></a>算数转换</h3><p>算数转换是隐式转换的一种，会将低类型转换为高类型</p>
<h2 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h2><h1 id="常见问题记录"><a href="#常见问题记录" class="headerlink" title="常见问题记录"></a>常见问题记录</h1><h2 id="作为函数参数的多维数组"><a href="#作为函数参数的多维数组" class="headerlink" title="作为函数参数的多维数组"></a>作为函数参数的多维数组</h2><blockquote>
<p>详见《C和指针》P159</p>
</blockquote>
<p>传数组参数，即是要传递指向数组第一个元素的指针。</p>
<p>以一维数组为例，<code>vector</code>即为指向数组第一个<code>int</code>元素的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">vector</span>[<span class="number">10</span>];</span><br><span class="line">...</span><br><span class="line">func1(<span class="built_in">vector</span>);</span><br></pre></td></tr></table></figure>
<p>参数<code>vector</code>是指向<code>int</code>型的指针，所以函数定义可以是如下两种方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">vector</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> <span class="built_in">vector</span>[])</span></span>;</span><br></pre></td></tr></table></figure>
<p>多维数组传参，同样是传指向第一个元素的指针，但有所不同的是，多维数组的每个元素本身也是另一个数组，编译器需要知道它的维度。</p>
<p>以二维数组为例，二维数组<code>matrix[3][10]</code>相当于是包含3个元素的一维数组，每个元素又是一个包含10个元素的一维数组，<code>matrix</code>的类型是指向包含10个整型元素的数组的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> matrix[<span class="number">3</span>][<span class="number">10</span>];</span><br><span class="line">...</span><br><span class="line">func2(matrix);</span><br></pre></td></tr></table></figure>
<p>所以，函数的原型必须包含第二个维度10，编译器才知道什么时候开始换行，可以有如下两种定义方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> (*matrix)[<span class="number">10</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> matrix[][<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>关键就在于编译器必须知道第2个及以后各维的长度，才能对下标进行求值</strong></p>
<hr>
<p>典型的错误写法</p>
<ul>
<li><p>错误写法一：未包含第二个维度长度，<code>**matrix</code>为指向整型指针的指针，而不是指向数组的指针</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> **matrix)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>错误写法二：<code>*matrix[10]</code>为指针数组，即数组元素是指针；<code>(*matrix)[10]</code>为数组指针，即指向数组的指针</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> *matrix[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="类模板头文件的编写"><a href="#类模板头文件的编写" class="headerlink" title="类模板头文件的编写"></a>类模板头文件的编写</h2><p>c++中模板的声明和定义不能分开</p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>如和一般的类头文件一样，将模板类中函数声明写在<code>类名.hpp</code>中，函数定义写在<code>类名.cpp</code>中，<code>类名.cpp</code>、<code>main.cpp</code>调用<code>.h</code>文件，则会出现报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: Undefined Symbol 成员函数</span><br></pre></td></tr></table></figure>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>模板类中的成员函数在调用时才创建。</p>
<blockquote>
<p>C++编译时，就要确定每个对象的空间大小。</p>
<p>但是，模板类在未被使用前，无法确定大小，比如<code>vector&lt;int&gt;</code>和<code>vector&lt;char&gt;</code>，这两套用不同数据类型的模版，实际是两个不同的类。</p>
</blockquote>
<p>所以，c++中模板的声明和定义不能分开。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li><p>方法一：将模板类中的成员函数的声明和定义都写在<code>.h</code>文件里</p>
  <figure class="highlight c"><figcaption><span>Stack.hpp++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> Stack_hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Stack_hpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    T *data; <span class="comment">//成员数组</span></span><br><span class="line">    <span class="keyword">int</span> top; <span class="comment">//栈顶指针，当前栈顶元素的位置</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>; <span class="comment">//栈中元素的最大个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stack();</span><br><span class="line">    ~Stack();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Stack&lt;T&gt;::Stack() : top(<span class="number">-1</span>), <span class="built_in">size</span>(<span class="number">10</span>) &#123;</span><br><span class="line">    data = <span class="keyword">new</span> T[<span class="built_in">size</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁栈</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Stack&lt;T&gt;::~Stack() &#123;</span><br><span class="line">    <span class="keyword">delete</span> [] data;</span><br><span class="line">    data = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>  在<code>main.cpp</code>调用<code>Stack.hpp</code>文件</p>
</li>
<li><p>方法二：<code>main.cpp</code>调用<code>类名.cpp</code>文件，<code>类名.cpp</code>文件调用<code>类名.h</code>文件</p>
  <figure class="highlight c"><figcaption><span>Stack.hpp++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> Stack_hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Stack_hpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    T *data; <span class="comment">//成员数组</span></span><br><span class="line">    <span class="keyword">int</span> top; <span class="comment">//栈顶指针，当前栈顶元素的位置</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>; <span class="comment">//栈中元素的最大个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stack();</span><br><span class="line">    ~Stack();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
  <figure class="highlight c"><figcaption><span>Stack.hpp++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Stack.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Stack&lt;T&gt;::Stack() : top(<span class="number">-1</span>), <span class="built_in">size</span>(<span class="number">10</span>) &#123;</span><br><span class="line">    data = <span class="keyword">new</span> T[<span class="built_in">size</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁栈</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Stack&lt;T&gt;::~Stack() &#123;</span><br><span class="line">    <span class="keyword">delete</span> [] data;</span><br><span class="line">    data = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在<code>main.cpp</code>调用<code>Stack.cpp</code>文件</p>
</li>
</ul>
<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h2 id="sort-排序函数"><a href="#sort-排序函数" class="headerlink" title="sort()排序函数"></a>sort()排序函数</h2><p>sort()函数类似于快速排序，时间复杂度为 $n*log2(n)$</p>
<ul>
<li>头文件  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li>基本使用方法  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(<span class="built_in">begin</span>, <span class="built_in">end</span>, cmp);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>begin</code>：待排序的数组的第一个元素的指针</li>
<li><code>end</code>：待排序的数组的最后一个元素的下一个位置的指针</li>
<li><code>cmp</code>：排序准则，不填则默认为从小到大排序，如想要从大到小排序，则填<code>greater&lt;int&gt;()</code>。如需自行定义排序准则，也可传入bool型函数，返回<code>true</code>则不换位置，返回<code>false</code>则前后调换位置</li>
</ul>
</li>
<li>用例<ul>
<li>数组排序<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num[<span class="number">5</span>] = &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">sort(num, num+<span class="number">5</span>); <span class="comment">//从小到大排序：0 1 2 3 4</span></span><br><span class="line">sort(num, num+<span class="number">5</span>, greater&lt;<span class="keyword">int</span>&gt;()); <span class="comment">//从大到小排序：4 3 2 1 0</span></span><br></pre></td></tr></table></figure></li>
<li>vector排序<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); <span class="comment">//从小到大排序：0 1 2 3 4</span></span><br></pre></td></tr></table></figure></li>
<li>自定义排序准则<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//个位数从大到小排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">10</span> &gt; y % <span class="number">10</span>; <span class="comment">//x个位大于y时，返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">5</span>] = &#123;<span class="number">24</span>, <span class="number">1</span>, <span class="number">83</span>, <span class="number">12</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    sort(num, num + <span class="number">5</span>, cmp); <span class="comment">//个位数从大到小排序：24 83 12 1 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://c.biancheng.net/cplus/" target="_blank" rel="noopener">C++入门教程，C++基础教程</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
              <a href="/tags/%E5%85%A5%E9%97%A8/" rel="tag"># 入门</a>
              <a href="/tags/Xcode/" rel="tag"># Xcode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/08/matlab-GUI%E5%85%A5%E9%97%A8/" rel="prev" title="matlab GUI入门">
      <i class="fa fa-chevron-left"></i> matlab GUI入门
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/15/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/" rel="next" title="直方图均衡化">
      直方图均衡化 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#环境搭建"><span class="nav-number">1.</span> <span class="nav-text">环境搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-VS-Code-搭建C-开发环境（MAC）"><span class="nav-number">1.1.</span> <span class="nav-text">使用 VS Code 搭建C++开发环境（MAC）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Xcode引入iostream库失败"><span class="nav-number">1.2.</span> <span class="nav-text">Xcode引入iostream库失败</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#从C到C"><span class="nav-number">2.</span> <span class="nav-text">从C到C++</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#输入输出"><span class="nav-number">2.1.</span> <span class="nav-text">输入输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标准输出cout"><span class="nav-number">2.1.1.</span> <span class="nav-text">标准输出cout</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标准输入cin"><span class="nav-number">2.1.2.</span> <span class="nav-text">标准输入cin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用标准库中的名字"><span class="nav-number">2.1.3.</span> <span class="nav-text">使用标准库中的名字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控制流"><span class="nav-number">2.2.</span> <span class="nav-text">控制流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#while语句"><span class="nav-number">2.2.1.</span> <span class="nav-text">while语句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#读取数量不定的输入数据"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">读取数量不定的输入数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for语句"><span class="nav-number">2.2.2.</span> <span class="nav-text">for语句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#遍历数组中的元素"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">遍历数组中的元素</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数重载"><span class="nav-number">2.3.</span> <span class="nav-text">函数重载</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-基础"><span class="nav-number">3.</span> <span class="nav-text">C++基础</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#变量和基本类型"><span class="nav-number">4.</span> <span class="nav-text">变量和基本类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类"><span class="nav-number">4.1.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#建立头文件"><span class="nav-number">4.1.1.</span> <span class="nav-text">建立头文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用类定义"><span class="nav-number">4.1.2.</span> <span class="nav-text">使用类定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器"><span class="nav-number">4.2.</span> <span class="nav-text">迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用迭代器"><span class="nav-number">4.2.1.</span> <span class="nav-text">使用迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代器运算符"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">迭代器运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器运算"><span class="nav-number">4.2.2.</span> <span class="nav-text">迭代器运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#try语句块和异常处理"><span class="nav-number">4.3.</span> <span class="nav-text">try语句块和异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#throw表达式"><span class="nav-number">4.3.1.</span> <span class="nav-text">throw表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#try语句块"><span class="nav-number">4.3.2.</span> <span class="nav-text">try语句块</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-面向对象"><span class="nav-number">5.</span> <span class="nav-text">C++面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类和对象"><span class="nav-number">5.1.</span> <span class="nav-text">类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类和对象的定义"><span class="nav-number">5.1.1.</span> <span class="nav-text">类和对象的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问权限"><span class="nav-number">5.1.2.</span> <span class="nav-text">访问权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数-析构函数"><span class="nav-number">5.1.3.</span> <span class="nav-text">构造函数&#x2F;析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数的分类和调用方式"><span class="nav-number">5.1.4.</span> <span class="nav-text">构造函数的分类和调用方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#无参构造"><span class="nav-number">5.1.4.1.</span> <span class="nav-text">无参构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有参构造"><span class="nav-number">5.1.4.2.</span> <span class="nav-text">有参构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#拷贝构造"><span class="nav-number">5.1.4.3.</span> <span class="nav-text">拷贝构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数的调用规则"><span class="nav-number">5.1.4.4.</span> <span class="nav-text">构造函数的调用规则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象参数的引用传递"><span class="nav-number">5.1.5.</span> <span class="nav-text">对象参数的引用传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深拷贝-浅拷贝"><span class="nav-number">5.1.6.</span> <span class="nav-text">深拷贝&#x2F;浅拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this指针"><span class="nav-number">5.1.7.</span> <span class="nav-text">this指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态成员"><span class="nav-number">5.1.8.</span> <span class="nav-text">静态成员</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#静态成员变量"><span class="nav-number">5.1.8.1.</span> <span class="nav-text">静态成员变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态成员函数"><span class="nav-number">5.1.8.2.</span> <span class="nav-text">静态成员函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const常函数和常对象"><span class="nav-number">5.1.9.</span> <span class="nav-text">const常函数和常对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#常函数"><span class="nav-number">5.1.9.1.</span> <span class="nav-text">常函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常对象"><span class="nav-number">5.1.9.2.</span> <span class="nav-text">常对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#友元"><span class="nav-number">5.1.10.</span> <span class="nav-text">友元</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#友元函数"><span class="nav-number">5.1.10.1.</span> <span class="nav-text">友元函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#友元类"><span class="nav-number">5.1.10.2.</span> <span class="nav-text">友元类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运算符重载"><span class="nav-number">5.2.</span> <span class="nav-text">运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#负号-重载（一元）"><span class="nav-number">5.2.1.</span> <span class="nav-text">负号-重载（一元）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加号-重载"><span class="nav-number">5.2.2.</span> <span class="nav-text">加号+重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关系运算符-重载"><span class="nav-number">5.2.3.</span> <span class="nav-text">关系运算符&#x3D;&#x3D;重载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">5.3.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#继承方式"><span class="nav-number">5.3.1.</span> <span class="nav-text">继承方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多继承"><span class="nav-number">5.3.2.</span> <span class="nav-text">多继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造和析构顺序"><span class="nav-number">5.3.3.</span> <span class="nav-text">构造和析构顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同名成员处理"><span class="nav-number">5.3.4.</span> <span class="nav-text">同名成员处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#派生类赋值给基类（向上转型）"><span class="nav-number">5.3.5.</span> <span class="nav-text">派生类赋值给基类（向上转型）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多态"><span class="nav-number">5.4.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#虚函数"><span class="nav-number">5.4.1.</span> <span class="nav-text">虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#纯虚函数"><span class="nav-number">5.4.2.</span> <span class="nav-text">纯虚函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#模版"><span class="nav-number">6.</span> <span class="nav-text">模版</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数模版-类模版"><span class="nav-number">6.1.</span> <span class="nav-text">函数模版&#x2F;类模版</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STL"><span class="nav-number">7.</span> <span class="nav-text">STL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#vector（向量）"><span class="nav-number">7.1.</span> <span class="nav-text">vector（向量）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数方法"><span class="nav-number">7.1.1.</span> <span class="nav-text">函数方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本用法"><span class="nav-number">7.1.2.</span> <span class="nav-text">基本用法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set（集合）"><span class="nav-number">7.2.</span> <span class="nav-text">set（集合）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数方法-1"><span class="nav-number">7.2.1.</span> <span class="nav-text">函数方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本用法-1"><span class="nav-number">7.2.2.</span> <span class="nav-text">基本用法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map（映射）"><span class="nav-number">7.3.</span> <span class="nav-text">map（映射）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数方法-2"><span class="nav-number">7.3.1.</span> <span class="nav-text">函数方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本用法-2"><span class="nav-number">7.3.2.</span> <span class="nav-text">基本用法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#deque（双端队列）"><span class="nav-number">7.4.</span> <span class="nav-text">deque（双端队列）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数方法-3"><span class="nav-number">7.4.1.</span> <span class="nav-text">函数方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本用法-3"><span class="nav-number">7.4.2.</span> <span class="nav-text">基本用法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stack（栈）"><span class="nav-number">7.5.</span> <span class="nav-text">stack（栈）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数方法-4"><span class="nav-number">7.5.1.</span> <span class="nav-text">函数方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本用法-4"><span class="nav-number">7.5.2.</span> <span class="nav-text">基本用法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string（字符串）"><span class="nav-number">7.6.</span> <span class="nav-text">string（字符串）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本用法-5"><span class="nav-number">7.6.1.</span> <span class="nav-text">基本用法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存分配"><span class="nav-number">8.</span> <span class="nav-text">内存分配</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型转换"><span class="nav-number">9.</span> <span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#隐式转换"><span class="nav-number">9.1.</span> <span class="nav-text">隐式转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算数转换"><span class="nav-number">9.1.1.</span> <span class="nav-text">算数转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#显式转换"><span class="nav-number">9.2.</span> <span class="nav-text">显式转换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常见问题记录"><span class="nav-number">10.</span> <span class="nav-text">常见问题记录</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#作为函数参数的多维数组"><span class="nav-number">10.1.</span> <span class="nav-text">作为函数参数的多维数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类模板头文件的编写"><span class="nav-number">10.2.</span> <span class="nav-text">类模板头文件的编写</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#问题描述"><span class="nav-number">10.2.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问题分析"><span class="nav-number">10.2.2.</span> <span class="nav-text">问题分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决方法"><span class="nav-number">10.2.3.</span> <span class="nav-text">解决方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常用函数"><span class="nav-number">11.</span> <span class="nav-text">常用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#sort-排序函数"><span class="nav-number">11.1.</span> <span class="nav-text">sort()排序函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">12.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="GuoYi"
      src="https://res.cloudinary.com/dh7ramrlh/image/upload/v1576578789/gy/IMG_0324_o40dwv.jpg">
  <p class="site-author-name" itemprop="name">GuoYi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">68</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">77</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">GuoYi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.6.0
  </div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'default',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      
<script type="text/x-mathjax-config">
    MathJax.Ajax.config.path['mhchem'] = '//cdn.jsdelivr.net/npm/mathjax-mhchem@3';

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        extensions: ['[mhchem]/mhchem.js'],
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: false,
      notify: false,
      appId: '8VTrBnqrHCihHxfEuBnrXVP3-gzGzoHsz',
      appKey: 'F0jqadgj1TbxEXnsj8evVvu9',
      placeholder: "来发个评论，留下邮箱接受回复。",
      avatar: 'mm',
      meta: guest,
      pageSize: '20' || 10,
      visitor: false,
      lang: '' || 'zh-cn',
      path: location.pathname,
      recordIP: false,
      serverURLs: ''
    });
  }, window.Valine);
});
</script>


  

</body>
</html>
