<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://gy23333.github.io').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="​    计算机网络课堂笔记，参考用书《计算机网络-自顶向下方法》。">
<meta property="og:type" content="article">
<meta property="og:title" content="《计算机网络-自顶向下方法》笔记">
<meta property="og:url" content="https://gy23333.github.io/2020/03/16/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="GuoYi的博客">
<meta property="og:description" content="​    计算机网络课堂笔记，参考用书《计算机网络-自顶向下方法》。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/J1qlUrQx9LiTFY2.png">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/oCDhqtVGuRLjenm.png">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/w1BdRQcMi5KS7Iz.png">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/xsZF9RbLfSq82or.png">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/dAzBna3i9lZU2uN.png">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/YZt3aBmjsS1dLIi.png">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/zkxt9eo4fQqmLRV.jpg">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/iCtTZGq6BQuHzwa.png">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/D91fBHdvxo24MFT.png">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/NubPYJA6WrcvsqI.png">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/yLN9bmafTdIqj6c.png">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/NugS6r92GDaCqeJ.png">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/RS7Lpk2YjGtCnKV.png">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/oYnb8OzPqg461Ux.png">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/uBFK4rGifLvsHqE.png">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/wxHkuoMDth7Bqpm.jpg">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/4mKvzSkIDigxhFX.png">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/OcMLw2JjiA9FsSP.png">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/tsgLBTpczPWhOHS.png">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/RJEuCxXSblUhyfV.png">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/2NDtUwYbpmuHPVo.png">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/ze59JcGyOojH2Dx.png">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/XmcGZnlLOg92azH.png">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/KQJyzFGPtanmhLk.jpg">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/CwpZhdnVO65m2DX.png">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/3vlYkrz47V6qC1w.jpg">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/mdYhZEKHulpkjTW.png">
<meta property="og:image" content="https://i.loli.net/2020/03/23/5D78VTnaSXjMyfR.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/delay.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/traffic%20intensity.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Throughput.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/socket.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_appsRequirements.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_appsProtocols.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Non-persistent%20HTTP(1).png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Non-persistent%20HTTP(2).png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/NetWork%20Non-persistent%20HTTP%20response%20time.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_DNS%20Server.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_iterated-query.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_recursive-query.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_DNS-message.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_file-distribution.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_vsPic.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_P2P-file.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_UDP_socket.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_UDP_socket_server.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_UDP_socket_client.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP_socket.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP_socket_server.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP_socket_client.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Multiplexing.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_segment-format.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_UDP-segment.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_provide-service.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_service-implementation.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt1-0-sender.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt1-0-receiver.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt2-0-sender.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt2-0-receiver.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt2-1-sender.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt2-1-receiver.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt2-2-sender.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt2-2-receiver.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt3-0-sender.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt3-0-NoLoss.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt3-0-LossPacket.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt3-0-LossACK.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt3-0-timeout.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Stop-and-Wait-Operation.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Pipelined-Operation.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_GBN-sender.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_GBN-sender(1).png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_GBN-receiver.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_GBN-action.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_SR-windows.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_SR-action.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_SR-dilemma.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-segment-structure.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-segment%23.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-segment-eg.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-sender.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-lostACK.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-premature-timeout.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-cumulativeACK.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-fastRetransmission.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-receiverBuffering.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-three-way-handshake.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-closeConnection.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-Lifecycle.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Congestion-scenario1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Congestion-scenario1-out.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Congestion-scenario1-delay.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Congestion-scenario2-pic1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Congestion-scenario2-pic2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Congestion-scenario2-pic3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-AIMD.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-cwnd.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-slow-start.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-congestion-window.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-congestion-control.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-throughput.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-Fairness.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-ECN.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_service-models.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Virtual-circuit.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Forwarding-Table.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_datagram-networks.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Longest-prefix-matching.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Router-architecture.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Input-port-processing.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Switching-Memory.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Switching-Bus.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Switching-Interconnection-Network.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Output-port-processing.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Abstract-graph-model.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Dijkstra%E2%80%99s-algorithm(1).png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Dijkstra%E2%80%99s-algorithm(2).png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_RPB.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Spanning-tree-broadcast.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_route-eg.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_DV.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_AS.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_RIP.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Hierarchical-OSPF.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_eBGP-iBGP.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_BGP-policy.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_IP-datagram-format.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_IP%20fragmentation-and-reassembly.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Fragmentation.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_IP-and-subnets.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_subnets.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Classful-Addressing.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_subnetting.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_DHCP.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Network-route.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Network-get-IP.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network-address-translation.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_IPv6-datagram-format.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Next-Header.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Dual-Stack.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Tunneling.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Character-count-method.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Framing-First-and-tail.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_EOT.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Framing-First-and-tail-bit.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_insert0.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Error-detection.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_One-bit-even-parity.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Two-dimensional-even-parity.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_CRC.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_CRC-calculation.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_CDMA.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Pure-ALOHA.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Slotted-ALOHA.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_ALOHA-Compare.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_CSMA-Collision.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_CSMA%3ACD.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_CSMA%3ACD1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Polling-protocol.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Token-Passing-protocol.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_MAC-address.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_APR.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_ARP.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Ethernet-Bus.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Ethernet-Star.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Ethernet-Frame-Structure.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Ethernet-standards.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_hub.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_switch1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_VLAN.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Connecting-two-VLAN.png">
<meta property="og:image" content="https://raw.githubusercontent.com/GY23333/imgs/master/Network_VLAN-frame.png">
<meta property="article:published_time" content="2020-03-16T12:54:15.000Z">
<meta property="article:modified_time" content="2024-12-25T15:42:08.176Z">
<meta property="article:author" content="GuoYi">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/J1qlUrQx9LiTFY2.png">

<link rel="canonical" href="https://gy23333.github.io/2020/03/16/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>《计算机网络-自顶向下方法》笔记 | GuoYi的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="GuoYi的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">GuoYi的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-music">

    <a href="/music/" rel="section"><i class="fa fa-fw fa-music"></i>music</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://gy23333.github.io/2020/03/16/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://res.cloudinary.com/dh7ramrlh/image/upload/v1576578789/gy/IMG_0324_o40dwv.jpg">
      <meta itemprop="name" content="GuoYi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GuoYi的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《计算机网络-自顶向下方法》笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-16 20:54:15" itemprop="dateCreated datePublished" datetime="2020-03-16T20:54:15+08:00">2020-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-25 23:42:08" itemprop="dateModified" datetime="2024-12-25T23:42:08+08:00">2024-12-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/03/16/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/03/16/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>​    计算机网络课堂笔记，参考用书《计算机网络-自顶向下方法》。</p>
<a id="more"></a>
<h1 id="计算机网络和因特网"><a href="#计算机网络和因特网" class="headerlink" title="计算机网络和因特网"></a>计算机网络和因特网</h1><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>​    起源是为了形成一个自主、自治、互联的计算机通信系统。</p>
<h3 id="构成描述"><a href="#构成描述" class="headerlink" title="构成描述"></a>构成描述</h3><p>​    因特网也被称为“网中网”，我们所用的网络都是大网中的小网（套娃）。</p>
<ul>
<li>接入网络的设备——网络边缘<ul>
<li><strong>主机</strong>（host） = <strong>端系统</strong>（end system）</li>
<li>运行的联网app</li>
</ul>
</li>
<li><strong>通信链路</strong>（communication link）——接入网<ul>
<li>媒介：同轴电缆、铜线、光纤、无线电频谱</li>
<li>传输速率：带宽 bps</li>
</ul>
</li>
<li><strong>分组交换机</strong>（packet switch）——网络核心<ul>
<li><strong>路由器</strong>（router）和 <strong>链路层交换机</strong>（link-layer switch）</li>
</ul>
</li>
</ul>
<ul>
<li><strong>协议</strong>：控制发送、接收信息。比如，TCP, IP, HTTP等等。每个层次有每个层次的协议。</li>
<li><strong>网络标准</strong><ul>
<li>因特网工程任务组（<strong>IETF</strong>）： 制定网络标准的组织</li>
<li>请求评论（<strong>RFC</strong>）：IETF的标准文档</li>
</ul>
</li>
</ul>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/J1qlUrQx9LiTFY2.png" style="zoom:50%;" /></p>
<h3 id="服务描述"><a href="#服务描述" class="headerlink" title="服务描述"></a>服务描述</h3><ul>
<li><p>为应用程序提供服务的基础设施</p>
<p>即用户使用应用。</p>
</li>
<li><p>应用程序编程接口</p>
<p>即编写应用。</p>
</li>
</ul>
<h2 id="网络边缘（Network-Edge）"><a href="#网络边缘（Network-Edge）" class="headerlink" title="网络边缘（Network Edge）"></a>网络边缘（Network Edge）</h2><p>​    与因特网相接的计算机及其他设备位于因特网的边缘，称为<strong>端系统</strong>。</p>
<p>端系统 = 主机，可以被划为下面两种：</p>
<ul>
<li>客户（client）</li>
<li>服务器（server）：比如有企业存储大量数据的大型<strong>数据中心</strong>（data centers）</li>
</ul>
<h3 id="接入网（Access-Networks）"><a href="#接入网（Access-Networks）" class="headerlink" title="接入网（Access Networks）"></a>接入网（Access Networks）</h3><p>​    网络边缘的端系统  通过 <strong>接入网</strong>（物理链路）  连接到  <strong>边缘路由器</strong>（端系统到任何其他远程端系统的路径上的第一台路由器）。</p>
<h4 id="家庭接入：DSL、电缆、FTTH、拨号和卫星"><a href="#家庭接入：DSL、电缆、FTTH、拨号和卫星" class="headerlink" title="家庭接入：DSL、电缆、FTTH、拨号和卫星"></a>家庭接入：DSL、电缆、FTTH、拨号和卫星</h4><ul>
<li><strong>数字用户线</strong>（digital subscriber line，<strong>DSL</strong>）</li>
</ul>
<p>​    利用<strong>电话线路</strong>接入网络。其中 <strong>ADSL</strong>是非对称的数字用户线，基本都用ADSL，因为一般下行的数据量都远大于上行的数据量，所以要设计成非平衡的链路。</p>
<p>​    采用<strong>独占</strong>的<strong>频分多路复用</strong>来传输。因为利用的是原有的电话线路，所以需要将DSL传输的网络信号（上行、下行）和电话信号通过频分多路复用来区分开来。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>频段</th>
<th>传输信号</th>
</tr>
</thead>
<tbody>
<tr>
<td>0~4K</td>
<td>电话语音线路</td>
</tr>
<tr>
<td>4K~50K</td>
<td>上行信号</td>
</tr>
<tr>
<td>50K~1M</td>
<td>下行信号</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/oCDhqtVGuRLjenm.png" alt="截屏2020-03-20上午12.22.20.png" style="zoom:50%;" /></p>
<ul>
<li><p><strong>电缆因特网接入</strong>（cable Internet access）</p>
<p>利用<strong>有线电视网</strong>接入网络。结构上，通过粗的同轴电缆接入社区，再用细的同轴电缆接入每家每户。</p>
<p>采用<strong>共享</strong>的<strong>频分多路复用</strong>来传输。</p>
</li>
</ul>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/w1BdRQcMi5KS7Iz.png" style="zoom:50%;" /></p>
<ul>
<li><strong>混合光纤同轴电缆</strong>（<strong>HFC</strong>）</li>
</ul>
<p>​    <strong>同轴电缆</strong>和<strong>光纤节点</strong>相连再接入边缘路由器。</p>
<p>​    <strong>不对称</strong>的<strong>竞争式协议</strong>，最高可达到30Mbps的下行速率和2Mbps的上行速率。由于采用竞争式协议，在用户少时使用体验优于普通的电缆因特网接入，但是在用户多时容易造成卡顿。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/xsZF9RbLfSq82or.png" style="zoom:50%;" /></p>
<h4 id="企业（家庭）接入：以太网和WiFi"><a href="#企业（家庭）接入：以太网和WiFi" class="headerlink" title="企业（家庭）接入：以太网和WiFi"></a>企业（家庭）接入：以太网和WiFi</h4><ul>
<li><strong>以太网</strong>：使用双绞铜线与一台以太网交换机相连，速率可达到100Mbps、1Gbps、10Gbps。</li>
<li><strong>WiFi</strong>：IEEE802.11技术无线LAN，范围在几十米内。</li>
</ul>
<h4 id="广义无线接入：4G和5G"><a href="#广义无线接入：4G和5G" class="headerlink" title="广义无线接入：4G和5G"></a>广义无线接入：4G和5G</h4><p>​    详见第六章</p>
<h3 id="物理媒体（Physical-Media）"><a href="#物理媒体（Physical-Media）" class="headerlink" title="物理媒体（Physical Media）"></a>物理媒体（Physical Media）</h3><ul>
<li>导引型媒体（guided media）：信号在固体媒体中传输，比如光缆、双绞铜线和同轴电缆。</li>
<li>非导引型媒体（unguided media）：电波在空气中传播，比如无线局域网或数字卫星频道。</li>
</ul>
<h2 id="网络核心（Network-Core）"><a href="#网络核心（Network-Core）" class="headerlink" title="网络核心（Network Core）"></a>网络核心（Network Core）</h2><p>​    网络核心：由端系统的分组交换机和链路构成的网状网络。下图标亮部分即使网络核心。</p>
<p>​    一共有三种交换方式：报文交换（很少使用）、分组交换和电路交换</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/dAzBna3i9lZU2uN.png" style="zoom:50%;" /></p>
<h3 id="分组交换（Packet-Switching）"><a href="#分组交换（Packet-Switching）" class="headerlink" title="分组交换（Packet Switching）"></a>分组交换（Packet Switching）</h3><p>​    端系统之间彼此传输报文，分组交换中，将长报文划分为分组，分组再通过通信链路和分组交换机（分为路由器和链路层交换机）传送。</p>
<ol>
<li><p><strong>存储转发传输</strong>（Store-and-Forward Transmission）</p>
<p>​    分组交换和报文交换都采用了存储转发的传输形式。但分组交换的存储转发以分组为单位，即交换机接收到整个分组后才能输出该分组的数据；而报文交换的存储转发单位为报文，需要交换机接收到整个报文后才能输出。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/YZt3aBmjsS1dLIi.png" style="zoom:50%;" /></p>
<p>​    传输相同大小的数据包，分组交换比报文交换更快。下面是分组交换传输3L大小的报文的时间流，报文分为3个大小为L的分组，根据分组交换原理，一共耗费了 4L/R 时间完成传输（即<strong>存储转发时延</strong>）。而如果使用报文传输同样的3L大小的报文则需要耗费 6L/R 时间。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/zkxt9eo4fQqmLRV.jpg" alt="分组交换.jpg" style="zoom: 30%;" /></p>
</li>
<li><p><strong>排队时延</strong>（Queuing Delay）和<strong>分组丢失</strong>（Packet Loss）</p>
<p>​    分组交换机有有一个<strong>输出缓存</strong>（output buffer），分组可能会在分组交换机上排队等待输出，造成排队时延。</p>
<p>​    分组交换机的缓存空间是有限的，所以在过于拥堵时会产生分组丢失（丢包）。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/iCtTZGq6BQuHzwa.png" style="zoom:50%;" /></p>
</li>
<li><p><strong>转发表</strong>（Forwarding Table）和<strong>路由选择协议</strong>（Routing Protocol）</p>
<ul>
<li><strong>路由</strong>：分组中包括IP地址；</li>
<li><strong>转发</strong>：路由器中将目的地址映射为输出链路。</li>
</ul>
</li>
</ol>
<h3 id="电路交换（Circuit-Switching）"><a href="#电路交换（Circuit-Switching）" class="headerlink" title="电路交换（Circuit Switching）"></a>电路交换（Circuit Switching）</h3><p>​    <strong>端到端连接</strong>（end- to-end connection）：在发送数据之前，必须先在发送和接收两端建立端到端连接，并预留一部分带宽。而分组交换不预留，所以会造成排队和丢包。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/D91fBHdvxo24MFT.png" style="zoom:50%;" /></p>
<h4 id="频分多路复用（FDM）"><a href="#频分多路复用（FDM）" class="headerlink" title="频分多路复用（FDM）"></a>频分多路复用（FDM）</h4><p>​    链路中的每条连接专用一个频段。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/NubPYJA6WrcvsqI.png" style="zoom: 40%;" /></p>
<h4 id="时分多路复用（TDM）"><a href="#时分多路复用（TDM）" class="headerlink" title="时分多路复用（TDM）"></a>时分多路复用（TDM）</h4><p>​    远距离传输会有衰减，所以考虑用<strong>数字信号</strong>进行传输。在时域上对信号进行<strong>采样</strong>，接收时再将采样信号恢复。</p>
<p>​    TDM在时域上被划分为固定的<strong>帧</strong>（frame），每帧又被划分为固定数量的<strong>时隙</strong>（slot），链路中的每条连接专用一个时隙。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/yLN9bmafTdIqj6c.png" style="zoom: 67%;" /></p>
<h3 id="分组交换-amp-电路交换"><a href="#分组交换-amp-电路交换" class="headerlink" title="分组交换 &amp; 电路交换"></a>分组交换 &amp; 电路交换</h3><p>​    分组交换的性能优于电路交换，适用于随机数据，可以满足更多用户。</p>
<p>​    电路交换需要预留带宽，相当于固定了链路用户的数量。而分组交换不需要预留带宽，用户使用网络是有一定概率的，在一个时刻较多人使用的概率其实相对较低，所以一条链路可以给更多的用户使用。</p>
<p>​    电路交换适用于特殊情况，比如要保障传输数据能力。</p>
<h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>​    网络结构是网中之网，具有层次结构。</p>
<ul>
<li><strong>ISP</strong>：ISP分为许多层级，比如<strong>第一层ISP</strong>（tier-1 ISP）、<strong>区域ISP</strong>（regional ISP）、<strong>接入ISP</strong>（access ISP）。端系统通过接入ISP与因特网相连，全球的ISP通过各个层级相连，形成了互联网的互联。</li>
<li>因特网交换点（Internet Exchange Point，<strong>IXP</strong>）：由第三方公司创建，IXP是一个汇合点，多个ISP在此处对等。</li>
</ul>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/NugS6r92GDaCqeJ.png" style="zoom: 60%;" /></p>
<h2 id="协议（Protocol）"><a href="#协议（Protocol）" class="headerlink" title="协议（Protocol）"></a>协议（Protocol）</h2><p>​    协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及报文发送和/或接收一条报文或其他时间所采取的动作。</p>
<p>​    协议三大要素：</p>
<ul>
<li>语法（Syntax）：每一段内容符合一定规则的格式，比如一个报文前8位是原地址，后八个是目的地址（只是举例，不要当真）之类。</li>
<li>语义（Semantics）：每一段内容需要代表某种意义，比如原地址部分的二进制到底是指哪个地址。</li>
<li>同步（Timing）：通信的过程，即每一段任务的执行顺序。</li>
</ul>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/RS7Lpk2YjGtCnKV.png" style="zoom:50%;" /></p>
<h2 id="协议层次（Protocol-Layer）及其服务模型"><a href="#协议层次（Protocol-Layer）及其服务模型" class="headerlink" title="协议层次（Protocol Layer）及其服务模型"></a>协议层次（Protocol Layer）及其服务模型</h2><h3 id="五层因特网协议栈"><a href="#五层因特网协议栈" class="headerlink" title="五层因特网协议栈"></a>五层因特网协议栈</h3><p>​    因特网协议栈由5个层次组成：物理层、链路层、网络层、传输层和应用层。因特网协议栈是一个理想模型。</p>
<p>​    下层为上层提供服务。越下面的层，越靠近硬件；越上面的层，越靠近用户。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/oYnb8OzPqg461Ux.png" alt="截屏2020-03-22上午12.23.35.png" style="zoom: 20%;" /></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">层次</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">应用层（Application Layer）</td>
<td>支持网络应用，应用协议仅仅是网络应用的一个组成部分，运行在不同主机上的进程则使用应用层协议进行通信。</td>
</tr>
<tr>
<td style="text-align:center">传输层（Transport Layer）</td>
<td>负责为信源和信宿提供应用程序进程间的数据传输服务，这一层上主要定义了两个传输协议，传输控制协议即TCP和用户数据报协议UDP。</td>
</tr>
<tr>
<td style="text-align:center">网络层（Network Layer）</td>
<td>负责将<strong>数据报</strong>独立地从信源发送到信宿，主要解决路由选择、拥塞控制和网络互联等问题。</td>
</tr>
<tr>
<td style="text-align:center">链路层（Link Layer）</td>
<td>负责将IP数据报封装成合适在物理网络上传输的<strong>帧</strong>格式并传输，或将从物理网络接收到的帧解封，取出IP数据报交给网络层。</td>
</tr>
<tr>
<td style="text-align:center">物理层（Physical Layer）</td>
<td>负责将<strong>比特流</strong>在结点间传输，即负责物理传输。该层的协议既与链路有关也与传输介质有关。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h3><p>​    OSI模型由国际标准化组织（ISO）制定，实际并没有应用，只有理论。</p>
<p>​    OSI模型由7层组成：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。</p>
<h3 id="封装（Encapsulation）"><a href="#封装（Encapsulation）" class="headerlink" title="封装（Encapsulation）"></a>封装（Encapsulation）</h3><p>​    在发送端，</p>
<ol>
<li><p>应用层：将 <strong>应用层报文</strong>（application-layer message）M传送给传输层；</p>
</li>
<li><p>传输层：接收报文M，附上传输层首部信息Ht（包括差错检测位信息等），构成 <strong>传输层报文段</strong>（transport-layer segment），将其传递给网络层；</p>
</li>
<li><p>网络层：接收传输层报文段，附上网络层首部信息Hn（包括源和目的地址等），构成 <strong>网络层数据段</strong>（network-layer datagram），将其传递给网络层；</p>
</li>
<li><p>链路层：接收网络层数据段，附上链路层首部信息Hl，构成 <strong>链路层帧</strong>（link-layer frame），将其传递给物理层；</p>
</li>
<li><p>物理层：负责比特流物理传输。</p>
<p>在接收端以反方向重构报文段。</p>
</li>
</ol>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/uBFK4rGifLvsHqE.png" style="zoom:50%;" /></p>
<h2 id="物理层概述"><a href="#物理层概述" class="headerlink" title="物理层概述"></a>物理层概述</h2><p>​    在两个物理媒体间进行比特流传输，上层都是逻辑链接，只有物理层是实际的物理连接。</p>
<h3 id="物理层基本目标"><a href="#物理层基本目标" class="headerlink" title="物理层基本目标"></a>物理层基本目标</h3><ul>
<li>保证发送信号“0”和“1”的正确性以及发送和接收的一致性；</li>
<li>比特流传输的模式、速度、持续时间和信号失真；</li>
<li>接口设计：引脚数目、功能等等；</li>
<li>信号传输的程序：如何安排传输过程和事件次序。</li>
</ul>
<h3 id="物理层的基本特性"><a href="#物理层的基本特性" class="headerlink" title="物理层的基本特性"></a>物理层的基本特性</h3><ul>
<li><p><strong>机械特性</strong>：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等；</p>
</li>
<li><p><strong>电气特性</strong>：指明传输模式、电压范围、编码、阻抗匹配、传输速率以及传输距离等等；</p>
</li>
<li><p><strong>功能特性</strong>：指明各条物理线路的功能，比如某条线上出现的某一电平的电压表示何种意义，</p>
<p>物理接口信号线按功能分为四类：数据线、控制线、定时线和地线；</p>
</li>
<li><p><strong>规程特性</strong>：指明各物理线路工作规程和时序的关系，比如对于不同功能的各种可能事件的出现顺序，</p>
<p>信号传输的模式：单工（仅单向通行）、半双工（双方通，但一个时刻仅一方通）、全双工（双方随时通）。</p>
</li>
</ul>
<h2 id="基本通信原理"><a href="#基本通信原理" class="headerlink" title="基本通信原理"></a>基本通信原理</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>数据（data）：对于客观事实描述的物理符号，包括数字、文本、语言、图像等等；</li>
<li>信息（information）：数据的集合；</li>
<li>信号（signal）：数据传输中的表现形式，比如模拟信号、数字信号；</li>
<li>信道（channel）：往固定方向传输信息的媒介。</li>
</ul>
<p><strong>模拟传输VS数字传输</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>传输方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>模拟</td>
<td>对信道有高利用率</td>
<td>不抗噪</td>
</tr>
<tr>
<td>数字</td>
<td>信号不易失真</td>
<td>需要更宽的带宽</td>
</tr>
</tbody>
</table>
</div>
<h3 id="信道特性"><a href="#信道特性" class="headerlink" title="信道特性"></a>信道特性</h3><ul>
<li><p><strong>码元</strong>（Symbol）：承载信息量的基本信号单位。</p>
<p>​    下面是马原分级数 N 与所需bit位数 n 的关系（N个离散的值需要n个bits）</p>
<script type="math/tex; mode=display">
n=log_2N</script><p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/wxHkuoMDth7Bqpm.jpg" style="zoom:40%;" /></p>
</li>
<li><p><strong>波特率</strong>（Baud rate）：传输码元的速率。</p>
</li>
<li><p><strong>比特率</strong>（Bit rate）：传输比特的速率。</p>
<p>波特率与比特率的关系</p>
<script type="math/tex; mode=display">
bit\ rate(b/s)=baud\ rate*n</script></li>
<li><p><strong>信道容量</strong>（Channel capacity）：在一个信道中能够可靠地传送信息时可达速率的最小上界，单位 bps。</p>
</li>
<li><p><strong>频带宽度</strong>（Frequency bandwidth）：信道允许的信号频率范围，单位 Hz。</p>
<script type="math/tex; mode=display">
Frequency\ bandwidth = maximum\ bandwidth-minimum\ bandwidth</script></li>
<li><p><strong>传输延迟</strong>（Transmission delay）：包括发送到接受的处理事件、电信号的响应时间、中间介质的传输时间。</p>
</li>
<li><p><strong>奈奎斯特定理</strong>（Nyquist’s Law）</p>
<ol>
<li>对于理想的低通信号，在一个频带宽度为 W 的信道，其码元的最大传输速率 = 2W Baud</li>
<li>对于理想的带通信号，在一个频带宽度为 W 的信道，其码元的最大传输速率 = W Baud</li>
</ol>
</li>
<li><p><strong>香农定理</strong>（Shannon’s Formula）</p>
<p>信道的信息传输速率C（单位：bps）</p>
<script type="math/tex; mode=display">
C=Wlog_2(1+S/N)</script><ul>
<li><p>W -  带宽，单位 Hz</p>
</li>
<li><p>S  -  信道的平均信号功率</p>
</li>
<li><p>N  -  信道的高斯噪声功率</p>
</li>
<li><p>S/N  -  信号功率与噪声功率之比（也可以叫信噪比）</p>
<p>一般情况下，信噪比不用 $S/N$ 表示，而是 $10log_{10}S/N$ ，单位为dB。</p>
</li>
</ul>
</li>
</ul>
<h3 id="模拟-数字信号传输"><a href="#模拟-数字信号传输" class="headerlink" title="模拟/数字信号传输"></a>模拟/数字信号传输</h3><p>​    模拟信道只能传输模拟信号，数字信道只能传输数字信号。</p>
<h4 id="调制解调器"><a href="#调制解调器" class="headerlink" title="调制解调器"></a>调制解调器</h4><p>​    数字/模拟信号 经过 <strong>调制</strong> 变成 <strong>模拟信号</strong>，如此可在 模拟信道 上传输，再经过 <strong>解调</strong> 变成 数字/模拟信号。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/4mKvzSkIDigxhFX.png" style="zoom:40%;" /></p>
<h4 id="编码解码器"><a href="#编码解码器" class="headerlink" title="编码解码器"></a>编码解码器</h4><p>​    数字/模拟信号 经过 <strong>编码</strong> 变成 <strong>数字信号</strong>，如此可在 数字信道 上传输，再经过 <strong>解码</strong> 变成 数字/模拟信号。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/OcMLw2JjiA9FsSP.png" alt="截屏2020-03-23上午1.37.30.png" style="zoom:40%;" /></p>
<h4 id="调制（Modulation）：数字信号到模拟信号"><a href="#调制（Modulation）：数字信号到模拟信号" class="headerlink" title="调制（Modulation）：数字信号到模拟信号"></a>调制（Modulation）：数字信号到模拟信号</h4><p>​    从数字信号到模拟信号的调制主要有三种方法：</p>
<ul>
<li><p><strong>调幅</strong>（Amplitude Modulation，<strong>AM</strong>）</p>
<p>把数字信号转化成不同幅度的正弦信号。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/tsgLBTpczPWhOHS.png" style="zoom:50%;" /></p>
</li>
<li><p><strong>调频</strong>（Frequency Modulation，<strong>FM</strong>）</p>
<p>把数字信号转化成不同频率的正弦信号。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/RJEuCxXSblUhyfV.png" style="zoom:40%;" /></p>
</li>
<li><p><strong>调相</strong>（Phase Modulation，<strong>PM</strong>）</p>
<p>把数字信号转化成不同相位的正弦信号。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/2NDtUwYbpmuHPVo.png" style="zoom:40%;" /></p>
</li>
</ul>
<h4 id="脉码调制（Pulse-Code-Modulation-PCM）"><a href="#脉码调制（Pulse-Code-Modulation-PCM）" class="headerlink" title="脉码调制（Pulse Code Modulation, PCM）"></a>脉码调制（Pulse Code Modulation, PCM）</h4><p>​    模拟信号变成数字信号。</p>
<p>脉码调制步骤：</p>
<ol>
<li><p>采样（Sampling system）</p>
<p>采样频率是信号频率的两倍，则可不失真地恢复原始信号。</p>
</li>
<li><p>量化（Quantify）</p>
<p>取整采样信号。</p>
</li>
<li><p>编码（Coding）</p>
<p>量化后的信号编码成二进制。</p>
</li>
</ol>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/ze59JcGyOojH2Dx.png" style="zoom: 33%;" /></p>
<h4 id="数字信号编码（Digital-signal-coding）"><a href="#数字信号编码（Digital-signal-coding）" class="headerlink" title="数字信号编码（Digital signal coding）"></a>数字信号编码（Digital signal coding）</h4><p>​    数字信号到数字信号。</p>
<h5 id="不归零编码（Non-Return-To-Zero-NRZ）"><a href="#不归零编码（Non-Return-To-Zero-NRZ）" class="headerlink" title="不归零编码（Non-Return-To-Zero, NRZ）"></a>不归零编码（Non-Return-To-Zero, NRZ）</h5><p>​    主要介绍两种不归零编码。</p>
<ul>
<li><p>Non-Return-To-Zero Level (<strong>NRZ-L</strong>) Coding</p>
<p>​    高电平表示“1”，低电平表示“0”。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/XmcGZnlLOg92azH.png" style="zoom: 15%;" /></p>
<p>NRZ-L的优点：简单好实现</p>
<p>NRZ-L的缺点：</p>
<ul>
<li>难以分清二进制一位的开始和结束，所以必须要带<strong>同步时钟</strong>（外同步）来同步。可以把上图的虚线当作是同步时钟，当把虚线去掉是，相同电平的信号就不好判断开始和结束了。</li>
<li>在传输全“1”或全“0”信号时，此时传输的只有直流分量（傅立叶分不出正弦或余弦分量），这样线路上会有比较大的噪声。</li>
</ul>
</li>
<li><p>反向不归零编码（<strong>NRZ-I</strong>）</p>
<p>​    遇“1”反向。只能解决NRZ-L的部分问题（全“1”问题，不再是直流）</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/KQJyzFGPtanmhLk.jpg" style="zoom:50%;" /></p>
</li>
</ul>
<p><strong>外同步</strong>（External synchronization）</p>
<p>​    给系统一个同步时钟信号，设置一个周期的宽度。</p>
<p>​    外同步有诸多不便，于是有了自同步的曼切斯特编码。</p>
<h5 id="曼切斯特编码（Manchester-encoding）"><a href="#曼切斯特编码（Manchester-encoding）" class="headerlink" title="曼切斯特编码（Manchester encoding）"></a>曼切斯特编码（Manchester encoding）</h5><p>​    每个编码由两段组成，“1”：先高后低；“0”：先低后高（可以反过来定义）。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/CwpZhdnVO65m2DX.png" style="zoom: 20%;" /></p>
<p>曼切斯特编码的优点（解决了不归零编码的问题）：</p>
<ul>
<li>自同步，不需要同步时钟；</li>
<li>直流分量为0。</li>
</ul>
<p>曼切斯特编码的缺点：</p>
<ul>
<li><p><strong>基频增加</strong>：基频是不归零编码的两倍，从而比特率变成了不归零编码的一半；</p>
</li>
<li><p><strong>二义性</strong>：组合情况有两种。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/3vlYkrz47V6qC1w.jpg" style="zoom: 40%;" /></p>
</li>
</ul>
<h5 id="差分曼切斯特编码（Differential-Manchester-encoding）"><a href="#差分曼切斯特编码（Differential-Manchester-encoding）" class="headerlink" title="差分曼切斯特编码（Differential Manchester encoding）"></a>差分曼切斯特编码（Differential Manchester encoding）</h5><p>​    解决曼切斯特编码的二义性。</p>
<ul>
<li>“1”：自己的前半波与前一个编码的后半波相同；</li>
<li><p>“0”：自己的前半波与前一个编码的后半波相反。</p>
<p> 有两种画法，初始为高、初始为低，两种画法结果对称。</p>
</li>
</ul>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/mdYhZEKHulpkjTW.png" style="zoom: 33%;" /></p>
<p>​    差分曼切斯特编码的优点：</p>
<ul>
<li>解决NRZ问题</li>
<li>解决二义性问题</li>
</ul>
<p>​    差分曼切斯特编码的缺点（同曼切斯特编码）：</p>
<ul>
<li>基频翻倍</li>
<li>高频噪声增加</li>
</ul>
<h5 id="块编码（Block-encoding）"><a href="#块编码（Block-encoding）" class="headerlink" title="块编码（Block encoding）"></a>块编码（Block encoding）</h5><ol>
<li>将原信号每 m bits 分为一块；</li>
<li>把 m bits 的每块映射成 n bits 的块（m &lt; n）；</li>
<li>将 n bits 的块重新组合起来。</li>
</ol>
<p><img src="https://i.loli.net/2020/03/23/5D78VTnaSXjMyfR.png" style="zoom:33%;" /></p>
<h3 id="多路复用（Multiplexing）"><a href="#多路复用（Multiplexing）" class="headerlink" title="多路复用（Multiplexing）"></a>多路复用（Multiplexing）</h3><h4 id="频分多路复用（Frequency-division-multiplexing，FDM）"><a href="#频分多路复用（Frequency-division-multiplexing，FDM）" class="headerlink" title="频分多路复用（Frequency division multiplexing，FDM）"></a>频分多路复用（Frequency division multiplexing，FDM）</h4><p>​    见 <a href="https://gy23333.github.io/2020/03/16/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0/#%E9%A2%91%E5%88%86%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%88FDM%EF%BC%89">频分多路复用</a> 。</p>
<h4 id="时分多路复用（Time-division-multiplexing，TDM）"><a href="#时分多路复用（Time-division-multiplexing，TDM）" class="headerlink" title="时分多路复用（Time division multiplexing，TDM）"></a>时分多路复用（Time division multiplexing，TDM）</h4><p>​    见 <a href="https://gy23333.github.io/2020/03/16/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0/#%E6%97%B6%E5%88%86%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%88TDM%EF%BC%89">时分多路复用</a> 。</p>
<h4 id="波分多路复用（Wavelength-division-multiplexing，WDM）"><a href="#波分多路复用（Wavelength-division-multiplexing，WDM）" class="headerlink" title="波分多路复用（Wavelength division multiplexing，WDM）"></a>波分多路复用（Wavelength division multiplexing，WDM）</h4><p>​    和FDM原理相同，但主要在光波中采用。</p>
<h4 id="码分多路复用（Code-division-multiplexing，CDM）"><a href="#码分多路复用（Code-division-multiplexing，CDM）" class="headerlink" title="码分多路复用（Code division multiplexing，CDM）"></a>码分多路复用（Code division multiplexing，CDM）</h4><p>举例说明</p>
<p>​    每台设备都给一个不同向量的码片，比如手机A的码片为A，手机B的码片为B。不同设备的码片正交，即</p>
<script type="math/tex; mode=display">
\begin{cases}
A\times B = 0\\
A\times A = 1
\end{cases}</script><p>​    要向手机A发送数据a，向手机B发送数据b，则在信道中发送 $a\times A + b\times B$。</p>
<p>​    在手机A接收数据时，将接收到的信号乘A。</p>
<script type="math/tex; mode=display">
(a\times A + b\times B) \times A = a\times A\times A + b\times B \times A = a</script><p>​    同理手机B，如此两台设备同时利用一条信道传输，并成功分离各自的数据。</p>
<h2 id="延时、丢包、吞吐量"><a href="#延时、丢包、吞吐量" class="headerlink" title="延时、丢包、吞吐量"></a>延时、丢包、吞吐量</h2><h3 id="延时（delay）"><a href="#延时（delay）" class="headerlink" title="延时（delay）"></a>延时（delay）</h3><p>​    现实中的计算机系统不是理想系统，事件是随机突发的，所以不可避免的存在延时。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/delay.png" alt="delay.png" style="zoom:33%;" /></p>
<p>​    数据包的延时由四个部分组成：</p>
<script type="math/tex; mode=display">
d_{nodal} = d_{prop}+d_{queue}+d_{trans}+d_{prop}</script><ul>
<li><p><strong>处理时延</strong>（Nodal Processing Delay，$d_{proc}$）</p>
<p>​    路由器接收到分组对其进行处理的时间（比如差错检测），耗时很短，毫秒级。</p>
</li>
<li><p><strong>排队时延</strong>（Queuing Delay，$d_{queue}$）</p>
<p>​    分组在链路上等待传输的时间，取决于先期到达的正在排队等待向链路传输的分组数量。</p>
</li>
<li><p><strong>传输时延</strong>（Transmission Delay，$d_{trans}$）</p>
<p>​    将分组的比特流传输到链路的时间（比如进行编码转换成查分曼切斯特编码的时间）。</p>
<p>​    如分组长度 L ，传输速率 R bps，则其传输时延为：</p>
<script type="math/tex; mode=display">
d_{trans}=L/R</script><p>​    所以传输时间取决于分组长度和传输速率。</p>
</li>
<li><p><strong>传播时延</strong>（Propagation Delay，$$）</p>
<p>​    信号在媒体上传播的时间。</p>
<p>​    如物理链路的长度 d，传播速度 s m/sec，则其传播时延为：</p>
<script type="math/tex; mode=display">
d_{prop}=d/s</script></li>
</ul>
<h3 id="丢包（Packet-Loss）"><a href="#丢包（Packet-Loss）" class="headerlink" title="丢包（Packet Loss）"></a>丢包（Packet Loss）</h3><p>​    流量强度（traffic intensity）代表了路由器上排队的拥堵率。</p>
<script type="math/tex; mode=display">
traffic\ intensity = (L\times a)/R</script><p>​    其中，L —— 分组长度（bits）；</p>
<p>​               R —— 链路带宽（bps）；</p>
<p>​               a —— 平均分组到达速率</p>
<ul>
<li>流量强度接近0时，几乎没有分组到达，排队延时很小；</li>
<li>流量强度0～1时，平均排队长度越来越长，排队延时越来越长；</li>
<li>流量强度接近1时，存在到达率超过传输时间间隔，拥堵。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/traffic%20intensity.png" alt="traffic intensity.png" style="zoom: 50%;" /></p>
<p>​    路由器的排队容量是有限的，当分组到达一个已满的队列时，路由器将丢弃该分组，产生丢包。</p>
<h3 id="吞吐量（Throughput）"><a href="#吞吐量（Throughput）" class="headerlink" title="吞吐量（Throughput）"></a>吞吐量（Throughput）</h3><p>​    从主机A到主机B传文件，B接收文件的速率为<strong>瞬时吞吐量</strong>（instantaneous throughput），单位bps；所有时间的平均速率为<strong>平均吞吐量</strong>（average throughput）。</p>
<p>​    串联链路吞吐量取决于<strong>瓶颈链路</strong>（bottleneck link）。</p>
<script type="math/tex; mode=display">
Throughput = min\{R_1, R_2,...,R_N\}</script><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Throughput.png" alt="Throughput.png" style="zoom:70%;" /></p>
<h1 id="应用层（Application-Layer）"><a href="#应用层（Application-Layer）" class="headerlink" title="应用层（Application Layer）"></a>应用层（Application Layer）</h1><h2 id="网络应用原理"><a href="#网络应用原理" class="headerlink" title="网络应用原理"></a>网络应用原理</h2><ul>
<li>可以在不同类型主机运行；</li>
<li>可以在不同终端间相互通讯；</li>
<li>在编写网络应用的过程中，不需要考虑网络核心设备，网络核心不会允许应用；</li>
<li>端系统上的应用可以快速开发，而且易于传播。</li>
</ul>
<h3 id="网络应用结构"><a href="#网络应用结构" class="headerlink" title="网络应用结构"></a>网络应用结构</h3><h4 id="客户机-服务器体系结构（Client-server-architecture）"><a href="#客户机-服务器体系结构（Client-server-architecture）" class="headerlink" title="客户机-服务器体系结构（Client-server architecture）"></a>客户机-服务器体系结构（Client-server architecture）</h4><p>​    例如：HTTP、IMAP、FTP</p>
<p><strong>服务器</strong>：</p>
<ul>
<li>永远在线；</li>
<li>IP地址恒定；</li>
<li>服务器往往在数据中心，通过多台服务器进行扩展。</li>
</ul>
<p><strong>客户机</strong>：</p>
<ul>
<li>可以和服务器进行通信；</li>
<li>可能间断性连接网络；</li>
<li>可能是动态的IP地址；</li>
<li>客户机之间不会直接通信；</li>
</ul>
<h4 id="点对点体系结构（Peer-peer-architecture）"><a href="#点对点体系结构（Peer-peer-architecture）" class="headerlink" title="点对点体系结构（Peer-peer architecture）"></a>点对点体系结构（Peer-peer architecture）</h4><ul>
<li>没有一个一直在线的服务器；</li>
<li>任意端系统之间直接进行通信；</li>
<li>每个点（peer）向其他的点请求服务，同时作为回报也会提供相应的服务；</li>
</ul>
<p>优点：<strong>自扩展性</strong>（self-scalability）：新的点都会提供服务容量和负荷。</p>
<p>缺点：每个点都是间断性连接，而且IP地址会改变。</p>
<p>例子：P2P的文件分享。</p>
<h3 id="进程通信（Processes-Communicating）"><a href="#进程通信（Processes-Communicating）" class="headerlink" title="进程通信（Processes Communicating）"></a>进程通信（Processes Communicating）</h3><h4 id="客户机和服务器进程"><a href="#客户机和服务器进程" class="headerlink" title="客户机和服务器进程"></a>客户机和服务器进程</h4><p>​    <strong>进程</strong>（Processe）：一台主机上运行的程序。</p>
<ul>
<li>在同一台主机上，两个进程通过<strong>进程间通信</strong>（inter-process communication）来进行通信。进程间通信由操作系统定义；</li>
<li><p>不同主机之间，进程通信同过报文交换，</p>
<p>比如并行计算中的MP和MPI，MP（Multi Processing）只能用于同一台主机间的通信，MPI（Message Processing Interface）主要用于不同主机之间的通信，也适用于同一台主机。</p>
</li>
</ul>
<p>​    <strong>客户机进程</strong>（client process）：发起通信的进程。</p>
<p>​    <strong>服务器进程</strong>（server process）：等待连接的进程。</p>
<div class="note info">
            <p>P2P应用也存在客户机进程和服务器进程。</p>
          </div>
<h4 id="套接字（Sockets）"><a href="#套接字（Sockets）" class="headerlink" title="套接字（Sockets）"></a>套接字（Sockets）</h4><p>​    进程之间通过socket来接收/发送消息。</p>
<p>socket在进程通信中的作用相当于一个信封：</p>
<ul>
<li>通信的信息需要装进socket</li>
<li>应用层下的各层作为基础设施，将信传到另一个进程</li>
<li>两个进程间的通讯会有两个socket</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/socket.png" alt="socket.png" style="zoom:50%;" /></p>
<h4 id="进程寻址（Addressing-Processes）"><a href="#进程寻址（Addressing-Processes）" class="headerlink" title="进程寻址（Addressing Processes）"></a>进程寻址（Addressing Processes）</h4><p>​    如果两个主机之间的进程进行通信，发送端不仅要知道接收端的IP地址还需要知道进程相应的端口号。</p>
<ul>
<li><p><strong>IP地址</strong>：IPv4中32位IP，负责找到接收端主机。</p>
</li>
<li><p><strong>端口号</strong>（port number）：每台主机都可能运行着多个进程，每个进程对应一个端口号。</p>
<p>比如，HTTP服务端口号80、邮件服务端口号25</p>
</li>
</ul>
<h3 id="应用层协议（Application-Layer-Protocols）"><a href="#应用层协议（Application-Layer-Protocols）" class="headerlink" title="应用层协议（Application-Layer Protocols）"></a>应用层协议（Application-Layer Protocols）</h3><p>​    网络应用的开发必须遵守网络协议。</p>
<h4 id="应用层协议的分类"><a href="#应用层协议的分类" class="headerlink" title="应用层协议的分类"></a>应用层协议的分类</h4><p><strong>公开网络协议</strong></p>
<ul>
<li>定义在RFC中</li>
<li>统一标准，易于相互操作</li>
<li>例如：HTTP、SMTP</li>
</ul>
<p><strong>专用网络协议</strong></p>
<ul>
<li>一些非公开的网络协议</li>
<li>例如：Skype</li>
</ul>
<h4 id="应用层协议内容"><a href="#应用层协议内容" class="headerlink" title="应用层协议内容"></a>应用层协议内容</h4><p>应用层协议定义了</p>
<ul>
<li>消息交换的类型：比如请求、响应</li>
<li>消息的语法：消息中有哪些字段以及这些字段如何定义</li>
<li>消息的语义：消息字段内容的含义</li>
<li>规则：进程什么时候、如何发送/接收消息</li>
</ul>
<h4 id="app对传输服务的需求"><a href="#app对传输服务的需求" class="headerlink" title="app对传输服务的需求"></a>app对传输服务的需求</h4><ul>
<li><p><strong>数据完整性</strong>（data integrity）</p>
<p>​    一些app需要100%可靠的文件传输，比如文件传输；有一些运行一部分的丢失，比如语音。</p>
</li>
<li><p><strong>时效性</strong>（timing）</p>
<p>​    一些app要求较少的延时，比如对话直播。</p>
</li>
<li><p><strong>吞吐率</strong>（throughput）</p>
<p>​    吞吐率，即<strong>最小带宽</strong>，一些app存在一个吞吐率下限才能正常使用，比如视频音频等多媒体；有些app运行弹性的吞吐率，比如邮件传输，吞吐率小可以慢慢传过去。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_appsRequirements.png" alt="appsRequirements.png" style="zoom:60%;" /></p>
<h3 id="网络传输协议服务"><a href="#网络传输协议服务" class="headerlink" title="网络传输协议服务"></a>网络传输协议服务</h3><p>​    <strong>传输层</strong>提供为应用层提供的两种传输服务。</p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>​    传输控制协议（TCP）</p>
<ul>
<li><strong>面向连接</strong>（connection-oriented）：需要客户端和服务器之间能够建立连接</li>
<li><strong>可靠传输</strong>（reliable transport）：数据完整性高</li>
<li><strong>流量控制</strong>（flow control）：发送方不能发送太多数据导致接收方过载</li>
<li><strong>阻塞控制</strong>（congestion control）：不能有太多个主机同时发送导致网络过载</li>
<li>不提供的服务：时效性、最小带宽（吞吐率）、安全性</li>
</ul>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>​    UDP是一种<strong>不提供不必要服务</strong>的轻量传输协议。优点是速度快、灵活性好。</p>
<ul>
<li><strong>不需要建立连接</strong></li>
<li><strong>不可靠的数据传输</strong></li>
<li>不提供的服务：基本都不提供，不提供包括可靠传输、流量控制、阻塞控制、时效性、最小带宽（吞吐率）、安全性</li>
</ul>
<h4 id="不同app选择的网络传输协议"><a href="#不同app选择的网络传输协议" class="headerlink" title="不同app选择的网络传输协议"></a>不同app选择的网络传输协议</h4><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_appsProtocols.png" style="zoom:60%;" /></p>
<h2 id="Web和HTTP"><a href="#Web和HTTP" class="headerlink" title="Web和HTTP"></a>Web和HTTP</h2><p>​    World Wide Web 中的网页由超链接（hyperlink）连接。</p>
<ul>
<li>页面由很多对象（object）组成，对象存储在服务器中；</li>
<li>对象有多种类型，可以是HTML文件，JPEG图片，动态脚本等等；</li>
<li>网页以HTML文件为基础，包括了许多参考对象，每个对象都可以通过URL来寻址。例如一张图片的URL为<code>www.someshcool.edu/someDept/pic.gif</code>，其中<code>www.someshcool.edu</code>为主机名，<code>/someDept/pic.gif</code>为路径名。</li>
</ul>
<h3 id="HTTP概述"><a href="#HTTP概述" class="headerlink" title="HTTP概述"></a>HTTP概述</h3><p>​    超文本传输协议（hypertext transfer protocol, HTTP）</p>
<ul>
<li><p>网页的<strong>应用层</strong>协议</p>
</li>
<li><p>基于<strong>客户机-服务器体系结构</strong></p>
<ul>
<li>客户机：负责请求、接收和显示Web对象</li>
<li>服务器：Web服务器负责发送对象，响应客户机请求</li>
</ul>
</li>
</ul>
<ul>
<li>HTTP的传输层使用<strong>TCP</strong><ol>
<li>客户机发起TCP连接（创建socket，<strong>端口号80</strong>）</li>
<li>服务器接收TCP连接</li>
<li>在浏览器和网页服务器之间进行HTTP信息的交换</li>
<li>TCP连接可以断开</li>
</ol>
</li>
</ul>
<ul>
<li>HTTP是无状态的<br>​    &emsp;&emsp;服务器不会保留之前客户机发的请求信息。<br>​    &emsp;&emsp;协议要维持状态是很复杂的：保留之前的历史记录很消耗资源；如果客户机或着服务器有死机，它们的状态会不一致，还需要重新同步，这很麻烦。</li>
</ul>
<ul>
<li>HTTP消息类型：请求（request）与响应（response）</li>
</ul>
<h3 id="HTTP连接类型"><a href="#HTTP连接类型" class="headerlink" title="HTTP连接类型"></a>HTTP连接类型</h3><h4 id="非持久性连接（Non-persistent-HTTP）"><a href="#非持久性连接（Non-persistent-HTTP）" class="headerlink" title="非持久性连接（Non-persistent HTTP）"></a>非持久性连接（Non-persistent HTTP）</h4><h5 id="非持久性HTTP步骤"><a href="#非持久性HTTP步骤" class="headerlink" title="非持久性HTTP步骤"></a>非持久性HTTP步骤</h5><ol>
<li>TCP连接开启</li>
<li>通过这个TCP连接最多传输一个对象</li>
<li><p>TCP连接关闭</p>
<p>如果要加载多个对象时，需要多次非持久性HTTP连接。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Non-persistent%20HTTP(1).png" alt="Non-persistent%20HTTP(1).png" style="zoom:67%;" /><br><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Non-persistent%20HTTP(2).png" alt="Non-persistent%20HTTP(2).png" style="zoom:67%;" /></p>
<h5 id="非持久性HTTP响应时间"><a href="#非持久性HTTP响应时间" class="headerlink" title="非持久性HTTP响应时间"></a>非持久性HTTP响应时间</h5><p>  <strong>RTT</strong>：往返时间（Round Trip Time）,一个很小的数据包（处理文件的时间可忽略）从客户机传到服务器再传回来的时间。</p>
<p>  <strong>HTTP响应时间</strong>（一个对象）：</p>
<ul>
<li>1个RTT：建立TCP连接的时间</li>
<li>1个RTT：HTTP请求以及收到HTTP响应的前几个字符的时间</li>
<li><p>对象/文件传输的时间</p>
<p>对一个对象来说，非持久性HTTP响应时间为</p>
<script type="math/tex; mode=display">
Nonpersistent\ HTTP\ response\ time = 2RTT + file\ transmission\ time</script></li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/NetWork%20Non-persistent%20HTTP%20response%20time.png" alt="Non-persistent response time.png" style="zoom:50%;" /></p>
<div class="note warning">
            <p>  例题：如果一个网页包含1个HTML和10个对象，则非持久性HTTP响应需要多少时间？</p><script type="math/tex; mode=display">  2RTT \times (1+10) + total\ file\ transmission\ time</script>
          </div>
<h5 id="非持久性HTTP的问题"><a href="#非持久性HTTP的问题" class="headerlink" title="非持久性HTTP的问题"></a>非持久性HTTP的问题</h5><ul>
<li>每传输一个对象都需要耗费 $2RTT$ </li>
<li>每建立一个TCP连接都会对操作系统（OS）产生负荷</li>
<li>并行抓取：浏览器常常开多个并行的TCP连接去抓取对象</li>
</ul>
<div class="note warning">
            <p>例题：一个网页包含1个HTML和10张图片，共有5个并行的TCP连接，则非持久性HTTP响应需要多少个RTT？<br>  &emsp;&emsp;首先传输HTML需要 $2RTT$ 的时间，5个并行的TCP连接传输10个对象需要2个 $2RTT$ 的时间。</p><script type="math/tex; mode=display">  RTT\ in\ Response\ Time = 2RTT + 2 \times 2RTT = 6RTT</script>
          </div>
<h4 id="持久性连接（Persistent-HTTP）"><a href="#持久性连接（Persistent-HTTP）" class="headerlink" title="持久性连接（Persistent HTTP）"></a>持久性连接（Persistent HTTP）</h4><h5 id="持久性HTTP步骤"><a href="#持久性HTTP步骤" class="headerlink" title="持久性HTTP步骤"></a>持久性HTTP步骤</h5><ol>
<li>开启TCP连接</li>
<li>通过这一个TCP连接可以传多个对象</li>
<li>TCP连接关闭</li>
</ol>
<h5 id="持久性HTTP特点（HTTP1-1）"><a href="#持久性HTTP特点（HTTP1-1）" class="headerlink" title="持久性HTTP特点（HTTP1.1）"></a>持久性HTTP特点（HTTP1.1）</h5><ul>
<li>服务器在发送响应后保持连接开启状态</li>
<li>后续这个客户机\服务器的HTTP消息都通过该开启的连接发送</li>
<li>两种发送对象方式：HTTP1.1采用流水的方式发送：一次性把对象全发了；另一种是客户机接收到一个对象后接着发下一个对象的请求</li>
<li>至少需要1个RTT发完所有对象</li>
</ul>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>​    &emsp;&emsp;域名系统（Domain Name System，DNS）通过分布式的数据库来实现IP地址和域名的映射。</p>
<ul>
<li><strong>层级结构的域名服务器提供分布式的数据库</strong></li>
<li><strong>应用层协议</strong>：主机和域名服务器通过通信来实现IP地址和域名的转换</li>
</ul>
<div class="note info">
            <p>DNS作为一个<strong>网络核心功能</strong>，为什么要放在应用层？<br>&emsp;&emsp;与网络结构设计理念有关，网络中主机很多映射很复杂，希望将复杂度留在端系统中，而不是在网络核心。</p>
          </div>
<h3 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h3><ul>
<li>IP地址和域名的转换</li>
<li>主机的别名</li>
<li>邮件服务的别名</li>
<li>负荷分配：有些Web可能有多个服务器，即会有多个IP地址对应一个域名，可调整IP地址的顺序以分配负荷。</li>
</ul>
<h3 id="DNS：分布式、层级的数据库"><a href="#DNS：分布式、层级的数据库" class="headerlink" title="DNS：分布式、层级的数据库"></a>DNS：分布式、层级的数据库</h3><div class="note info">
            <p>为什么要选用分布的DNS，而不采用集中式的DNS？</p><ul><li>单点可能失效：一个故障就gg了</li><li>流量问题：所有客户机都访问一个域名服务器，会产生很大的流量</li><li>远程的集中式数据库：客户机要访问可能要花费很多时间，RTT会很大，造成大时延</li></ul>
          </div>
<p>  &emsp;&emsp;DNS采用三层结构</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_DNS%20Server.png" alt="DNS Server.png" style="zoom: 33%;" /></p>
<p>一个客户机得到<code>www.amazon.com</code>的IP地址的步骤：</p>
<ol>
<li>客户机先查询根域名服务器，得到顶级域名服务器<code>.com DNS server</code>的地址；</li>
<li>客户机查询顶级域名服务器<code>.com DNS server</code>，得到权威域名服务器<code>amazon.com DNS server</code>的地址；</li>
<li>客户机查询权威域名服务器<code>amazon.com DNS server</code>，得到<code>www.amazon.com</code>的IP地址</li>
</ol>
<h4 id="根域名服务器（Root-Name-Server）"><a href="#根域名服务器（Root-Name-Server）" class="headerlink" title="根域名服务器（Root Name Server）"></a>根域名服务器（Root Name Server）</h4><ul>
<li>官方的服务器，是<u>连接的最后的方法</u>（如果知道下级域名服务器的地址就不需要再从头开始查询根域名服务器，不然会对根域名服务器产生很大的流量负荷）</li>
<li>对网络运行相当重要，离开根域名服务器网络无法正常工作</li>
<li>域名系统安全扩展（Domain Name System Security Extensions，DNSSEC） —— 对DNS提供给DNS客户端（解析器）的DNS数据来源进行认证，并验证不存在性和校验数据完整性验证。</li>
<li>ICANN（互联网名称与数字地址分配机构，Internet Corporation for Assigned Names and Numbers）—— 管理根域名服务器的组织</li>
</ul>
<div class="note info">
            <p>世界上现在有13个根域名服务器，分布在世界各地。</p>
          </div>
<h4 id="顶层域名服务器（Top-Level-Domain-Server-TLD）"><a href="#顶层域名服务器（Top-Level-Domain-Server-TLD）" class="headerlink" title="顶层域名服务器（Top-Level Domain Server, TLD）"></a>顶层域名服务器（Top-Level Domain Server, TLD）</h4><ul>
<li>各种类型的TLD，比如<code>.com</code>、<code>.org</code>、<code>net</code>、<code>.edu</code>等等，国家的TLD，比如<code>.cn</code>、<code>.uk</code>等等。</li>
<li>Network Solutions：管理<code>.com</code>、<code>net</code>TLD的组织</li>
<li>Educause：管理<code>.edu</code>的组织</li>
</ul>
<h4 id="权威域名服务器（Authoritative-Domain-Server）"><a href="#权威域名服务器（Authoritative-Domain-Server）" class="headerlink" title="权威域名服务器（Authoritative Domain Server）"></a>权威域名服务器（Authoritative Domain Server）</h4><ul>
<li>组织自己的DNS服务器，用来提供组织内部的域名到IP地址的映射</li>
<li>由组织自己或者服务提供商来维护</li>
</ul>
<h4 id="本地域名服务器（Local-DNS-Name-Server）"><a href="#本地域名服务器（Local-DNS-Name-Server）" class="headerlink" title="本地域名服务器（Local DNS Name Server）"></a>本地域名服务器（Local DNS Name Server）</h4><ul>
<li>严格来说不属于层级结构</li>
<li>每个ISP都会有一个本地域名服务器，也叫做<strong>默认域名服务器</strong>（default name server）</li>
<li>当主机要进行DNS查询时，查询会被直接送到本地的DNS服务器。</li>
<li>作用：<ul>
<li>缓存：可以缓存最近收到的域名到IP地址的映射（缓存有时效，会过期）</li>
<li>代理：可以作为代理，代替主机在层级结构中进行查询</li>
</ul>
</li>
</ul>
<h3 id="DNS查询方法"><a href="#DNS查询方法" class="headerlink" title="DNS查询方法"></a>DNS查询方法</h3><h4 id="迭代查询（iterated-query）"><a href="#迭代查询（iterated-query）" class="headerlink" title="迭代查询（iterated query）"></a>迭代查询（iterated query）</h4><p>&emsp;&emsp;被联系到的服务器会将后一个服务器的名字反馈回来，即“我不认识这个域名，但是你可以去问那台服务器(=ﾟωﾟ)ﾉ”</p>
<p>&emsp;&emsp;下面的迭代查询过程，利用本地域名服务器作为代理迭代查询域名对于的IP地址。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_iterated-query.png" alt="iterated query.png" style="zoom:40%;" /></p>
<h4 id="递归查询（recursive-query）"><a href="#递归查询（recursive-query）" class="headerlink" title="递归查询（recursive query）"></a>递归查询（recursive query）</h4><p>&emsp;&emsp;把域名解析的负担交给了联系到的域名服务器，这种方法对于高级的负担增加，所以一般采用迭代查询而不采用递归查询。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_recursive-query.png" alt="recursive query.png" style="zoom:38%;" /></p>
<h3 id="DNS缓存和更新"><a href="#DNS缓存和更新" class="headerlink" title="DNS缓存和更新"></a>DNS缓存和更新</h3><ul>
<li>一旦域名服务器学习到了一个映射，它就会<strong>缓存</strong>这个映射。缓存往往在本地域名服务器里，这样可以减轻根域名服务器的压力。</li>
<li><strong>缓存有效时间TTL</strong>，过了有效时间该缓存就会被删除。</li>
<li><strong>更新/通知机制</strong>：由IETF制定的 RFC2136 标准。<br>&emsp;&emsp;如果中途域名主机改变IP地址，整个网络可能都不知道真正的IP地址，直到TTL到时，所以需要更新/通知机制。</li>
</ul>
<h3 id="DNS记录和消息"><a href="#DNS记录和消息" class="headerlink" title="DNS记录和消息"></a>DNS记录和消息</h3><h4 id="DNS记录"><a href="#DNS记录" class="headerlink" title="DNS记录"></a>DNS记录</h4><p>&emsp;&emsp;DNS的分布式数据库里存储了<strong>资源记录</strong>（resource record, RR）</p>
<p>RR的格式：<code>(name, value, type, ttl)</code></p>
<p><strong>type = A</strong></p>
<ul>
<li>name：主机名</li>
<li>value：对应的IP地址</li>
</ul>
<p><strong>type = NS</strong></p>
<ul>
<li>name：域（如<code>foo.com</code>）</li>
<li>value：对应的权威域名服务器的主机名</li>
</ul>
<p><strong>type = CNAME</strong></p>
<ul>
<li>name：别名</li>
<li>value：对应的规范主机名</li>
<li>比如 <code>www.ibm.com</code> 是 <code>servereast.backup2.ibm.com</code> 的别名，这与负荷的分配有关，可能有多个服务器。</li>
</ul>
<p><strong>type = MX</strong></p>
<ul>
<li>name：邮件服务器别名</li>
<li>value：对应的规范主机名</li>
</ul>
<h4 id="DNS消息"><a href="#DNS消息" class="headerlink" title="DNS消息"></a>DNS消息</h4><p>&emsp;&emsp;DNS有两种消息类型：查询（query）和回答（reply），两种消息格式相同。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_DNS-message.png" alt="DNS message.png" style="zoom: 50%;" /></p>
<h4 id="向DNS数据库插入记录"><a href="#向DNS数据库插入记录" class="headerlink" title="向DNS数据库插入记录"></a>向DNS数据库插入记录</h4><p>比如要创建一个<code>networkutopia.com</code>的网站</p>
<ul>
<li>先在<code>.com</code>的TLD提供商 Network Solution 注册 <code>networkutopia.com</code><ul>
<li>提供信息：域名、权威域名服务器的IP地址</li>
<li>提供商会向<code>.com</code>TLD服务器插入 NS、A 的RR<br>(<code>networkutopia.com</code>, <code>dns1.networkutopia.com</code>, NS)<br>(<code>dns1.networkutopia.com</code>, <code>212.212.212.1</code>, A)</li>
</ul>
</li>
<li>在自己的权威域名服务器上进行配置<ul>
<li>插入<code>www.networkutopia.com</code>的type A记录</li>
<li>如果是邮件服务，插入<code>networkutopia.com</code>的type MX记录</li>
</ul>
</li>
</ul>
<h3 id="DNS查询工具"><a href="#DNS查询工具" class="headerlink" title="DNS查询工具"></a>DNS查询工具</h3><p>&emsp;&emsp;在命令行用<code>nslookup</code>进行DNS查询。</p>
<h4 id="nslookup直接查询"><a href="#nslookup直接查询" class="headerlink" title="nslookup直接查询"></a>nslookup直接查询</h4><p>&emsp;&emsp;查询一个域名的A记录，如果没指定dns-server，用系统默认的dns服务器。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup domain [dns-server]</span><br></pre></td></tr></table></figure>
<h4 id="nslookup查询其他记录"><a href="#nslookup查询其他记录" class="headerlink" title="nslookup查询其他记录"></a>nslookup查询其他记录</h4>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup -qt&#x3D;type domain [dns-server]</span><br></pre></td></tr></table></figure>
<p>type可以是以下这些类型：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>type</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>地址记录</td>
</tr>
<tr>
<td>AAAA</td>
<td>地址记录</td>
</tr>
<tr>
<td>AFSDB</td>
<td>Andrew文件系统数据库服务器记录</td>
</tr>
<tr>
<td>ATMA</td>
<td>ATM地址记录</td>
</tr>
<tr>
<td>CNAME</td>
<td>别名记录</td>
</tr>
<tr>
<td>HINFO</td>
<td>硬件配置记录，包括CPU、操作系统信息</td>
</tr>
<tr>
<td>ISDN</td>
<td>域名对应的ISDN号码</td>
</tr>
<tr>
<td>MB</td>
<td>存放指定邮箱的服务器</td>
</tr>
<tr>
<td>MG</td>
<td>邮件组记录</td>
</tr>
<tr>
<td>MINFO</td>
<td>邮件组和邮箱的信息记录</td>
</tr>
<tr>
<td>MR</td>
<td>改名的邮箱记录</td>
</tr>
<tr>
<td>MX</td>
<td>邮件服务器记录</td>
</tr>
<tr>
<td>NS</td>
<td>名字服务器记录</td>
</tr>
<tr>
<td>PTR</td>
<td>反向记录</td>
</tr>
<tr>
<td>RP</td>
<td>负责人记录</td>
</tr>
<tr>
<td>RT</td>
<td>路由穿透记录</td>
</tr>
<tr>
<td>SRV</td>
<td>TCP服务器信息记录</td>
</tr>
<tr>
<td>TXT</td>
<td>域名对应的文本信息</td>
</tr>
<tr>
<td>X25</td>
<td>域名对应的X.25地址记录</td>
</tr>
</tbody>
</table>
</div>
<h2 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h2><p>&emsp;&emsp;点对点体系结构（Peer-peer architecture）</p>
<h3 id="P2P概述"><a href="#P2P概述" class="headerlink" title="P2P概述"></a>P2P概述</h3><ul>
<li>没有一个一直在线的服务器；</li>
<li>任意端系统之间直接进行通信；</li>
<li>每个点（peer）向其他的点请求服务，同时作为回报也会提供相应的服务；</li>
</ul>
<p>优点：<strong>自扩展性</strong>（self-scalability）：新的点都会提供服务容量和负荷。</p>
<p>缺点：每个点都是间断性连接，而且IP地址会改变。</p>
<p>例子：P2P的文件分享。</p>
<h3 id="文件分发：客户机-服务器结构-vs-P2P"><a href="#文件分发：客户机-服务器结构-vs-P2P" class="headerlink" title="文件分发：客户机-服务器结构 vs P2P"></a>文件分发：客户机-服务器结构 vs P2P</h3><p>&emsp;&emsp;从一个服务器分发大小为F的文件到N个节点需要多少时间？（每个节点上传和下载的速率都是有限的，网络中有足够的带宽）</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_file-distribution.png" alt="file distribution.png" style="zoom: 40%;" /></p>
<p>如果选用<strong>客户机-服务器</strong>结构</p>
<ul>
<li>服务器上传：需要上传这份文件 $N$ 次，上传速度为 $u_s$，则需要的上传时间为 $NF/u_s$</li>
<li><p>客户机下载：每个客户机都需要下载文件，$d_{min}$ 是客户机最小下载速度，则客户机下载的最大时间为 $F/d{min}$</p>
<p>&emsp;&emsp;客户机-服务器结构的分发时间</p>
<script type="math/tex; mode=display">
D_{c\_s} \geq max\{NF/u_s, F/d_{min}\}</script><p>&emsp;&emsp;此处的N导致耗费的时间随要下载的节点的数量线性增长，当要下载的节点数目大时，要耗费相当多的时间。</p>
<div class="note info">
            <p>&emsp;&emsp;不需要先上传完再下载，参考<a href="https://gy23333.github.io/2020/03/16/《计算机网络-自顶向下方法》笔记/#分组交换（Packet-Switching）">第一章/网络核心/分组交换</a>，以分组为单位发送，可以忽略上传到下载的时间。</p>
          </div>
</li>
</ul>
<p>如果选用<strong>P2P</strong>结构</p>
<ul>
<li>服务器上传：服务器至少要上传1次文件，上传时间为 $F/u_s$</li>
<li>客户机下载：每个客户机都要下载文件，客户机最大下载时间为$F/d_{min}$</li>
<li><p>客户机上传：每个下载了文件的客户机都可以上传文件，此时总上传速率可以达到$u_s+\sum\limits^{n} u_i$</p>
<p>&emsp;&emsp;P2P结构的分发时间</p>
<script type="math/tex; mode=display">
D_{P2P} \geq max\{F/u_s, F/d_{min}, NF/(u_s+\sum\limits^{n} u_i)\}</script></li>
</ul>
<p>客户机-服务器结构和P2P分发时间对比</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_vsPic.png" alt="vsPic.png" style="zoom:33%;" /></p>
<h3 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h3><ul>
<li>文件分为大小为 256Kb的块（chunk）</li>
<li>每个节点负责上传和下载的文件块</li>
<li>追踪器（tracker）：追踪参加洪流的节点</li>
<li>洪流（torrent）：有一组节点相互交换文件块</li>
<li><p>新的节点想下载文件，先询问追踪器参加的节点，再从相近的节点处下载文件块</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_P2P-file.png" alt="P2P file.png" style="zoom:50%;" /></p>
</li>
<li><p>节点加入洪流：</p>
<ul>
<li>本身没有文件块，但是随着时间的推移会从其他节点获取文件块</li>
<li>需要在追踪器进行登记，并且一般连接临近的节点</li>
</ul>
</li>
<li>下载时，节点会上传文件块到其他节点</li>
<li>节点可以更改交换文件块的节点</li>
<li>节点随时会上线和下线</li>
<li>一旦节点有了完整的文件，它可以离开或者留在洪流中</li>
</ul>
<h4 id="请求文件块"><a href="#请求文件块" class="headerlink" title="请求文件块"></a>请求文件块</h4><ul>
<li>在给定的时间，不同的节点拥有不同的文件块</li>
<li>一定周期，新的节点会问每个节点有哪些块</li>
<li>新节点会从其他节点处下载缺失的文件块<br><strong>最稀缺优先</strong>（rarest first）：如果有10个节点都有第1、2块，只有一个节点有第3块，则先下载第3块。</li>
</ul>
<h4 id="发送文件块"><a href="#发送文件块" class="headerlink" title="发送文件块"></a>发送文件块</h4><p>  &emsp;&emsp;发送文件块遵守<strong>一报还一报原则（tit-for-tat）</strong></p>
<ul>
<li>节点会给目前给它发送文件块速率最高的四个节点发送文件块，其他节点就不发送了，每隔 10s 会选出新的top4</li>
<li><p>每隔 30s 会随机选择其他节点发送文件块，这样这个随机节点可能就会成为新的top4</p>
<div class="note info">
            <p>tit-for-tat原则：上传速率快的节点相应地得到高下载速率的回报。</p>
          </div>
</li>
</ul>
<h2 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h2><p>  &emsp;&emsp;目标：建立客户机/服务器的应用中的通信运用socket</p>
<p>  &emsp;&emsp;socket：相当于应用进程和点对点传输协议之间的一扇门</p>
<p>  &emsp;&emsp;socket类型：对应TCP和UDP有两种socket</p>
<h3 id="UDP中的socket编程"><a href="#UDP中的socket编程" class="headerlink" title="UDP中的socket编程"></a>UDP中的socket编程</h3><p>  UDP：客户机与服务器之间没有连接</p>
<ul>
<li>发送数据前不需要握手</li>
<li>发送数据包附加IP地址+端口号</li>
<li><p>接收方从数据包中提取处IP地址+端口号</p>
<div class="note info">
            <p>&emsp;&emsp;UDP提供的是一种不可靠的数据流传输，传输过程中可能会丢包，接收的时候顺序也可能被打乱。</p>
          </div>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_UDP_socket.png" alt="UDP socket.png" style="zoom:50%;" /></p>
<h4 id="UDP中的socket编程示例"><a href="#UDP中的socket编程示例" class="headerlink" title="UDP中的socket编程示例"></a>UDP中的socket编程示例</h4><p>&emsp;&emsp;这里jupyter notebook中进行编程，安装好jupyter notebook后，在命令行执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure>
<p>即可启动jupyter notebook</p>
<p>UDP服务器代码</p>
<figure class="highlight python"><figcaption><span>UDPServer.ipynb</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> * <span class="comment">#引入socket库</span></span><br><span class="line"></span><br><span class="line">serverPort = <span class="number">12000</span> <span class="comment">#服务器端口号</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_DGRAM) <span class="comment">#创建服务器套接字</span></span><br><span class="line">serverSocket.bind((<span class="string">''</span>, serverPort)) <span class="comment">#给套接字绑定端口号</span></span><br><span class="line">print(<span class="string">'The server is ready to receive.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>: <span class="comment">#服务器要一直在线等待，所以给一个死循环</span></span><br><span class="line">    message, clientAddress = serverSocket.recvfrom(<span class="number">2048</span>) <span class="comment">#从服务器套接字中读取信息（发送的消息和客户机IP地址+端口号）</span></span><br><span class="line">    modifiedMessage = message.decode().upper() <span class="comment">#对消息进行处理（此处是改大写）</span></span><br><span class="line">    </span><br><span class="line">    serverSocket.sendto(modifiedMessage.encode(), clientAddress) <span class="comment">#将处理后的消息发回给客户机</span></span><br></pre></td></tr></table></figure>
<p>UDP客户机代码</p>
<figure class="highlight python"><figcaption><span>UDPClient.ipynb</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> * <span class="comment">#引入socket库</span></span><br><span class="line"></span><br><span class="line">serverName = gethostname() <span class="comment">#由于没得服务器，服务器主机用本机来当</span></span><br><span class="line">serverPort = <span class="number">12000</span> <span class="comment">#服务器端口号</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_DGRAM) <span class="comment">#创建客户机套接字</span></span><br><span class="line"></span><br><span class="line">message = input(<span class="string">'Input lowercase sentence:'</span>) <span class="comment">#得到输入字符串</span></span><br><span class="line">clientSocket.sendto(message.encode(),(serverName, serverPort)) <span class="comment">#发送数据到相应主机名+端口号的服务器进程</span></span><br><span class="line"></span><br><span class="line">modifiedMessage, serverAddress = clientSocket.recvfrom(<span class="number">2048</span>) <span class="comment">#接收服务器发回的消息</span></span><br><span class="line">print(modifiedMessage.decode()) <span class="comment">#显示接收的字符串</span></span><br><span class="line"></span><br><span class="line">clientSocket.close() <span class="comment">#关闭客户机socket</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;先运行UDPServer.ipynb，启动服务器运行。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_UDP_socket_server.png" alt="UDP socket.png" style="zoom:50%;" /></p>
<p>&emsp;&emsp;先运行UDPClient.ipynb，进行客户机访问。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_UDP_socket_client.png" alt="UDP socket.png" style="zoom:50%;" /></p>
</li>
</ul>
<h3 id="TCP中的socket编程"><a href="#TCP中的socket编程" class="headerlink" title="TCP中的socket编程"></a>TCP中的socket编程</h3><ul>
<li>服务器的先行准备<ul>
<li>服务器必须先运行</li>
<li>服务器需要创建socket来连接客户机</li>
</ul>
</li>
<li>客户机连接服务器<ul>
<li>客户机需要创建自己的socket，明确服务器进程的IP地址和端口号</li>
<li>客户机创建socket时，客户机和服务器之间需建立TCP连接</li>
</ul>
</li>
<li><p>服务器接收客户机消息</p>
<ul>
<li>服务器需创建一个新的socket，为了服务器进程能够和客户机进行通信<ul>
<li>要运行服务器与多个客户机进行通信</li>
<li>用源的端口号来区分不同的客户机</li>
</ul>
</li>
</ul>
<div class="note info">
            <p>&emsp;&emsp;TCP提供的是一种可靠的字节流（byte-stream）传输（pipe）。</p>
          </div>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP_socket.png" alt="TCP socket.png" style="zoom:50%;" /></p>
</li>
</ul>
<h4 id="TCP中的socket编程示例"><a href="#TCP中的socket编程示例" class="headerlink" title="TCP中的socket编程示例"></a>TCP中的socket编程示例</h4><p>  TCP服务器代码<br>  <figure class="highlight python"><figcaption><span>TCPServer.ipynb</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> * <span class="comment">#引入socket库</span></span><br><span class="line"></span><br><span class="line">serverPort = <span class="number">12000</span> <span class="comment">#服务器端口号</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_STREAM) <span class="comment">#创建服务器套接字（前台）</span></span><br><span class="line">serverSocket.bind((<span class="string">''</span>, serverPort)) <span class="comment">#给套接字绑定端口号</span></span><br><span class="line">serverSocket.listen(<span class="number">1</span>)</span><br><span class="line">print(<span class="string">'The server is ready to receive.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>: <span class="comment">#服务器要一直在线等待，所以给一个死循环</span></span><br><span class="line">    connectionSocket, addr = serverSocket.accept() <span class="comment">#前台套接字接收到请求后，创建一个新的套接字（窗口）</span></span><br><span class="line">    </span><br><span class="line">    sentence = connectionSocket.recv(<span class="number">1024</span>).decode() <span class="comment">#窗口套接字读取信息</span></span><br><span class="line">    capitalizedSentence = sentence.upper() <span class="comment">#对消息进行处理（此处是改大写）</span></span><br><span class="line">    </span><br><span class="line">    connectionSocket.send(capitalizedSentence.encode()) <span class="comment">#将处理后的信息发回给客户机</span></span><br><span class="line">    </span><br><span class="line">    connectionSocket.close() <span class="comment">#关闭窗口套接字，前台套接字保持开放</span></span><br></pre></td></tr></table></figure></p>
<p>  TCP客户机代码<br>  <figure class="highlight python"><figcaption><span>TCPClient.ipynb</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> * <span class="comment">#引入socket库</span></span><br><span class="line"></span><br><span class="line">serverName = gethostname() <span class="comment">#由于没得服务器，服务器主机用本机来当</span></span><br><span class="line">serverPort = <span class="number">12000</span> <span class="comment">#服务器端口号</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_STREAM) <span class="comment">#创建客户机套接字(类型为字节流SOCK_STREAM)</span></span><br><span class="line">clientSocket.connect((serverName, serverPort)) <span class="comment">#TCP连接</span></span><br><span class="line"></span><br><span class="line">sentence = input(<span class="string">'Input lowercase sentence:'</span>) <span class="comment">#得到输入字符串</span></span><br><span class="line">clientSocket.send(sentence.encode()) <span class="comment">#发送数据到服务器</span></span><br><span class="line"></span><br><span class="line">modifiedSentence = clientSocket.recv(<span class="number">1024</span>) <span class="comment">#接收服务器发回的消息</span></span><br><span class="line">print(<span class="string">'From server:'</span>, modifiedSentence.decode()) <span class="comment">#显示接收的字符串</span></span><br><span class="line"></span><br><span class="line">clientSocket.close() <span class="comment">#关闭客户机socket</span></span><br></pre></td></tr></table></figure></p>
<p>  &emsp;&emsp;先运行TCPServer.ipynb，启动服务器运行。</p>
<p>  <img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP_socket_server.png" alt="TCP socket.png" style="zoom:50%;" /></p>
<p>  &emsp;&emsp;先运行TCPClient.ipynb，进行客户机访问。</p>
<p>  <img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP_socket_client.png" alt="TCP socket.png" style="zoom:50%;" /></p>
<h1 id="传输层（Transport-Layer）"><a href="#传输层（Transport-Layer）" class="headerlink" title="传输层（Transport Layer）"></a>传输层（Transport Layer）</h1><h2 id="传输层服务"><a href="#传输层服务" class="headerlink" title="传输层服务"></a>传输层服务</h2><h3 id="传输层概述"><a href="#传输层概述" class="headerlink" title="传输层概述"></a>传输层概述</h3><ul>
<li>为不同主机之间的应用进程提供通信的桥梁</li>
<li>端对端：传输层协议在端系统间运行，不需要涉及网络核心<ul>
<li>发送方把应用层接到的消息分成段（segment），再把这些段传输给网络层</li>
<li>接收方把接收到的段重新拼装成消息，传输给应用层</li>
</ul>
</li>
<li>传输层的协议：TCP和UDP</li>
</ul>
<p><strong>传输层和网络层对比</strong></p>
<ul>
<li>网络层：主机之间的通信</li>
<li><p>传输层：进程之间的通信</p>
<p>传输层依赖于并能强化网络层服务。</p>
</li>
</ul>
<h3 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h3><ul>
<li>TCP：可靠的，有序的传送<ul>
<li>拥塞控制</li>
<li>流量控制</li>
<li>需要建立连接</li>
</ul>
</li>
<li><p>UDP：不可靠的，无序的传送</p>
<ul>
<li>提供尽力而为交付服务</li>
</ul>
<p>二者均不提供的服务：延时保障、带宽保障</p>
</li>
</ul>
<h2 id="多路复用（Multiplexing）与多路分用（Demultiplexing）"><a href="#多路复用（Multiplexing）与多路分用（Demultiplexing）" class="headerlink" title="多路复用（Multiplexing）与多路分用（Demultiplexing）"></a>多路复用（Multiplexing）与多路分用（Demultiplexing）</h2><p>  &emsp;&emsp;多路复用存在于发送方：发送方需要处理多个套接字，并且给套接字加上传输层的头部。</p>
<p>  &emsp;&emsp;多路分用存在于接收方：利用头部信息，将接收到的报文段传输给正确的套接字。</p>
<p>  <img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Multiplexing.png" alt="Multiplexing/demultiplexing.png" style="zoom:50%;" /></p>
<h3 id="多路分用"><a href="#多路分用" class="headerlink" title="多路分用"></a>多路分用</h3><h4 id="多路分用工作流程"><a href="#多路分用工作流程" class="headerlink" title="多路分用工作流程"></a>多路分用工作流程</h4><ul>
<li>主机收到IP数据报（IP datagram）<ul>
<li>每个数据报有源IP地址和目的IP地址</li>
<li>每个数据报携带一个传输层报文段（segment）</li>
<li>每个报文段有源和目的的端口号</li>
</ul>
</li>
<li><p>主机利用IP地址和端口号来把报文段传入正确的套接字</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_segment-format.png" alt="segment format.png" style="zoom:50%;" /></p>
</li>
</ul>
<h4 id="无连接的多路分用（Connectionless-demultiplexing）"><a href="#无连接的多路分用（Connectionless-demultiplexing）" class="headerlink" title="无连接的多路分用（Connectionless demultiplexing）"></a>无连接的多路分用（Connectionless demultiplexing）</h4><p>  &emsp;&emsp;参考<a href="https://gy23333.github.io/2020/03/16/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0/#UDP%E4%B8%AD%E7%9A%84socket%E7%BC%96%E7%A8%8B">UDP的socket工作方式</a>，如果数据报的<strong>目的IP地址和端口号</strong>相同，它们将被传到同一个socket当中。（即使数据报的源可能不同）</p>
<h4 id="面向连接的多路分用（Connection-oriented-demux）"><a href="#面向连接的多路分用（Connection-oriented-demux）" class="headerlink" title="面向连接的多路分用（Connection-oriented demux）"></a>面向连接的多路分用（Connection-oriented demux）</h4><p>  &emsp;&emsp;参考<a href="https://gy23333.github.io/2020/03/16/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0/#TCP%E4%B8%AD%E7%9A%84socket%E7%BC%96%E7%A8%8B">TCP的socket工作方式</a></p>
<ul>
<li>标记TCP的socket需要4元组：源IP地址、源端口号、目的IP地址、目的端口号</li>
<li>多路分用：接收方要用到上面4个值来传入不同的socket</li>
<li>服务器的主机可能要同时支持多个TCP连接</li>
<li>web服务器有不同的socket对应每个连接的客户机，其中非持久性HTTP会给每个请求都建立新的socket。</li>
</ul>
<h2 id="UDP-1"><a href="#UDP-1" class="headerlink" title="UDP"></a>UDP</h2><h2 id="UDP概述"><a href="#UDP概述" class="headerlink" title="UDP概述"></a>UDP概述</h2><p>  &emsp;&emsp;UDP（User Datagram Protocol，用户数据报协议），标准为RFC 768。</p>
<ul>
<li>只有基本的功能</li>
<li>尽力而为的服务，UDP可能会丢包或者失序</li>
<li><p>不用连接：客户机和服务器不需要握手，每个UDP段都是独立处理的</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_UDP-segment.png" alt="UDP segment.png" style="zoom:50%"></p>
</li>
<li><p>UDP的优点</p>
<ul>
<li>不需要进行连接，连接可能会造成时延</li>
<li>简单：不需要考虑连接的状态</li>
<li>相对小的头的大小</li>
<li>不需要拥塞控制，可以尽快地把UDP段发出去</li>
</ul>
</li>
<li>UDP的应用<ul>
<li>流媒体的app（运行一部分数据的丢失，但是对速度很敏感）</li>
<li>DNS</li>
<li>SNMP</li>
</ul>
</li>
<li>通过UDP进行可靠的传输（UDP本身是不可靠的）<ul>
<li>在应用层增加可靠性</li>
<li>app要有对应的错误恢复方法</li>
</ul>
</li>
</ul>
<h3 id="UDP校验和（UDP-checksum）"><a href="#UDP校验和（UDP-checksum）" class="headerlink" title="UDP校验和（UDP checksum）"></a>UDP校验和（UDP checksum）</h3><p>  &emsp;&emsp;位于UDP头部，负责检测传输的段有没有发生“错误”（比如位的翻转）</p>
<ul>
<li>发送方：<ul>
<li>把发送的段的内容包括头部分，当作一组16-bit的整数</li>
<li>校验和：报文段中的所有16-bit的和的取关于“1”的补码</li>
<li>发送方要将校验和放到UDP的校验和部分</li>
</ul>
</li>
<li><p>接收方：</p>
<ul>
<li>计算接收到的报文段的校验和</li>
<li>将接收方的校验和与发送方的校验和进行比较，不同则检测出错误，相同则没检测出错误</li>
</ul>
<div class="note info">
            <p>&emsp;&emsp;校验和相同只能说是“检验不出错误”，不能保障没有错误。比如传输中多个16bit字发生错误，但是可能恰巧相加校验和不变。</p>
          </div>
<div class="note warning">
            <p>  例题：有两个16-bit的字，1110011001100110 和 1101010101010101，求校验和。</p><script type="math/tex; mode=display">\begin{split}   &1110011001100110\\\\  +\ &1101010101010101\\\\  ———————&—————————\\\\  wrap\ around\quad1&1011101110111011\quad\\\\  sum\quad&1011101110111100\\\\  checksum\quad&0100010001000011  \end{split}</script><p>  &emsp;&emsp;wraparound存在溢出，进位的部分回卷，加到最后一位。</p>
          </div>
</li>
</ul>
<h2 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h2><p>  &emsp;&emsp;可靠数据传输原理（Principles of reliable data transfer, <strong>rdt</strong>）</p>
<ul>
<li><p>对应用层、传输层、链路层都很重要</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_provide-service.png" alt="provide service.png" style="zoom:46%">&emsp;&emsp;<img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_service-implementation.png" alt="service implementation.png" style="zoom:50%"></p>
</li>
<li><p>不可靠信道的特点决定了不可靠传输协议的复杂度</p>
</li>
</ul>
<p>调用接口函数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>接口函数</th>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rdt_send()</code></td>
<td>data</td>
<td>调用数据传输协议的发送方，将要发送的数据交付给位于接收方的较高层</td>
</tr>
<tr>
<td><code>udt_send()</code></td>
<td>packet</td>
<td>rdt调用，通过不可靠信道，将packet传输到接收方</td>
</tr>
<tr>
<td><code>rdt_rcv()</code></td>
<td>packet</td>
<td>在packet到达接收方信道时调用</td>
</tr>
<tr>
<td><code>deliver_data()</code></td>
<td>data</td>
<td>rdt调用，传输数据到高层</td>
</tr>
</tbody>
</table>
</div>
<div class="note info">
            <p>与不可靠信道之间的函数调用都是双向的，由于其不可靠性，需要进行确认的控制信号（ACK，NAK）。</p>
          </div>
<h3 id="rdt1-0：经可靠信道的可靠数据传输"><a href="#rdt1-0：经可靠信道的可靠数据传输" class="headerlink" title="rdt1.0：经可靠信道的可靠数据传输"></a>rdt1.0：经可靠信道的可靠数据传输</h3><h4 id="rdt1-0概述"><a href="#rdt1-0概述" class="headerlink" title="rdt1.0概述"></a>rdt1.0概述</h4><ul>
<li>下层信道完全可靠：rdt1.0中假设下层的信道是一个完全可靠的信道（理想情况）<ul>
<li>没有bit的错误</li>
<li>没有分组（packet）丢失</li>
</ul>
</li>
<li>发送方和接收方的<strong>有限状态机（FSM）</strong>（存在状态和操作）<ul>
<li>发送方发送数据给下层信道</li>
<li>接收方接收下层信道传来的数据</li>
</ul>
</li>
</ul>
<h4 id="rdt1-0有限状态机"><a href="#rdt1-0有限状态机" class="headerlink" title="rdt1.0有限状态机"></a>rdt1.0有限状态机</h4><h5 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h5><p>&emsp;&emsp;发送方首先在“<strong>等待上级调用</strong>”的状态，<code>rdt_send(data)</code>上级调用rdt，从上级接收到data，<code>make_pkt(data)</code>将data装到packet里，再用<code>udt_send(packet)</code>将packet发送出去，完成后发送方再回到“等待上级调用”的状态。（发送方只有一个状态）</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt1-0-sender.png" alt="rdt1.0 sender.png" style="zoom:50%"></p>
<h5 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h5><p>&emsp;&emsp;接收方首先在“<strong>等待下级调用</strong>”的状态，<code>rdt_rcv(packet)</code>下级调用rdt，从下级接收到packet，用<code>extract(packet, data)</code>将packet重新恢复成data，提取出来的data再通过<code>deliver_data(data)</code>传送给上级。完成后接收方再回到“等待下级调用”的状态。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt1-0-receiver.png" alt="rdt1.0 receiver.png" style="zoom:50%"></p>
<p>下层信道不可能完全可靠 =&gt; 引入rdt2.0</p>
<h3 id="rdt2-0：经具有比特差错信道的数据传输"><a href="#rdt2-0：经具有比特差错信道的数据传输" class="headerlink" title="rdt2.0：经具有比特差错信道的数据传输"></a>rdt2.0：经具有比特差错信道的数据传输</h3><p>&emsp;&emsp;引入差错检测、控制信号和重传机制，解决下层信道不可靠问题。</p>
<h4 id="rdt2-0概述"><a href="#rdt2-0概述" class="headerlink" title="rdt2.0概述"></a>rdt2.0概述</h4><ul>
<li>packet在下层信道传输中会出现<strong>比特翻转</strong>：可以引入<a href="https://gy23333.github.io/2020/03/16/《计算机网络-自顶向下方法》笔记/#UDP校验和（UDP-checksum）"><strong>校验和（checksum）</strong></a>来检测比特错误。</li>
<li>错误恢复——如果检验到错误如何恢复？<ul>
<li><strong>ACKs（acknowledgements）</strong>：接收方告诉发送方收到的pkt是正确的</li>
<li><strong>NAKs（negative acknowledgements）</strong>：接收方告诉发送方收到的pkt是错误的</li>
<li>发送方收到NAK则重传那个pkt</li>
</ul>
</li>
<li>rdt2.0引入的新机制<ul>
<li>差错检测：checksum</li>
<li>接收方反馈：控制信号（control msg），即ACK和NAK</li>
<li>重传</li>
</ul>
</li>
</ul>
<h4 id="rdt2-0无限状态机"><a href="#rdt2-0无限状态机" class="headerlink" title="rdt2.0无限状态机"></a>rdt2.0无限状态机</h4><h5 id="发送方-1"><a href="#发送方-1" class="headerlink" title="发送方"></a>发送方</h5><p>&emsp;&emsp;rdt2.0的发送方有2个状态——<strong>等待上级调用</strong>、<strong>等待ACK或NAK</strong>。发送方最初处于“<strong>等待上级调用</strong>”的状态，<code>rdt_send(data)</code>上级调用rdt，从上级接收到data，<code>sndpkt = make_pkt(data, checksum)</code>将data装到packet里，再用<code>udt_send(sndpkt)</code>将packet发送出去。此时，发送方变为“<strong>等待ACK或NAK</strong>”的状态。<code>rdt_rcv(rcvpkt)</code>接收反馈，如果<code>isNAK(rcvpkt)</code>即接收到NAK，则重传<code>udt_send(sndpkt)</code>，并保持“<strong>等待ACK或NAK</strong>”的状态；如果<code>isACK(rcvpkt)</code>即接收到ACK，则回到“<strong>等待上级调用</strong>”的状态。</p>
<div class="note info">
            <p>停等机制（stop and wait）</p><p>&emsp;&emsp;发送方发送一个packet，然后等待接收方的响应。</p>
          </div>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt2-0-sender.png" alt="rdt2.0 sender.png" style="zoom:50%"></p>
<h5 id="接收方-1"><a href="#接收方-1" class="headerlink" title="接收方"></a>接收方</h5><p>&emsp;&emsp;接收方还是只有一个状态——<strong>等待下级调用</strong>。接收方首先在“<strong>等待下级调用</strong>”的状态，<code>rdt_rcv(rcvpkt)</code>接收方接收packet，如果<code>corrupt(rcvpkt)</code>，即检测到错误，则<code>udt_send(NAK)</code>反馈NAK；如果<code>notcorrupt(rcvpkt)</code>，即未检测到错误，则<code>extract(packet, data)</code>将packet重新恢复成data，<code>deliver_data(data)</code>将data传送给上级，最后<code>udt_send(ACK)</code>反馈ACK。完成后接收方再回到“等待下级调用”的状态。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt2-0-receiver.png" alt="rdt2.0 receiver.png" style="zoom:50%"></p>
<p>接收方可能判断ACK/NAK信号出错，导致发送分组重复 =&gt; 引入rdt2.1</p>
<h3 id="rdt2-1：接收方判断ACK-NAK信号出错"><a href="#rdt2-1：接收方判断ACK-NAK信号出错" class="headerlink" title="rdt2.1：接收方判断ACK/NAK信号出错"></a>rdt2.1：接收方判断ACK/NAK信号出错</h3><p>&emsp;&emsp;引入0/1序号和丢弃分组，解决接收方判断ACK/NAK信号出错，导致发送分组重复问题。但这也让发送方和接收方有限状态机的状态翻倍。</p>
<h4 id="rdt2-1有限状态机"><a href="#rdt2-1有限状态机" class="headerlink" title="rdt2.1有限状态机"></a>rdt2.1有限状态机</h4><h5 id="发送方-2"><a href="#发送方-2" class="headerlink" title="发送方"></a>发送方</h5><p>&emsp;&emsp;相较于rdt2.0，rdt2.1在发送的packet里包含了0/1序号（sequence number），所以发送方有4种状态——<strong>等待上级调用 0</strong>、<strong>等待ACK或NAK 0</strong>、<strong>等待上级调用 1</strong>、<strong>等待ACK或NAK 1</strong>。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt2-1-sender.png" alt="rdt2.1 sender.png" style="zoom:50%"></p>
<h5 id="接收方-2"><a href="#接收方-2" class="headerlink" title="接收方"></a>接收方</h5><p>&emsp;&emsp;接收方有2种状态——<strong>等待下级调用 0</strong>、<strong>等待下级调用 1</strong>。只有在数据包ACK且<strong>收到的packet序号与目前状态等待的序号相同</strong>时，才能向上传输。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt2-1-receiver.png" alt="rdt2.1 receiver.png" style="zoom:50%"></p>
<div class="note info">
            <p>为什么接收方等待1状态接收到0的packet时，为什么要反馈ACK？</p><p>&emsp;&emsp;为了让发送方的状态转移，从“等待ACK或NAK 0”到“等待上级调用 1”。</p>
          </div>
<h3 id="rdt2-2：不发送NAK的协议"><a href="#rdt2-2：不发送NAK的协议" class="headerlink" title="rdt2.2：不发送NAK的协议"></a>rdt2.2：不发送NAK的协议</h3><p>&emsp;&emsp;用重复的ACK替代NAK，解决信号冗余问题。</p>
<h4 id="rdt2-2概述"><a href="#rdt2-2概述" class="headerlink" title="rdt2.2概述"></a>rdt2.2概述</h4><ul>
<li>只用ACK，不用NAK，实现和rdt2.1一样的功能。</li>
<li>在检测到错误时，不发送NAK，但是接收方要发送判断上一次序号的ACK（同时包括序号）</li>
<li>用重复的ACK代替NAK</li>
</ul>
<h4 id="rdt2-2有限状态机"><a href="#rdt2-2有限状态机" class="headerlink" title="rdt2.2有限状态机"></a>rdt2.2有限状态机</h4><h5 id="发送方-3"><a href="#发送方-3" class="headerlink" title="发送方"></a>发送方</h5><p>&emsp;&emsp;将rdt2.1中的<code>isNAK(rcvpkt)</code>判断本次反馈是NAK，替代成判断上次序号的反馈是ACK，比如rdt2.2在“<strong>等待ACK 0</strong>”时，如果<code>isACK(rcvpkt, 1)</code>，则相当于收到来rdt2.1中的<code>isNAK(rcvpkt)</code>。其余不变。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt2-2-sender.png" alt="rdt2.2 sender.png" style="zoom:50%"></p>
<h5 id="接收方-3"><a href="#接收方-3" class="headerlink" title="接收方"></a>接收方</h5><p>&emsp;&emsp;接收方如果校验和检测出错，则发送上一次序号的ACK；在校验和检测正确时，发送ACK也需要带上本次的序号。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt2-2-receiver.png" alt="rdt2.2 receiver.png" style="zoom:50%"></p>
<h3 id="rdt3-0：信道存在错误和丢包"><a href="#rdt3-0：信道存在错误和丢包" class="headerlink" title="rdt3.0：信道存在错误和丢包"></a>rdt3.0：信道存在错误和丢包</h3><h4 id="rdt3-0概述"><a href="#rdt3-0概述" class="headerlink" title="rdt3.0概述"></a>rdt3.0概述</h4><p>&emsp;&emsp;发送端在一个合理的时间内，等待接收ACK。</p>
<ul>
<li>当在等待时间内没有接收ACK时，重传</li>
<li>超过时间可能有两种情况：丢包或时延，如果发生时延可能会重复发生pkt，此时rdt2.1和2.2中的序号可以解决问题，同样的发生ACK得带上序号。</li>
<li>需要计时器</li>
</ul>
<h4 id="rdt3-0有限状态机"><a href="#rdt3-0有限状态机" class="headerlink" title="rdt3.0有限状态机"></a>rdt3.0有限状态机</h4><p>&emsp;&emsp;发送方传输开始时，<code>start_timer</code>启动计时器。如果<code>timeout</code>传输超时，则重新启动计时器；如果在规定时间内接收到反馈，则<code>stop_timer</code>结束计时。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt3-0-sender.png" alt="rdt3.0 sender.png" style="zoom:50%"></p>
<h4 id="rdt3-0流程"><a href="#rdt3-0流程" class="headerlink" title="rdt3.0流程"></a>rdt3.0流程</h4><h5 id="正常流程"><a href="#正常流程" class="headerlink" title="正常流程"></a>正常流程</h5><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt3-0-NoLoss.png" alt="rdt3.0 NoLoss.png" style="zoom:50%"></p>
<h5 id="丢packet"><a href="#丢packet" class="headerlink" title="丢packet"></a>丢packet</h5><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt3-0-LossPacket.png" alt="rdt3.0 LossPacket.png" style="zoom:50%"></p>
<h5 id="丢ACK"><a href="#丢ACK" class="headerlink" title="丢ACK"></a>丢ACK</h5><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt3-0-LossACK.png" alt="rdt3.0 LossACK.png" style="zoom:50%"></p>
<h5 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h5><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt3-0-timeout.png" alt="rdt3.0 timeout.png" style="zoom:50%"></p>
<h4 id="rdt3-0性能"><a href="#rdt3-0性能" class="headerlink" title="rdt3.0性能"></a>rdt3.0性能</h4><p>&emsp;&emsp;rdt3.0性能很差</p>
<div class="note warning">
            <p>例题：一个 1Gbps的链路，15ms的传播时延，传输8000bit的packet，求发送方的使用效率。</p><p>传输时延</p><script type="math/tex; mode=display">D_{tran} = \frac LR = \frac{8000\ bits}{10^9\ bits/sec} = 8 ms</script><p>发送方使用效率</p><script type="math/tex; mode=display">U_{sender} = \frac{L/R}{RTT+L/R} = \frac{0.008}{30.008} = 0.00027</script><p>&emsp;&emsp;可见rdt3.0的使用效率很低。</p>
          </div>
<p>&emsp;&emsp;rdt3.0网络协议限制了物理资源的使用率。</p>
<h2 id="流水线协议"><a href="#流水线协议" class="headerlink" title="流水线协议"></a>流水线协议</h2><p>&emsp;&emsp;采用流水线的机制，不要等一个RTT发送回来再发下一个（即不再采用停等机制），来提高物理资源的使用率。</p>
<span class="label info">图 停等机制（Stop-and-wait）</span>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Stop-and-Wait-Operation.png" alt="Stop-and-Wait Operation.png" style="zoom:50%"></p>
<span class="label info">图 流水线机制（Pipelined Operation）</span>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Pipelined-Operation.png" alt="Pipelined Operation.png" style="zoom:50%"></p>
<h3 id="回退N步（Go-back-N，GBN）"><a href="#回退N步（Go-back-N，GBN）" class="headerlink" title="回退N步（Go-back-N，GBN）"></a>回退N步（Go-back-N，GBN）</h3><ul>
<li>发送方可以有至多N个没有ACK的packet同时在流水线上</li>
<li>接收方只发送累计ACK</li>
<li>发送方给最早还没ACK的packet一个计时器，当这个计时器到时时，重传所有的未ACK的packet。</li>
</ul>
<h4 id="GBN发送方"><a href="#GBN发送方" class="headerlink" title="GBN发送方"></a>GBN发送方</h4><ul>
<li>packet头部有k bit的序号，则可以表示 $2^k$ 个序号。</li>
<li>“窗口”大小为N，这一段是允许的未ACK的packet</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_GBN-sender.png" alt="GBN sender.png" style="zoom:50%"></p>
<ul>
<li>ACK(n)累计确认：ACK在发送的时候要带上序号#n，即#n及之前的packet都收到了。接收方发送ACK n，则证明#n及之前的packet都收到了。否则接收方还是发送之前的ACK（重复）。</li>
<li>计时器只给最早的未ACK的packet保留</li>
<li>如果timeout（n），重传#n以及比#n更大的未ACK的packet</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_GBN-sender(1).png" alt="GBN sender.png" style="zoom:50%"></p>
<h4 id="GBN接收方"><a href="#GBN接收方" class="headerlink" title="GBN接收方"></a>GBN接收方</h4><ul>
<li>发送的ACK是顺序接收到的packet里面最大的序列号#<ul>
<li>可能会产生重复的ACK</li>
<li>只需要记住期望的序列号（expextedseqnum）</li>
</ul>
</li>
<li>乱序到达的packet<ul>
<li>直接丢弃，不缓存（缓存会造成数据重复）</li>
<li>重新发送顺序最大序列号#</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_GBN-receiver.png" alt="GBN receiver.png" style="zoom:50%"></p>
<h4 id="GBN流程"><a href="#GBN流程" class="headerlink" title="GBN流程"></a>GBN流程</h4><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_GBN-action.png" alt="GBN action.png" style="zoom:50%"></p>
<div class="note warning">
            <p>例题：采用GBN协议，一个发送方发送了 #0到#5 的packet，但是只收到了 ACK0 和 ACK2。问发送方要重发哪些packet？</p><p>&emsp;&emsp;重发#3、#4、#5 的 packet。</p><p>&emsp;&emsp;虽然没有收到ACK1，但是接收方只有在#n及之前的packet都收到了的时候，才会发送ACKn，发送方接收到ACK n，则证明接收方#n及之前的packet都收到了。所以ACK1应该是在发送过程中丢包了，但是实际接收方已经收到了#1 packet。所以重发#3、#4、#5 的 packet。</p>
          </div>
<h3 id="选择重传（Selective-Repeat，SR）"><a href="#选择重传（Selective-Repeat，SR）" class="headerlink" title="选择重传（Selective Repeat，SR）"></a>选择重传（Selective Repeat，SR）</h3><ul>
<li>接收方分别确认所有正确收到的pkt<ul>
<li>缓存pkt，最终有序传给上层</li>
</ul>
</li>
<li>发送方重发没ACK的pkt<ul>
<li>发送方给每个还没ACK的packet都维持一个计时器</li>
</ul>
</li>
<li>发送方的window<ul>
<li>N个连续的序号</li>
<li>限制发送并且未ACK的pkt</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_SR-windows.png" alt="SR windows.png" style="zoom:50%"></p>
<h4 id="SR发送方"><a href="#SR发送方" class="headerlink" title="SR发送方"></a>SR发送方</h4><ul>
<li>收到上层数据<ul>
<li>如果window里还有可用序列，则继续发送</li>
</ul>
</li>
<li>timeout(n)<ul>
<li>重发<code>pkt n</code>，重启timer</li>
</ul>
</li>
<li>如果<code>ACK(n)</code>在可接收范围内$[sendbase, sendbase+N-1]$<ul>
<li>将<code>pkt n</code>标记为接收完成</li>
<li>如果 n 是最小的未ACK的pkt，则将window滑动到下一个未ACK的pkt</li>
</ul>
</li>
</ul>
<h4 id="SR接收方"><a href="#SR接收方" class="headerlink" title="SR接收方"></a>SR接收方</h4><ul>
<li>如果<code>pkt n</code>在接收范围内$[rcvbase, rcvbase+N-1]$<ul>
<li>发送<code>ACK(n)</code></li>
<li>如果不是按序到达，则缓存pkt</li>
<li>如果是按序到达，则向上交付已有的按序的缓存，并将window滑动到下一个未收到的pkt</li>
</ul>
</li>
<li>如果<code>pkt n</code>在$[rcvbase-N, rcvbase-1]$内<ul>
<li>发送<code>ACK(n)</code></li>
</ul>
</li>
<li>其他情况忽略</li>
</ul>
<h4 id="SR流程"><a href="#SR流程" class="headerlink" title="SR流程"></a>SR流程</h4><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_SR-action.png" alt="SR action.png" style="zoom:50%"></p>
<h4 id="SR困境"><a href="#SR困境" class="headerlink" title="SR困境"></a>SR困境</h4><p>&emsp;&emsp;比如下面序列号有：#0, #1, #2, #3，window大小为3的情况。SR会无法分清a、b两种情况，导致在b中误判重发的第一轮的<code>pkt0</code>，被当作后一轮的<code>pkt0</code>填入。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_SR-dilemma.png" alt="SR dilemma.png" style="zoom:40%"></p>
<h2 id="TCP-1"><a href="#TCP-1" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP概论"><a href="#TCP概论" class="headerlink" title="TCP概论"></a>TCP概论</h3><ul>
<li>点对点（point-to-point）：一个发送方、一个接收方</li>
<li>可靠的、有序的字节流<ul>
<li>没有消息的边界</li>
</ul>
</li>
<li>流水线机制<ul>
<li>窗口大小由拥塞和流量控制</li>
</ul>
</li>
<li>全双工<ul>
<li>同时双向数据流</li>
<li>MSS（maximum segment size）：最大报文段长度</li>
</ul>
</li>
<li>面向连接<ul>
<li>握手：交换控制信息，初始化发送方和接收方的状态</li>
</ul>
</li>
<li>流量控制</li>
</ul>
<h3 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h3><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-segment-structure.png" alt="TCP segment structure.png" style="zoom:30%"></p>
<p>1、端口号：用来标识同一台计算机的不同的应用进程。</p>
<ul>
<li>源端口：源端口和IP地址的作用是标识报文的返回地址。</li>
<li>目的端口：端口指明接收方计算机上的应用程序接口。</li>
</ul>
<p>&emsp;&emsp;TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。</p>
<p>2、序号和确认号：是TCP可靠传输的关键部分。序号是本报文段发送的数据组的第一个字节的序号。在TCP传送的流中，每一个字节一个序号。e.g.一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为400。所以序号确保了TCP传输的有序性。确认号，即ACK，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。</p>
<p>3、数据偏移／首部长度：4bits。由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32/8 = 60，故报头最大长度为60字节。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。</p>
<p>4、保留：为将来定义新的用途保留，现在一般置0。</p>
<p>5、控制位：URG  ACK  PSH  RST  SYN  FIN，共6个，每一个标志位表示一个控制功能。</p>
<ul>
<li>URG：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。</li>
<li>ACK：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。</li>
<li>PSH：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。</li>
<li>RST：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。</li>
<li>SYN：同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。</li>
<li>FIN：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。</li>
</ul>
<p>6、窗口：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。</p>
<p>7、校验和：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。</p>
<p>8、紧急指针：只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。</p>
<p>9、选项和填充：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。</p>
<p>10、数据部分： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。</p>
<h4 id="TCP序号"><a href="#TCP序号" class="headerlink" title="TCP序号"></a>TCP序号</h4><p>&emsp;&emsp;报文段（segment）的序号：字节流第一个字节的序号</p>
<div class="note warning">
            <p>例题：下面文件的前3个报文段的序号分别是？</p><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-segment%23.png" alt="TCP segment sequenceNum.png" style="zoom:50%"></p><p>&emsp;&emsp;第一个报文段：0；第二个报文段：1000；第三个报文段：2000</p>
          </div>
<h4 id="TCP-ACK"><a href="#TCP-ACK" class="headerlink" title="TCP ACK"></a>TCP ACK</h4><ul>
<li>TCP报文的ACK填写：期望从另一方收到的下一个字节序号<ul>
<li>主机A接收到从主机B传来的字节#0～535，A下一个期望接到的字节#为536，所以主机A发送的报文段的ACK中填536。</li>
</ul>
</li>
<li>累计ACK（cumulative ACK）:与GBN相似<ul>
<li>主机A接收到从主机B传来的字节 #0～535 和 #900～1000，A下一个期望接到的字节#依旧为536，所以主机A下一个发送的报文段的ACK中填536。</li>
</ul>
</li>
</ul>
<h4 id="TCP-序号和ACK传输"><a href="#TCP-序号和ACK传输" class="headerlink" title="TCP 序号和ACK传输"></a>TCP 序号和ACK传输</h4><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-segment-eg.png" alt="TCP segment eg.png" style="zoom:40%"></p>
<h4 id="TCP计时"><a href="#TCP计时" class="headerlink" title="TCP计时"></a>TCP计时</h4><p>如何设置TCP timeout值？</p>
<ul>
<li>$time &gt; RTT$（但是RTT会改变）</li>
<li>不能太短：过早timeout造成不必要的重传</li>
<li>不能太长：对丢包反应太慢</li>
</ul>
<p>如何EstimateRTT（估计RTT）？</p>
<ul>
<li>SampleRTT（样本RTT）：计算发送segment到接收ACK的时间，忽略重传</li>
<li>SampleRTT多次测量取平均</li>
</ul>
<p>则EstimateRTT为</p>
<script type="math/tex; mode=display">
EstimateRTT = (1-\alpha )*EstimateRTT + \alpha *SamleRTT</script><ul>
<li>指数加权移动平均（不是线形的，存在迭代使原来的SamleRTT的系数越来越小，越靠后的越接近当前网络状态）</li>
<li>EstimateRTT的变化通常比SamleRTT变化更加平滑</li>
<li>一般，$\alpha = 0.125$</li>
</ul>
<p>DevRTT（偏差RTT）为（一般$\beta = 0.25$）</p>
<script type="math/tex; mode=display">
DevRTT = (1-\beta )*DevRTT + \beta *|SampleRTT-EstimatedRTT|</script><p>重传超时间隙（TimeoutInterval）</p>
<script type="math/tex; mode=display">
TimeoutInterval = EstimatedRTT + 4*DevRTT</script><h3 id="TCP可靠数据传输"><a href="#TCP可靠数据传输" class="headerlink" title="TCP可靠数据传输"></a>TCP可靠数据传输</h3><ul>
<li>TCP的rdt服务是建立在IP的不可靠传输上的<ul>
<li>流水机制</li>
<li>累计ACK</li>
<li>一个timer</li>
</ul>
</li>
<li>重传触发情况<ul>
<li>超时</li>
<li>重复的ACK</li>
</ul>
</li>
</ul>
<h4 id="TCP简化"><a href="#TCP简化" class="headerlink" title="TCP简化"></a>TCP简化</h4><p>&emsp;&emsp;TCP简化版：无重复ACK、拥塞控制和流量控制。</p>
<h5 id="TCP-sender"><a href="#TCP-sender" class="headerlink" title="TCP sender"></a>TCP sender</h5><p>TCP sender 的3种事件</p>
<ul>
<li>从上一层收到数据<ul>
<li>分段，创建seq#（报文中字节流第一个字节的序号）</li>
<li>开始timer<ul>
<li>只给最早一个未ACK的segment timer</li>
<li>用 TimeoutInterval 作为timeout时间</li>
</ul>
</li>
</ul>
</li>
<li>超时<ul>
<li>重传segment</li>
<li>重启timer</li>
</ul>
</li>
<li>收到ACK<ul>
<li>如果收到未ACK的segment的ACK<ul>
<li>更新被ACK的segment标记</li>
<li>从最近的一个未ACK的segment开新的timer</li>
</ul>
</li>
</ul>
</li>
</ul>
<span class="label info">图 TCP sender简化版</span>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-sender.png" alt="TCP sender.png" style="zoom:30%"></p>
<h5 id="TCP重传情况"><a href="#TCP重传情况" class="headerlink" title="TCP重传情况"></a>TCP重传情况</h5><span class="label info">图 ACK丢包</span>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-lostACK.png" alt="TCP lost ACK.png" style="zoom:50%"></p>
<span class="label info">图 提前timeout</span>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-premature-timeout.png" alt="TCP premature timeout.png" style="zoom:50%"></p>
<span class="label info">图 累计ACK</span>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-cumulativeACK.png" alt="TCP cumulative ACK.png" style="zoom:50%"></p>
<h5 id="TCP-receiver"><a href="#TCP-receiver" class="headerlink" title="TCP receiver"></a>TCP receiver</h5><div class="table-container">
<table>
<thead>
<tr>
<th>事件</th>
<th>TCP接收方反应</th>
</tr>
</thead>
<tbody>
<tr>
<td>具有所期望序号的按序报文段到达。所有在期望序号及以前的数据都已经被确认</td>
<td><strong>延迟的ACK</strong>，对另一个按序报文段的到达最多等待500ms。如果下一个按序报文段在这个时间间隔内没有到达，则发送一个ACK</td>
</tr>
<tr>
<td>具有所期望序号的按序报文段到达。另一个按序报文段等待ACK传输</td>
<td>立即发送单个累计ACK，以确认两个按序报文段</td>
</tr>
<tr>
<td>比期望序号大的失序报文段到达。检测出间隔</td>
<td>立即发送冗余ACK，指示下一个期待字节的序号（其为间隔的低端的序号）</td>
</tr>
<tr>
<td>能部分或完全填充接收数据间隔的报文段到达</td>
<td>倘若该报文段起始于间隔的低端，则立即发送ACK</td>
</tr>
</tbody>
</table>
</div>
<h4 id="TCP快速重传"><a href="#TCP快速重传" class="headerlink" title="TCP快速重传"></a>TCP快速重传</h4><ul>
<li>timeout时间长，造成长时延</li>
<li>通过重复的ACK检测丢包<ul>
<li>发送方会发送很多个segment</li>
<li>如果有segment丢失，则可能会收到很多个重复的ACK</li>
</ul>
</li>
</ul>
<p>TCP快速重传机制：</p>
<p>&emsp;&emsp;如果发送方收到对同一数据收到3个重复的ACK（实际收到4次该ACK），则认为此时未ACK的segment丢失，不需再等待timeout，重发未ACK的最小seq#</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-fastRetransmission.png" alt="TCP fast retransmit.png" style="zoom:50%"></p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>&emsp;&emsp;接收方要控制发送方，使发送方不会发送得太快导致接收方的缓存（buffer）溢出。</p>
<ul>
<li>接收方告诉发送方free buffer大小，包含在TCP报文的<strong>rwnd</strong>（receive window中）<ul>
<li>RcvBuffer socket设定大小（一般，4096）</li>
<li>一些操作系统也可以自动调节RcvBuffer</li>
</ul>
</li>
</ul>
<span class="label info">图 接收方缓存</span>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-receiverBuffering.png" alt="TCP  receiver Buffering.png" style="zoom: 25%;"></p>
<ul>
<li>sender通过rwnd来限制unacked segment的数量</li>
<li>保障receive的buffer不会溢出</li>
</ul>
<div class="note info">
            <p>&emsp;&emsp;如果sender接收到$rwnd=0$，此时没有剩余buffer，再发送数据会造成receiver buffer溢出，但是有要防止锁住。<br>&emsp;&emsp;所以sender向receiver发送一个1 byte data的报文，以更新rwnd。</p>
          </div>
<h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><h4 id="TCP建立连接：3次握手"><a href="#TCP建立连接：3次握手" class="headerlink" title="TCP建立连接：3次握手"></a>TCP建立连接：3次握手</h4><p>建立连接之前，先握手</p>
<ul>
<li>双方同意建立连接</li>
<li>同意连接的参数</li>
</ul>
<div class="note info">
            <p>&emsp;&emsp;为什么两次握手行不通？</p><ul><li>各种delay</li><li>消息丢失导致重传</li><li>消息乱序</li></ul>
          </div>
<p>图 TCP3次握手&emsp;&emsp;<br><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-three-way-handshake.png" alt="TCP three-way handshake.png" style="zoom:40%"></p>
<h4 id="TCP关闭连接：4次挥手"><a href="#TCP关闭连接：4次挥手" class="headerlink" title="TCP关闭连接：4次挥手"></a>TCP关闭连接：4次挥手</h4><ul>
<li>client、server两边都可关闭连接<ul>
<li>发送TCP segment的 FIN bit = 1</li>
</ul>
</li>
<li>用ACK回应FIN（ACK可以和FIN一起发）</li>
<li>同时收到FIN也可以处理（双工）</li>
</ul>
<p>图 TCP关闭连接<br><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-closeConnection.png" alt="TCP closing connection.png" style="zoom: 40%;"></p>
<span class="label info">图 TCP双方状态循环</span>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-Lifecycle.png" alt="TCP Lifecycle.png" style="zoom: 40%;"></p>
<h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><p>拥塞：</p>
<ul>
<li>非正式定义：太多的源发送数据太多太快，导致网络无法处理</li>
<li>和流量控制不同（流量控制c-s一对一）</li>
<li>产生丢包、延时</li>
<li>网络前十的问题</li>
</ul>
<h3 id="场景一：2个Sender-和1个无限buffer的Router"><a href="#场景一：2个Sender-和1个无限buffer的Router" class="headerlink" title="场景一：2个Sender, 和1个无限buffer的Router"></a>场景一：2个Sender, 和1个无限buffer的Router</h3><ul>
<li>2个sender，2个receiver</li>
<li>1个router带无限buffer</li>
<li>输出链路的容量：R</li>
<li>没有重传（无限buffer不会丢包）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Congestion-scenario1.png" alt="Congestion scenario1.png" style="zoom: 50%;"></p>
<span class="label info">图 输入速率-输出速率</span>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Congestion-scenario1-out.png" alt="Congestion scenario1 out.png" style="zoom: 50%;"></p>
<span class="label info">图 输入速率-时延</span>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Congestion-scenario1-delay.png" alt="Congestion scenario1 delay.png" style="zoom: 50%;"></p>
<h3 id="场景二：2个Sender-和1个有限buffer的Router"><a href="#场景二：2个Sender-和1个有限buffer的Router" class="headerlink" title="场景二：2个Sender, 和1个有限buffer的Router"></a>场景二：2个Sender, 和1个有限buffer的Router</h3><ul>
<li>一个router、有限buffer</li>
<li>重传timeout的packet<ul>
<li>$\lambda _{in}$ —— 源数据</li>
<li>$\lambda _{in}’$ —— 源数据+重传<script type="math/tex; mode=display">
\lambda _{in}' \geq \lambda _{in}</script></li>
</ul>
</li>
</ul>
<div class="note info">
            <p>正常理想情况下，</p><script type="math/tex; mode=display">\lambda _{in}' \geq \lambda _{in} = \lambda _{out}</script>
          </div>
<p>情况一（理想）：sender只在router的buffer有空时才发送</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Congestion-scenario2-pic1.png" alt="Congestion scenario2 pic1.png" style="zoom: 50%;"></p>
<p>情况二：知道丢包，当router的buffer满了，packet丢失。sender只有在知道丢包时才重传。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Congestion-scenario2-pic2.png" alt="Congestion scenario2 pic2.png" style="zoom: 50%;"></p>
<p>情况三：重复packet</p>
<ul>
<li>在router的buffer满时，packet可以丢包</li>
<li>提前timeout，会导致发送两个相同的packet</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Congestion-scenario2-pic3.png" alt="Congestion scenario2 pic3.png" style="zoom: 50%;"></p>
<h3 id="拥塞代价"><a href="#拥塞代价" class="headerlink" title="拥塞代价"></a>拥塞代价</h3><ul>
<li>排队延时</li>
<li>丢包导致重传</li>
<li>提前timeout导致非必要的重传，pkt重复，降低吞吐量</li>
<li>当一个packet被丢弃，其上游提供给这个packet的传输容量都浪费了</li>
</ul>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;sender逐渐增加发送速率（window size），从而探查可用bandwidth，直到丢包</p>
<ul>
<li>加性增（additive increase）：cwnd每次每个RTT增加 1 MSS 直到检测到丢包（MSS 最大报文段长度）</li>
<li>乘性减（multiplicative decrease）：如果发生丢包，cwnd减半</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-AIMD.png" alt="TCP AIMD.png" style="zoom: 30%;"></p>
<ul>
<li>sender传输限制<script type="math/tex; mode=display">
LastByteSent - LastByteAcked \leq cwnd</script></li>
<li><strong>cwnd</strong>是动态的随着网络拥塞程度变化的函数</li>
<li>结合之前的rwnd，实际的窗口大小为 $min{ rwnd, cwnd }$</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-cwnd.png" alt="TCP cwnd.png" style="zoom: 30%;"></p>
<p><strong>TCP发送速率（TCP sending rate）</strong></p>
<p>&emsp;&emsp;发送cwnd bytes，等待1个RTT接收ACK，然后再发送后续的bytes。</p>
<script type="math/tex; mode=display">
rate \approx \frac{cwnd}{RTT}\ bytes/sec</script><h3 id="TCP慢启动（TCP-slow-start）"><a href="#TCP慢启动（TCP-slow-start）" class="headerlink" title="TCP慢启动（TCP slow start）"></a>TCP慢启动（TCP slow start）</h3><ul>
<li>连接开始时，先指数级增长发送速率，直到出现<strong>丢包</strong><ul>
<li>初始，$cwnd = 1\ MSS$</li>
<li>每经过一个RTT，翻倍cwnd（实际上，每收到一个ACK，cwnd+1）</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-slow-start.png" alt="TCP slow start.png" style="zoom: 50%;"></p>
<p>当出现<strong>丢包</strong>时，</p>
<ul>
<li>timeout情况<ul>
<li>cwnd重新设为 1MSS</li>
<li>重新开始慢启动，直到到达一个threshold</li>
</ul>
</li>
<li>3个重复的ACK情况（TCP RENO版本）<ul>
<li>重复的ACK既然能收到，那么网络还是有一定的传输能力，不需要像timeout一样重开。</li>
<li>cwnd减半（乘性减）</li>
</ul>
</li>
<li>TCP Tahoe版本中，timeout和3个重复的ACK都将cwnd设为 1MSS</li>
</ul>
<h3 id="从-slow-start-到-CA-的转换"><a href="#从-slow-start-到-CA-的转换" class="headerlink" title="从 slow start 到 CA 的转换"></a>从 slow start 到 CA 的转换</h3><p>&emsp;&emsp;当cwnd达到上次timeout时的1/2（即sstresh）时，从指数级增长变成线形增长。</p>
<p><strong>sstresh</strong> —— 出现丢包时，将sstresh设置为此时cwnd的1/2</p>
<p>图 TCP Tahoe/Reno下cwnd的变化图【注：中间有一次3次ACK的丢包】<br><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-congestion-window.png" alt="TCP congestion window.png" style="zoom: 50%;"></p>
<h3 id="TCP拥塞控制FSM"><a href="#TCP拥塞控制FSM" class="headerlink" title="TCP拥塞控制FSM"></a>TCP拥塞控制FSM</h3><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-congestion-control.png" alt="TCP congestion control.png" style="zoom: 70%;"></p>
<h3 id="TCP吞吐量"><a href="#TCP吞吐量" class="headerlink" title="TCP吞吐量"></a>TCP吞吐量</h3><ul>
<li>avg TCP throughput（TCP平均吞吐量）由window size 和 RTT 决定（忽略slow start，假设一直由data在发送）</li>
<li>W：丢包时的 window size，avg window size 为 $3/4W$，则TCP平均吞吐量为<script type="math/tex; mode=display">
avg\ TCP\ throughput = \frac34 \frac{W}{RTT}\ bytes/sec</script></li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-throughput.png" alt="TCP throughput.png" style="zoom: 30%;"></p>
<h3 id="高速TCP"><a href="#高速TCP" class="headerlink" title="高速TCP"></a>高速TCP</h3><p>&emsp;&emsp;假设一条具有 1500byte 报文段和 100ms RTT 的TCP连接，用此连接以 10Gps 发送数据。此时平均拥塞窗口长度为 83.333 个报文段。TCP连接的吞吐量公式（单位 bytes/sec）：</p>
<script type="math/tex; mode=display">
TCP\ throughput = \frac{1.22MSS}{RTT\sqrt{L}}</script><p>10Gps的吞吐量，报文段丢失概率为 $2\times 10^{-10}$</p>
<h3 id="TCP公平性"><a href="#TCP公平性" class="headerlink" title="TCP公平性"></a>TCP公平性</h3><p>目标：K条TCP连接，经过R bps的瓶颈，每条TCP连接分 R/Kbps，则公平。</p>
<p>&emsp;&emsp;以两条TCP连接为例，从A出发，经过加性增、乘性减，会逐渐趋向公平线。所以TCP可以实现公平性。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-Fairness.png" alt="TCP Fairness.png" style="zoom: 50%;"></p>
<h3 id="Explicit-Congestion-Notification（ECN）"><a href="#Explicit-Congestion-Notification（ECN）" class="headerlink" title="Explicit Congestion Notification（ECN）"></a>Explicit Congestion Notification（ECN）</h3><p><strong>网络辅助的拥塞控制</strong></p>
<ul>
<li>ToS field（IP datagram头部的 2 bits）可以被网络路由标记，以显示拥塞</li>
<li>ToS field会被送到receiver的主机</li>
<li>receiver在发送给sender的ACK中嵌入ECE，来通知sender有拥塞</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-ECN.png" alt="TCP ECN.png" style="zoom: 50%;"></p>
<h1 id="网络层（Network-Layer）"><a href="#网络层（Network-Layer）" class="headerlink" title="网络层（Network Layer）"></a>网络层（Network Layer）</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li>在发送和接收的主机之间传送packet</li>
<li>路由器（router）要检验通过的IP数据报（IP datagram）的头部</li>
</ul>
<h3 id="网络层功能"><a href="#网络层功能" class="headerlink" title="网络层功能"></a>网络层功能</h3><ul>
<li>路由（Routing）：决定packet从源到目的路径</li>
<li>转发（Forwarding）：将packet从route的输入端口到合适的输出端口</li>
<li>连接建立（Connection setup）：一些网络结构要求数据传输前先建立路由路径</li>
</ul>
<h3 id="网络层服务"><a href="#网络层服务" class="headerlink" title="网络层服务"></a>网络层服务</h3><ul>
<li>确保交付（Guaranteed delivery）</li>
<li>具有时延上界的确保交付（Guaranteed delivery with bounded delay）</li>
<li>有序分组交付（In-order packet delivery）</li>
<li>确保最小带宽（Guaranteed minimal bandwidth）</li>
<li>安全性服务（Security）</li>
</ul>
<p>&emsp;&emsp;网络层提供<strong>尽力而为的服务</strong>（best-effort service）。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_service-models.png" alt="Network layer service models" style="zoom: 30%;"></p>
<h2 id="虚电路和数据报网络（Virtual-circuit-and-datagram-networks）"><a href="#虚电路和数据报网络（Virtual-circuit-and-datagram-networks）" class="headerlink" title="虚电路和数据报网络（Virtual circuit and datagram networks）"></a>虚电路和数据报网络（Virtual circuit and datagram networks）</h2><ul>
<li>数据报网络是无连接的服务</li>
<li>虚电路是面向连接的服务</li>
<li>端到端的服务、运行在网络核心</li>
</ul>
<h3 id="虚电路（Virtual-circuit，VC）"><a href="#虚电路（Virtual-circuit，VC）" class="headerlink" title="虚电路（Virtual circuit，VC）"></a>虚电路（Virtual circuit，VC）</h3><ul>
<li>呼叫建立 -&gt; 数据传输 -&gt; 呼叫拆除</li>
<li>每个packet携带VC号</li>
<li>路径上的每个router会给每个经过的VC维护连接状态</li>
<li>链路、路由资源（带宽、缓存）都会分配到VC</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Virtual-circuit.png" alt="Virtual circuit" style="zoom: 30%;"></p>
<p>VC组成：</p>
<ul>
<li>从源到目的的路径</li>
<li>VC号：路径上每个链路都有一个号码（可以变化）</li>
<li>转发表</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Forwarding-Table.png" alt="Forwarding Tables" style="zoom: 30%;"></p>
<p>路由维持连接状态的信息。</p>
<p><strong>信令协议(signaling protocol)</strong></p>
<p>VC采用信令协议(signaling protocol)</p>
<ul>
<li>用来建立、维护、拆除VC</li>
<li>用在ATM、frame-relay、X.25</li>
<li>VC在Internet中没有使用</li>
</ul>
<h3 id="数据报网络（Datagram-networks）"><a href="#数据报网络（Datagram-networks）" class="headerlink" title="数据报网络（Datagram networks）"></a>数据报网络（Datagram networks）</h3><ul>
<li>无连接</li>
<li>路由没有端到端的连接状态</li>
<li>packet通过目的主机ID来路由，同一个源到目的的packet可能走不同的路径。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_datagram-networks.png" alt="Datagram networks" style="zoom: 30%;"></p>
<p>转发表存储地址范围对应的链路接口，比如</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Destination Address Range</th>
<th>Link Interface</th>
</tr>
</thead>
<tbody>
<tr>
<td>11001000 00010111 00010000 00000000 ～ 11001000 00010111 00010111 11111111</td>
<td>0</td>
</tr>
<tr>
<td>11001000 00010111 00011000 00000000 ～ 11001000 00010111 00011000 11111111</td>
<td>1</td>
</tr>
<tr>
<td>11001000 00010111 00011001 00000000 ～ 11001000 00010111 00011111 11111111</td>
<td>2</td>
</tr>
<tr>
<td>Otherwise</td>
<td>3</td>
</tr>
</tbody>
</table>
</div>
<p><strong>最长前缀匹配</strong></p>
<p>&emsp;&emsp;选择 Link Interface 遵循最长前缀匹配原则。</p>
<p>例题：下面转发表</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Longest-prefix-matching.png" alt="Forwarding Table" style="zoom: 30%;"></p>
<p>目的地址<code>11001000 00010111 00010110 10100001</code> 和 <code>11001000 00010111 00011000 10101010</code> 分别对应的Link Interface为？</p>
<p><code>11001000 00010111 00010110 10100001</code> -&gt; 0</p>
<p><code>11001000 00010111 00011000 10101010</code> -&gt; 1（与1和2都匹配，但是与1匹配更长）</p>
<h3 id="虚电路和数据报网络选择"><a href="#虚电路和数据报网络选择" class="headerlink" title="虚电路和数据报网络选择"></a>虚电路和数据报网络选择</h3><p>Internet：网络核心简单，复杂度在网络边缘</p>
<ul>
<li>计算机数据交换：弹性服务，没有严格时间要求</li>
<li>链路类型多：有不同特性，不能统一服务</li>
<li>“智能”端系统</li>
</ul>
<p>ATM：复杂度在网络核心</p>
<ul>
<li>电话演变而来</li>
<li>人之间的交流：严格的时间限制、可靠性、确定的服务保障</li>
<li>“笨拙”端系统</li>
</ul>
<h2 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h2><h3 id="路由器结构"><a href="#路由器结构" class="headerlink" title="路由器结构"></a>路由器结构</h3><ul>
<li>输入端口（Input port）</li>
<li>交换结构（Switch fabric）</li>
<li>输出端口（Output port）</li>
<li>路由选择处理器（Routing processor）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Router-architecture.png" alt="Router architecture.png" style="zoom: 50%;"></p>
<ul>
<li>上半部分为控制面板：软件、毫秒级</li>
<li>下半部分为数据面板：硬件、纳秒级</li>
</ul>
<h4 id="输入端口（Input-port）"><a href="#输入端口（Input-port）" class="headerlink" title="输入端口（Input port）"></a>输入端口（Input port）</h4><ol>
<li>线路端接（line termination）：物理层功能，用来比特的接收</li>
<li>数据链路处理（协议，拆封）（data link processing (protocol, decapsulation)）：数据链路层功能，比如以太网</li>
<li>查找、转发、排队（lookup, forwarding, queueing）<ul>
<li>分散交换：给出数据报目的地，然后根据转发表查找输出端口</li>
<li>目标：希望在“line speed”上完成输入端口的处理</li>
<li>排队：数据报到达速度大于转发速度</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Input-port-processing.png" alt="Input port processing.png" style="zoom: 50%;"></p>
<h4 id="交换结构（Switch-fabric）"><a href="#交换结构（Switch-fabric）" class="headerlink" title="交换结构（Switch fabric）"></a>交换结构（Switch fabric）</h4><p>&emsp;&emsp;三种交换结构：共享内存、共享总线、交叉开关矩阵</p>
<h5 id="共享内存（Switching-via-memory）"><a href="#共享内存（Switching-via-memory）" class="headerlink" title="共享内存（Switching via memory）"></a>共享内存（Switching via memory）</h5><ul>
<li>初代路由常采用共享内存</li>
<li>pkt在memory复制</li>
<li>速度被内存带宽限制，每个datagram都要经过2个bus</li>
<li>Cisco Catalyst 8500</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Switching-Memory.png" alt="Switching via memory.png" style="zoom: 70%;"></p>
<h5 id="共享总线（Switching-via-a-bus）"><a href="#共享总线（Switching-via-a-bus）" class="headerlink" title="共享总线（Switching via a bus）"></a>共享总线（Switching via a bus）</h5><ul>
<li>datagram通过共享的bus从输入端口到输出端口</li>
<li>总线冲突（bus contention）：交换速度被总线带宽限制</li>
<li>Cisco 5600</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Switching-Bus.png" alt="Switching via a bus.png" style="zoom: 70%;"></p>
<h5 id="交叉开关矩阵（Switching-via-an-interconnection-network）"><a href="#交叉开关矩阵（Switching-via-an-interconnection-network）" class="headerlink" title="交叉开关矩阵（Switching via an interconnection network）"></a>交叉开关矩阵（Switching via an interconnection network）</h5><ul>
<li>客服总线带宽的限制</li>
<li>纵横式交换机是一种由2N条总线组成的互联网络，连接N个输入端口和N个输出端口</li>
<li>可并行转发多个分组，但如果同输入输出端口，还是必须等待前一个发送了再发下一个</li>
<li>Cisco 12000</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Switching-Interconnection-Network.png" alt="Switching via an interconnection network.png" style="zoom: 70%;"></p>
<h4 id="输出端口（Output-port）"><a href="#输出端口（Output-port）" class="headerlink" title="输出端口（Output port）"></a>输出端口（Output port）</h4><ol>
<li>排队（缓存管理）（Queueing(datagram buffer)）<ul>
<li>缓存：当数据报到达快于传输速率，如果缓存不够会导致丢包</li>
<li>调度方法：从排队中选择数据报进行传输，例如按时间顺序、按优先级顺序</li>
</ul>
</li>
<li>数据链路处理（协议，封装）（Data link processing(protocol, encapsulation)）</li>
<li>线路端接（Line termination）</li>
</ol>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Output-port-processing.png" alt="Output port processing.png" style="zoom: 50%;"></p>
<h3 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h3><h4 id="输入端口排队"><a href="#输入端口排队" class="headerlink" title="输入端口排队"></a>输入端口排队</h4><ul>
<li>当fabric比input port慢时，发生排队</li>
<li>buffer满时，出现排队延时和丢包</li>
<li>队首阻塞（Head-of-the-Line blocking，HOL）：队首的datagram会阻塞排在它后面的datagram输入</li>
</ul>
<h4 id="输出端口排队"><a href="#输出端口排队" class="headerlink" title="输出端口排队"></a>输出端口排队</h4><ul>
<li>当switch到达比output line快，发生排队</li>
<li>buffer满时，出现排队延时和丢包</li>
</ul>
<h2 id="路由算法（Routing-algorithms）"><a href="#路由算法（Routing-algorithms）" class="headerlink" title="路由算法（Routing algorithms）"></a>路由算法（Routing algorithms）</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p><strong>路由协议</strong></p>
<p>目标：从源到目的找到一条最好的路径</p>
<ul>
<li>一般，最好路径是最小代价路径</li>
<li>但也可以有其他定义</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Abstract-graph-model.png" alt="Abstract graph model.png" style="zoom: 50%;"></p>
<ul>
<li>路由 -&gt; 节点</li>
<li>物理链路 -&gt; 边</li>
<li>链路代价：可以是延时、花费或拥塞等级等等</li>
</ul>
<p>路由图表示：</p>
<script type="math/tex; mode=display">
G = (N,E)</script><ul>
<li>路由器集合：$N = {u,v,w,x,y,z}$</li>
<li>链路集合：$E = {(u,v),(u,x),(v,x),(v,w),(x,w),(x,y),(w,y),(w,z),(y,z)}$</li>
<li>路径cost：$cost\ of\ path\ (x<em>1,x_2,x_3,…,x_p)=c(x_1,x_2)+c(x_2,x_3)+…+c(x</em>{p-1},x_p)$</li>
</ul>
<p>路由算法：找到cost最小路径</p>
<p><strong>路由算法分类</strong></p>
<ul>
<li>全局/分散信息<ul>
<li>全局：知道所有路由信息</li>
<li>分散：只知道邻居路由的信息，需要进行迭代查询</li>
</ul>
</li>
<li>静态/动态<ul>
<li>静态：需要手动配置，路由变化慢</li>
<li>动态：路由变化快，周期更新</li>
</ul>
</li>
</ul>
<h3 id="LS算法：路由选择算法（Link-state-alorithm）"><a href="#LS算法：路由选择算法（Link-state-alorithm）" class="headerlink" title="LS算法：路由选择算法（Link state alorithm）"></a>LS算法：路由选择算法（Link state alorithm）</h3><h4 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h4><ul>
<li>基于<strong>全局</strong>信息的算法</li>
<li>计算从源到所有其他节点的最小cost</li>
<li>迭代：经过k次迭代可知到k个目的的路径cost</li>
</ul>
<p>算法步骤如下：<br>G={V,E}</p>
<ol>
<li>初始时令 S={V0},T=V-S={其余顶点}，T中顶点对应的距离值<br>若存在<V0,Vi>，d(V0,Vi)为<V0,Vi>弧上的权值<br>若不存在<V0,Vi>，d(V0,Vi)为∞</li>
<li>从T中选取一个与S中顶点有关联边且权值最小的顶点W，加入到S中</li>
<li>对其余T中顶点的距离值进行修改：若加进W作中间顶点，从V0到Vi的距离值缩短，则修改此距离值<br>重复上述步骤2、3，直到S中包含峙所有顶点，即W=Vi为止</li>
</ol>
<ul>
<li>$c(x,y)$：x到y的cost，如果x，y不是邻居，则为$c(x,y) = \infty $</li>
<li>$D(v)$：从源到目的v的路径的cost</li>
<li>$p(v)$：从源到目的v的路径的前一个节点</li>
<li>$N’$：最小cost路径的节点集</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Dijkstra’s-algorithm(1).png" alt="Dijkstra’s-algorithm(1).png" style="zoom: 30%;"></p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Dijkstra’s-algorithm(2).png" alt="Dijkstra’s-algorithm(2).png" style="zoom: 30%;"></p>
<p><strong>算法复杂度</strong></p>
<p>假如有n个节点，</p>
<ul>
<li>一般的Dijkstra算法需要 $n(n+1)/2$，即$O(n^2)$</li>
<li>通过算法优化，可将复杂度降为$O(n\log n)$</li>
</ul>
<p>&emsp;&emsp;Dijkstra算法存在振荡问题。</p>
<h4 id="广播路由（Broadcast-routing）"><a href="#广播路由（Broadcast-routing）" class="headerlink" title="广播路由（Broadcast routing）"></a>广播路由（Broadcast routing）</h4><p>&emsp;&emsp;通过广播路由得到路由的实时情况。完成广播通信的最直接方式是由发送节点向每个目的地分别发送分组的拷贝。</p>
<ul>
<li><p><strong>洪泛</strong>（Flooding）：从源发送pkt到所有其他的节点</p>
<p>&emsp;&emsp;无限制洪泛会引起<strong>广播风暴</strong>（Broadcast storm），导致广播路由耗光了所有的流量。</p>
</li>
<li><p><strong>受控洪泛</strong>（Controlled flooding）：解决广播风暴问题</p>
<ul>
<li><p><strong>序号控制洪泛</strong>（Sequence-number-controlled flooding）</p>
<p>&emsp;&emsp;源节点将其地址(或其他的唯一标识符)以及广播序号放人广播分组，再向它的所有邻居发送该分组。每个节点维护它已经收到的、复制的和转发的源地址和每个广播分组的序号列表。当一个节点接收到一个广播分组时，它首先检查该分组是否在该列表中。如果在，丢弃该分组;如果不在，复制该分组并向该节点的所有邻居转发。</p>
</li>
<li><p><strong>反向路径广播</strong>(Reverse Path Broadcasting，RPB)</p>
<p>RPB 的基本思想是当一台路由器接收到具有给定源地址的广播分组时， 仅当该分组到达的链路正好是位于它自己到其源的最短单播路径上，它才向其所有出链路 (除了它接收分组的那个)传输分组。否则，该路由器丢弃入分组。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_RPB.png" style="zoom:33%;" /></p>
</li>
</ul>
</li>
<li><p><strong>生成树广播</strong>（Spanning-tree broadcast）：消除了冗余广播pkt，而且能够被任何节点用于开始广播分组</p>
<ul>
<li>在生成树上广播pkt，这样就不再会有圈了</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Spanning-tree-broadcast.png" style="zoom:33%;" /></p>
</li>
</ul>
<h4 id="LS算法"><a href="#LS算法" class="headerlink" title="LS算法"></a>LS算法</h4><p>LS算法 = 广播路由 + Dijkstra算法</p>
<ul>
<li>广播路由：每个节点都要广播链接状态pkt给每个其他节点，从而每个节点都获得相同完整的网络信息</li>
<li>Dijkstra算法：计算源到每个节点的最小cost路径</li>
<li>如果有link cost变化，则重新进行上述操作</li>
</ul>
<h3 id="DV算法：距离向量算法（Distance-vector-algorithm）"><a href="#DV算法：距离向量算法（Distance-vector-algorithm）" class="headerlink" title="DV算法：距离向量算法（Distance vector algorithm）"></a>DV算法：距离向量算法（Distance vector algorithm）</h3><p>&emsp;&emsp;DV算法为基于分散信息、动态的路由算法。</p>
<h4 id="Bellman-Ford公式"><a href="#Bellman-Ford公式" class="headerlink" title="Bellman-Ford公式"></a>Bellman-Ford公式</h4><p>&emsp;&emsp;定义 $d_x(y)$ ：从x到y的最小cost路径的cost</p>
<p>Bellman-Ford方程：$d_x(y)$进行分解</p>
<script type="math/tex; mode=display">
d_x(y) = min_v\{c(x,v)+d_v(y)\}</script><p>例题：通过$d_v(z)$、$d_w(z)$、$d_x(z)$计算$d_u(z)$。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_route-eg.png" style="zoom: 50%;" /></p>
<script type="math/tex; mode=display">
d_u(z) = min\{c(u,v)+d_v(z), c(u,w)+d_w(z), c(u,x)+d_x(z)\} = min(2+5,1+3,5+3) = 4</script><ul>
<li>$D_x(y)$为估算的$d_x(y)$</li>
<li>对于节点x<ul>
<li>知道邻居节点v的 $c(x,v)$</li>
<li>维持邻居的距离向量 $D_v = [D_v(y):y\in N]$</li>
</ul>
</li>
</ul>
<h4 id="DV算法"><a href="#DV算法" class="headerlink" title="DV算法"></a>DV算法</h4><ul>
<li>每个节点定期发送它的 DV estimate 给邻居</li>
<li>当一个节点x收到邻居发来的新的 DV estimate 时，它会根据 B-F公式 更新自己的 DV estimate</li>
<li>多次更新后，DV estimate 会收敛于真实的最小cost $d_x(y)$</li>
</ul>
<p><strong>迭代、异步</strong>：<br>每个本地迭代产生于：</p>
<ul>
<li>本地链接cost改变</li>
<li>邻居发来新的 DV estimate</li>
</ul>
<p><strong>分布</strong>：</p>
<ul>
<li>每个节点只会在它的DV改变的时候才会通知邻居</li>
<li>邻居如果改变再通知邻居</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_DV.png" style="zoom: 50%;" /></p>
<h4 id="好事传得快，坏事传得慢"><a href="#好事传得快，坏事传得慢" class="headerlink" title="好事传得快，坏事传得慢"></a>好事传得快，坏事传得慢</h4><ul>
<li>“好事”（cost变小）：更新完成快</li>
<li>“坏事”（cost变大）：更新完成慢，造成无限问题</li>
</ul>
<p>如何解决无限问题？</p>
<p>&emsp;&emsp;如果要节点最小cost路由要绕路（即不是邻居），则标为$\infty $</p>
<h3 id="LS算法和DV算法对比"><a href="#LS算法和DV算法对比" class="headerlink" title="LS算法和DV算法对比"></a>LS算法和DV算法对比</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>LS</th>
<th>DV</th>
</tr>
</thead>
<tbody>
<tr>
<td>信息复杂度（Message complexity）</td>
<td>$O(nE)$（n个节点，E条链路）</td>
<td>只在邻居之间交换</td>
</tr>
<tr>
<td>收敛速度（Speed of convergence）</td>
<td>$O(n^2)$，可优化到$O(n\log n)$</td>
<td>速度会变化</td>
</tr>
<tr>
<td>强健性（Robustness）</td>
<td>有一定强健性，每个节点都有自己的表</td>
<td>强健性低，节点依赖于邻居</td>
</tr>
</tbody>
</table>
</div>
<h3 id="层次路由（Hierarchical-Routing）"><a href="#层次路由（Hierarchical-Routing）" class="headerlink" title="层次路由（Hierarchical Routing）"></a>层次路由（Hierarchical Routing）</h3><p>之前讨论的路由都是理想化的：所有路由器都相同，网络是“扁平”的。而实际，并不存在这样的理想路由。</p>
<ul>
<li>大规模<ul>
<li>无法存储所有目的的转发表</li>
<li>路由交换流量大，导致淹没链路</li>
</ul>
</li>
<li>管理自治<ul>
<li>因特网是网中网</li>
<li>每个网络管理都希望控制所在网络的路由</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;聚集路由成<strong>自治系统</strong>（autonomous system，AS）</p>
<ul>
<li><strong>AS内的路由</strong>（intra_AS routing）<ul>
<li>在一个AS间的路由</li>
<li>在一个AS的所有路由器运行同一个区域内协议</li>
<li>不同AS的路由器运行不同区域的协议</li>
<li>网管路由器：位于AS边缘，与其他AS的路由器有链接</li>
</ul>
</li>
<li><strong>AS间的路由</strong>（inter_AS routing）<ul>
<li>在不同AS间的路由</li>
<li>网管参与区域间的路由</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_AS.png" style="zoom: 30%;" /></p>
<p><strong>AS分类</strong></p>
<ul>
<li>Stub AS：末端AS，用于小企业</li>
<li>Multihomed AS：多出口AS，用于大企业，外部不能通过它传输</li>
<li>Transit AS：中转AS，网络提供商，用于传输</li>
</ul>
<h2 id="因特网中的路由选择"><a href="#因特网中的路由选择" class="headerlink" title="因特网中的路由选择"></a>因特网中的路由选择</h2><p>&emsp;&emsp;内部网关协议（Interior Gateway Protocols，IGP）是AS内的路由。</p>
<p>常用的IGP有：</p>
<ul>
<li>RIP：路由信息协议，Routing Information Protocol</li>
<li>OSPF：开放最短路径，Open Shortest Path First</li>
<li>IGRP：Interior Gateway Routing Protocol</li>
</ul>
<h3 id="RIP：路由信息协议（Routing-Information-Protocol）"><a href="#RIP：路由信息协议（Routing-Information-Protocol）" class="headerlink" title="RIP：路由信息协议（Routing Information Protocol）"></a>RIP：路由信息协议（Routing Information Protocol）</h3><ul>
<li><p>DV算法</p>
</li>
<li><p>cost：跳数</p>
<p>&emsp;&emsp;<strong>最大15跳</strong>，16跳视为$\infty $。设置最大跳数以防止无穷计数问题，但这也限制了只能用于小网络，大网络很容易超最大跳数。</p>
</li>
<li><p>每30s通过发送通告的方式更新DV，通告最多路由到25个目的</p>
</li>
<li><p>如果超过180s每收到通告，则这个邻居/链路宣告死亡</p>
<ul>
<li>通过该邻居的路由失效</li>
<li>发送新通告给邻居</li>
<li>如果邻居的转发表变化，它也会发送新的通告</li>
<li>链接失败的信息会快速迭代完成<ul>
<li>采用毒性逆转防止循环</li>
<li>将16跳设置为$\infty $</li>
</ul>
</li>
</ul>
</li>
<li><p>RIP运行在应用层（路由器实际可能存在应用层，只是不对用户开放）</p>
</li>
<li>通告用 UDP pkt 周期性发送</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_RIP.png" style="zoom: 30%;" /></p>
<h3 id="OSPF：开放最短路径（Open-Shortest-Path-First）"><a href="#OSPF：开放最短路径（Open-Shortest-Path-First）" class="headerlink" title="OSPF：开放最短路径（Open Shortest Path First）"></a>OSPF：开放最短路径（Open Shortest Path First）</h3><h4 id="OSPF概述"><a href="#OSPF概述" class="headerlink" title="OSPF概述"></a>OSPF概述</h4><ul>
<li>对公众开放</li>
<li>使用<strong>LS算法</strong><ul>
<li>需要发送LS pkt</li>
<li>每个节点采用拓扑结构</li>
<li>路由采用 Dijkstra 算法</li>
</ul>
</li>
<li>OSPF通告每个邻居路由器携带一个条目</li>
<li>通告通过洪泛散布到整个AS<ul>
<li>OSPF消息直接分装在IP数据报上</li>
</ul>
</li>
</ul>
<h4 id="OSPF优点"><a href="#OSPF优点" class="headerlink" title="OSPF优点"></a>OSPF优点</h4><ul>
<li><strong>安全</strong>：所有OSPF消息都要认证，防止恶意侵入</li>
<li><strong>多条相同cost的路径</strong>：当到达某目的的多条路径具有相同的cost时，OSPF允许使用多条路径。即可以分流。</li>
<li><strong>每条链路，给不同的数据类型不同的cost度量</strong></li>
<li><strong>对单播和多播（MOSPF）路由的支持</strong>：对单播进行扩展，以便提供给多播使用</li>
<li><strong>在大域中用分层OSPF</strong></li>
</ul>
<h4 id="分层OSPF"><a href="#分层OSPF" class="headerlink" title="分层OSPF"></a>分层OSPF</h4><ul>
<li>两层结构：<strong>局部区域</strong>（local area）和 <strong>主干</strong>（backbone）<ul>
<li>LS通告只在区域内</li>
<li>每个节点知道该区域的拓扑结构，对于其他区域只知道到那个区域的方向（最短路径）</li>
</ul>
</li>
<li><strong>区域边界路由器</strong>（area border router）：负责为流向该区域以外的分组提供路由选择。汇拢该区域的节点距离信息，通告给其他的区域边界路由器</li>
<li><strong>主干路由器</strong>（backbone router）：在主干内运行OSPF路由</li>
<li><strong>网关路由器</strong>（boundary router）：与其他AS连接</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Hierarchical-OSPF.png" style="zoom: 30%;" /></p>
<h3 id="IGRP（Interior-Gateway-Routing-Protocol）"><a href="#IGRP（Interior-Gateway-Routing-Protocol）" class="headerlink" title="IGRP（Interior Gateway Routing Protocol）"></a>IGRP（Interior Gateway Routing Protocol）</h3><ul>
<li>最初是CISCO私有的，后来开放了，RIP的后继者</li>
<li>DV算法</li>
<li>cost：时延、带宽、可靠性、负荷等等</li>
<li>利用TCP来交换路由更新</li>
<li>利用<strong>扩散更新算法</strong>（Diffusing Update Algorithm,DUAL）来防止循环</li>
</ul>
<h3 id="BGP：边界网管协议（Border-Gateway-Protocol）"><a href="#BGP：边界网管协议（Border-Gateway-Protocol）" class="headerlink" title="BGP：边界网管协议（Border Gateway Protocol）"></a>BGP：边界网管协议（Border Gateway Protocol）</h3><h4 id="BGP概述"><a href="#BGP概述" class="headerlink" title="BGP概述"></a>BGP概述</h4><p>采用 <strong>Path Vector protocol</strong></p>
<ul>
<li>与<strong>DV协议</strong>相似</li>
<li><p>每个边界网关向邻居（对等方）广播到达目的地的整个路径（即 AS的序列）</p>
</li>
<li><p><strong>eBGP</strong>：外部BGP，跨越两个AS对话。从相邻的AS获取子网可达性信息。</p>
</li>
<li><strong>iBGP</strong>：内部BGP，同一个AS中的两台路由器之间的BGP对话。将可达性信息传播到所有内部AS路由器。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_eBGP-iBGP.png" style="zoom: 30%;" /></p>
<ul>
<li>BGP会话：两BGP路由器通过半永久的TCP连接来交换消息<ul>
<li>将路径通告到不同的目标网络前缀（BGP是“路径向量”协议）</li>
</ul>
</li>
<li>如果一个AS向另一个AS通告了某个路由器，则承诺了可以路由到该路由器</li>
</ul>
<h4 id="路径属性和BGP路由"><a href="#路径属性和BGP路由" class="headerlink" title="路径属性和BGP路由"></a>路径属性和BGP路由</h4><ul>
<li>通告前缀（advertised prefix）包括BGP属性<ul>
<li>prefix + attributes = “route”</li>
</ul>
</li>
<li>两个重要attributes<ul>
<li>AS-PATH：路径中的AS的列表</li>
<li>NEXT-HOP：以AS-PATH开头的路由器接口的IP地址</li>
</ul>
</li>
<li>基于policy的路由<ul>
<li>网关接收路由广告使用导入policy接受/拒绝路径（例如，从不通过AS Y路由）</li>
<li>AS policy还确定是否向其他相邻AS通告路径</li>
</ul>
</li>
</ul>
<h4 id="BGP消息"><a href="#BGP消息" class="headerlink" title="BGP消息"></a>BGP消息</h4><ul>
<li>使用TCP交换BGP消息</li>
<li>BGP消息：<ul>
<li>OPEN：打开TCP连接，认证sender</li>
<li>UPDATE：通告新路径（删除旧路径）</li>
<li>KEEP ALIVE：在没有UPDATE的情况下，保持连接活跃；ACK OPEN请求</li>
<li>NOTIFICATION：报告以前的msg中的错误；也用于关闭连接</li>
</ul>
</li>
</ul>
<h4 id="BGP路由选择"><a href="#BGP路由选择" class="headerlink" title="BGP路由选择"></a>BGP路由选择</h4><p>&emsp;&emsp;路由器可能知道到达同一个前缀的多条路由。BGP以下优先级选择路由：</p>
<ul>
<li>本地偏好值：由政策决定</li>
<li>最短 AS-PATH：通过的AS最少</li>
<li>最近 NEXT-HOP 路由器：最近的下一跳路由器</li>
<li>其他标准</li>
</ul>
<p>假设：网关X 将其路径发送到 网关W</p>
<ul>
<li>W 可以选择/不选 X所提供的路径<ul>
<li>根据cost，policy（eg.不通过竞争对手的AS进行路由），防止环路 的原因选择/不选</li>
</ul>
</li>
<li>如果W选择X通告的路径<script type="math/tex; mode=display">
Path(W,Z) = W,Path(X,Z)</script></li>
<li>X可以通过advertisement来控制传入流量：<ul>
<li>eg.不希望将流量路由到Z -&gt; 不通告任何路由到Z</li>
</ul>
</li>
</ul>
<h4 id="BGP路由策略"><a href="#BGP路由策略" class="headerlink" title="BGP路由策略"></a>BGP路由策略</h4><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_BGP-policy.png" style="zoom: 50%;" /></p>
<ul>
<li>A,B,C是ISP（网络服务提供商）</li>
<li>W,X,Y是客户</li>
<li><p>X是 Multihomed AS，连接了两个ISP，也可以称为 dual-homed，一般是大型公司。X可以不允许 B -&gt; X -&gt; C 这条路由，则X不通告B有路由到C</p>
</li>
<li><p>A 通告 B 路径 AW</p>
</li>
<li>B 通告 X 路径 BAW</li>
<li>是否 B 通告 C 路径 BAW ？<ul>
<li>不会，C不是B的客户，B希望强迫C走AW，B只想从客户发送/接收路由</li>
</ul>
</li>
</ul>
<h4 id="Inra-Inter-AS-的区别"><a href="#Inra-Inter-AS-的区别" class="headerlink" title="Inra-/Inter-AS 的区别"></a>Inra-/Inter-AS 的区别</h4><p><strong>规模</strong>：分层可以节省表格大小，减小更新的流量。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Intra-AS</th>
<th>Inter-AS</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Policy</strong></td>
<td>一个管理员，不需要policy决策</td>
<td>管理员想要控制路由，需要有policy</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>关注性能</td>
<td>比起性能更关注policy</td>
</tr>
</tbody>
</table>
</div>
<h2 id="IP：Internet-Protocol"><a href="#IP：Internet-Protocol" class="headerlink" title="IP：Internet Protocol"></a>IP：Internet Protocol</h2><h3 id="IPv4数据报结构"><a href="#IPv4数据报结构" class="headerlink" title="IPv4数据报结构"></a>IPv4数据报结构</h3><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_IP-datagram-format.png" style="zoom: 30%;" /></p>
<ul>
<li><strong>版本</strong>（Version, <strong>4bit</strong>）<br>对于IPv4，字段的值是4。</li>
<li><strong>首部长度</strong>（Header Length， IHL, <strong>4bit</strong>）<br>首部长度说明首部有多少32位字（4字节）。<strong>一般为5</strong>，相当于5*4=20字节。</li>
<li><strong>服务类别</strong>（Type Of Service，<strong>8bit</strong>）</li>
<li><strong>报文长度</strong>（Length, <strong>16bit</strong>）<br>IP首部+数据部分的总长度</li>
<li><strong>标识</strong>（Identification, <strong>16bit</strong>）<br>用于在IP层对数据报进行分片的时候，标识数据包。</li>
<li><strong>标志</strong> （Flags, <strong>3bit</strong>）<br>这个3位字段用于控制和识别分片，它们是：<ul>
<li>位0：保留，必须为0；</li>
<li>位1：禁止分片（Don’t Fragment，DF），当DF=0时才允许分片；</li>
<li>位2：更多分片（More Fragment，MF），MF=1代表后面还有分片，MF=0 代表已经是最后一个分片。<br>如果DF标志被设置为1，但路由要求必须分片报文，此报文会被丢弃。这个标志可被用于发往没有能力组装分片的主机。<br>当一个报文被分片，除了最后一片外的所有分片都设置MF为1。最后一个片段具有非零片段偏移字段，将其与未分片数据包区分开，未分片的偏移字段为0。</li>
</ul>
</li>
<li><strong>分片偏移</strong> （Fragment Offset, <strong>13bit</strong>）<br>这个13位字段指明了每个分片相对于原始报文开头的偏移量，以8字节作单位。</li>
<li><strong>存活时间</strong>（Time To Live，TTL, <strong>8bit</strong>）<br>本数据报的TTL.</li>
<li><strong>协议</strong> （Protocol, <strong>8bit</strong>）<br>1—-icmp, 2—-igmp, 6—-tcp, 17—-udp, 89—-ospf</li>
<li><strong>首部检验和</strong> （Header Checksum， <strong>16bit</strong>）<br>IP首部的校验和</li>
<li><strong>源IP地址</strong>（Source IP, <strong>32bit</strong>）</li>
<li><strong>目的IP地址</strong>（Destination IP, <strong>32bit</strong>）</li>
</ul>
<h3 id="IPv4数据报分片"><a href="#IPv4数据报分片" class="headerlink" title="IPv4数据报分片"></a>IPv4数据报分片</h3><ul>
<li>网络链路有MTU（最大传送单元）— 最大可传输的链路的帧<ul>
<li>不同的链路类型有不同的MTU</li>
</ul>
</li>
<li>如果IP数据报 &gt; MTU ，则分片，到目的地后再重组</li>
<li>IP头部字段用来标记</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_IP%20fragmentation-and-reassembly.png" style="zoom: 50%;" /></p>
<p><strong>IP数据报分片示例</strong></p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Fragmentation.png" style="zoom: 30%;" /></p>
<ul>
<li>本来要发送 4000 byte 的数据报（head部分 + data部分）</li>
<li>链路的 MTU = 1500 bytes</li>
<li><p>需要将数据分为3片来发送</p>
</li>
<li><p><code>length</code>：片长度，包括了 20 bytes IP首部部分，最大为MTU</p>
<ul>
<li>length为1500的数据报，实际包含 $1500-20=1480\ bytes$ 的data部分</li>
<li>最后一片的length为 $(4000-20) - 1480\times 2 + 20 = 1040$</li>
</ul>
</li>
<li><code>fragflag</code>：3 bits<ul>
<li>第二个bit为 DF（Don’t Flag）：为0则该数据报分片，为1则不分片</li>
<li>第三个bit为 MF：为0则后面没有片了，为1则后面还有片</li>
<li>前两片为 1（001），表示该IP数据报分片，且后面还有片</li>
<li>最后一片为 0（000），表示该IP数据报分片，后面没片（即最后一片）</li>
</ul>
</li>
<li><code>offset</code>：data部分偏移量，以 8 bytes 为单位，只计算data部分<ul>
<li>第一片的offset为 0</li>
<li>第二片的offset为 $1480\ bytes/8\ bytes = 185$</li>
</ul>
</li>
</ul>
<h3 id="IPv4编址"><a href="#IPv4编址" class="headerlink" title="IPv4编址"></a>IPv4编址</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><ul>
<li>IP地址：32位、主机和路由器接口的ID</li>
<li><strong>接口</strong>（interface）：主机/路由器 和 物理链接 之间的连接<ul>
<li>路由器一般有多个接口</li>
<li>主机一般有1到2个接口</li>
</ul>
</li>
<li>每个接口都有一个对应的IP地址</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_IP-and-subnets.png" style="zoom: 50%;" /></p>
<p><strong>接口连接方式</strong></p>
<ul>
<li>通过<strong>路由器</strong>连接</li>
<li>有线以太网通过<strong>以太网交换机</strong>连接</li>
<li>无线网络通过<strong>WiFi基站</strong>连接</li>
</ul>
<h4 id="子网（Subnet）"><a href="#子网（Subnet）" class="headerlink" title="子网（Subnet）"></a>子网（Subnet）</h4><p><strong>IP地址</strong></p>
<ul>
<li>网络部分 —— 高位</li>
<li>主机部分 —— 低位</li>
</ul>
<p><strong>子网</strong></p>
<ul>
<li>子网部分相同</li>
<li>可以不通过路由器到达彼此</li>
</ul>
<p>&emsp;&emsp;把路由器去掉，剩下的每个区域都是一个子网。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_subnets.png" style="zoom: 50%;" /></p>
<p>&emsp;&emsp;上图中有6个子网。</p>
<h4 id="分类编制（Classful-Addressing）"><a href="#分类编制（Classful-Addressing）" class="headerlink" title="分类编制（Classful Addressing）"></a>分类编制（Classful Addressing）</h4><ul>
<li>A类<ul>
<li>网络部分前1位 —— <code>0</code></li>
<li>网络部分 8 bits，主机部分 24 bits</li>
<li>IP地址范围：<code>1.0.0.0</code> ～ <code>127.255.255.255</code></li>
</ul>
</li>
<li>B类<ul>
<li>网络部分前2位 —— <code>10</code></li>
<li>网络部分 16 bits，主机部分 16 bits</li>
<li>IP地址范围：<code>128.0.0.0</code> ～ <code>191.255.255.255</code></li>
</ul>
</li>
<li>C类<ul>
<li>网络部分前3位 —— <code>110</code></li>
<li>网络部分 24 bits，主机部分 8 bits</li>
<li>IP地址范围：<code>192.0.0.0</code> ～ <code>223.255.255.255</code></li>
</ul>
</li>
<li>D类<ul>
<li>前4位 —— <code>1110</code></li>
<li>用于多播地址</li>
</ul>
</li>
<li>E类<ul>
<li>前4位 —— <code>1111</code></li>
<li>被留作将来使用</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Classful-Addressing.png" style="zoom: 30%;" /></p>
<h4 id="子网掩码（subnet-mask）"><a href="#子网掩码（subnet-mask）" class="headerlink" title="子网掩码（subnet mask）"></a>子网掩码（subnet mask）</h4><ul>
<li>IP地址采用点分十进制：例如 <code>192.32.216.9</code></li>
<li>分类编制导致了地址资源的浪费</li>
<li>子网和子网掩码：可以减小地址资源的浪费</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_subnetting.png" style="zoom: 30%;" /></p>
<p>&emsp;&emsp;<code>200.23.16.64/27</code>中的<code>27</code>为 <strong>网络部分+子网部分 的位数</strong></p>
<ul>
<li>子网掩码<ul>
<li>网络部分+子网部分 置1</li>
<li>主机部分 置0</li>
</ul>
</li>
<li>子网的网络ID<ul>
<li>网络部分+子网部分 不变</li>
<li>主机部分 置0</li>
</ul>
</li>
</ul>
<h4 id="CIDR：无类的域间路由（Classless-InterDomain-Routing）"><a href="#CIDR：无类的域间路由（Classless-InterDomain-Routing）" class="headerlink" title="CIDR：无类的域间路由（Classless InterDomain Routing）"></a>CIDR：无类的域间路由（Classless InterDomain Routing）</h4><ul>
<li>IP分为两个部分 —— 子网部分 + 主机部分</li>
<li>子网部分可以是任意长度</li>
<li>地址格式：<code>a.b.c.d / x</code>，其中x是子网部分位数</li>
<li>网络部分称为前缀（prefix）</li>
</ul>
<h4 id="如何获取IP地址"><a href="#如何获取IP地址" class="headerlink" title="如何获取IP地址"></a>如何获取IP地址</h4><h5 id="主机如何获取IP地址"><a href="#主机如何获取IP地址" class="headerlink" title="主机如何获取IP地址"></a>主机如何获取IP地址</h5><p>主机获取IP地址：</p>
<ul>
<li>硬编码：自己设置静态的IP设置</li>
<li><strong>DHCP</strong>：动态主机配置（Dynamic Host Configuration Protocol）<br>&emsp;&emsp;当主机连接网络时，允许主机从网络服务器动态获取IP地址。</li>
</ul>
<h6 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h6><ul>
<li>即插即用</li>
<li>可以更新IP</li>
<li>地址重用：主机的IP只有在上线时才固定，下线即释放</li>
<li>支持移动用户</li>
</ul>
<p>&emsp;&emsp;当一台主机加入网络时，从子网中的DHCP服务器获取IP地址。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_DHCP.png" style="zoom: 50%;" /></p>
<h5 id="网络如何获取IP地址"><a href="#网络如何获取IP地址" class="headerlink" title="网络如何获取IP地址"></a>网络如何获取IP地址</h5><p>&emsp;&emsp;从ISP处获取分配的IP地址。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Network-route.png" style="zoom: 30%;" /></p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Network-get-IP.png" style="zoom: 30%;" /></p>
<h5 id="ISP如何获取IP地址"><a href="#ISP如何获取IP地址" class="headerlink" title="ISP如何获取IP地址"></a>ISP如何获取IP地址</h5><p>&emsp;&emsp;ISP从ICANN组织获取IP地址</p>
<p>ICANN：Internet Corporation for Assigned Names and Numbers</p>
<ul>
<li>分配地址</li>
<li>管理DNS</li>
<li>分配域名、解决争议</li>
</ul>
<h4 id="NAT：网络地址转换（Network-Address-Translation）"><a href="#NAT：网络地址转换（Network-Address-Translation）" class="headerlink" title="NAT：网络地址转换（Network Address Translation）"></a>NAT：网络地址转换（Network Address Translation）</h4><ul>
<li>从这个本地网络出去的报文都有着：相同的源IP+不同的端口号</li>
<li>对于外界网络来说，这个本地网络都是一个IP<ul>
<li>本地网络有内部地址，改变该内部地址不需要通知外部网络</li>
<li>改变ISP不需要改变本地网络的内部地址</li>
<li>内部地址在外部不可见（保障安全性）</li>
</ul>
</li>
<li>实现方式<ul>
<li>发送出去的报文：（源IP(内部的IP)，端口号）—&gt; （NAT IP(NAT统一的IP)，新端口号）<ul>
<li>外部发来的报文的目的地址填写：（NAT IP(NAT统一的IP)，新端口号）</li>
</ul>
</li>
<li>NAT转换表：记住（源IP(内部的IP)，端口号）&lt;—&gt; （NAT IP(NAT统一的IP)，新端口号）的转换对</li>
<li>收到的报文：根据NAT转换表，（NAT IP(NAT统一的IP)，新端口号）—&gt; （源IP(内部的IP)，端口号）</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network-address-translation.png" style="zoom: 50%;" /></p>
<ul>
<li>外部不知道内部的情况，所以外部不能发起通信</li>
<li>预留给内部的IP地址：<ul>
<li><code>10.0.0.0</code>~<code>10.255.255.255</code>（A类）</li>
<li><code>176.16.0.0</code>~<code>172.31.255.255</code>（B类）</li>
<li><code>192.168.0.0</code>~<code>192.168.255.255</code>（C类）</li>
</ul>
</li>
<li>可以有16bit的主机地址位（<code>10.0.0.0</code>~<code>10.255.255.255</code>），一个NAT支持内部60000+的连接</li>
<li>NAT存在争议<ul>
<li>路由器本来是在第3层，但NAT修改了端口号，而端口号包含在TCP/UDP的段结构里，即改了第4层的内容</li>
<li>违反了端到端</li>
<li>所以用IPv6来解决地址短缺</li>
</ul>
</li>
</ul>
<h4 id="ICMP：因特网控制消息协议（Internet-Control-Message-Protocol）"><a href="#ICMP：因特网控制消息协议（Internet-Control-Message-Protocol）" class="headerlink" title="ICMP：因特网控制消息协议（Internet Control Message Protocol）"></a>ICMP：因特网控制消息协议（Internet Control Message Protocol）</h4><h5 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h5><ul>
<li>主机、路由器、网关来交流网络层信息<ul>
<li>报错：到达不了主机、网络、端口、协议等等</li>
<li>用于探测：echo request/reply（使用ping）</li>
</ul>
</li>
<li>IP的一部分，但体系结构在IP之上：ICMP消息搭载在IP数据报上</li>
<li><strong>ICMP消息</strong>：type，code，引发错误的IP数据报首部和前8个字节</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Type</th>
<th><strong>Code</strong></th>
<th>description</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>echo reply (ping)</td>
<td>echo响应 (被程序ping使用）</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>dest. network unreachable</td>
<td>目标网络不可达</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>dest host unreachable</td>
<td>目标主机不可达</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>dest protocol unreachable</td>
<td>目标协议不可达</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>dest port unreachable</td>
<td>目标端口不可达</td>
</tr>
<tr>
<td>3</td>
<td>6</td>
<td>dest network unknown</td>
<td>未知的目标网络</td>
</tr>
<tr>
<td>3</td>
<td>7</td>
<td>dest host unknown</td>
<td>未知的目标主机</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>source quench (congestion control - not used)</td>
<td>源端关闭（拥塞控制）</td>
</tr>
<tr>
<td>8</td>
<td>0</td>
<td>echo request (ping)</td>
<td>Echo请求</td>
</tr>
<tr>
<td>9</td>
<td>0</td>
<td>route advertisement</td>
<td>路由通告</td>
</tr>
<tr>
<td>10</td>
<td>0</td>
<td>router discovery</td>
<td>路由器的发现/选择/请求</td>
</tr>
<tr>
<td>11</td>
<td>0</td>
<td>TTL expired</td>
<td>TTL 超时</td>
</tr>
<tr>
<td>12</td>
<td>0</td>
<td>bad IP header</td>
<td>IP 报首部参数错误</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>ICMP是管控制的IP的“兄弟”</li>
<li>ICMP被IP使用，同时作为网络层协议使用IP</li>
<li>ping、traceroute、path MTU discovery 都使用到了ICMP<ul>
<li>ping：使用 ICMP Echo request/repley msgs</li>
<li>path MTU discovery<ul>
<li>发送一个大的IP数据报，该数据报的 don’t fragment 置 1（即不分片）</li>
<li>减小数据报大小，直至成功（成功标志：没有接收到返回的ICMP消息）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a>Traceroute</h5><p>&emsp;&emsp;Traceroute程序：跟踪从一台主机到其他主机之间的路由，用ICMP报文实现。</p>
<ul>
<li>源发送一系列 UDP报文段 到目的<ul>
<li>第一个数据报 TTL=1，第二个数据报 TTL=2，以此类推</li>
<li>使用不常见的端口号</li>
</ul>
</li>
<li>当第n个数据报到达第n台主机时<ul>
<li>这个第n个数据报TTL刚好过期</li>
<li>路由器丢弃该数据报</li>
<li>路由器发送一个ICMP告警报文（type 11，code 0）给源</li>
<li>该ICMP告警报文包括第n台路由器名字及其IP</li>
</ul>
</li>
<li>当该ICMP报文返回到源主机，源主机计算RTT（往返时延），得到第n台路由器名字及其IP</li>
<li>标准的Traceroute程序用相同的TTL发送3个一组的分组，输出对每个TTL提供3个结果</li>
<li>停止条件步骤<ul>
<li>UDP数据报到达目的主机</li>
<li>目的主机返回 ICMP端口不可到达报文（type 3，code 3）</li>
<li>源主机接收到该ICMP报文，则停止</li>
</ul>
</li>
</ul>
<p>在Mac上可在app“系统信息”中的<code>窗口</code>-&gt;<code>网络实用工具</code>中使用Ping、Traceroute等工具。</p>
<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><ul>
<li>动机<ul>
<li>初动机：解决32位IP地址空间分配完的问题</li>
<li>更快处理/转发的头部格式</li>
<li>头部支持QoS</li>
</ul>
</li>
<li>IPv6数据报格式<ul>
<li>固定长度的头部：40 byte （IPv4头部长度不固定）</li>
<li>不允许分片</li>
</ul>
</li>
</ul>
<h4 id="IPv6数据报结构"><a href="#IPv6数据报结构" class="headerlink" title="IPv6数据报结构"></a>IPv6数据报结构</h4><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_IPv6-datagram-format.png" style="zoom:50%;" /></p>
<ul>
<li><p><strong>版本</strong>（Version, <strong>4 bit</strong>）<br>对于IPv6，字段的值是6（0110）。</p>
</li>
<li><p><strong>流量类型</strong>（Traffic class，<strong>8 bit</strong>）</p>
<p>用来标识对应IPv6的通信流类别，类似于IPv4中的ToS。</p>
</li>
<li><p><strong>流标签</strong>（Flow label，<strong>20 bit</strong>）</p>
<p>用来标记报文的数据流类型，以便在网络层区分不同的报文。</p>
</li>
<li><p><strong>有效载荷长度</strong>（Payload length，<strong>16 bit</strong>）</p>
<p>给出了IPv6数据报中跟在定长的40 byte数据报头部后面的字节数量。</p>
</li>
<li><p><strong>下一个头部</strong>（Next Header，<strong>8 bit</strong>）</p>
<p>该字段标识数据报中的内容（数据字段）需要交付给哪个协议（如TCP或UDP）。无扩展的头部，Next Header指向TCP/UDP；有扩展的头部，Next Header指向的下一个头部比如路由选择。与IPv4头部 协议（Protocol）字段相同。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Next-Header.png" style="zoom: 25%;" /></p>
</li>
<li><p><strong>跳段数限制</strong>（Hop limit，<strong>8 bit</strong>）</p>
<p>生存时间，相当于IPv4中的TTL。转发数据报的每台路由器讲对该字段内容 -1，如果跳转限制计数到0时，则丢弃该数据报</p>
</li>
<li><p><strong>源IP地址</strong>（Source Address，<strong>128 bit</strong>）</p>
</li>
<li><p><strong>目的IP地址</strong>（Destination Address，<strong>128 bit</strong>）</p>
</li>
<li><p><strong>数据</strong>（Data）</p>
</li>
</ul>
<h4 id="IPv6相较于IPv4的部分改变"><a href="#IPv6相较于IPv4的部分改变" class="headerlink" title="IPv6相较于IPv4的部分改变"></a>IPv6相较于IPv4的部分改变</h4><ul>
<li><strong>去除Checksum</strong>：加快了转发速度</li>
<li><strong>Options</strong>：依旧允许可选项，但是不放在头部，而是放在 Next Header 指出的位置上</li>
<li><strong>ICMPv6</strong>：ICMP的IPv6版本<ul>
<li>增加新的 type：比如“Packet Too Big”</li>
<li>包含<strong>多播组管理</strong></li>
</ul>
</li>
</ul>
<h4 id="IPv6地址"><a href="#IPv6地址" class="headerlink" title="IPv6地址"></a>IPv6地址</h4><ul>
<li><p>三种类型：<strong>单播</strong>（unicast）、<strong>多播</strong>（multicast）、<strong>任意播</strong>（anycast）</p>
</li>
<li><p><strong>冒号划分的十六进制</strong>（128 bit）</p>
<p>eg.  <code>68E6:8C64:FFFF:FFFF:0:1180:960A:FFFF</code></p>
</li>
<li><p><strong>0的压缩</strong></p>
<p>用双冒号<code>::</code>表示一组0或多组连续的0，但只能出现一次。</p>
<ul>
<li><code>FF05:0:0:0:0:0:0:B3</code> = <code>FF05::B3</code></li>
<li><code>0:0:0:0:0:0:128.10.2.1</code> = <code>::128.10.2.1</code>（IPv4和IPv6兼容的IP）</li>
<li><code>12AB:0:0:CD30:0:0:0:0</code> = <code>12AB::CD30:0:0:0:0</code> = <code>12AB:0:0:CD30::</code>（如果出现两个多个0，随意压一个都行）</li>
</ul>
</li>
</ul>
<h4 id="单播（Unicast-address）"><a href="#单播（Unicast-address）" class="headerlink" title="单播（Unicast address）"></a>单播（Unicast address）</h4><p>单播的地址格式（一共 128 bit）：</p>
<ul>
<li><p><strong>全球路由前缀</strong>（Global routing prefix，<strong>48 bit</strong>）</p>
<p>前3位为<code>001</code>，分配给公司和组织。</p>
</li>
<li><p><strong>子网ID</strong>（Subnet ID，<strong>16 bit</strong>）</p>
<p>如果是小公司，只需要1个子网的话，全设为0</p>
</li>
<li><p><strong>接口ID</strong>（Interface ID，<strong>64 bit</strong>）</p>
<p>基于 EUI-64</p>
</li>
</ul>
<h3 id="IPv4到IPv6的迁移"><a href="#IPv4到IPv6的迁移" class="headerlink" title="IPv4到IPv6的迁移"></a>IPv4到IPv6的迁移</h3><ul>
<li>现在的网络既有IPv4，也有IPv6。世界上的所有网从IPv4到IPv6需要很长的转换时间。</li>
<li>两种IPv4到IPv6的迁移<ul>
<li><strong>双栈</strong>（Dual Stack）：一些路由器可以兼容IPv4和IPv6</li>
<li><strong>隧道</strong>（Tunneling）：当IPv6穿过IPv4的路由器上时，将IPv6作为载荷承载在IPv4上</li>
</ul>
</li>
</ul>
<h4 id="双栈（Dual-Stack）"><a href="#双栈（Dual-Stack）" class="headerlink" title="双栈（Dual Stack）"></a>双栈（Dual Stack）</h4><ul>
<li>早期的设计</li>
<li>一些路由器有双栈（IPv4 &amp; IPv6），可以翻译这两种格式</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Dual-Stack.png" style="zoom:33%;" /></p>
<h4 id="隧道（Tunneling）"><a href="#隧道（Tunneling）" class="headerlink" title="隧道（Tunneling）"></a>隧道（Tunneling）</h4><p>&emsp;&emsp;当IPv6穿过IPv4的路由器上时，将IPv6作为载荷承载在IPv4上。就是像一个连接两个IPv6路由器的IPv4隧道</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Tunneling.png" style="zoom:50%;" /></p>
<h1 id="链路层（Link-Layer）"><a href="#链路层（Link-Layer）" class="headerlink" title="链路层（Link Layer）"></a>链路层（Link Layer）</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><p>保证<strong>帧</strong>流的透明传输</p>
<p><strong>链路层服务：</strong></p>
<ul>
<li><p><strong>成帧</strong>（Framing）、<strong>接入链路</strong>（link access）</p>
<ul>
<li><p>将来自上级的数据报分装成帧，加上header、trailer</p>
</li>
<li><p>完成共享媒体的信道连接</p>
</li>
<li>物理地址，用来 indentify 源/目的，在帧头中</li>
</ul>
</li>
<li><p>可靠交付（Reliable delivery）</p>
<ul>
<li>可靠数据传输协议（rdt）</li>
<li>在可靠的传输情况下很少应用，一般应用在高错误概率的链路传输中</li>
</ul>
</li>
<li><p>流量控制（Flow Control）</p>
<ul>
<li>协调发送方和接收方</li>
</ul>
</li>
<li><p>差错检测（Error Detection）</p>
</li>
<li><p>差错纠正（Error Correction）</p>
</li>
</ul>
<h2 id="成帧（Framing）"><a href="#成帧（Framing）" class="headerlink" title="成帧（Framing）"></a>成帧（Framing）</h2><p>&emsp;&emsp;主要考虑帧的界定，即如何将前一帧和后一帧分开。</p>
<h3 id="字符计数法（Character-count-method）"><a href="#字符计数法（Character-count-method）" class="headerlink" title="字符计数法（Character count method）"></a>字符计数法（Character count method）</h3><p>&emsp;&emsp;在每帧的前面添加 Counting header（本帧长度） </p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Character-count-method.png" style="zoom:33%;" /></p>
<h3 id="基于字符的首尾界定法（First-and-tail-bound-method-based-on-character）"><a href="#基于字符的首尾界定法（First-and-tail-bound-method-based-on-character）" class="headerlink" title="基于字符的首尾界定法（First and tail bound method based on character）"></a>基于字符的首尾界定法（First and tail bound method based on character）</h3><p>&emsp;&emsp;设定两个ASCII——SOH、EOT，SOH为标注开始的字符，EOT为标注结尾的字符。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Framing-First-and-tail.png" style="zoom:33%;" /></p>
<p>&emsp;&emsp;如果中间的数据部分也有SOH或EOT，则加入转义字符 EOT 标识。类似于C语言中的<code>\</code>的作用。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_EOT.png" style="zoom:33%;" /></p>
<h3 id="基于bit的首尾界定法（First-and-tail-bound-method-based-on-bit）"><a href="#基于bit的首尾界定法（First-and-tail-bound-method-based-on-bit）" class="headerlink" title="基于bit的首尾界定法（First and tail bound method based on bit）"></a>基于bit的首尾界定法（First and tail bound method based on bit）</h3><p>&emsp;&emsp;与基于字符的首尾界定法的思路相似，但开始和结束的标志为<code>01111110</code></p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Framing-First-and-tail-bit.png" style="zoom:33%;" /></p>
<p>&emsp;&emsp;为防止中间的数据部分也有<code>01111110</code>导致提前结束</p>
<ul>
<li>发送方：每5个<code>1</code>后插入一个<code>0</code></li>
<li>接收方：每5个<code>1</code>后删除一个<code>0</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_insert0.png" style="zoom:33%;" /></p>
<h3 id="物理层违逆码法（Pysical-layer-coding-violation-method）"><a href="#物理层违逆码法（Pysical-layer-coding-violation-method）" class="headerlink" title="物理层违逆码法（Pysical layer coding violation method）"></a>物理层违逆码法（Pysical layer coding violation method）</h3><p>比如在曼切斯特编码中，如果</p>
<ul>
<li>高低表示<code>1</code></li>
<li>低高表示<code>0</code></li>
<li>那么 低低/高高 就可以用来表示开始和结束</li>
</ul>
<p>&emsp;&emsp;违逆码只能应用在物理层，因为违逆码无法储存。</p>
<h2 id="差错检测（Error-Detection）"><a href="#差错检测（Error-Detection）" class="headerlink" title="差错检测（Error Detection）"></a>差错检测（Error Detection）</h2><p>&emsp;&emsp;通过增加<strong>冗余位（EDC）</strong>来检测差错。</p>
<p>&emsp;&emsp;差错检测不是100%可靠的。</p>
<ul>
<li>可能会漏掉一些错误，但是概率很小</li>
<li><p>更大的EDC检错能力更强</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Error-detection.png" style="zoom:50%;" /></p>
</li>
</ul>
<h3 id="奇偶校验（Parity-Checking）"><a href="#奇偶校验（Parity-Checking）" class="headerlink" title="奇偶校验（Parity Checking）"></a>奇偶校验（Parity Checking）</h3><ul>
<li><p><strong>单个奇偶校验位</strong>（Single Bit Parity）</p>
<p>&emsp;&emsp;分为奇校验和偶校验，EDC长度为1 bit。</p>
<p>如发送一个长为$d$ bit 的信息时，加EDC一共$d+1$ bit。</p>
<ul>
<li>偶校验中，则EDC需使这$d+1$ bit 中有偶数个<code>1</code>（即如果发送的信息有偶数个<code>1</code>，则EDC为<code>0</code>；奇数个<code>1</code>，则EDC为<code>1</code>）</li>
<li>奇校验中，则EDC需使这$d+1$ bit 中有奇数个<code>1</code>（即如果发送的信息有偶数个<code>1</code>，则EDC为<code>1</code>；奇数个<code>1</code>，则EDC为<code>0</code>）</li>
</ul>
<p>&emsp;&emsp;下图采用偶校验，信息D中共有9个<code>1</code>，所以偶校验位为<code>1</code>。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_One-bit-even-parity.png" style="zoom:50%;" /></p>
<p>&emsp;&emsp;奇偶校验只能检测出奇数个错误的情况。但由于现在传输的准确率很高，就算出错，大概率也就出 1 bit 的错误，所以使用简单的奇偶校验也能检测出大部分错误。</p>
</li>
<li><p><strong>二维奇偶校验</strong>（two-dimensional parity）</p>
<p>&emsp;&emsp;将$D$中的$d$ bit 划分成$i$行、$j$列，计算每行和每列的奇偶校验值，产生$i+j+1$个奇偶比特，即ECD长度为$i+j+1$ bit。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Two-dimensional-even-parity.png" style="zoom:50%;" /></p>
<p>&emsp;&emsp;二维奇偶校验不仅可以检测错误，还可以利用奇偶校验差错的行和列的索引找出错误的比特位，进行纠错。</p>
</li>
</ul>
<h3 id="CRC校验（Cyclic-Redundancy-Check）"><a href="#CRC校验（Cyclic-Redundancy-Check）" class="headerlink" title="CRC校验（Cyclic Redundancy Check）"></a>CRC校验（Cyclic Redundancy Check）</h3><p>&emsp;&emsp;CRC（Cyclic Redundancy Check），循环冗余检测。</p>
<p>思路：发送信息$D$，设置一个生成多项式，利用冗余位$R$，将$D+R$凑成生成多项式的整数倍，在接收方如果无法整除，则出差错。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_CRC.png" style="zoom:50%;" /></p>
<ul>
<li><p>生成多项式$G$和CRC比特位数</p>
<p>&emsp;&emsp;设置一个$r+1$ bit 的生成多项式，先将生成多项式$G(x)$化为二进制数$G$，最高位必须为$1$。</p>
<p>&emsp;&emsp;比如下面，三次项和常数项系数为$1$，则二进制数$G$的第四位和第一位为$1$</p>
<script type="math/tex; mode=display">
G(x)=x^3+1\ ,\quad G=1001</script><p>&emsp;&emsp;生成多项式$G$为$r+1$ bit，则CRC冗余位为$r$ bit。如此才能保证能把$D+R$凑成$G$的整数。</p>
</li>
<li><p>计算CRC冗余位$R$</p>
<p>&emsp;&emsp;增加$R$的目的是实现：</p>
<script type="math/tex; mode=display">
D\times 2^r \oplus R = nG</script><p>先将信息$D$乘以$2^r$，即左移$r$ bit，后面补<code>0</code>。再将移位后的$D\times 2^r$除$G$，但是中间步骤不用减，而用异或。比如</p>
<script type="math/tex; mode=display">
1001-1101=0100</script><p>&emsp;&emsp;信息$D$为<code>101110</code>，生成多项式$G(x)=x^3+1$。此时$r=3$，先在$D$后补$3$个<code>0</code>，得<code>101110000</code>，再除以$G=1001$</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_CRC-calculation.png" style="zoom:50%;" /></p>
<p>得到的余数<code>011</code>则为CRC冗余位$R$。</p>
<p>&emsp;&emsp;发送方发送信息$D$和冗余位$R$的拼接，即<code>101110011</code>。</p>
</li>
<li><p>接收方检错</p>
<p>&emsp;&emsp;接收方收到发送方发来的<code>101110011</code>后，将其除以生成多项式$G$ <code>1001</code>。如果整除则未检测到差错，否则检测到差错。</p>
</li>
</ul>
<h2 id="多路访问链路和协议（Multiple-Access-Links-and-Protocols）"><a href="#多路访问链路和协议（Multiple-Access-Links-and-Protocols）" class="headerlink" title="多路访问链路和协议（Multiple Access Links and Protocols）"></a>多路访问链路和协议（Multiple Access Links and Protocols）</h2><p>链路的两种类型：</p>
<ul>
<li><p>点对点链路（point-to-point link）</p>
<p>&emsp;&emsp;由链路一端的单个发送方和链路另一端的单个接收方组成。</p>
</li>
<li><p><strong>广播链路</strong>（broadcast link）</p>
<p>&emsp;&emsp;多个发送方和接收方，单一的、共享的信道。</p>
<p>&emsp;&emsp;<strong>多路访问协议</strong>（Multiple access protocol），规范结点在共享的广播信道上的传输行为。</p>
</li>
</ul>
<p>多路访问协议分类：</p>
<ul>
<li><strong>信道划分协议</strong>（channel partitioning protocol）<ul>
<li>静态</li>
<li>将信道平分给各节点</li>
<li>优点：公平、相互不干扰</li>
<li>缺点：闲置占有带宽</li>
</ul>
</li>
<li><strong>随机接入协议</strong>（random access protocol）<ul>
<li>动态</li>
<li>独占信道</li>
<li>允许冲突，并能从冲突中恢复</li>
</ul>
</li>
<li><strong>轮流协议</strong>（taking-turns protocol）<ul>
<li>上两种的结合</li>
<li>紧密协调共享访问以避免冲突</li>
</ul>
</li>
</ul>
<p>多路访问协议的目标：高效、公平、简单、分布式</p>
<h3 id="信道划分协议（Channel-Partitioning-protocols）"><a href="#信道划分协议（Channel-Partitioning-protocols）" class="headerlink" title="信道划分协议（Channel Partitioning protocols）"></a>信道划分协议（Channel Partitioning protocols）</h3><h4 id="时分多路复用（TDMA）"><a href="#时分多路复用（TDMA）" class="headerlink" title="时分多路复用（TDMA）"></a>时分多路复用（TDMA）</h4><p>&emsp;&emsp;TDM将时间划分为时间帧（frame），并进一步划分每个时间帧为$N$个时隙（slot），链路中的每条连接专用一个时隙。</p>
<p>&emsp;&emsp;详见 <a href="https://gy23333.github.io/2020/03/16/《计算机网络-自顶向下方法》笔记/#时分多路复用（TDM）">时分多路复用（TDM）</a>。</p>
<h4 id="频分多路复用（FDMA）"><a href="#频分多路复用（FDMA）" class="headerlink" title="频分多路复用（FDMA）"></a>频分多路复用（FDMA）</h4><p>&emsp;&emsp;链路中的每条连接专用一个频段。</p>
<p> &emsp;&emsp;详见 <a href="https://gy23333.github.io/2020/03/16/《计算机网络-自顶向下方法》笔记/#时分多路复用（TDM）">时分多路复用（FDM）</a> 。</p>
<h4 id="码分多址（CDMA）"><a href="#码分多址（CDMA）" class="headerlink" title="码分多址（CDMA）"></a>码分多址（CDMA）</h4><p> &emsp;&emsp;详见 <a href="[https://gy23333.github.io/2020/03/16/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0/#%E7%A0%81%E5%88%86%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%88Code-division-multiplexing%EF%BC%8CCDM%EF%BC%89](https://gy23333.github.io/2020/03/16/《计算机网络-自顶向下方法》笔记/#码分多路复用（Code-division-multiplexing，CDM）">码分多路复用（Code division multiplexing，CDM）</a>) 。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_CDMA.png" style="zoom:50%;" /></p>
<h3 id="随机接入协议（Random-Access-protocols）"><a href="#随机接入协议（Random-Access-protocols）" class="headerlink" title="随机接入协议（Random Access protocols）"></a>随机接入协议（Random Access protocols）</h3><ul>
<li>结点传输pkt时，占有信道全部带宽，结点间无优先级</li>
<li>存在多个传输结点 =&gt; 碰撞</li>
<li>随机接入协议明确了：<ul>
<li>如何检测碰撞</li>
<li>如何从碰撞中恢复</li>
</ul>
</li>
<li>常用的随机接入协议<ul>
<li>ALOHA</li>
<li>Slotted ALOHA</li>
<li>CSMA 和 CSMA/CD</li>
</ul>
</li>
</ul>
<h4 id="纯ALOHA（Pure-ALOHA）"><a href="#纯ALOHA（Pure-ALOHA）" class="headerlink" title="纯ALOHA（Pure ALOHA）"></a>纯ALOHA（Pure ALOHA）</h4><ul>
<li>非时隙、简单、完全分散</li>
<li>最早的ALOHA，目前已经不再使用</li>
<li>帧长一定 =&gt; 帧传输时间一定</li>
<li>当一帧首次到达（从网络层传下来），结点立即将该帧完整传输进广播信道</li>
<li>如果发送碰撞，则该结点<ul>
<li>有$p$的概率，将立即以重传该帧</li>
<li>有$1-p$的概率，等待一个帧传输时间，再以$p$的概率判断是否重传</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Pure-ALOHA.png" style="zoom:50%;" /></p>
<p>&emsp;&emsp;假设一帧在$t_0$处开始传输，则在$[t_0-1,t_0+1]$，其他结点如有传输，发生碰撞，则易损时间区长度为$2\tau$（$tau$为一帧的传输时间）。</p>
<p>&emsp;&emsp;一个结点发送成功，则需要本结点发送、其他结点在$[t_0-1,t_0]$和$[t_0,t_0+1]$不发送。一个给定结点成功传送的概率为</p>
<script type="math/tex; mode=display">
\begin{split} 
  P(success\ by\ given\ node)=&P(node\ transmits)\times\\
    & P(no\ other\ node\ transmits\ in\ [t_0-1,t_0])\times\\
    & P(no\ other\ node\ transmits\ in\ [t_0,t_0+1])\\
    =&p\times (1-p)^{N-1}\times (1-p)^{N-1}\\
    =&p\times (1-p)^{2(N-1)}
 \end{split}</script><p>则有$N$个结点，任意一个结点成功传送的概率为</p>
<script type="math/tex; mode=display">
S=Np(1-p)^{2(N-1)}</script><p>如此，求得纯ALOHA的最大效率为$1/(2e)\approx 0.18$（改变$p$，使$S$最大化）。</p>
<h4 id="时隙ALOHA（Slotted-ALOHA）"><a href="#时隙ALOHA（Slotted-ALOHA）" class="headerlink" title="时隙ALOHA（Slotted ALOHA）"></a>时隙ALOHA（Slotted ALOHA）</h4><ul>
<li>时间被划分成长度相等的时隙（slot）</li>
<li>结点只在时隙起点开始传输帧</li>
<li>如果碰撞，在下一时隙的开始以$p$的概率重传，直至成功。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Slotted-ALOHA.png" style="zoom:50%;" /></p>
<p>&emsp;&emsp;假设一帧在$t_0$处开始传输，则在本时隙中，其他结点如有传输，发生碰撞，则易损时间区长度为$\tau$（$\tau$为一帧的传输时间）。</p>
<p>&emsp;&emsp;一个给定结点成功传送的概率为</p>
<script type="math/tex; mode=display">
S=p(1-p)^{N-1}</script><p>&emsp;&emsp;如果有$N$个活跃结点，任意一个结点成功传送的概率为</p>
<script type="math/tex; mode=display">
S=Np(1-p)^{N-1}</script><p>如此，求得时隙ALOHA的最大效率为$1/e\approx 0.37$（改变$p$，使$S$最大化）。即在有大量结点有帧要传输时，最多$37%$的时隙做有用的工作，信道传输速率不是$R$ bps，而是$0.37R$ bps。</p>
<p>&emsp;&emsp;时隙ALOHA的最大效率是纯ALOHA的两倍。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_ALOHA-Compare.png" style="zoom: 33%;" /></p>
<h4 id="CSMA：载波侦听多路访问"><a href="#CSMA：载波侦听多路访问" class="headerlink" title="CSMA：载波侦听多路访问"></a>CSMA：载波侦听多路访问</h4><p>&emsp;&emsp;载波侦听多路访问（CSMA，Carrier Sense Multiple Access），一个结点在传输前先侦听信道。</p>
<ul>
<li><p>如果侦听到<strong>信道空闲</strong>，则传输帧</p>
</li>
<li><p>如果侦听到<strong>信道正忙</strong>，则推迟传输。再传输方式分为坚持型和非坚持型：</p>
<ul>
<li><strong>坚持型CSMA</strong>（Persisitent CSMA）：一直坚持监听，直到信道空闲时，立即以概率$p$重试（可能导致不稳定）。其中<strong>1-坚持型CSMA</strong>的$p=1$，即立即重试。</li>
<li><strong>非坚持型CSMA</strong>（Non-Persisitent CSMA）：不再监听，等待一个随机的时间之后再进行监听。</li>
</ul>
</li>
<li><p>CSMA依旧会发生<strong>碰撞</strong></p>
<p>&emsp;&emsp;只要共享信道，那么碰撞就是不可避免的，即使CSMA有侦听。</p>
<p>&emsp;&emsp;比如下图中，B结点在$t_0$时传输帧，但是帧的传输是需要一定时间的，这就导致在$t_1$时，D结点侦听判断信道空闲，传输帧。两信号发生碰撞。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_CSMA-Collision.png" style="zoom: 40%;" /></p>
<p>&emsp;&emsp;如此，整个帧传输时间被浪费了。可以看出，广播信道的端到端<strong>信道传播时延</strong>（distance and propagation delay）（信号从一个结点到另一个结点的传播时间）在决定性能上起关键作用。</p>
</li>
</ul>
<h4 id="CSMA-CD：具有碰撞检测的载波侦听多路访问"><a href="#CSMA-CD：具有碰撞检测的载波侦听多路访问" class="headerlink" title="CSMA/CD：具有碰撞检测的载波侦听多路访问"></a>CSMA/CD：具有碰撞检测的载波侦听多路访问</h4><ul>
<li>碰撞要在短时间内检测出来（最好在一个争用期内）</li>
<li>一旦检测到碰撞立即停止传输，以减少信道的浪费</li>
<li>采样坚持型或非坚持型重传</li>
<li>碰撞检测<ul>
<li>有线网络检测碰撞比较简单：如阈值法、过零法等等</li>
<li>无线网络检测碰撞比较困难</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;如下图，当B结点和D结点检测到碰撞时，立即停止继续发送。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_CSMA%3ACD.png" style="zoom: 40%;" /></p>
<p><strong>争用期</strong>：以太网的端到端往返时间$2\tau$</p>
<p>&emsp;&emsp;A结点给B结点发送帧流，最坏情况就是在即将发送到B结点时，发生碰撞，返回碰撞信息，最大用时即为$2\tau$。</p>
<p><strong>最短帧</strong>：最短帧长度为$2\tau R$（$R$为信道速率）</p>
<p>&emsp;&emsp;和上述同样的最坏情况中，从A结点发送帧，到碰撞信号返回到A结点花费$2\tau$的时间，在此期间A结点不能停止帧的发送，所以最短帧的长度为$2\tau R$。</p>
<p>&emsp;&emsp;如此可以最大利用网络效率，而且不会产生二义型。如果发送完了这个帧，没有发生碰撞，则发生成功。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_CSMA%3ACD1.png" style="zoom:50%;" /></p>
<p><strong>CSMA/CD 效率</strong></p>
<p>&emsp;&emsp;CSMA/CD 效率：当有大量的活跃结点，且每个结点有大量的帧要发送时，帧在信道中无碰撞地传输的那部分时间在长期运行时间中所占的份额。</p>
<script type="math/tex; mode=display">
efficiency = \frac 1{1+t_{prop}/t_{trans}}</script><p>其中，$t_{prop}$为两结点之间的最大传播时间；</p>
<p>&emsp;&emsp;&emsp;$t_{trans}$为传输一个最大长度的帧的时间。</p>
<p>效率趋近1，则需</p>
<ul>
<li>$t_{prop}$ -&gt; 0</li>
<li>或，$t_{trans}$ -&gt; $\infty$</li>
</ul>
<p>&emsp;&emsp;CSMA/CD 比 ALOHA 简单、便宜、分布式。</p>
<h3 id="轮流协议（Taking-Turns-protocol）"><a href="#轮流协议（Taking-Turns-protocol）" class="headerlink" title="轮流协议（Taking-Turns protocol）"></a>轮流协议（Taking-Turns protocol）</h3><h4 id="轮询协议（Polling-protocol）"><a href="#轮询协议（Polling-protocol）" class="headerlink" title="轮询协议（Polling protocol）"></a>轮询协议（Polling protocol）</h4><ul>
<li><p>有一个主结点</p>
</li>
<li><p>主结点以循环的方式轮询每个结点</p>
</li>
<li><p>主结点先向一个结点发送报文，告诉能够传输的帧的最多的数量，这个结点传输完帧后，主机点再发给下一个结点报文，循环轮询。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Polling-protocol.png" style="zoom:30%;" /></p>
</li>
<li><p>缺点：</p>
<ul>
<li>主结点需先给结点发送报文，增加开销</li>
<li>轮询时延，不及时</li>
<li>如果主结点出故障，则整个网络无法工作</li>
</ul>
</li>
</ul>
<h4 id="令牌传递协议（Token-Passing-protocol）"><a href="#令牌传递协议（Token-Passing-protocol）" class="headerlink" title="令牌传递协议（Token-Passing protocol）"></a>令牌传递协议（Token-Passing protocol）</h4><ul>
<li><p><strong>令牌</strong>（token）在结点之间以某种固定次序进行交换</p>
</li>
<li><p>结点只有在拿到令牌时，才能发送帧</p>
</li>
<li><p>受控的，不会发生碰撞</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Token-Passing-protocol.png" style="zoom:30%;" /></p>
</li>
<li><p>缺点：</p>
<ul>
<li>令牌开销</li>
<li>时延</li>
<li>令牌环会故障</li>
</ul>
</li>
</ul>
<h2 id="局域网技术"><a href="#局域网技术" class="headerlink" title="局域网技术"></a>局域网技术</h2><h3 id="局域网模型"><a href="#局域网模型" class="headerlink" title="局域网模型"></a>局域网模型</h3><p>&emsp;&emsp;局域网模型中，<strong>数据链路层</strong>分为LLC子层和MAC子层。</p>
<ul>
<li><strong>逻辑链路控制层</strong>（Logical Link Control，<strong>LLC</strong>）：为上层（网络层）提供连接环境</li>
<li><strong>媒体接入层</strong>（Media Access Control，<strong>MAC</strong>）：为下层（物理层）提供媒体接入</li>
</ul>
<h3 id="局域网地址和ARP"><a href="#局域网地址和ARP" class="headerlink" title="局域网地址和ARP"></a>局域网地址和ARP</h3><h4 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h4><ul>
<li><p>可以叫<strong>MAC 地址</strong>、<strong>LAN地址</strong>、<strong>物理地址</strong></p>
</li>
<li><p>用于从一个接口到另一个物理连接的接口（同一网络）获取数据报</p>
</li>
<li><p>MAC地址长度：$48$ bit / $6$ byte</p>
</li>
<li><p>与硬件有关，一个网卡（适配器）对应一个MAC地址</p>
</li>
<li><p>例如：<code>1A-2F-BB-76-09-AD</code></p>
</li>
<li><p>与局域网相连的每个接口都有唯一的MAC地址</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_MAC-address.png" style="zoom:50%;" /></p>
</li>
<li><p>MAC地址由IEEE分配</p>
</li>
<li><p>IEEE给公司固定MAC地址的前$24$ bit，后$24$ bit由公司保证每个适配器MAC地址的唯一性</p>
</li>
<li><p>IP地址和MAC地址的关系：IP地址就像是一个邮件地址，解决在哪上网的问题；MAC地址像身份证，解决谁在上网的问题</p>
<ul>
<li>IP地址<strong>层次结构</strong>，主机移动，主机的IP地址也改变</li>
<li>MAC地址<strong>扁平寻址结构</strong>，不会因为位置改变MAC地址</li>
</ul>
</li>
</ul>
<h4 id="ARP：地址解析协议"><a href="#ARP：地址解析协议" class="headerlink" title="ARP：地址解析协议"></a>ARP：地址解析协议</h4><p>&emsp;&emsp;ARP（Address Resolution Protocol），地址解析协议</p>
<ul>
<li><p>局域网中的每个IP结点（主机、路由器）都有ARP表</p>
</li>
<li><p><strong>ARP表</strong>：局域网结点的IP地址和MAC地址的对应关系</p>
<ul>
<li>每行的结构：<code>&lt;IP address; MAC address; TTL&gt;</code></li>
<li><code>TTL</code>：存活时间，过TTL的时间要丢弃这一行数据</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_APR.png" style="zoom:50%;" /></p>
</li>
</ul>
<h5 id="同一子网内的地址解析"><a href="#同一子网内的地址解析" class="headerlink" title="同一子网内的地址解析"></a>同一子网内的地址解析</h5><p>&emsp;&emsp;A想要发送数据报给B，但是B的MAC地址没有记录在A的ARP表中。</p>
<ul>
<li>A发送一个<strong>广播帧</strong>——查询ARP分组，包含B的IP地址<ul>
<li>目的MAC地址：<code>FF-FF-FF-FF-FF-FF</code></li>
<li>所有结点都会收到该ARP查询分组</li>
</ul>
</li>
<li>B接收到ARP分组，给A回复B的MAC地址<ul>
<li>给A的MAC地址<strong>单播</strong>帧——响应APR分组</li>
</ul>
</li>
<li>A在ARP表中缓存IP到MAC地址对，直至超时TTL</li>
</ul>
<p>&emsp;&emsp;ARP即插即用：ARP表自动建立，不需要系统管理员来配置</p>
<h5 id="不同子网的地址解析"><a href="#不同子网的地址解析" class="headerlink" title="不同子网的地址解析"></a>不同子网的地址解析</h5><p>&emsp;&emsp;不同子网的A和B通过路由器R发送数据报，A只知道B的IP地址，不知道B的MAC地址</p>
<ul>
<li>A创建IP报文（IP地址在整个传输过程中不改变）<ul>
<li>源IP地址：A的IP</li>
<li>目的IP地址：B的IP</li>
</ul>
</li>
<li>A创建数据帧，在IP报文的基础上，加上MAC地址<ul>
<li>源MAC地址：A的MAC</li>
<li>目的MAC地址：路由器R左端的MAC（路由器R左端与A在一个子网中）</li>
</ul>
</li>
<li>帧从A传到路由器R</li>
<li>路由器R接收帧，并从路由器R的数据链路层传到网络层，从数据帧拆成IP数据报</li>
<li>路由器R在IP报文的基础上，加上新的MAC地址段，传到数据链路层<ul>
<li>源MAC地址：路由器R右端的MAC（路由器R右端与B在一个子网中）</li>
<li>目的MAC地址：B的MAC</li>
</ul>
</li>
<li>帧从路由器R传到B，B接收到数据</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_ARP.gif" alt=""></p>
<h3 id="以太网（Enternet）"><a href="#以太网（Enternet）" class="headerlink" title="以太网（Enternet）"></a>以太网（Enternet）</h3><h4 id="以太网物理拓扑"><a href="#以太网物理拓扑" class="headerlink" title="以太网物理拓扑"></a>以太网物理拓扑</h4><ul>
<li><p><strong>总线型</strong></p>
<p>&emsp;&emsp;早期流行，所有的结点共用一条总线。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Ethernet-Bus.png" style="zoom:35%;" /></p>
</li>
<li><p><strong>星型</strong></p>
<p>&emsp;&emsp;以太网现在使用的拓扑结构，中间是交换机，所有结点和交换机的连接是唯一的，不会发生冲突。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Ethernet-Star.png" style="zoom:27%;" /></p>
</li>
</ul>
<h4 id="以太网帧结构"><a href="#以太网帧结构" class="headerlink" title="以太网帧结构"></a>以太网帧结构</h4><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Ethernet-Frame-Structure.png" style="zoom:50%;" /></p>
<ul>
<li><p><strong>前导码</strong>（Preamble，<strong>7 byte</strong>）</p>
<p>7 bytes 的方波<code>10101010</code>，用于“唤醒”接收适配器，并将它们的时钟与发送方的时钟同步。</p>
</li>
<li><p><strong>帧开始符</strong>（Start of Frame Delimiter(SFD)，<strong>1 byte</strong>）</p>
<p><code>10101011</code>，用来警告接收适配器，要开始了。</p>
</li>
<li><p><strong>目的MAC地址</strong>（Destination address，<strong>6 byte</strong>）</p>
<p>目的适配器的MAC地址。</p>
</li>
<li><p><strong>源MAC地址</strong>（Source address，<strong>6 byte</strong>）</p>
<p>源适配器的MAC地址。</p>
</li>
<li><p><strong>类型</strong>（Type，<strong>2 byte</strong>）</p>
<p>上层的协议。比如，IP协议对应<code>0X0800</code>。</p>
</li>
<li><p><strong>数据</strong>（Data，<strong>46~1500 byte</strong>）</p>
<p>IP数据报。</p>
<ul>
<li><p>最小长度——46 byte</p>
<p>由$2\tau R$决定。IEEE 802.3中，$2\tau$为$51.2\mu s$，$R=10Mbps$，由此得到最小帧长度$64\ bytes$。再减去$18\ bytes$的其他部分，得到最小数据的长度$46\ bytes$。</p>
<p>详见<a href="https://gy23333.github.io/2020/03/16/《计算机网络-自顶向下方法》笔记/#CSMA-CD：具有碰撞检测的载波侦听多路访问">CSMA-C中的最短帧</a>。</p>
<p>小于最小长度得补充到46 byte。</p>
</li>
<li><p>最大长度——1500 byte</p>
<p>超过最大长度得分片。</p>
</li>
</ul>
</li>
<li><p><strong>帧校验序列</strong>（FCS，<strong>4 byte</strong>）</p>
<p>错误检测机制，比如CRC。</p>
</li>
</ul>
<h4 id="以太网技术"><a href="#以太网技术" class="headerlink" title="以太网技术"></a>以太网技术</h4><ul>
<li><strong>无连接</strong>：不需要握手</li>
<li><strong>不可靠</strong>：不需要发送ack或nack</li>
<li>以太网MAC协议：<strong>非时隙、1-坚持、二进制指数退避的CSMA/CD</strong></li>
</ul>
<h5 id="二进制指数退避CSMA-CD算法"><a href="#二进制指数退避CSMA-CD算法" class="headerlink" title="二进制指数退避CSMA/CD算法"></a>二进制指数退避CSMA/CD算法</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">A: <span class="comment">//A事件</span></span><br><span class="line">sense channel, <span class="keyword">if</span> idle <span class="comment">//如果侦听信道空闲</span></span><br><span class="line">then &#123;</span><br><span class="line">  transmit <span class="keyword">and</span> monitor the channel; <span class="comment">//传输并监听信道（监听是否有其他站点在传输）</span></span><br><span class="line">  <span class="keyword">if</span> detect another transmission <span class="comment">//如果监听到其他站点在传输</span></span><br><span class="line">    then &#123;</span><br><span class="line">      <span class="built_in">abort</span> <span class="keyword">and</span> send jam signal; <span class="comment">//停止并发送jam信号（将冲突信号发送给其他站点）</span></span><br><span class="line">      update <span class="meta"># collisions; <span class="comment">//更新冲突次数（冲突次数+1）</span></span></span><br><span class="line">      <span class="built_in">delay</span> as required by exponential backoff algorithm; <span class="comment">//调用二进制指数退避算法来延时</span></span><br><span class="line">      <span class="keyword">goto</span> A <span class="comment">//重新执行A事件</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;done with the frame; <span class="built_in">set</span> collisions to zero&#125; <span class="comment">//如果在传输的过程中没监听到其他站点在传输，则完成帧的传输，并将冲突次数清零</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;wait until ongoing transmission is over <span class="keyword">and</span> <span class="keyword">goto</span> A&#125; <span class="comment">//如果侦听信道在忙，则继续侦听，直至信道空闲，再发送（1-坚持）；如果是非坚持，则等待一个随机的时间之后再进行监听</span></span><br></pre></td></tr></table></figure>
<p><strong>Jam Signal</strong>：长$48\ bits$，保证每个其他的发送方意识到冲突</p>
<h5 id="二进制指数退避算法（Binary-Exponential-Backoff-Algorithm）"><a href="#二进制指数退避算法（Binary-Exponential-Backoff-Algorithm）" class="headerlink" title="二进制指数退避算法（Binary Exponential Backoff Algorithm）"></a>二进制指数退避算法（Binary Exponential Backoff Algorithm）</h5><p>&emsp;&emsp;一旦检测到冲突，为降低再冲突的概率，需要等待一个随机时间，二进制指数退避算法即解决时延时间的问题。</p>
<p>&emsp;&emsp;时延的时间为端到端的往返时间$2\tau$的整数倍，即$2\tau \times n$（$n$为整数）。$k$为冲突次数collisions。</p>
<ol>
<li>初始的冲突次数$k=0$；</li>
<li>每冲突一次，则$k=k+1$；</li>
<li>如果$k&lt;10$，$n$从$[0, 2^k)$中随机选择一个整数（注意⚠️：右边为开区间），则延时$2\tau \times n$的时间；</li>
<li>如果$k\geq 10$，则$n$从${0,1,2,3,…,1023}$中随机选择一个，延时$2\tau \times n$的时间。（$k$在$10$之后就不再增加时延的选择范围，防止延时过长）</li>
</ol>
<h5 id="802-3以太网标准"><a href="#802-3以太网标准" class="headerlink" title="802.3以太网标准"></a>802.3以太网标准</h5><p>不同的以太网标准有：</p>
<ul>
<li>相同的MAC协议和帧格式</li>
<li>不同的速度：$2/ Mbps$、$10\ Mbps$、$100\ Mbps$等等</li>
<li>不同的物理层媒体：光纤、铜线</li>
</ul>
<p>&emsp;&emsp;下图为$100\ Mbps$以太网标准，其中100代表$100\ Mbps，TX、T2、T4代表媒体为不同的铜线，FX、SX、BX代表媒体为不同的光纤。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Ethernet-standards.png" style="zoom:50%;" /></p>
<h3 id="交换机（Switch）"><a href="#交换机（Switch）" class="headerlink" title="交换机（Switch）"></a>交换机（Switch）</h3><h4 id="集线器（Hub）"><a href="#集线器（Hub）" class="headerlink" title="集线器（Hub）"></a>集线器（Hub）</h4><ul>
<li>物理层设备：相当于工作在bit 层的传话筒，将接收到的bit从一个接口传到其他的所有接口</li>
<li>层级结构</li>
<li>每个连接的LAN称为LAN网段</li>
<li>集线器不会隔离冲突域</li>
<li>集线器的优点<ul>
<li>简单便宜</li>
<li>如果一个集线器发生故障，则局域网的其他部分将继续运行</li>
<li>扩展节点对之间的最大距离（每个集线器100m）</li>
</ul>
</li>
<li>集线器的缺点<ul>
<li>未隔离冲突域，导致最大吞吐量没有增加（多层吞吐量与单段吞吐量相同）</li>
<li>单独的LAN限制对相同冲突域中的结点数以及允许的总地理覆盖范围进行了限制</li>
<li>无法连接不同的以太网类型（例如10BaseT和100baseT）</li>
</ul>
</li>
<li>由于上述缺陷，如今大部分集线器已被交换机取代</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_hub.png" style="zoom: 33%;" /></p>
<h4 id="以太网交换机概述"><a href="#以太网交换机概述" class="headerlink" title="以太网交换机概述"></a>以太网交换机概述</h4><ul>
<li>交换机，也可以叫网桥</li>
<li>链路层设备<ul>
<li>存储、转发以太网帧</li>
<li>检查传入的帧的MAC地址，有选择地将帧转发到一个或多个传出链路，使用CSMA / CD访问段<ul>
<li>收到的帧与发送的结点在同一网段，则丢弃该帧</li>
<li>收到的帧的目的MAC地址在转发表里，且与发送的结点不在同一网段，则向目的地址所对应端口转发该帧</li>
<li>收到的帧的目的MAC地址不在转发表里，则泛洪</li>
</ul>
</li>
</ul>
</li>
<li>透明：主机不知道交换机的存在</li>
<li>即插即用，自学习（不需要配置交换机）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_switch1.png" style="zoom: 33%;" /></p>
<ul>
<li>主机有专用的、直接的到交换机的连接</li>
<li>交换机缓存pkt</li>
<li>每个输入链路都使用以太网协议，但是没有冲突</li>
<li>全双工</li>
<li>每个链路都是自己的冲突域</li>
<li>A至A’和B至B’可以同时传输而不会发生冲突</li>
</ul>
<h4 id="交换机自学习"><a href="#交换机自学习" class="headerlink" title="交换机自学习"></a>交换机自学习</h4><ul>
<li>每个交换机都有一张<strong>交换表</strong>作为转发表，交换表的每行数据为<code>&lt;MAC address, interface, TTL&gt;</code>，即MAC地址、通向该MAC地址的接口、存活时间。</li>
<li>交换机表初始为空</li>
<li>交换机每接收到一个帧，就记录一条数据（发送结点的数据）</li>
<li>过了TTL，则删掉该条数据</li>
</ul>
<h4 id="交换机转发与过滤"><a href="#交换机转发与过滤" class="headerlink" title="交换机转发与过滤"></a>交换机转发与过滤</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">when frame received at <span class="keyword">switch</span>: <span class="comment">//交换机接收到帧</span></span><br><span class="line">  <span class="number">1.</span> record incoming link, MAC address of sending host <span class="comment">//在交换表中记录发送方的传入接口、MAC地址</span></span><br><span class="line">  <span class="number">2.</span> index <span class="keyword">switch</span> table <span class="keyword">using</span> MAC destination address <span class="comment">//在交换表中查找目的MAC地址</span></span><br><span class="line">  <span class="number">3.</span> <span class="keyword">if</span> entry found <span class="keyword">for</span> destination <span class="comment">//如果在交换表找到了该目的MAC地址</span></span><br><span class="line">     then &#123;</span><br><span class="line">        <span class="keyword">if</span> destination on segment from which frame arrived then drop frame <span class="comment">//如果目的与发送方在同一网段，则丢弃该帧</span></span><br><span class="line">        <span class="keyword">else</span> forward frame on interface indicated by entry  <span class="comment">//如果不在同一网段，则转发帧到相应接口</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> flood <span class="comment">//如果在交换表找到不到该目的MAC地址，则泛洪（转发到除发送方所在接口以外的所有接口）</span></span><br></pre></td></tr></table></figure>
<h4 id="交换机-vs-路由器"><a href="#交换机-vs-路由器" class="headerlink" title="交换机 vs 路由器"></a>交换机 vs 路由器</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>路由器</th>
<th>交换机</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储转发</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>所在层</td>
<td>网络层设备（检查网络层头部）</td>
<td>链路层设备（检查链路层头部）</td>
</tr>
<tr>
<td>转发表</td>
<td>使用路由算法，IP地址</td>
<td>使用泛洪，自学习，MAC地址</td>
</tr>
</tbody>
</table>
</div>
<h3 id="VLAN：虚拟局域网"><a href="#VLAN：虚拟局域网" class="headerlink" title="VLAN：虚拟局域网"></a>VLAN：虚拟局域网</h3><p>&emsp;&emsp;交换机以太网存在缺点：缺乏广播隔离，导致易产生广播风暴。</p>
<p>&emsp;&emsp;为解决上述问题，采用虚拟局域网VLAN。</p>
<p>&emsp;&emsp;VLAN：在单个LAN内，将支持VLAN功能的交换机配置为多个虚拟LAN。</p>
<h4 id="基于端口的VLAN"><a href="#基于端口的VLAN" class="headerlink" title="基于端口的VLAN"></a>基于端口的VLAN</h4><p>&emsp;&emsp;将单个LAN基于端口划分为多个VLAN。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_VLAN.png" style="zoom: 50%;" /></p>
<ul>
<li>流量隔离：帧只能在本VLAN内往返（VLAN相当于一个真实的局域网，将功能限制在链路层，只能传帧）</li>
<li>VLAN之间的转发：通过路由完成（就像使用单独的交换机一样）</li>
<li>动态成员资格：端口可以在VLAN之间动态分配</li>
</ul>
<h4 id="跨多个交换机的VLAN"><a href="#跨多个交换机的VLAN" class="headerlink" title="跨多个交换机的VLAN"></a>跨多个交换机的VLAN</h4><ul>
<li><p>最早采用实体线相连，后采用中继端口。</p>
</li>
<li><p><strong>中继端口</strong>（trunk port）：也可以叫共享端口，在多个物理交换机上定义的VLAN之间传送帧。</p>
<p>下图中，a为实体线相连，b为中继端口连。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Connecting-two-VLAN.png" style="zoom: 50%;" /></p>
</li>
<li><p>802.1q：原802.1帧未带有VLAN标识，所以802.1q协议为中继端口之间转发的帧添加/删除了其他报头字段</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_VLAN-frame.png" style="zoom: 50%;" /></p>
<ul>
<li>增加了$4\ byte$</li>
<li>前$2\ byte$为协议标识</li>
<li>后$2\ byte$中，前$12\ bit$为VLAN的ID，后$3\ bit$为优先级</li>
<li>由于位数改变，CRC需重算</li>
</ul>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"># 计算机网络</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/05/MATLAB%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/" rel="prev" title="MATLAB学习手册">
      <i class="fa fa-chevron-left"></i> MATLAB学习手册
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/31/Xcode%E8%B0%83%E7%94%A8Mac%E6%91%84%E5%83%8F%E5%A4%B4/" rel="next" title="Xcode调用Mac摄像头">
      Xcode调用Mac摄像头 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#计算机网络和因特网"><span class="nav-number">1.</span> <span class="nav-text">计算机网络和因特网</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#计算机网络"><span class="nav-number">1.1.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构成描述"><span class="nav-number">1.1.1.</span> <span class="nav-text">构成描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务描述"><span class="nav-number">1.1.2.</span> <span class="nav-text">服务描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络边缘（Network-Edge）"><span class="nav-number">1.2.</span> <span class="nav-text">网络边缘（Network Edge）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#接入网（Access-Networks）"><span class="nav-number">1.2.1.</span> <span class="nav-text">接入网（Access Networks）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#家庭接入：DSL、电缆、FTTH、拨号和卫星"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">家庭接入：DSL、电缆、FTTH、拨号和卫星</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#企业（家庭）接入：以太网和WiFi"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">企业（家庭）接入：以太网和WiFi</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#广义无线接入：4G和5G"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">广义无线接入：4G和5G</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#物理媒体（Physical-Media）"><span class="nav-number">1.2.2.</span> <span class="nav-text">物理媒体（Physical Media）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络核心（Network-Core）"><span class="nav-number">1.3.</span> <span class="nav-text">网络核心（Network Core）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分组交换（Packet-Switching）"><span class="nav-number">1.3.1.</span> <span class="nav-text">分组交换（Packet Switching）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#电路交换（Circuit-Switching）"><span class="nav-number">1.3.2.</span> <span class="nav-text">电路交换（Circuit Switching）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#频分多路复用（FDM）"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">频分多路复用（FDM）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时分多路复用（TDM）"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">时分多路复用（TDM）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分组交换-amp-电路交换"><span class="nav-number">1.3.3.</span> <span class="nav-text">分组交换 &amp; 电路交换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络结构"><span class="nav-number">1.3.4.</span> <span class="nav-text">网络结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协议（Protocol）"><span class="nav-number">1.4.</span> <span class="nav-text">协议（Protocol）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协议层次（Protocol-Layer）及其服务模型"><span class="nav-number">1.5.</span> <span class="nav-text">协议层次（Protocol Layer）及其服务模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#五层因特网协议栈"><span class="nav-number">1.5.1.</span> <span class="nav-text">五层因特网协议栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OSI模型"><span class="nav-number">1.5.2.</span> <span class="nav-text">OSI模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#封装（Encapsulation）"><span class="nav-number">1.5.3.</span> <span class="nav-text">封装（Encapsulation）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#物理层概述"><span class="nav-number">1.6.</span> <span class="nav-text">物理层概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#物理层基本目标"><span class="nav-number">1.6.1.</span> <span class="nav-text">物理层基本目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#物理层的基本特性"><span class="nav-number">1.6.2.</span> <span class="nav-text">物理层的基本特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本通信原理"><span class="nav-number">1.7.</span> <span class="nav-text">基本通信原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本概念"><span class="nav-number">1.7.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信道特性"><span class="nav-number">1.7.2.</span> <span class="nav-text">信道特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模拟-数字信号传输"><span class="nav-number">1.7.3.</span> <span class="nav-text">模拟&#x2F;数字信号传输</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#调制解调器"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">调制解调器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编码解码器"><span class="nav-number">1.7.3.2.</span> <span class="nav-text">编码解码器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调制（Modulation）：数字信号到模拟信号"><span class="nav-number">1.7.3.3.</span> <span class="nav-text">调制（Modulation）：数字信号到模拟信号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#脉码调制（Pulse-Code-Modulation-PCM）"><span class="nav-number">1.7.3.4.</span> <span class="nav-text">脉码调制（Pulse Code Modulation, PCM）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数字信号编码（Digital-signal-coding）"><span class="nav-number">1.7.3.5.</span> <span class="nav-text">数字信号编码（Digital signal coding）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#不归零编码（Non-Return-To-Zero-NRZ）"><span class="nav-number">1.7.3.5.1.</span> <span class="nav-text">不归零编码（Non-Return-To-Zero, NRZ）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#曼切斯特编码（Manchester-encoding）"><span class="nav-number">1.7.3.5.2.</span> <span class="nav-text">曼切斯特编码（Manchester encoding）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#差分曼切斯特编码（Differential-Manchester-encoding）"><span class="nav-number">1.7.3.5.3.</span> <span class="nav-text">差分曼切斯特编码（Differential Manchester encoding）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#块编码（Block-encoding）"><span class="nav-number">1.7.3.5.4.</span> <span class="nav-text">块编码（Block encoding）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多路复用（Multiplexing）"><span class="nav-number">1.7.4.</span> <span class="nav-text">多路复用（Multiplexing）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#频分多路复用（Frequency-division-multiplexing，FDM）"><span class="nav-number">1.7.4.1.</span> <span class="nav-text">频分多路复用（Frequency division multiplexing，FDM）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时分多路复用（Time-division-multiplexing，TDM）"><span class="nav-number">1.7.4.2.</span> <span class="nav-text">时分多路复用（Time division multiplexing，TDM）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#波分多路复用（Wavelength-division-multiplexing，WDM）"><span class="nav-number">1.7.4.3.</span> <span class="nav-text">波分多路复用（Wavelength division multiplexing，WDM）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#码分多路复用（Code-division-multiplexing，CDM）"><span class="nav-number">1.7.4.4.</span> <span class="nav-text">码分多路复用（Code division multiplexing，CDM）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#延时、丢包、吞吐量"><span class="nav-number">1.8.</span> <span class="nav-text">延时、丢包、吞吐量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#延时（delay）"><span class="nav-number">1.8.1.</span> <span class="nav-text">延时（delay）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#丢包（Packet-Loss）"><span class="nav-number">1.8.2.</span> <span class="nav-text">丢包（Packet Loss）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#吞吐量（Throughput）"><span class="nav-number">1.8.3.</span> <span class="nav-text">吞吐量（Throughput）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#应用层（Application-Layer）"><span class="nav-number">2.</span> <span class="nav-text">应用层（Application Layer）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#网络应用原理"><span class="nav-number">2.1.</span> <span class="nav-text">网络应用原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#网络应用结构"><span class="nav-number">2.1.1.</span> <span class="nav-text">网络应用结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#客户机-服务器体系结构（Client-server-architecture）"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">客户机-服务器体系结构（Client-server architecture）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#点对点体系结构（Peer-peer-architecture）"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">点对点体系结构（Peer-peer architecture）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程通信（Processes-Communicating）"><span class="nav-number">2.1.2.</span> <span class="nav-text">进程通信（Processes Communicating）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#客户机和服务器进程"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">客户机和服务器进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#套接字（Sockets）"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">套接字（Sockets）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程寻址（Addressing-Processes）"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">进程寻址（Addressing Processes）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用层协议（Application-Layer-Protocols）"><span class="nav-number">2.1.3.</span> <span class="nav-text">应用层协议（Application-Layer Protocols）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#应用层协议的分类"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">应用层协议的分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用层协议内容"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">应用层协议内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#app对传输服务的需求"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">app对传输服务的需求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络传输协议服务"><span class="nav-number">2.1.4.</span> <span class="nav-text">网络传输协议服务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">TCP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP"><span class="nav-number">2.1.4.2.</span> <span class="nav-text">UDP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不同app选择的网络传输协议"><span class="nav-number">2.1.4.3.</span> <span class="nav-text">不同app选择的网络传输协议</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Web和HTTP"><span class="nav-number">2.2.</span> <span class="nav-text">Web和HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP概述"><span class="nav-number">2.2.1.</span> <span class="nav-text">HTTP概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP连接类型"><span class="nav-number">2.2.2.</span> <span class="nav-text">HTTP连接类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#非持久性连接（Non-persistent-HTTP）"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">非持久性连接（Non-persistent HTTP）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#非持久性HTTP步骤"><span class="nav-number">2.2.2.1.1.</span> <span class="nav-text">非持久性HTTP步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#非持久性HTTP响应时间"><span class="nav-number">2.2.2.1.2.</span> <span class="nav-text">非持久性HTTP响应时间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#非持久性HTTP的问题"><span class="nav-number">2.2.2.1.3.</span> <span class="nav-text">非持久性HTTP的问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#持久性连接（Persistent-HTTP）"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">持久性连接（Persistent HTTP）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#持久性HTTP步骤"><span class="nav-number">2.2.2.2.1.</span> <span class="nav-text">持久性HTTP步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#持久性HTTP特点（HTTP1-1）"><span class="nav-number">2.2.2.2.2.</span> <span class="nav-text">持久性HTTP特点（HTTP1.1）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DNS"><span class="nav-number">2.3.</span> <span class="nav-text">DNS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DNS服务"><span class="nav-number">2.3.1.</span> <span class="nav-text">DNS服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DNS：分布式、层级的数据库"><span class="nav-number">2.3.2.</span> <span class="nav-text">DNS：分布式、层级的数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#根域名服务器（Root-Name-Server）"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">根域名服务器（Root Name Server）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#顶层域名服务器（Top-Level-Domain-Server-TLD）"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">顶层域名服务器（Top-Level Domain Server, TLD）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#权威域名服务器（Authoritative-Domain-Server）"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">权威域名服务器（Authoritative Domain Server）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#本地域名服务器（Local-DNS-Name-Server）"><span class="nav-number">2.3.2.4.</span> <span class="nav-text">本地域名服务器（Local DNS Name Server）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DNS查询方法"><span class="nav-number">2.3.3.</span> <span class="nav-text">DNS查询方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代查询（iterated-query）"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">迭代查询（iterated query）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#递归查询（recursive-query）"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">递归查询（recursive query）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DNS缓存和更新"><span class="nav-number">2.3.4.</span> <span class="nav-text">DNS缓存和更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DNS记录和消息"><span class="nav-number">2.3.5.</span> <span class="nav-text">DNS记录和消息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DNS记录"><span class="nav-number">2.3.5.1.</span> <span class="nav-text">DNS记录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DNS消息"><span class="nav-number">2.3.5.2.</span> <span class="nav-text">DNS消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#向DNS数据库插入记录"><span class="nav-number">2.3.5.3.</span> <span class="nav-text">向DNS数据库插入记录</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DNS查询工具"><span class="nav-number">2.3.6.</span> <span class="nav-text">DNS查询工具</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#nslookup直接查询"><span class="nav-number">2.3.6.1.</span> <span class="nav-text">nslookup直接查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nslookup查询其他记录"><span class="nav-number">2.3.6.2.</span> <span class="nav-text">nslookup查询其他记录</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#P2P"><span class="nav-number">2.4.</span> <span class="nav-text">P2P</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#P2P概述"><span class="nav-number">2.4.1.</span> <span class="nav-text">P2P概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件分发：客户机-服务器结构-vs-P2P"><span class="nav-number">2.4.2.</span> <span class="nav-text">文件分发：客户机-服务器结构 vs P2P</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BitTorrent"><span class="nav-number">2.4.3.</span> <span class="nav-text">BitTorrent</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#请求文件块"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">请求文件块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#发送文件块"><span class="nav-number">2.4.3.2.</span> <span class="nav-text">发送文件块</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#socket编程"><span class="nav-number">2.5.</span> <span class="nav-text">socket编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP中的socket编程"><span class="nav-number">2.5.1.</span> <span class="nav-text">UDP中的socket编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP中的socket编程示例"><span class="nav-number">2.5.1.1.</span> <span class="nav-text">UDP中的socket编程示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP中的socket编程"><span class="nav-number">2.5.2.</span> <span class="nav-text">TCP中的socket编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP中的socket编程示例"><span class="nav-number">2.5.2.1.</span> <span class="nav-text">TCP中的socket编程示例</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#传输层（Transport-Layer）"><span class="nav-number">3.</span> <span class="nav-text">传输层（Transport Layer）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#传输层服务"><span class="nav-number">3.1.</span> <span class="nav-text">传输层服务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#传输层概述"><span class="nav-number">3.1.1.</span> <span class="nav-text">传输层概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传输层协议"><span class="nav-number">3.1.2.</span> <span class="nav-text">传输层协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多路复用（Multiplexing）与多路分用（Demultiplexing）"><span class="nav-number">3.2.</span> <span class="nav-text">多路复用（Multiplexing）与多路分用（Demultiplexing）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多路分用"><span class="nav-number">3.2.1.</span> <span class="nav-text">多路分用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多路分用工作流程"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">多路分用工作流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#无连接的多路分用（Connectionless-demultiplexing）"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">无连接的多路分用（Connectionless demultiplexing）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#面向连接的多路分用（Connection-oriented-demux）"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">面向连接的多路分用（Connection-oriented demux）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP-1"><span class="nav-number">3.3.</span> <span class="nav-text">UDP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP概述"><span class="nav-number">3.4.</span> <span class="nav-text">UDP概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP校验和（UDP-checksum）"><span class="nav-number">3.4.1.</span> <span class="nav-text">UDP校验和（UDP checksum）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可靠数据传输原理"><span class="nav-number">3.5.</span> <span class="nav-text">可靠数据传输原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#rdt1-0：经可靠信道的可靠数据传输"><span class="nav-number">3.5.1.</span> <span class="nav-text">rdt1.0：经可靠信道的可靠数据传输</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#rdt1-0概述"><span class="nav-number">3.5.1.1.</span> <span class="nav-text">rdt1.0概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rdt1-0有限状态机"><span class="nav-number">3.5.1.2.</span> <span class="nav-text">rdt1.0有限状态机</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#发送方"><span class="nav-number">3.5.1.2.1.</span> <span class="nav-text">发送方</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#接收方"><span class="nav-number">3.5.1.2.2.</span> <span class="nav-text">接收方</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rdt2-0：经具有比特差错信道的数据传输"><span class="nav-number">3.5.2.</span> <span class="nav-text">rdt2.0：经具有比特差错信道的数据传输</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#rdt2-0概述"><span class="nav-number">3.5.2.1.</span> <span class="nav-text">rdt2.0概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rdt2-0无限状态机"><span class="nav-number">3.5.2.2.</span> <span class="nav-text">rdt2.0无限状态机</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#发送方-1"><span class="nav-number">3.5.2.2.1.</span> <span class="nav-text">发送方</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#接收方-1"><span class="nav-number">3.5.2.2.2.</span> <span class="nav-text">接收方</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rdt2-1：接收方判断ACK-NAK信号出错"><span class="nav-number">3.5.3.</span> <span class="nav-text">rdt2.1：接收方判断ACK&#x2F;NAK信号出错</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#rdt2-1有限状态机"><span class="nav-number">3.5.3.1.</span> <span class="nav-text">rdt2.1有限状态机</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#发送方-2"><span class="nav-number">3.5.3.1.1.</span> <span class="nav-text">发送方</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#接收方-2"><span class="nav-number">3.5.3.1.2.</span> <span class="nav-text">接收方</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rdt2-2：不发送NAK的协议"><span class="nav-number">3.5.4.</span> <span class="nav-text">rdt2.2：不发送NAK的协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#rdt2-2概述"><span class="nav-number">3.5.4.1.</span> <span class="nav-text">rdt2.2概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rdt2-2有限状态机"><span class="nav-number">3.5.4.2.</span> <span class="nav-text">rdt2.2有限状态机</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#发送方-3"><span class="nav-number">3.5.4.2.1.</span> <span class="nav-text">发送方</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#接收方-3"><span class="nav-number">3.5.4.2.2.</span> <span class="nav-text">接收方</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rdt3-0：信道存在错误和丢包"><span class="nav-number">3.5.5.</span> <span class="nav-text">rdt3.0：信道存在错误和丢包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#rdt3-0概述"><span class="nav-number">3.5.5.1.</span> <span class="nav-text">rdt3.0概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rdt3-0有限状态机"><span class="nav-number">3.5.5.2.</span> <span class="nav-text">rdt3.0有限状态机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rdt3-0流程"><span class="nav-number">3.5.5.3.</span> <span class="nav-text">rdt3.0流程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#正常流程"><span class="nav-number">3.5.5.3.1.</span> <span class="nav-text">正常流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#丢packet"><span class="nav-number">3.5.5.3.2.</span> <span class="nav-text">丢packet</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#丢ACK"><span class="nav-number">3.5.5.3.3.</span> <span class="nav-text">丢ACK</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#超时"><span class="nav-number">3.5.5.3.4.</span> <span class="nav-text">超时</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rdt3-0性能"><span class="nav-number">3.5.5.4.</span> <span class="nav-text">rdt3.0性能</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流水线协议"><span class="nav-number">3.6.</span> <span class="nav-text">流水线协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#回退N步（Go-back-N，GBN）"><span class="nav-number">3.6.1.</span> <span class="nav-text">回退N步（Go-back-N，GBN）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GBN发送方"><span class="nav-number">3.6.1.1.</span> <span class="nav-text">GBN发送方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GBN接收方"><span class="nav-number">3.6.1.2.</span> <span class="nav-text">GBN接收方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GBN流程"><span class="nav-number">3.6.1.3.</span> <span class="nav-text">GBN流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择重传（Selective-Repeat，SR）"><span class="nav-number">3.6.2.</span> <span class="nav-text">选择重传（Selective Repeat，SR）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SR发送方"><span class="nav-number">3.6.2.1.</span> <span class="nav-text">SR发送方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SR接收方"><span class="nav-number">3.6.2.2.</span> <span class="nav-text">SR接收方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SR流程"><span class="nav-number">3.6.2.3.</span> <span class="nav-text">SR流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SR困境"><span class="nav-number">3.6.2.4.</span> <span class="nav-text">SR困境</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-1"><span class="nav-number">3.7.</span> <span class="nav-text">TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP概论"><span class="nav-number">3.7.1.</span> <span class="nav-text">TCP概论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP报文段结构"><span class="nav-number">3.7.2.</span> <span class="nav-text">TCP报文段结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP序号"><span class="nav-number">3.7.2.1.</span> <span class="nav-text">TCP序号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-ACK"><span class="nav-number">3.7.2.2.</span> <span class="nav-text">TCP ACK</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-序号和ACK传输"><span class="nav-number">3.7.2.3.</span> <span class="nav-text">TCP 序号和ACK传输</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP计时"><span class="nav-number">3.7.2.4.</span> <span class="nav-text">TCP计时</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP可靠数据传输"><span class="nav-number">3.7.3.</span> <span class="nav-text">TCP可靠数据传输</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP简化"><span class="nav-number">3.7.3.1.</span> <span class="nav-text">TCP简化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP-sender"><span class="nav-number">3.7.3.1.1.</span> <span class="nav-text">TCP sender</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP重传情况"><span class="nav-number">3.7.3.1.2.</span> <span class="nav-text">TCP重传情况</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP-receiver"><span class="nav-number">3.7.3.1.3.</span> <span class="nav-text">TCP receiver</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP快速重传"><span class="nav-number">3.7.3.2.</span> <span class="nav-text">TCP快速重传</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流量控制"><span class="nav-number">3.7.4.</span> <span class="nav-text">流量控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连接管理"><span class="nav-number">3.7.5.</span> <span class="nav-text">连接管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP建立连接：3次握手"><span class="nav-number">3.7.5.1.</span> <span class="nav-text">TCP建立连接：3次握手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP关闭连接：4次挥手"><span class="nav-number">3.7.5.2.</span> <span class="nav-text">TCP关闭连接：4次挥手</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拥塞控制原理"><span class="nav-number">3.8.</span> <span class="nav-text">拥塞控制原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#场景一：2个Sender-和1个无限buffer的Router"><span class="nav-number">3.8.1.</span> <span class="nav-text">场景一：2个Sender, 和1个无限buffer的Router</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#场景二：2个Sender-和1个有限buffer的Router"><span class="nav-number">3.8.2.</span> <span class="nav-text">场景二：2个Sender, 和1个有限buffer的Router</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拥塞代价"><span class="nav-number">3.8.3.</span> <span class="nav-text">拥塞代价</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP拥塞控制"><span class="nav-number">3.9.</span> <span class="nav-text">TCP拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-number">3.9.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP慢启动（TCP-slow-start）"><span class="nav-number">3.9.2.</span> <span class="nav-text">TCP慢启动（TCP slow start）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从-slow-start-到-CA-的转换"><span class="nav-number">3.9.3.</span> <span class="nav-text">从 slow start 到 CA 的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP拥塞控制FSM"><span class="nav-number">3.9.4.</span> <span class="nav-text">TCP拥塞控制FSM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP吞吐量"><span class="nav-number">3.9.5.</span> <span class="nav-text">TCP吞吐量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高速TCP"><span class="nav-number">3.9.6.</span> <span class="nav-text">高速TCP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP公平性"><span class="nav-number">3.9.7.</span> <span class="nav-text">TCP公平性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Explicit-Congestion-Notification（ECN）"><span class="nav-number">3.9.8.</span> <span class="nav-text">Explicit Congestion Notification（ECN）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网络层（Network-Layer）"><span class="nav-number">4.</span> <span class="nav-text">网络层（Network Layer）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-1"><span class="nav-number">4.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#网络层功能"><span class="nav-number">4.1.1.</span> <span class="nav-text">网络层功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络层服务"><span class="nav-number">4.1.2.</span> <span class="nav-text">网络层服务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚电路和数据报网络（Virtual-circuit-and-datagram-networks）"><span class="nav-number">4.2.</span> <span class="nav-text">虚电路和数据报网络（Virtual circuit and datagram networks）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#虚电路（Virtual-circuit，VC）"><span class="nav-number">4.2.1.</span> <span class="nav-text">虚电路（Virtual circuit，VC）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据报网络（Datagram-networks）"><span class="nav-number">4.2.2.</span> <span class="nav-text">数据报网络（Datagram networks）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚电路和数据报网络选择"><span class="nav-number">4.2.3.</span> <span class="nav-text">虚电路和数据报网络选择</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路由器工作原理"><span class="nav-number">4.3.</span> <span class="nav-text">路由器工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#路由器结构"><span class="nav-number">4.3.1.</span> <span class="nav-text">路由器结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输入端口（Input-port）"><span class="nav-number">4.3.1.1.</span> <span class="nav-text">输入端口（Input port）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#交换结构（Switch-fabric）"><span class="nav-number">4.3.1.2.</span> <span class="nav-text">交换结构（Switch fabric）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#共享内存（Switching-via-memory）"><span class="nav-number">4.3.1.2.1.</span> <span class="nav-text">共享内存（Switching via memory）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#共享总线（Switching-via-a-bus）"><span class="nav-number">4.3.1.2.2.</span> <span class="nav-text">共享总线（Switching via a bus）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#交叉开关矩阵（Switching-via-an-interconnection-network）"><span class="nav-number">4.3.1.2.3.</span> <span class="nav-text">交叉开关矩阵（Switching via an interconnection network）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#输出端口（Output-port）"><span class="nav-number">4.3.1.3.</span> <span class="nav-text">输出端口（Output port）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排队"><span class="nav-number">4.3.2.</span> <span class="nav-text">排队</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输入端口排队"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">输入端口排队</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#输出端口排队"><span class="nav-number">4.3.2.2.</span> <span class="nav-text">输出端口排队</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路由算法（Routing-algorithms）"><span class="nav-number">4.4.</span> <span class="nav-text">路由算法（Routing algorithms）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-2"><span class="nav-number">4.4.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LS算法：路由选择算法（Link-state-alorithm）"><span class="nav-number">4.4.2.</span> <span class="nav-text">LS算法：路由选择算法（Link state alorithm）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Dijkstra算法"><span class="nav-number">4.4.2.1.</span> <span class="nav-text">Dijkstra算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#广播路由（Broadcast-routing）"><span class="nav-number">4.4.2.2.</span> <span class="nav-text">广播路由（Broadcast routing）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LS算法"><span class="nav-number">4.4.2.3.</span> <span class="nav-text">LS算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DV算法：距离向量算法（Distance-vector-algorithm）"><span class="nav-number">4.4.3.</span> <span class="nav-text">DV算法：距离向量算法（Distance vector algorithm）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Bellman-Ford公式"><span class="nav-number">4.4.3.1.</span> <span class="nav-text">Bellman-Ford公式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DV算法"><span class="nav-number">4.4.3.2.</span> <span class="nav-text">DV算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#好事传得快，坏事传得慢"><span class="nav-number">4.4.3.3.</span> <span class="nav-text">好事传得快，坏事传得慢</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LS算法和DV算法对比"><span class="nav-number">4.4.4.</span> <span class="nav-text">LS算法和DV算法对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#层次路由（Hierarchical-Routing）"><span class="nav-number">4.4.5.</span> <span class="nav-text">层次路由（Hierarchical Routing）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#因特网中的路由选择"><span class="nav-number">4.5.</span> <span class="nav-text">因特网中的路由选择</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RIP：路由信息协议（Routing-Information-Protocol）"><span class="nav-number">4.5.1.</span> <span class="nav-text">RIP：路由信息协议（Routing Information Protocol）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OSPF：开放最短路径（Open-Shortest-Path-First）"><span class="nav-number">4.5.2.</span> <span class="nav-text">OSPF：开放最短路径（Open Shortest Path First）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OSPF概述"><span class="nav-number">4.5.2.1.</span> <span class="nav-text">OSPF概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OSPF优点"><span class="nav-number">4.5.2.2.</span> <span class="nav-text">OSPF优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分层OSPF"><span class="nav-number">4.5.2.3.</span> <span class="nav-text">分层OSPF</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IGRP（Interior-Gateway-Routing-Protocol）"><span class="nav-number">4.5.3.</span> <span class="nav-text">IGRP（Interior Gateway Routing Protocol）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BGP：边界网管协议（Border-Gateway-Protocol）"><span class="nav-number">4.5.4.</span> <span class="nav-text">BGP：边界网管协议（Border Gateway Protocol）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BGP概述"><span class="nav-number">4.5.4.1.</span> <span class="nav-text">BGP概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#路径属性和BGP路由"><span class="nav-number">4.5.4.2.</span> <span class="nav-text">路径属性和BGP路由</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BGP消息"><span class="nav-number">4.5.4.3.</span> <span class="nav-text">BGP消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BGP路由选择"><span class="nav-number">4.5.4.4.</span> <span class="nav-text">BGP路由选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BGP路由策略"><span class="nav-number">4.5.4.5.</span> <span class="nav-text">BGP路由策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Inra-Inter-AS-的区别"><span class="nav-number">4.5.4.6.</span> <span class="nav-text">Inra-&#x2F;Inter-AS 的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IP：Internet-Protocol"><span class="nav-number">4.6.</span> <span class="nav-text">IP：Internet Protocol</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IPv4数据报结构"><span class="nav-number">4.6.1.</span> <span class="nav-text">IPv4数据报结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IPv4数据报分片"><span class="nav-number">4.6.2.</span> <span class="nav-text">IPv4数据报分片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IPv4编址"><span class="nav-number">4.6.3.</span> <span class="nav-text">IPv4编址</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概述-3"><span class="nav-number">4.6.3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#子网（Subnet）"><span class="nav-number">4.6.3.2.</span> <span class="nav-text">子网（Subnet）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分类编制（Classful-Addressing）"><span class="nav-number">4.6.3.3.</span> <span class="nav-text">分类编制（Classful Addressing）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#子网掩码（subnet-mask）"><span class="nav-number">4.6.3.4.</span> <span class="nav-text">子网掩码（subnet mask）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CIDR：无类的域间路由（Classless-InterDomain-Routing）"><span class="nav-number">4.6.3.5.</span> <span class="nav-text">CIDR：无类的域间路由（Classless InterDomain Routing）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何获取IP地址"><span class="nav-number">4.6.3.6.</span> <span class="nav-text">如何获取IP地址</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#主机如何获取IP地址"><span class="nav-number">4.6.3.6.1.</span> <span class="nav-text">主机如何获取IP地址</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#DHCP"><span class="nav-number">4.6.3.6.1.1.</span> <span class="nav-text">DHCP</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#网络如何获取IP地址"><span class="nav-number">4.6.3.6.2.</span> <span class="nav-text">网络如何获取IP地址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ISP如何获取IP地址"><span class="nav-number">4.6.3.6.3.</span> <span class="nav-text">ISP如何获取IP地址</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NAT：网络地址转换（Network-Address-Translation）"><span class="nav-number">4.6.3.7.</span> <span class="nav-text">NAT：网络地址转换（Network Address Translation）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ICMP：因特网控制消息协议（Internet-Control-Message-Protocol）"><span class="nav-number">4.6.3.8.</span> <span class="nav-text">ICMP：因特网控制消息协议（Internet Control Message Protocol）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ICMP"><span class="nav-number">4.6.3.8.1.</span> <span class="nav-text">ICMP</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Traceroute"><span class="nav-number">4.6.3.8.2.</span> <span class="nav-text">Traceroute</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IPv6"><span class="nav-number">4.6.4.</span> <span class="nav-text">IPv6</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IPv6数据报结构"><span class="nav-number">4.6.4.1.</span> <span class="nav-text">IPv6数据报结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IPv6相较于IPv4的部分改变"><span class="nav-number">4.6.4.2.</span> <span class="nav-text">IPv6相较于IPv4的部分改变</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IPv6地址"><span class="nav-number">4.6.4.3.</span> <span class="nav-text">IPv6地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单播（Unicast-address）"><span class="nav-number">4.6.4.4.</span> <span class="nav-text">单播（Unicast address）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IPv4到IPv6的迁移"><span class="nav-number">4.6.5.</span> <span class="nav-text">IPv4到IPv6的迁移</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#双栈（Dual-Stack）"><span class="nav-number">4.6.5.1.</span> <span class="nav-text">双栈（Dual Stack）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#隧道（Tunneling）"><span class="nav-number">4.6.5.2.</span> <span class="nav-text">隧道（Tunneling）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#链路层（Link-Layer）"><span class="nav-number">5.</span> <span class="nav-text">链路层（Link Layer）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-4"><span class="nav-number">5.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#成帧（Framing）"><span class="nav-number">5.2.</span> <span class="nav-text">成帧（Framing）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符计数法（Character-count-method）"><span class="nav-number">5.2.1.</span> <span class="nav-text">字符计数法（Character count method）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于字符的首尾界定法（First-and-tail-bound-method-based-on-character）"><span class="nav-number">5.2.2.</span> <span class="nav-text">基于字符的首尾界定法（First and tail bound method based on character）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于bit的首尾界定法（First-and-tail-bound-method-based-on-bit）"><span class="nav-number">5.2.3.</span> <span class="nav-text">基于bit的首尾界定法（First and tail bound method based on bit）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#物理层违逆码法（Pysical-layer-coding-violation-method）"><span class="nav-number">5.2.4.</span> <span class="nav-text">物理层违逆码法（Pysical layer coding violation method）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#差错检测（Error-Detection）"><span class="nav-number">5.3.</span> <span class="nav-text">差错检测（Error Detection）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#奇偶校验（Parity-Checking）"><span class="nav-number">5.3.1.</span> <span class="nav-text">奇偶校验（Parity Checking）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CRC校验（Cyclic-Redundancy-Check）"><span class="nav-number">5.3.2.</span> <span class="nav-text">CRC校验（Cyclic Redundancy Check）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多路访问链路和协议（Multiple-Access-Links-and-Protocols）"><span class="nav-number">5.4.</span> <span class="nav-text">多路访问链路和协议（Multiple Access Links and Protocols）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#信道划分协议（Channel-Partitioning-protocols）"><span class="nav-number">5.4.1.</span> <span class="nav-text">信道划分协议（Channel Partitioning protocols）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#时分多路复用（TDMA）"><span class="nav-number">5.4.1.1.</span> <span class="nav-text">时分多路复用（TDMA）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#频分多路复用（FDMA）"><span class="nav-number">5.4.1.2.</span> <span class="nav-text">频分多路复用（FDMA）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#码分多址（CDMA）"><span class="nav-number">5.4.1.3.</span> <span class="nav-text">码分多址（CDMA）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#随机接入协议（Random-Access-protocols）"><span class="nav-number">5.4.2.</span> <span class="nav-text">随机接入协议（Random Access protocols）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#纯ALOHA（Pure-ALOHA）"><span class="nav-number">5.4.2.1.</span> <span class="nav-text">纯ALOHA（Pure ALOHA）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时隙ALOHA（Slotted-ALOHA）"><span class="nav-number">5.4.2.2.</span> <span class="nav-text">时隙ALOHA（Slotted ALOHA）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CSMA：载波侦听多路访问"><span class="nav-number">5.4.2.3.</span> <span class="nav-text">CSMA：载波侦听多路访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CSMA-CD：具有碰撞检测的载波侦听多路访问"><span class="nav-number">5.4.2.4.</span> <span class="nav-text">CSMA&#x2F;CD：具有碰撞检测的载波侦听多路访问</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#轮流协议（Taking-Turns-protocol）"><span class="nav-number">5.4.3.</span> <span class="nav-text">轮流协议（Taking-Turns protocol）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#轮询协议（Polling-protocol）"><span class="nav-number">5.4.3.1.</span> <span class="nav-text">轮询协议（Polling protocol）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#令牌传递协议（Token-Passing-protocol）"><span class="nav-number">5.4.3.2.</span> <span class="nav-text">令牌传递协议（Token-Passing protocol）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#局域网技术"><span class="nav-number">5.5.</span> <span class="nav-text">局域网技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#局域网模型"><span class="nav-number">5.5.1.</span> <span class="nav-text">局域网模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#局域网地址和ARP"><span class="nav-number">5.5.2.</span> <span class="nav-text">局域网地址和ARP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MAC-地址"><span class="nav-number">5.5.2.1.</span> <span class="nav-text">MAC 地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ARP：地址解析协议"><span class="nav-number">5.5.2.2.</span> <span class="nav-text">ARP：地址解析协议</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#同一子网内的地址解析"><span class="nav-number">5.5.2.2.1.</span> <span class="nav-text">同一子网内的地址解析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#不同子网的地址解析"><span class="nav-number">5.5.2.2.2.</span> <span class="nav-text">不同子网的地址解析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#以太网（Enternet）"><span class="nav-number">5.5.3.</span> <span class="nav-text">以太网（Enternet）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#以太网物理拓扑"><span class="nav-number">5.5.3.1.</span> <span class="nav-text">以太网物理拓扑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#以太网帧结构"><span class="nav-number">5.5.3.2.</span> <span class="nav-text">以太网帧结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#以太网技术"><span class="nav-number">5.5.3.3.</span> <span class="nav-text">以太网技术</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#二进制指数退避CSMA-CD算法"><span class="nav-number">5.5.3.3.1.</span> <span class="nav-text">二进制指数退避CSMA&#x2F;CD算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二进制指数退避算法（Binary-Exponential-Backoff-Algorithm）"><span class="nav-number">5.5.3.3.2.</span> <span class="nav-text">二进制指数退避算法（Binary Exponential Backoff Algorithm）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#802-3以太网标准"><span class="nav-number">5.5.3.3.3.</span> <span class="nav-text">802.3以太网标准</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#交换机（Switch）"><span class="nav-number">5.5.4.</span> <span class="nav-text">交换机（Switch）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#集线器（Hub）"><span class="nav-number">5.5.4.1.</span> <span class="nav-text">集线器（Hub）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#以太网交换机概述"><span class="nav-number">5.5.4.2.</span> <span class="nav-text">以太网交换机概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#交换机自学习"><span class="nav-number">5.5.4.3.</span> <span class="nav-text">交换机自学习</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#交换机转发与过滤"><span class="nav-number">5.5.4.4.</span> <span class="nav-text">交换机转发与过滤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#交换机-vs-路由器"><span class="nav-number">5.5.4.5.</span> <span class="nav-text">交换机 vs 路由器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VLAN：虚拟局域网"><span class="nav-number">5.5.5.</span> <span class="nav-text">VLAN：虚拟局域网</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基于端口的VLAN"><span class="nav-number">5.5.5.1.</span> <span class="nav-text">基于端口的VLAN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#跨多个交换机的VLAN"><span class="nav-number">5.5.5.2.</span> <span class="nav-text">跨多个交换机的VLAN</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="GuoYi"
      src="https://res.cloudinary.com/dh7ramrlh/image/upload/v1576578789/gy/IMG_0324_o40dwv.jpg">
  <p class="site-author-name" itemprop="name">GuoYi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">71</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">80</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">GuoYi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.6.0
  </div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'default',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      
<script type="text/x-mathjax-config">
    MathJax.Ajax.config.path['mhchem'] = '//cdn.jsdelivr.net/npm/mathjax-mhchem@3';

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        extensions: ['[mhchem]/mhchem.js'],
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: false,
      notify: false,
      appId: '8VTrBnqrHCihHxfEuBnrXVP3-gzGzoHsz',
      appKey: 'F0jqadgj1TbxEXnsj8evVvu9',
      placeholder: "来发个评论，留下邮箱接受回复。",
      avatar: 'mm',
      meta: guest,
      pageSize: '20' || 10,
      visitor: false,
      lang: '' || 'zh-cn',
      path: location.pathname,
      recordIP: false,
      serverURLs: ''
    });
  }, window.Valine);
});
</script>


  

</body>
</html>
