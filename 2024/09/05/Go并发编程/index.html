<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://gy23333.github.io').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="Go 并发编程">
<meta property="og:type" content="article">
<meta property="og:title" content="Go并发编程">
<meta property="og:url" content="https://gy23333.github.io/2024/09/05/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="GuoYi的博客">
<meta property="og:description" content="Go 并发编程">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20240905132345930.png">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20240905132404280.png">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20240912012030653.png">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/view.png">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/3.png">
<meta property="og:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/4.png">
<meta property="article:published_time" content="2024-09-04T16:58:16.000Z">
<meta property="article:modified_time" content="2024-11-11T03:57:58.107Z">
<meta property="article:author" content="GuoYi">
<meta property="article:tag" content="Golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20240905132345930.png">

<link rel="canonical" href="https://gy23333.github.io/2024/09/05/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Go并发编程 | GuoYi的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="GuoYi的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">GuoYi的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-music">

    <a href="/music/" rel="section"><i class="fa fa-fw fa-music"></i>music</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://gy23333.github.io/2024/09/05/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://res.cloudinary.com/dh7ramrlh/image/upload/v1576578789/gy/IMG_0324_o40dwv.jpg">
      <meta itemprop="name" content="GuoYi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GuoYi的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Go并发编程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-09-05 00:58:16" itemprop="dateCreated datePublished" datetime="2024-09-05T00:58:16+08:00">2024-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-11-11 11:57:58" itemprop="dateModified" datetime="2024-11-11T11:57:58+08:00">2024-11-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Golang/" itemprop="url" rel="index">
                    <span itemprop="name">Golang</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2024/09/05/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/09/05/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Go 并发编程</p>
<a id="more"></a>
<h1 id="并发基本概念"><a href="#并发基本概念" class="headerlink" title="并发基本概念"></a>并发基本概念</h1><h2 id="进程-Process-与线程-Thread"><a href="#进程-Process-与线程-Thread" class="headerlink" title="进程 Process 与线程 Thread"></a>进程 Process 与线程 Thread</h2><ul>
<li>进程是系统进行资源分配和调度的一个基本单位，程序在操作系统中的一次执行过程</li>
<li>线程是进程的执行单位，是CPU调度和分派的基本单位</li>
<li>一个进程可以创建和撤销多个线程;同一个进程中的多个线程之间可以并发执行</li>
</ul>
<h2 id="并行-Concurrent-与并发-Paralled"><a href="#并行-Concurrent-与并发-Paralled" class="headerlink" title="并行 Concurrent 与并发 Paralled"></a>并行 Concurrent 与并发 Paralled</h2><ul>
<li><p>并行：多个线程同时操作多个资源类</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20240905132345930.png" alt="并行"></p>
</li>
<li><p>并发：多个线程交替操作同一资源类</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20240905132404280.png" alt="并发"></p>
</li>
</ul>
<h2 id="进程-process-与线程-thread-与协程-coroutine"><a href="#进程-process-与线程-thread-与协程-coroutine" class="headerlink" title="进程 process 与线程 thread 与协程 coroutine"></a>进程 process 与线程 thread 与协程 coroutine</h2><ul>
<li>一个进程上可以跑多个线程，一个线程上可以跑多个协程</li>
<li>多个线程可以利用多个 CPU 并行，但一个线程内的多个协程是串行的，同一时刻只能有一个在运行，无法利用 CPU 多核，但不同线程内的协程之间可以并行</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>进程 process</th>
<th>线程 thread</th>
<th>协程 coroutine</th>
</tr>
</thead>
<tbody>
<tr>
<td>切换者</td>
<td>操作系统</td>
<td>操作系统</td>
<td>用户</td>
</tr>
<tr>
<td>切换内容</td>
<td>页全局目录、内核栈、硬件上下文</td>
<td>内核栈、硬件上下文</td>
<td>硬件上下文</td>
</tr>
<tr>
<td>切换内容保存位置</td>
<td>内存</td>
<td>内核栈</td>
<td>用户栈或堆（变量）</td>
</tr>
<tr>
<td>状态切换</td>
<td>用户态 —&gt; 内核态 —&gt; 用户态</td>
<td>用户态 —&gt; 内核态 —&gt; 用户态</td>
<td>用户态</td>
</tr>
<tr>
<td>切换效率</td>
<td>低</td>
<td>中</td>
<td>高</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>进程、线程的切换者是操作系统，操作系统决定切换时刻，用户无感</li>
<li>协程的切换者是用户，由用户程序决定切换时间</li>
<li>进程切换内容：页全局目录、内核栈、硬件上下文，切换的内容保存在内存中，采用 用户态 —&gt; 内核态 —&gt; 用户态</li>
<li>线程切换内容：内核栈、硬件上下文，切换的内容保存在内核栈中，采用 用户态 —&gt; 内核态 —&gt; 用户态</li>
<li>协程切换内容：硬件上下文，切换的内容保存在用户栈或堆（变量）中，切换过程始终处于用户态</li>
</ul>
<h1 id="协程-Goroutine"><a href="#协程-Goroutine" class="headerlink" title="协程 Goroutine"></a>协程 Goroutine</h1><p>Go 不需要自己编写进程、线程、协程，直接使用 goroutine，在语言中内置了调度和上下文切换机制，可轻松开启上万 goroutine。</p>
<p>goroutine 协程概念上类似于线程，Go 程序可以智能地将 goroutine 分配给不同的 CPU，由Go的运行时（runtime）调度和管理的。</p>
<h2 id="使用-goroutine"><a href="#使用-goroutine" class="headerlink" title="使用 goroutine"></a>使用 goroutine</h2><p>goroutine 使用时将任务包装成函数，通过 <code>go</code> 关键字开启</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>如果 goroutine 没有执行完，但主线程已经结束，goroutine 也会跟着结束。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>每两秒输出一次 go routine，每秒输出一次 hello，输出 10 次 hello 后结束</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"go routine"</span>)</span><br><span class="line">		time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> runtime()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="协程调度"><a href="#协程调度" class="headerlink" title="协程调度"></a>协程调度</h1><h2 id="GPM-模型"><a href="#GPM-模型" class="headerlink" title="GPM 模型"></a>GPM 模型</h2><p>goroutine 调度系统为 GPM 运行时（runtime）调度器，包括了 3 个部分—— goroutine G、处理器 P、线程 M</p>
<ul>
<li>G：goroutine<ul>
<li>存放本 goroutine 的一些信息，以及与 P 绑定等信息</li>
</ul>
</li>
<li>P：Processor，处理器<ul>
<li>P 对 goroutine 队列进行调度</li>
<li>goroutine 与线程的中间层，管理着一组 goroutine 队列，储存所管 goroutine 运行的上下文</li>
<li>P 的数量决定了最大可并行数量，个数由 <code>runtime.GOMAXPROCS</code> 设置，最大 256，默认为 CPU 数</li>
</ul>
</li>
<li>M：Machine，线程<ul>
<li>Go 运行时对操作内核线程的虚拟，与内核线程一一对应</li>
</ul>
</li>
</ul>
<p>P 管理着一群 G，调度在 M 上运行。一般比例为 G : P : M = n : 1 : 1</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20240912012030653.png" alt="GPM调度" style="zoom:50%;" /></p>
<p>调度机制：</p>
<ul>
<li>把占用 CPU 时间过长的 goroutine 暂停，去运行后续的 goroutine</li>
<li>当自己队列的消费光了，则去取全局队列中的 goroutine</li>
<li>如全局队列也消费光了，则去抢其他 P 的 goroutine</li>
<li>如果一个 G 长时间占据着 M，runtime 就会新建一个 M，管理阻塞 G 的 P 会将其他的 G 都挂到新建的 M 上。当旧的 M 上的 G 运行完或者被判定为死掉时，就会回收旧有的 M。</li>
</ul>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/view.png" alt="GPM调度机制"></p>
<p>由此可以看出，从调度角度看，goroutine 相较于线程的优势：</p>
<ul>
<li>goroutine 的调度由 runtime 调度器调度，全程在用户态</li>
<li>线程需要内核进行调度，需要内核态和用户态之间频繁切换</li>
</ul>
<h2 id="runtime-包"><a href="#runtime-包" class="headerlink" title="runtime 包"></a>runtime 包</h2><p>runtime 运行时用来调度和管理 goroutine，可通过 runtime 包程序控制 goroutine 以及获取环境信息。</p>
<h3 id="runtime-Gosched"><a href="#runtime-Gosched" class="headerlink" title="runtime.Gosched()"></a>runtime.Gosched()</h3><p>释放当前 goroutine 的 CPU 时间片给其他 goroutine 执行，当前 goroutine 等待未来的时间片再执行。</p>
<p><strong>示例</strong></p>
<p>下面代码，运行后有两种可能：</p>
<ul>
<li>一段数字 + 两个 hello<ul>
<li>CPU 时间片先给数字协程，再分配给 hello 主协程</li>
</ul>
</li>
<li>两个 hello<ul>
<li>CPU 时间片先给 hello 主协程，主协程结束后程序直接结束，不输出数字，再分配数字协程</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ &#123;</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 主协程</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时在主协程运行输出 <code>hello</code> 前，添加 <code>runtime.Gosched()</code>，会切到其他 goroutine 输出多次数字，等数字协程的时间片用完时，切回主协程输出 <code>hello</code> ，再切回数字协程输出数字，最后主协程输出 <code>hello</code> 后结束程序。</p>
<p>即输出：一段数字 + hello + 一段数字 + hello</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 主协程</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 切到其他进程先执行</span></span><br><span class="line">		runtime.Gosched()</span><br><span class="line">		fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="runtime-Goexit"><a href="#runtime-Goexit" class="headerlink" title="runtime.Goexit()"></a>runtime.Goexit()</h3><p>退出当前 goroutine，不过退出前还是会正常执行 defer 语句。</p>
<p><strong>示例</strong></p>
<p>下面代码，主协程休眠一秒，数字协程输出一段数字之后，主协程苏醒输出 <code>hello</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">      <span class="comment">// runtime.Goexit()</span></span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加 <code>runtime.Goexit()</code> 后，直接结束协程，不会输出数字，只输出 <code>hello</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">			runtime.Goexit()</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="runtime-GOMAXPROCS"><a href="#runtime-GOMAXPROCS" class="headerlink" title="runtime.GOMAXPROCS()"></a>runtime.GOMAXPROCS()</h3><p>设置可同时使用最大 CPU 核数，并返回之前的设置。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime</span>.<span class="title">GOMAXPROCS</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>
<h3 id="其他运行时信息"><a href="#其他运行时信息" class="headerlink" title="其他运行时信息"></a>其他运行时信息</h3><ul>
<li><p>获取 CPU 核数量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime.NumCPU()</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取 GOROOT 路径</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime.GOROOT()</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取操作系统</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime.GOOS</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h1><h2 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h2><p>临界资源：并发环境中多个进程/线程/协程共享的资源。</p>
<p>多个 goroutine 访问同一资源时，多个写 goroutine，会造成临界资源安全问题。</p>
<p>下面示例中，4 个售票员并发卖 10 张票，原本是希望卖到无票时所有售票员停止卖票，但同时读写就可能导致资源安全问题。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numTicket = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">saleTicket</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> numTicket &gt; <span class="number">0</span> &#123;</span><br><span class="line">			time.Sleep(time.Duration(rand.Intn(<span class="number">1000</span>)) * time.Millisecond)</span><br><span class="line">			numTicket--</span><br><span class="line">			fmt.Printf(<span class="string">"Saler %d sales one ticket, left %d tickets.\n"</span>, i, numTicket)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"Saler %d detects no ticket.\n"</span>, i)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	numSaler := <span class="number">4</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numSaler; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> saleTicket(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如这次跑的结果，最后三个售票员检查时还有余票，但卖时已经无票了，导致票成负数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Saler 3 sales one ticket, left 9 tickets.</span><br><span class="line">Saler 0 sales one ticket, left 8 tickets.</span><br><span class="line">Saler 0 sales one ticket, left 7 tickets.</span><br><span class="line">Saler 2 sales one ticket, left 6 tickets.</span><br><span class="line">Saler 1 sales one ticket, left 5 tickets.</span><br><span class="line">Saler 3 sales one ticket, left 4 tickets.</span><br><span class="line">Saler 1 sales one ticket, left 3 tickets.</span><br><span class="line">Saler 0 sales one ticket, left 2 tickets.</span><br><span class="line">Saler 2 sales one ticket, left 1 tickets.</span><br><span class="line">Saler 3 sales one ticket, left 0 tickets.</span><br><span class="line">Saler 3 detects no ticket.</span><br><span class="line">Saler 2 sales one ticket, left -1 tickets.</span><br><span class="line">Saler 2 detects no ticket.</span><br><span class="line">Saler 1 sales one ticket, left -2 tickets.</span><br><span class="line">Saler 1 detects no ticket.</span><br><span class="line">Saler 0 sales one ticket, left -3 tickets.</span><br><span class="line">Saler 0 detects no ticket.</span><br></pre></td></tr></table></figure>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><h3 id="互斥锁-sync-Mutex"><a href="#互斥锁-sync-Mutex" class="headerlink" title="互斥锁 sync.Mutex"></a>互斥锁 sync.Mutex</h3><p>多个 goroutine 同时操作同一个资源（临界区）会导致竞态问题，需要通过对资源上锁，确保同一时刻只有一个 goroutine 访问该共享资源。</p>
<ul>
<li><p>声明一个互斥锁</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mutex sync.Mutex</span><br></pre></td></tr></table></figure>
</li>
<li><p>在使用资源前加锁，防止其他 goroutine 同时使用该资源</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mutex.Lock()</span><br></pre></td></tr></table></figure>
</li>
<li><p>在使用完资源后解锁，释放该资源给其他 goroutine 使用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mutex.Unlock()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面的用例，在查看票数前加锁，再售票和退出前解锁，如此就不会出现多卖出票的情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line"><span class="keyword">var</span> numTicket = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">saleTicket</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">		mutex.Lock()</span><br><span class="line">		<span class="keyword">if</span> numTicket &gt; <span class="number">0</span> &#123;</span><br><span class="line">			time.Sleep(time.Duration(rand.Intn(<span class="number">1000</span>)) * time.Millisecond)</span><br><span class="line">			numTicket--</span><br><span class="line">			fmt.Printf(<span class="string">"Saler %d sales one ticket, left %d tickets.\n"</span>, i, numTicket)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//解锁</span></span><br><span class="line">			mutex.Unlock()</span><br><span class="line">			fmt.Printf(<span class="string">"Saler %d detects no ticket.\n"</span>, i)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">		mutex.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	numSaler := <span class="number">4</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numSaler; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> saleTicket(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读写互斥锁-sync-RWMutex"><a href="#读写互斥锁-sync-RWMutex" class="headerlink" title="读写互斥锁 sync.RWMutex"></a>读写互斥锁 sync.RWMutex</h3><p>互斥锁是完全互斥的，无关是读还是写。但其实并发读并不会出现资源竞争的问题，所以引入读写锁，不限制并发读，但限制并发读写、写写。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>读</th>
<th>写</th>
</tr>
</thead>
<tbody>
<tr>
<td>读</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>写</td>
<td>N</td>
<td>N</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>声明一个读写互斥锁</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mutex sync.RWMutex</span><br></pre></td></tr></table></figure>
</li>
<li><p>在写资源前加写锁，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mutex.Lock()</span><br></pre></td></tr></table></figure>
</li>
<li><p>在写完资源后解写锁，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mutex.Unlock()</span><br></pre></td></tr></table></figure>
</li>
<li><p>在读资源前加读锁</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mutex.RLock()</span><br></pre></td></tr></table></figure>
</li>
<li><p>在读完资源后解读锁</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mutex.RUnlock()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>示例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	x      <span class="keyword">int64</span></span><br><span class="line">	wg     sync.WaitGroup</span><br><span class="line">	lock   sync.Mutex</span><br><span class="line">	rwlock sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rwlock.Lock() <span class="comment">// 加写锁</span></span><br><span class="line">	x = x + <span class="number">1</span></span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Millisecond) <span class="comment">// 假设读操作耗时10毫秒</span></span><br><span class="line">	rwlock.Unlock()                   <span class="comment">// 解写锁</span></span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rwlock.RLock()               <span class="comment">// 加读锁</span></span><br><span class="line">	time.Sleep(time.Millisecond) <span class="comment">// 假设读操作耗时1毫秒</span></span><br><span class="line">	rwlock.RUnlock()             <span class="comment">// 解读锁</span></span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> write()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> read()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	end := time.Now()</span><br><span class="line">	fmt.Println(end.Sub(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原子操作-atomic"><a href="#原子操作-atomic" class="headerlink" title="原子操作 atomic"></a>原子操作 atomic</h2><blockquote>
<p>原子操作即不能被中断的操作，对资源进行原子操作时，CPU 不会再对该资源进行其他操作。原子操作无锁，通过 CPU 指令直接实现。</p>
</blockquote>
<p>通过互斥锁操作会涉及内核态的上下文切换，Go 可以调用 atomic 包在用户态完成原子操作来保证并发安全。</p>
<ul>
<li>原子操作支持的类型：<code>int32</code>、<code>int64</code>、<code>uint32</code>、<code>uint64</code>、<code>uintptr</code>、<code>unsafe.Pointer</code>，即整数和指针</li>
</ul>
<p>以 <code>int64</code> 为例，取变量地址用于操作</p>
<ul>
<li><p>读取</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atomic</span>.<span class="title">LoadInt64</span><span class="params">(addr *<span class="keyword">int64</span>)</span> <span class="params">(val <span class="keyword">int64</span>)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>写入</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atomic</span>.<span class="title">StoreInt64</span><span class="params">(addr *<span class="keyword">int64</span>, val <span class="keyword">int64</span>)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atomic</span>.<span class="title">AddInt64</span><span class="params">(addr *<span class="keyword">int64</span>, delta <span class="keyword">int64</span>)</span> <span class="params">(<span class="built_in">new</span> <span class="keyword">int64</span>)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>交换</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atomic</span>.<span class="title">SwapInt64</span><span class="params">(addr *<span class="keyword">int64</span>, <span class="built_in">new</span> <span class="keyword">int64</span>)</span> <span class="params">(old <span class="keyword">int64</span>)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>比较交换，交换前先检查当前值是否是 old，如是则交换成 new，如不是则不交换</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atomic</span>.<span class="title">CompareAndSwapInt64</span><span class="params">(addr *<span class="keyword">int64</span>, old <span class="keyword">int64</span>, <span class="built_in">new</span> <span class="keyword">int64</span>)</span> <span class="params">(swapped <span class="keyword">bool</span>)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="管道-Channel"><a href="#管道-Channel" class="headerlink" title="管道 Channel"></a>管道 Channel</h2><p>Go 的并发模型是 CSP，Communicating Sequential Process，提倡使用通信共享内存，而不是通过共享内存方式进行通信。</p>
<p>Go 可以通过共享内存来实现数据共享，使用锁来防止竞态，但这不可避免的加大了性能问题。由此引入了管道 Channel 的概念，用于 goroutine 之间通信。</p>
<h3 id="创建-Channel"><a href="#创建-Channel" class="headerlink" title="创建 Channel"></a>创建 Channel</h3><p>Channel 是引用类型，每个 Channel 都需要定义其允许传输的数据类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> 数据类型  <span class="comment">//零值为nil</span></span><br></pre></td></tr></table></figure>
<p>通道的零值为 <code>nil</code>，因此需要使用 <code>make</code> 来定义（缓冲区大小可缺省）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> 数据类型 [, 缓冲区大小])</span><br></pre></td></tr></table></figure>
<h3 id="Channel-操作"><a href="#Channel-操作" class="headerlink" title="Channel 操作"></a>Channel 操作</h3><p>在定义了 Channel 后，可对其进行下面操作，以 <code>int</code> 类型为例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>发送</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">10</span></span><br></pre></td></tr></table></figure>
<ol>
<li>当存在等待的接收者时，直接将数据发送给阻塞的接收者</li>
<li>当不存在等待的接收者，但缓冲区存在空余空间时，将数据写入缓冲区</li>
<li>当不存在等待的接收者，且不存在缓冲区或者缓冲区已满时，阻塞等待其他 goroutine 从 Channel 中接收数据</li>
</ol>
</li>
<li><p><strong>接收</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;-ch <span class="comment">//丢弃通道值</span></span><br><span class="line">data := &lt;-ch <span class="comment">//接收通道值到data</span></span><br><span class="line">data, ok := &lt;-ch <span class="comment">//接收通道值到data，ok接收通道是否关闭（false，则通道已关闭）</span></span><br></pre></td></tr></table></figure>
<ol>
<li>当存在等待的发送者时，从阻塞的发送者或者缓冲区中获取数据</li>
<li>当不存在等待的发送者，但缓冲区存在数据时，从缓冲区接收数据</li>
<li>当不存在等待的发送者，且不存在缓冲区或者缓冲区不存在数据时，阻塞等待其他 goroutine 向 Channel 中发送数据</li>
</ol>
</li>
<li><p><strong>关闭</strong>，如果不再需要往通道发送值，则可以关闭通道，关闭通道不是必须的，可以自动通过垃圾回收机制回收</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>
<p>关闭后的通道：</p>
<ol>
<li>对关闭后的通道发送值会导致 panic</li>
<li>对关闭后的通道接收会一直获取到值，知道通道空</li>
<li>对关闭后且已经空的通道接收会得到对应数据类型的零值</li>
<li>关闭已经关闭的通道会导致 panic</li>
</ol>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Channel缓冲区</th>
<th>nil</th>
<th>非空</th>
<th>空</th>
<th>满</th>
<th>非空非满</th>
</tr>
</thead>
<tbody>
<tr>
<td>发送</td>
<td>阻塞</td>
<td>发送值</td>
<td>发送值</td>
<td>阻塞</td>
<td>发送值</td>
</tr>
<tr>
<td>接收</td>
<td>阻塞</td>
<td>接收值</td>
<td>阻塞</td>
<td>接收值</td>
<td>接收值</td>
</tr>
<tr>
<td>关闭</td>
<td>panic</td>
<td>关闭成功，读取所有数据后，返回零值</td>
<td>关闭成功，返回零值</td>
<td>关闭成功，读取所有数据后，返回零值</td>
<td>关闭成功，读取所有数据后，返回零值</td>
</tr>
</tbody>
</table>
</div>
<h3 id="无缓冲的通道"><a href="#无缓冲的通道" class="headerlink" title="无缓冲的通道"></a>无缓冲的通道</h3><p>无缓冲通道，又称阻塞通道、同步通道，定义 Channel 时不设置缓冲区大小即为无缓冲通道。</p>
<p>此类 Channel 发送和接收都无缓冲，所以无接收时发送会被阻塞，直到其他 goroutine 从该通道读取数据；同理，无发送时接收会被阻塞，直到其他 goroutine 发送到该通道。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/3.png" alt="无缓冲Channel"></p>
<p>下面错误用例，发送数据到 Channel，无接收，阻塞，无法运行到接收步骤，于是发生死锁报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	ch &lt;- <span class="number">10</span> <span class="comment">//无接收发送，死锁</span></span><br><span class="line">	data := &lt;-ch</span><br><span class="line">	fmt.Println(data)</span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要启动另一个 goroutine 接收，解开死锁</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recvFromChannel</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	data := &lt;-ch</span><br><span class="line">	fmt.Println(data)</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> recvFromChannel(ch)</span><br><span class="line">	ch &lt;- <span class="number">10</span></span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有缓冲的通道"><a href="#有缓冲的通道" class="headerlink" title="有缓冲的通道"></a>有缓冲的通道</h3><p>定义 Channel 时设置缓冲区大小即可设置为有缓冲通道，在缓冲区有剩余时，即使无接收者，也不阻塞发送。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/4.png" alt="有缓冲Channel"></p>
<p>上述死锁用例，加上缓冲区，即可正常运行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">//创建容量为1的缓冲区的通道</span></span><br><span class="line">	ch &lt;- <span class="number">10</span></span><br><span class="line">	data := &lt;-ch</span><br><span class="line">	fmt.Println(data)</span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h3><p>有些 goroutine 函数调用 Channel 仅需发送或者接收，则可以使用单向通道进行限制。</p>
<ul>
<li><p>只能发送的通道</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chan</span>&lt;- <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>只能接收的通道</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;-<span class="keyword">chan</span> <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>下面例子，两个函数一个仅需要发送，一个仅需要接收，即可传入单向通道</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recvFromChannel</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123; <span class="comment">//仅接收通道</span></span><br><span class="line">	data := &lt;-ch</span><br><span class="line">	fmt.Println(data)</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendToChannel</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123; <span class="comment">//仅发送通道</span></span><br><span class="line">	ch &lt;- <span class="number">10</span></span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> recvFromChannel(ch)</span><br><span class="line">	<span class="keyword">go</span> sendToChannel(ch)</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通道的遍历"><a href="#通道的遍历" class="headerlink" title="通道的遍历"></a>通道的遍历</h3><p>循环从通道取值的方法</p>
<p>方法一：使用 <code>for</code> 持续循环</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendToChannel</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		ch &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> sendToChannel(ch)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		data, ok := &lt;-ch</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(data)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：<code>for...range</code>，既可以循环取值，并且在通道关闭后退出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendToChannel</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		ch &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> sendToChannel(ch)</span><br><span class="line">	<span class="keyword">for</span> data := <span class="keyword">range</span> ch &#123;</span><br><span class="line">		fmt.Println(data)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通道的调度"><a href="#通道的调度" class="headerlink" title="通道的调度"></a>通道的调度</h3><p>通过 <code>select</code> 随机运行一个接收到的 Channel 的 case</p>
<ol>
<li>如果有可接收的 Channel，则随机运行其中一个 case</li>
<li>如果没有可接收的 Channel，则运行 <code>default</code> case</li>
<li>如果没有可接收的 Channel，且没有 <code>default</code> case，则会阻塞直到有接收到 Channel</li>
</ol>
<p>使用无限 <code>for</code> 循环包裹 <code>select</code>，则可实现持续监听多个通道，触发相应操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> data1, ok := &lt;-ch1:</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      fmt.Println(<span class="string">"ch1 closed."</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ch1处理</span></span><br><span class="line">  <span class="keyword">case</span> &lt;-ch2:</span><br><span class="line">		<span class="comment">// ch2处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="sync-包"><a href="#sync-包" class="headerlink" title="sync 包"></a>sync 包</h1><h2 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h2><p>在多线程并发过程中，如果主协程结束，其他 goroutine 也会跟着结束，所以经常需要让主协程等待其他 goroutine 结束。使用 <code>time.Sleep</code> 过于生硬，不合适。于是引入了 <code>sync.WaitGroup</code> 处理该问题 。</p>
<ul>
<li><code>(wg * WaitGroup) Add(delta int)</code>：计数器 + delta</li>
<li><code>(wg *WaitGroup) Done()</code>：计数器 -1</li>
<li><code>(wg *WaitGroup) Wait()</code>：阻塞直到计数器变为 0</li>
</ul>
<p>每开一个并发 goroutine 就让计数器 +1，并发 goroutine 结束时则让计数器 -1，主协程调用 <code>Wait()</code> 阻塞直到所有 goroutine 结束，计数器清零。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup <span class="comment">//声明一个WaitGroup</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Done() <span class="comment">//一个goroutine结束，计数器-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	numGoroutine := <span class="number">4</span></span><br><span class="line">	wg.Add(numGoroutine) <span class="comment">//计数器+并发goroutine数</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numGoroutine; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> funcA()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait() <span class="comment">//主协程阻塞直到所有goroutine跑完</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h2><p><code>sync.Once</code> 提供函数只执行一次的方法，如初始化配置、数据库连接此类并发只需要调用一次的函数，可用此方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span></span><br></pre></td></tr></table></figure>
<p>下面示例，<code>funcA</code> 和 <code>funcB</code> 都需要调用 <code>InitConfig</code> 函数，使用 <code>sync.Once</code>，可使得该函数只被调用一次。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	wg   sync.WaitGroup</span><br><span class="line">	once sync.Once <span class="comment">//声明once</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitConfig</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Init Configuration"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">()</span></span> &#123;</span><br><span class="line">	once.Do(InitConfig) <span class="comment">//并发只调用一次</span></span><br><span class="line">	fmt.Println(<span class="string">"function A"</span>)</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcB</span><span class="params">()</span></span> &#123;</span><br><span class="line">	once.Do(InitConfig) <span class="comment">//并发只调用一次</span></span><br><span class="line">	fmt.Println(<span class="string">"function B"</span>)</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> funcA()</span><br><span class="line">	<span class="keyword">go</span> funcB()</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Init Configuration</span><br><span class="line">function B</span><br><span class="line">function A</span><br></pre></td></tr></table></figure>
<h2 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h2><p>Go 原生的 map 并不是并发安全的，需要额外加锁。sync 包提供 <code>sync.Map</code> 则是一种并发安全的 map，无需加锁。内置了诸如Store、Load、LoadOrStore、Delete、Range等操作方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"strconv"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	wg   sync.WaitGroup</span><br><span class="line">	once sync.Once</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := sync.Map&#123;&#125; <span class="comment">//定义map</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			key := strconv.Itoa(n)</span><br><span class="line">			m.Store(key, n) <span class="comment">//存值</span></span><br><span class="line">			value, _ := m.Load(key) <span class="comment">//取值</span></span><br><span class="line">			fmt.Printf(<span class="string">"key: %v, value: %v\n"</span>, key, value)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><h2 id="周期性定时器-ticker"><a href="#周期性定时器-ticker" class="headerlink" title="周期性定时器 ticker"></a>周期性定时器 ticker</h2><p>ticker 是周期性定时器，除非主动停止，就会一直循环计时下去。如果希望每隔一段时间执行一次，推荐使用 <code>ticker</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>用法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>func time.NewTicker(d time.Duration) *time.Ticker</code></td>
<td>定义一个定时器 ticker，每隔一个间隔时间就会向 <code>.C</code> 通道发送当前时间</td>
</tr>
<tr>
<td><code>func (t *time.Ticker) Stop()</code></td>
<td>回收资源，否则会产生内存泄漏</td>
</tr>
<tr>
<td><code>&lt;-t.C</code></td>
<td>每隔一个设置的时间就会从通道接收到当前时间</td>
</tr>
</tbody>
</table>
</div>
<p>以下示例，每隔 5s 输出当前时间</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ticker := time.NewTicker(<span class="number">5</span> * time.Second) <span class="comment">//定义5s一次的定时器</span></span><br><span class="line">	<span class="keyword">defer</span> ticker.Stop() <span class="comment">//回收资源</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(t *time.Ticker)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"Time: "</span>, time.Now().Format(<span class="string">"2006-01-02 15:04:05"</span>))</span><br><span class="line">			&lt;-t.C <span class="comment">//每隔5s触发一次</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(ticker)</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">15</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一次性定时器-timer"><a href="#一次性定时器-timer" class="headerlink" title="一次性定时器 timer"></a>一次性定时器 timer</h2><p>timer 是一次性定时器，只计时一次，重新开始计时需要重置。如果希望只执行一次，或者需要重新设置间隔时间的，推荐使用 <code>timer</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>用法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>func time.NewTimer(d time.Duration) *time.Timer</code></td>
<td>定义一个定时器 timer，过一个间隔时间后会向 <code>.C</code> 通道发送当前时间</td>
</tr>
<tr>
<td><code>&lt;-t.C</code></td>
<td>过一个设置的时间从通道接收到当前时间</td>
</tr>
<tr>
<td><code>func (t *time.Timer) Stop() bool</code></td>
<td>停止当前计时，如果当前在计时，则返回 true，并不会再发送到通道；如果不在计时中，则返回 fasle</td>
</tr>
<tr>
<td><code>func (t *time.Timer) Reset(d time.Duration) bool</code></td>
<td>重置计时器，如果现在正在计时，则停止当前计时，重新计时（返回同 <code>Stop</code>）</td>
</tr>
</tbody>
</table>
</div>
<p>以下示例，使用一次性计时器 timer 模拟周期性计时器 ticker</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	timer := time.NewTimer(<span class="number">5</span> * time.Second) <span class="comment">//定义一次性计时器timer</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"Time: "</span>, time.Now().Format(<span class="string">"2006-01-02 15:04:05"</span>))</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(t *time.Timer)</span></span> &#123;</span><br><span class="line">		times := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			&lt;-t.C <span class="comment">//计时</span></span><br><span class="line">			fmt.Println(<span class="string">"Time: "</span>, time.Now().Format(<span class="string">"2006-01-02 15:04:05"</span>))</span><br><span class="line"></span><br><span class="line">			times++</span><br><span class="line">			t.Reset(<span class="number">5</span> * time.Second) <span class="comment">//重新开始计时</span></span><br><span class="line">			<span class="keyword">if</span> times &gt; <span class="number">3</span> &#123;</span><br><span class="line">				t.Stop() <span class="comment">//停止计时</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(timer)</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">30</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><p><a href="https://www.topgoer.com/并发编程/" target="_blank" rel="noopener">并发编程</a></p>
</li>
<li><p><a href="https://hedon954.github.io/noteSite/backend/golang/high/goroutine_channel.html" target="_blank" rel="noopener">Golang 并发编程</a></p>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Golang/" rel="tag"># Golang</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/09/04/Go%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/" rel="prev" title="Go学习路线">
      <i class="fa fa-chevron-left"></i> Go学习路线
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/09/19/OSPF%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/" rel="next" title="OSPF 路由协议">
      OSPF 路由协议 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#并发基本概念"><span class="nav-number">1.</span> <span class="nav-text">并发基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程-Process-与线程-Thread"><span class="nav-number">1.1.</span> <span class="nav-text">进程 Process 与线程 Thread</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并行-Concurrent-与并发-Paralled"><span class="nav-number">1.2.</span> <span class="nav-text">并行 Concurrent 与并发 Paralled</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程-process-与线程-thread-与协程-coroutine"><span class="nav-number">1.3.</span> <span class="nav-text">进程 process 与线程 thread 与协程 coroutine</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#协程-Goroutine"><span class="nav-number">2.</span> <span class="nav-text">协程 Goroutine</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-goroutine"><span class="nav-number">2.1.</span> <span class="nav-text">使用 goroutine</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#示例"><span class="nav-number">2.2.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#协程调度"><span class="nav-number">3.</span> <span class="nav-text">协程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#GPM-模型"><span class="nav-number">3.1.</span> <span class="nav-text">GPM 模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#runtime-包"><span class="nav-number">3.2.</span> <span class="nav-text">runtime 包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#runtime-Gosched"><span class="nav-number">3.2.1.</span> <span class="nav-text">runtime.Gosched()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#runtime-Goexit"><span class="nav-number">3.2.2.</span> <span class="nav-text">runtime.Goexit()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#runtime-GOMAXPROCS"><span class="nav-number">3.2.3.</span> <span class="nav-text">runtime.GOMAXPROCS()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他运行时信息"><span class="nav-number">3.2.4.</span> <span class="nav-text">其他运行时信息</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据共享"><span class="nav-number">4.</span> <span class="nav-text">数据共享</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#临界资源"><span class="nav-number">4.1.</span> <span class="nav-text">临界资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#互斥锁"><span class="nav-number">4.2.</span> <span class="nav-text">互斥锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#互斥锁-sync-Mutex"><span class="nav-number">4.2.1.</span> <span class="nav-text">互斥锁 sync.Mutex</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读写互斥锁-sync-RWMutex"><span class="nav-number">4.2.2.</span> <span class="nav-text">读写互斥锁 sync.RWMutex</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子操作-atomic"><span class="nav-number">4.3.</span> <span class="nav-text">原子操作 atomic</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管道-Channel"><span class="nav-number">4.4.</span> <span class="nav-text">管道 Channel</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建-Channel"><span class="nav-number">4.4.1.</span> <span class="nav-text">创建 Channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Channel-操作"><span class="nav-number">4.4.2.</span> <span class="nav-text">Channel 操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无缓冲的通道"><span class="nav-number">4.4.3.</span> <span class="nav-text">无缓冲的通道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有缓冲的通道"><span class="nav-number">4.4.4.</span> <span class="nav-text">有缓冲的通道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单向通道"><span class="nav-number">4.4.5.</span> <span class="nav-text">单向通道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通道的遍历"><span class="nav-number">4.4.6.</span> <span class="nav-text">通道的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通道的调度"><span class="nav-number">4.4.7.</span> <span class="nav-text">通道的调度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sync-包"><span class="nav-number">5.</span> <span class="nav-text">sync 包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#sync-WaitGroup"><span class="nav-number">5.1.</span> <span class="nav-text">sync.WaitGroup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sync-Once"><span class="nav-number">5.2.</span> <span class="nav-text">sync.Once</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sync-Map"><span class="nav-number">5.3.</span> <span class="nav-text">sync.Map</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#定时器"><span class="nav-number">6.</span> <span class="nav-text">定时器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#周期性定时器-ticker"><span class="nav-number">6.1.</span> <span class="nav-text">周期性定时器 ticker</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一次性定时器-timer"><span class="nav-number">6.2.</span> <span class="nav-text">一次性定时器 timer</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">7.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="GuoYi"
      src="https://res.cloudinary.com/dh7ramrlh/image/upload/v1576578789/gy/IMG_0324_o40dwv.jpg">
  <p class="site-author-name" itemprop="name">GuoYi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">85</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">82</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">GuoYi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.6.0
  </div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'default',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      
<script type="text/x-mathjax-config">
    MathJax.Ajax.config.path['mhchem'] = '//cdn.jsdelivr.net/npm/mathjax-mhchem@3';

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        extensions: ['[mhchem]/mhchem.js'],
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: false,
      notify: false,
      appId: '8VTrBnqrHCihHxfEuBnrXVP3-gzGzoHsz',
      appKey: 'F0jqadgj1TbxEXnsj8evVvu9',
      placeholder: "来发个评论，留下邮箱接受回复。",
      avatar: 'mm',
      meta: guest,
      pageSize: '20' || 10,
      visitor: false,
      lang: '' || 'zh-cn',
      path: location.pathname,
      recordIP: false,
      serverURLs: ''
    });
  }, window.Valine);
});
</script>


  

</body>
</html>
