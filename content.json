{"meta":{"title":"GuoYi的博客","subtitle":"","description":"","author":"GuoYi","url":"https://gy23333.github.io","root":"/"},"pages":[{"title":"分类","date":"2019-12-17T03:14:13.000Z","updated":"2024-11-11T03:57:58.133Z","comments":false,"path":"categories/index.html","permalink":"https://gy23333.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-12-17T03:35:54.000Z","updated":"2024-11-11T03:57:58.133Z","comments":false,"path":"tags/index.html","permalink":"https://gy23333.github.io/tags/index.html","excerpt":"","text":""},{"title":"歌单","date":"2020-02-25T11:50:11.000Z","updated":"2024-11-11T03:57:58.104Z","comments":true,"path":"music/index.html","permalink":"https://gy23333.github.io/music/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux网卡绑定","slug":"Linux网卡绑定","date":"2025-03-25T16:36:08.000Z","updated":"2025-03-26T05:54:33.555Z","comments":true,"path":"2025/03/26/Linux网卡绑定/","link":"","permalink":"https://gy23333.github.io/2025/03/26/Linux%E7%BD%91%E5%8D%A1%E7%BB%91%E5%AE%9A/","excerpt":"Linux NIC Bonding 技术可以将多张物理网卡或者虚拟网卡绑定为一张虚拟的逻辑网卡，从而实现网卡的冗余、带宽的扩容以及负载均衡。","text":"Linux NIC Bonding 技术可以将多张物理网卡或者虚拟网卡绑定为一张虚拟的逻辑网卡，从而实现网卡的冗余、带宽的扩容以及负载均衡。 网卡绑定的作用网卡绑定的作用主要有两个方面： 提供冗余（负载均衡）：网卡绑定最主要的作用，如下图，物理机的多张物理网卡可以上连多个交换机，将网卡绑定为一张虚拟网卡，使用该 bond 虚拟网卡，当其中一个交换机故障时，流量可以自动切换到另一个交换机与物理网卡，提供了网卡的容灾能力。 提高吞吐量：由于是多张网卡进行负载均衡，bond 出来的网卡的吞吐量也得到了提升。 网卡绑定模式Mode 0 — balance-rr（轮询模式）数据包依次顺序轮询每张网卡传输，即第1个包走 eth0，下一个包就走 eth1….一直轮询下去。 Mode 1 — active-backup（主备模式）只有一张网卡作为主，承接流量，当主网卡宕机后，启用备网卡。 Mode 2 — balance-xor（异或模式）基于源 MAC 和目的 MAC 的 Hash 选择网卡 Mode 3 — broadcast（广播模式）所有数据包在所有网卡上传输。 Mode 4 — link aggregation（动态链接聚合）Mode 5 — balance-tlb（传输负载均衡）Mode 6 — balance-alb（适应性负载均衡）使用 nmcli 绑定网卡 创建绑定网卡 1nmcli connection add type bond ifname &lt;绑定网卡名&gt; mode &lt;模式&gt; 例如，创建一张名为 bond0 的主备模式绑定网卡 12root@ubuntu2404:/# nmcli connection add type bond ifname bond0 mode active-backupConnection 'bond-bond0' (fed29263-5656-449b-95c8-cf2e23432736) successfully added. 查看网络设备，即可看到新建的 bond0 网卡 1234567root@ubuntu2404:/# nmcli device statusDEVICE TYPE STATE CONNECTIONens160 ethernet connected netplan-ens160ens256 ethernet connected Wired connection 1bond0 bond connecting (getting IP configuration) bond-bond0lo loopback connected (externally) lodocker0 bridge connected (externally) docker0 添加从属网卡 1nmcli connection add type bond-slave ifname &lt;从属网卡名&gt; master &lt;绑定网卡名&gt; 例如，将 ens160 和 ens256 网卡绑定到 bond0 网卡上 1234root@ubuntu2404:/# nmcli connection add type bond-slave ifname ens160 master bond0Connection 'bond-slave-ens160' (021cce67-1440-4d50-a8a9-5c7faf8a361b) successfully added.root@ubuntu2404:/# nmcli connection add type bond-slave ifname ens256 master bond0Connection 'bond-slave-ens256' (f17d7bf7-4313-4f90-8f9c-5c35c0ebe319) successfully added. 123456789root@ubuntu2404:/# nmcli connection showNAME UUID TYPE DEVICEnetplan-ens160 febc54dc-e29c-3939-a911-8a11855bd1c8 ethernet ens160Wired connection 1 ec18620e-37bf-3343-acf5-b57b8928465d ethernet ens256bond-bond0 fed29263-5656-449b-95c8-cf2e23432736 bond bond0lo 73b7043c-59f1-42aa-a711-2eb721fc18b4 loopback lodocker0 5fb2c927-9b29-4d43-99ab-09af694a8927 bridge docker0bond-slave-ens160 021cce67-1440-4d50-a8a9-5c7faf8a361b ethernet --bond-slave-ens256 f17d7bf7-4313-4f90-8f9c-5c35c0ebe319 ethernet -- 配置绑定网卡 1nmcli connection modify bond-bond0 ipv4.addresses 192.168.1.100&#x2F;24 ipv4.method manual 激活绑定 123sudo nmcli connection up bond-bond0sudo nmcli connection up bond-slave-ens160sudo nmcli connection up bond-slave-ens256 1nmcli connection add type bond ifname bond0 mode active-backup","categories":[],"tags":[]},{"title":"Linux策略路由","slug":"Linux策略路由","date":"2025-03-20T15:11:01.000Z","updated":"2025-03-23T16:38:45.429Z","comments":true,"path":"2025/03/20/Linux策略路由/","link":"","permalink":"https://gy23333.github.io/2025/03/20/Linux%E7%AD%96%E7%95%A5%E8%B7%AF%E7%94%B1/","excerpt":"Linux 策略路由是一种高级路由机制。相比于传统路由，策略路由允许用户配置多张路由表，根据源地址、目的地址等选择不同路由表，提供了更灵活的路由控制能力。","text":"Linux 策略路由是一种高级路由机制。相比于传统路由，策略路由允许用户配置多张路由表，根据源地址、目的地址等选择不同路由表，提供了更灵活的路由控制能力。 路由表（Routing Table）路由表是存储路由规则的集合，Linux 支持配置多张路由表。 rt_tables 文件/etc/iproute2/rt_tables 是 Linux 中用于定义路由表名称和编号映射的文件。 其中的每一行定义了一个路由表，包括其编号（1～255）和名称，编号和名称都不能重复。 Linux 发行版中，/etc/iproute2/rt_tables 的默认内容如下： 123456789101112root@ubuntu2404:/# cat /etc/iproute2/rt_tables## reserved values#255 local254 main253 default0 unspec## local##1 inr.ruhep Linux 默认路由表Linux 初始的默认状态下，包含下面四个路由表： local表 编号：255 存储本地接口地址和广播地址 内核自动维护，用户通常不需要修改 12345678910root@ubuntu2404:/# ip route show table locallocal 127.0.0.0/8 dev lo proto kernel scope host src 127.0.0.1local 127.0.0.1 dev lo proto kernel scope host src 127.0.0.1broadcast 127.255.255.255 dev lo proto kernel scope link src 127.0.0.1local 172.16.19.129 dev ens160 proto kernel scope host src 172.16.19.129local 172.16.19.133 dev ens256 proto kernel scope host src 172.16.19.133broadcast 172.16.19.255 dev ens160 proto kernel scope link src 172.16.19.129broadcast 172.16.19.255 dev ens256 proto kernel scope link src 172.16.19.133local 172.17.0.1 dev docker0 proto kernel scope host src 172.17.0.1broadcast 172.17.255.255 dev docker0 proto kernel scope link src 172.17.0.1 linkdown main表 编号：254 主路由表，传统路由使用的表 通过 ip route 命令配置或展示的都是此表 123456root@ubuntu2404:/# ip route show table maindefault via 172.16.19.2 dev ens160 proto dhcp src 172.16.19.129 metric 100default via 172.16.19.2 dev ens256 proto dhcp src 172.16.19.133 metric 101172.16.19.0/24 dev ens160 proto kernel scope link src 172.16.19.129 metric 100172.16.19.0/24 dev ens256 proto kernel scope link src 172.16.19.133 metric 101172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown default表 编号：253 默认路由表，通常用于存储默认路由 初始时为空 unspec表 编号：0 未指定路由表，用于表示未指定或无效的路由表 自定义路由表修改 /etc/iproute2/rt_tables 文件，可添加自定义路由表。 1&lt;编号&gt; &lt;路由表名&gt; 建议：编号虽然可以从 1 开始取，但是为了避免与未来系统可能保留的编号冲突，通常选择从 100 开始分配编号 12100 custom1101 custom2 也可以分段分配编号，以方便管理不同类型的路由表 12100 custom1200 custom2 路由规则（Rule）路由规则：数据包如何匹配并选择路由表的规则，根据特定的条件（如源地址、目的地址、入接口等）选择不同的路由表。 查看路由规则1234root@ubuntu2404:/# ip rule show0: from all lookup local32766: from all lookup main32767: from all lookup default 路由规则的组成每一条路由规则包含 3 个信息： 优先级：数字越小，优先级越高。自定义规则的优先级通常设置在 1 到 32765 之间。 条件：匹配数据包的条件，如源地址、目的地址、入接口等 动作：通常规定选择哪个路由表 按照优先级，从小到大匹配规则，如果匹配到，则选择规定的路由表。 增/删路由规则 增加路由规则（优先级可缺省，缺省时取低优先级） 1ip rule add &lt;条件&gt; lookup &lt;表名&gt; priority &lt;优先级&gt; 删除路由规则 1ip rule del &lt;条件&gt; lookup &lt;表名&gt; 匹配条件路由规则的匹配条件支持以下字段： 匹配数据包的源地址 from &lt;PREFIX&gt; 示例： 12# 来自 192.168.1.0/24 的流量使用 custom1 表ip rule add from 192.168.1.0/24 lookup custom1 匹配数据包的目的地址 to &lt;PREFIX&gt; 示例： 12# 去往 8.8.8.8 的流量使用 custom2 表ip rule add to 8.8.8.8 lookup custom2 匹配数据包的入网卡 iif &lt;网卡&gt; 示例： 12# 从 eth1 接口进入的流量使用 custom3 表ip rule add iif eth1 lookup custom3 匹配数据包的协议 ipproto &lt;PROTOCOL&gt; 示例： 12# TCP 协议的流量使用 custom4 表ip rule add proto tcp lookup custom4 等等，详细见 help help1234567891011121314151617181920root@ubuntu2404:/# ip rule helpUsage: ip rule &#123; add | del &#125; SELECTOR ACTION ip rule &#123; flush | save | restore &#125; ip rule [ list [ SELECTOR ]]SELECTOR := [ not ] [ from PREFIX ] [ to PREFIX ] [ tos TOS ] [ fwmark FWMARK[/MASK] ] [ iif STRING ] [ oif STRING ] [ pref NUMBER ] [ l3mdev ] [ uidrange NUMBER-NUMBER ] [ ipproto PROTOCOL ] [ sport [ NUMBER | NUMBER-NUMBER ] [ dport [ NUMBER | NUMBER-NUMBER ] ]ACTION := [ table TABLE_ID ] [ protocol PROTO ] [ nat ADDRESS ] [ realms [SRCREALM/]DSTREALM ] [ goto NUMBER ] SUPPRESSORSUPPRESSOR := [ suppress_prefixlength NUMBER ] [ suppress_ifgroup DEVGROUP ]TABLE_ID := [ local | main | default | NUMBER ] 路由（Route）每张路由表里都可以配置自己的路由。 ip route 命令ip route 命令如果没有指定路由表，则默认指定 main 表。 查看路由表1ip route show table &lt;路由表名&gt; help123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657root@ubuntu2404:/# ip route helpUsage: ip route &#123; list | flush &#125; SELECTOR ip route save SELECTOR ip route restore ip route showdump ip route get [ ROUTE_GET_FLAGS ] ADDRESS [ from ADDRESS iif STRING ] [ oif STRING ] [ tos TOS ] [ mark NUMBER ] [ vrf NAME ] [ uid NUMBER ] [ ipproto PROTOCOL ] [ sport NUMBER ] [ dport NUMBER ] ip route &#123; add | del | change | append | replace &#125; ROUTESELECTOR := [ root PREFIX ] [ match PREFIX ] [ exact PREFIX ] [ table TABLE_ID ] [ vrf NAME ] [ proto RTPROTO ] [ type TYPE ] [ scope SCOPE ]ROUTE := NODE_SPEC [ INFO_SPEC ]NODE_SPEC := [ TYPE ] PREFIX [ tos TOS ] [ table TABLE_ID ] [ proto RTPROTO ] [ scope SCOPE ] [ metric METRIC ] [ ttl-propagate &#123; enabled | disabled &#125; ]INFO_SPEC := &#123; NH | nhid ID &#125; OPTIONS FLAGS [ nexthop NH ]...NH := [ encap ENCAPTYPE ENCAPHDR ] [ via [ FAMILY ] ADDRESS ] [ dev STRING ] [ weight NUMBER ] NHFLAGSFAMILY := [ inet | inet6 | mpls | bridge | link ]OPTIONS := FLAGS [ mtu NUMBER ] [ advmss NUMBER ] [ as [ to ] ADDRESS ] [ rtt TIME ] [ rttvar TIME ] [ reordering NUMBER ] [ window NUMBER ] [ cwnd NUMBER ] [ initcwnd NUMBER ] [ ssthresh NUMBER ] [ realms REALM ] [ src ADDRESS ] [ rto_min TIME ] [ hoplimit NUMBER ] [ initrwnd NUMBER ] [ features FEATURES ] [ quickack BOOL ] [ congctl NAME ] [ pref PREF ] [ expires TIME ] [ fastopen_no_cookie BOOL ]TYPE := &#123; unicast | local | broadcast | multicast | throw | unreachable | prohibit | blackhole | nat &#125;TABLE_ID := [ local | main | default | all | NUMBER ]SCOPE := [ host | link | global | NUMBER ]NHFLAGS := [ onlink | pervasive ]RTPROTO := [ kernel | boot | static | NUMBER ]PREF := [ low | medium | high ]TIME := NUMBER[s|ms]BOOL := [1|0]FEATURES := ecnENCAPTYPE := [ mpls | ip | ip6 | seg6 | seg6local | rpl | ioam6 | xfrm ]ENCAPHDR := [ MPLSLABEL | SEG6HDR | SEG6LOCAL | IOAM6HDR | XFRMINFO ]SEG6HDR := [ mode SEGMODE ] segs ADDR1,ADDRi,ADDRn [hmac HMACKEYID] [cleanup]SEGMODE := [ encap | encap.red | inline | l2encap | l2encap.red ]SEG6LOCAL := action ACTION [ OPTIONS ] [ count ]ACTION := &#123; End | End.X | End.T | End.DX2 | End.DX6 | End.DX4 | End.DT6 | End.DT4 | End.DT46 | End.B6 | End.B6.Encaps | End.BM | End.S | End.AS | End.AM | End.BPF &#125;OPTIONS := OPTION [ OPTIONS ]OPTION := &#123; flavors FLAVORS | srh SEG6HDR | nh4 ADDR | nh6 ADDR | iif DEV | oif DEV | table TABLEID | vrftable TABLEID | endpoint PROGNAME &#125;FLAVORS := &#123; FLAVOR[,FLAVOR] &#125;FLAVOR := &#123; psp | usp | usd | next-csid &#125;IOAM6HDR := trace prealloc type IOAM6_TRACE_TYPE ns IOAM6_NAMESPACE size IOAM6_TRACE_SIZEXFRMINFO := if_id IF_ID [ link_dev LINK ]ROUTE_GET_FLAGS := [ fibmatch ]","categories":[],"tags":[]},{"title":"堆","slug":"堆","date":"2025-01-15T17:41:45.000Z","updated":"2025-01-19T16:48:44.084Z","comments":true,"path":"2025/01/16/堆/","link":"","permalink":"https://gy23333.github.io/2025/01/16/%E5%A0%86/","excerpt":"堆（heap）是一种满足特定条件的完全二叉树，分为大顶堆和小顶堆，通常用于实现优先队列，进行堆排序。本文主要介绍推数据结构以及其 Go 实现。","text":"堆（heap）是一种满足特定条件的完全二叉树，分为大顶堆和小顶堆，通常用于实现优先队列，进行堆排序。本文主要介绍推数据结构以及其 Go 实现。 堆堆是一种完全二叉树，与优先队列等价，分为两种类型： 小顶堆（min heap）：任意节点的值 &lt;= 其子节点的值 大顶堆（max heap）：任意节点的值 &gt;= 其子节点的值 从存储结构来看，实际就是树层次遍历所得的队列。 container/heapGolang 标准库 container/heap 提供了堆的快速实现。 接口定义源码heap.Interface 接口定义源码 12345type Interface interface &#123; sort.Interface Push(x any) // add x as element Len() Pop() any // remove and return element Len() - 1.&#125; sort.Interface 接口定义源码 1234567891011type Interface interface &#123; // Len is the number of elements in the collection. Len() int // Less reports whether the element with index i // must sort before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int)&#125; 接口实现通过实现 heap.Interface 接口，从而实现一个堆。 堆的结构体首先定义堆的结构体，堆的数据类型需要是一个切片（实际以切片形式存储），切片的 type 即为堆的每个元素的数据类型。 最常用的整数 1type IntHeap []int 也可使用结构体的切片，比如想要实现一个每个元素都是一个长方体的优先队列 123456type Rectangle struct &#123; width int height int&#125;type RectangleHeap []Rectangle Len() int用于返回堆中元素的数量。 实现方式相对固定，返回切片长度即可。 123func (h IntHeap) Len() int &#123; return len(h)&#125; Less(i, j int) bool用于设置堆的元素的大小比较方法。 比较索引为 i 和 j 上的两个元素，如果 i 索引元素应该排在 j 的前面，即返回 true。 小顶堆：$h[i] &lt; h[j]$，则返回 true 大顶堆：$h[i] &gt; h[j]$，则返回 true 示例： 整数小顶堆 123func (h IntHeap) Less(i, j int) bool &#123; return h[i] &lt; h[j]&#125; 整数大顶堆 123func (h IntHeap) Less(i, j int) bool &#123; return h[i] &gt; h[j]&#125; 长方体大顶堆，面积比大小 1234567func (r Rectangle) area() int &#123; return r.width * r.height&#125;func (h RectangleHeap) Less(i, j int) bool &#123; return h[i].area() &gt; h[j].area()&#125; Swap(i, j int)用于交换堆中索引 i 和 j 位置的元素。 实现方式相对固定，直接交换二者存储位置。 123func (h IntHeap) Swap(i, j int) &#123; h[i], h[j] = h[j], h[i]&#125; Push(x any)将新的元素 x 加入堆切片，即 append 到最后。 注：接口的 Push(x any) 只需要将新元素加到堆尾即可，使用 heap.Push() 时，将会调用用户实现的 Push(x any) ，将元素加到队尾，然后自动实现上浮排序。 123func (h *IntHeap) Push(x any) &#123; *h = append(*h, x.(int))&#125; Pop() any从堆切片中移除最后一个元素，并返回。 注：使用 heap.Pop() 时，将先将堆顶的元素下沉到队尾，然后调用用户实现的 Pop() any 删除并返回。 123456func (h *IntHeap) Pop() any &#123; n := len(*h) x := (*h)[n-1] *h = (*h)[:n-1] return x&#125; 实现 Push() 和 Pop() 时，都需使用指针接收。切片是引用类型，但在方法中增加/删除元素，可能会修改切片本身，所以需使用指针接收。 堆的使用heap.Init()作用：完成堆的初始化。调用结束后，堆的切片即完成排序。 实现方式：将堆的非叶子节点一一下沉。（由底向上，从第一个非叶子节点开始下沉，直到堆顶，叶子节点没有下沉的必要） 1234567func Init(h Interface) &#123; // heapify n := h.Len() for i := n/2 - 1; i &gt;= 0; i-- &#123; down(h, i, n) &#125;&#125; heap.Push()作用：将新元素推入堆中，并完成排序。 实现方式：先调用用户实现的 Push() 接口，将新元素加入切片的最尾部，再将尾部上浮。 1234func Push(h Interface, x any) &#123; h.Push(x) up(h, h.Len()-1)&#125; heap.Pop()作用：将堆顶推出并返回。 实现方式：先将堆顶和堆尾交换，再将新换上的堆顶下沉，最后调用用户实现的 Pop() 接口，将堆尾推出并返回。 123456func Pop(h Interface) any &#123; n := h.Len() - 1 h.Swap(0, n) down(h, 0, n) return h.Pop()&#125; 例题滑动窗口最大值给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值 。 示例 1： 1234567891011输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3输出：[3,3,5,5,6,7]解释：滑动窗口的位置 最大值--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 优先队列方法题解： 将前 k-1 个数字初始化大顶堆 从第 k 个数字开始遍历 将该数字 Push 入堆 查看堆顶元素 如果已经不在滑动窗口里，则 Pop 出堆 否则，该堆顶即为现在滑动窗口里最大元素，加入结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657type element struct &#123; num int index int&#125;type ElementHeap []elementfunc (h ElementHeap) Len() int &#123; return len(h)&#125;func (h ElementHeap) Less(i, j int) bool &#123; return h[i].num &gt; h[j].num&#125;func (h ElementHeap) Swap(i, j int) &#123; h[i], h[j] = h[j], h[i]&#125;func (h *ElementHeap) Push(x any) &#123; *h = append(*h, x.(element))&#125;func (h *ElementHeap) Pop() any &#123; n := h.Len() x := (*h)[n-1] *h = (*h)[:n-1] return x&#125;func maxSlidingWindow(nums []int, k int) []int &#123; h := &amp;ElementHeap&#123;&#125; for i := 0; i &lt; k-1; i++ &#123; *h = append(*h, element&#123; num: nums[i], index: i, &#125;) &#125; heap.Init(h) ans := make([]int, 0, len(nums)) for i := k - 1; i &lt; len(nums); i++ &#123; heap.Push(h, element&#123; num: nums[i], index: i, &#125;) for &#123; if (*h)[0].index &lt; i-k+1 &#123; heap.Pop(h) &#125; else &#123; ans = append(ans, (*h)[0].num) break &#125; &#125; &#125; return ans&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://gy23333.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://gy23333.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"堆","slug":"堆","permalink":"https://gy23333.github.io/tags/%E5%A0%86/"}]},{"title":"OpenTelemetry分布式链路追踪","slug":"OpenTelemetry分布式链路追踪","date":"2025-01-05T16:37:19.000Z","updated":"2025-01-06T17:48:25.073Z","comments":true,"path":"2025/01/06/OpenTelemetry分布式链路追踪/","link":"","permalink":"https://gy23333.github.io/2025/01/06/OpenTelemetry%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/","excerpt":"","text":"https://jckling.github.io/2021/04/02/Jaeger/全链路追踪与%20Jaeger%20入门/index.html 1docker run -d --name jaeger -e COLLECTOR_ZIPKIN_HTTP_PORT&#x3D;9411 -p 5775:5775&#x2F;udp -p 6831:6831&#x2F;udp -p 6832:6832&#x2F;udp -p 5778:5778 -p 16686:16686 -p 14268:14268 -p 14250:14250 -p 9411:9411 quay.io&#x2F;jaegertracing&#x2F;all-in-one:1.64.0","categories":[],"tags":[]},{"title":"TLS 证书","slug":"TLS-证书","date":"2024-12-24T14:55:05.000Z","updated":"2024-12-24T14:55:05.810Z","comments":true,"path":"2024/12/24/TLS-证书/","link":"","permalink":"https://gy23333.github.io/2024/12/24/TLS-%E8%AF%81%E4%B9%A6/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Go 依赖管理","slug":"Go-依赖管理","date":"2024-12-23T17:18:11.000Z","updated":"2024-12-23T17:28:37.726Z","comments":true,"path":"2024/12/24/Go-依赖管理/","link":"","permalink":"https://gy23333.github.io/2024/12/24/Go-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/","excerpt":"Go 依赖管理","text":"Go 依赖管理 初始化 Go 项目 新建项目文件夹 12mkdir survey-testcd survey-test 初始化 Go 模块 12go mod init github.com/GY23333/survey-testgo: creating new go.mod: module github.com/GY23333/survey-test 该步会自动生成 go.mod 文件 123module github.com/GY23333/survey-testgo 1.23.3 如需获取依赖 1go get -u github.com&#x2F;gorilla&#x2F;mux","categories":[{"name":"Golang","slug":"Golang","permalink":"https://gy23333.github.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://gy23333.github.io/tags/Golang/"}]},{"title":"Go Package: survey","slug":"Go-Package-survey","date":"2024-12-23T16:44:26.000Z","updated":"2024-12-25T18:09:26.971Z","comments":true,"path":"2024/12/24/Go-Package-survey/","link":"","permalink":"https://gy23333.github.io/2024/12/24/Go-Package-survey/","excerpt":"Go 交互式命令行工具库，提供了包括文本输入、选择菜单、确认提示、多项选择等多种交互类型，帮助快速构建交互式命令行页面。","text":"Go 交互式命令行工具库，提供了包括文本输入、选择菜单、确认提示、多项选择等多种交互类型，帮助快速构建交互式命令行页面。 安装1go get -u github.com&#x2F;AlecAivazis&#x2F;survey&#x2F;v2 PromptInput 单行输入12345var username stringprompt := &amp;survey.Input&#123; Message: \"Input username:\",&#125;survey.AskOne(prompt, &amp;username) 可以通过设置 Suggest 来给用户提供建议，帮助补全输入，Suggest 为由当前输入值返回建议值列表的方法。如下面补全文件路径示例。 123456789var path stringprompt := &amp;survey.Input&#123; Message: \"Input file path:\", Suggest: func(toComplete string) []string &#123; files, _ := filepath.Glob(toComplete + \"*\") return files &#125;,&#125;survey.AskOne(prompt, &amp;path) Multiline 多行输入Select 单选123456var tool stringprompt := &amp;survey.Select&#123; Message: \"Choose a tool:\", Options: []string&#123;\"toolA\", \"toolB\", \"toolC\"&#125;,&#125;survey.AskOne(prompt, &amp;tool) 可以通过设置 Description 给每个选项添加描述， Description 为由选项值/序号返回描述的方法 1234567891011121314var tool stringdescription := map[string]string&#123; \"toolA\": \"Description for toolA\", \"toolB\": \"Description for toolB\", \"toolC\": \"Description for toolC\",&#125;prompt := &amp;survey.Select&#123; Message: \"Choose a tool:\", Options: []string&#123;\"toolA\", \"toolB\", \"toolC\"&#125;, Description: func(value string, index int) string &#123; return description[value] &#125;,&#125;survey.AskOne(prompt, &amp;tool) MultiSelect 多选123456days := []string&#123;&#125;prompt := &amp;survey.MultiSelect&#123; Message: \"What days do you prefer:\", Options: []string&#123;\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"&#125;,&#125;survey.AskOne(prompt, &amp;days) Confirm 确认12345answer := falseprompt := &amp;survey.Confirm&#123; Message: \"Are you sure to continue?\",&#125;survey.AskOne(prompt, &amp;answer) Password 密码12345password := \"\"prompt := &amp;survey.Password&#123; Message: \"Please type your password\",&#125;survey.AskOne(prompt, &amp;password) OptionValidator设置输入验证，提供输入验证函数（输入：输入值，返回 error），如果用户输入验证不通过，则提示错误，并重新提问。 12345678910111213141516var input stringprompt := &amp;survey.Input&#123; Message: \"Input number:\",&#125;// 验证输入为数字，并在0到10范围内vaildInputNumber := func(val interface&#123;&#125;) error &#123; num, err := strconv.Atoi(val.(string)) if err != nil &#123; return fmt.Errorf(\"not number\") &#125; if num &lt; 0 || num &gt; 10 &#123; return fmt.Errorf(\"not in 0~10\") &#125; return nil&#125;survey.AskOne(prompt, &amp;input, survey.WithValidator(vaildInputNumber)) Survey 库也提供了一些可直接调用的验证函数 Required：要求非空 MinLength(n)：最小长度 MaxLength(n)：最大长度 AskAsk支持连续问多个问题，设置多个问题，每个问题可以包括四个部分： Name：与回答结构体里的元素对应，用于指名结果解析到哪个元素 Prompt：具体的问题 Vaildate：回答的验证方法 Transform：自动更改格式 12345678910111213141516171819202122232425262728293031323334353637383940qs := []*survey.Question&#123; &#123; Name: \"name\", Prompt: &amp;survey.Input&#123;Message: \"What is your name?\"&#125;, Validate: survey.Required, Transform: survey.Title, &#125;, &#123; Name: \"color\", Prompt: &amp;survey.Select&#123; Message: \"Choose a color:\", Options: []string&#123;\"red\", \"blue\", \"green\"&#125;, Default: \"red\", &#125;, &#125;, &#123; Name: \"age\", Prompt: &amp;survey.Input&#123;Message: \"How old are you?\"&#125;, Validate: func(val interface&#123;&#125;) error &#123; _, err := strconv.Atoi(val.(string)) if err != nil &#123; return fmt.Errorf(\"not number\") &#125; return nil &#125;, &#125;,&#125;answers := struct &#123; Name string // survey will match the question and field names FavoriteColor string `survey:\"color\"` // or you can tag fields to match a specific name Age int // if the types don't match, survey will convert it&#125;&#123;&#125;// perform the questionserr := survey.Ask(qs, &amp;answers)if err != nil &#123; fmt.Println(err.Error()) return&#125; 参考 https://github.com/AlecAivazis/survey https://pkg.go.dev/github.com/AlecAivazis/survey/v2#section-readme","categories":[{"name":"Golang","slug":"Golang","permalink":"https://gy23333.github.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://gy23333.github.io/tags/Golang/"}]},{"title":"IPIP隧道","slug":"IPIP隧道","date":"2024-12-06T16:47:53.000Z","updated":"2024-12-06T16:47:53.899Z","comments":true,"path":"2024/12/07/IPIP隧道/","link":"","permalink":"https://gy23333.github.io/2024/12/07/IPIP%E9%9A%A7%E9%81%93/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"IPv6","slug":"IPv6","date":"2024-12-06T16:47:16.000Z","updated":"2025-02-18T17:24:18.406Z","comments":true,"path":"2024/12/07/IPv6/","link":"","permalink":"https://gy23333.github.io/2024/12/07/IPv6/","excerpt":"IPv6 是网络层协议的第二代标准协议，将 IP 地址长度从原来的 32 位升级为 128 位，从根本上解决了 IP 地址耗尽的问题。","text":"IPv6 是网络层协议的第二代标准协议，将 IP 地址长度从原来的 32 位升级为 128 位，从根本上解决了 IP 地址耗尽的问题。 IPv6 地址IPv6 地址由 128 位二进制数组成，书写时采用十六进制，分为 8 组，组之间用 : 分开，每组 16 位，用 4 个十六进制表示。 1XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX 比如 2001:00b8:130F:0000:0000:09C0:0000:0000 简写如 IPv6 地址 2001:00b8:130F:0000:0000:09C0:0000:0000 每组前半部分的 0 可省去，0000 可简写为 0 2001:b8:130F:0:0:9C0:0:0 连续的 0 可以用 :: 缩写（只能用一个 ::，且缩最前面那个连续 0） 2001:b8:130F::9C0:0:0 IPv4 转 IPv6原 IPv4 地址转 IPv6 采用 0:0:0:0:0:FFFF:IPv4-address 格式。 如 172.17.0.3 变成 0:0:0:0:0:FFFF:172.17.0.3 地址结构IPv6 地址可以划分为两个部分：网络前缀、接口标识 网络前缀：前 n 位划分为网络前缀，类似于 IPv4 中的网络号，一般推荐使用 64 位 接口标识：后 128-n 位划分为网络前缀，类似于 IPv4 中的主机号 如 2001:db8:130F:0000:0000:09C0:876A:130B/64，/ 后数字表示网络前缀的长度 地址划分按照目的地址，可以将 IPv6 地址划分成下面三种类型： 单播地址：唯一标识一个接口，和 IPv4 单播一样，点对点的通信。 组播地址：一点对多点的通信，和 IPv4 组播一样，发送到组播地址的数据包被传输给此地址所标识的所有接口。 任播地址：IPv6 相比 IPv4 新增地址类型，发送到任播地址的数据包被传输给此地址所标识的一组接口中距离源节点最近的一个接口。 IPv6 不支持广播，广播地址的功能均由组播地址来提供。IPv4 依赖 BGP 来实现任播。 IPv6 单播地址又可分为 地址类型 二进制前缀 IPv6前缀标识 链路本地单播地址 1111111010 FE80::/10 唯一本地地址 1111110 FC00::/7 环回地址 00…1 (128 bits) ::1/128 未指定地址 00…0 (128 bits) ::/128 全球单播地址 其他 -","categories":[],"tags":[]},{"title":"Linux日志管理工具--logrotate","slug":"Linux日志管理工具-logrotate","date":"2024-12-06T16:45:51.000Z","updated":"2024-12-16T05:23:49.137Z","comments":true,"path":"2024/12/07/Linux日志管理工具-logrotate/","link":"","permalink":"https://gy23333.github.io/2024/12/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-logrotate/","excerpt":"logrotate 是 Linux 系统中用来管理日志的工具，通过配置可以实现日志的自动轮转、压缩、删除、邮件发送功能。","text":"logrotate 是 Linux 系统中用来管理日志的工具，通过配置可以实现日志的自动轮转、压缩、删除、邮件发送功能。 概述logrotate 提供了日志的自动轮转、压缩、删除、邮件发送能力，可以设置定期或者限制文件大小来触发。 一般来说，logrotate 都是作为每日的定时任务运行，一般不会一天内处理多次，除非触发条件是基于文件的大小并且设置 logrotate 一天执行多次，或者在执行时使用强制选项 -f logrotate 命令1logrotate [OPTION...] &lt;configfile&gt; -d, --debug：以调试模式运行，打印出详细的调试信息，但不执行任何轮转操作 -f, --force：强制执行日志轮转，即使不符合轮转条件 -v, --verbose：在轮转时显示更多信息 -s, --state=statefile：指定一个状态文件来记录日志轮转的历史状态，默认状态文件是 /var/lib/logrotate/status 1logrotate -s &#x2F;var&#x2F;log&#x2F;logrotate.status &#x2F;etc&#x2F;logrotate.conf -l, --log=logfile：指定 logrotate 日志记入的日志文件 -m, --mail=command：指定发送邮件的命令 logrotate 定时任务logrotate 配置文件将 logrotate 配置文件按路径不同分为下面三种： /etc/logrotate.conf /etc/logrotate.d/ 其他路径 logrotate 配置参考 logrotate 官方文档","categories":[{"name":"Linux","slug":"Linux","permalink":"https://gy23333.github.io/categories/Linux/"}],"tags":[{"name":"logrotate","slug":"logrotate","permalink":"https://gy23333.github.io/tags/logrotate/"}]},{"title":"基于FRRouting/Bird的OSPF组网及负载均衡实现","slug":"基于FRRouting-Bird的OSPF组网及负载均衡实现","date":"2024-12-06T16:36:31.000Z","updated":"2024-12-09T13:33:38.863Z","comments":true,"path":"2024/12/07/基于FRRouting-Bird的OSPF组网及负载均衡实现/","link":"","permalink":"https://gy23333.github.io/2024/12/07/%E5%9F%BA%E4%BA%8EFRRouting-Bird%E7%9A%84OSPF%E7%BB%84%E7%BD%91%E5%8F%8A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E7%8E%B0/","excerpt":"基于 FRRouting/Bird 配置多虚拟机之间的 OSPF 组网（建邻、路由交换），并实现多路径负载均衡。","text":"基于 FRRouting/Bird 配置多虚拟机之间的 OSPF 组网（建邻、路由交换），并实现多路径负载均衡。 概述FRRouting、Bird 都是常用的开源路由软件，支持 OSPF 协议。本文采用 FRRouting 作为两台 DNS Server 的路由发布器，Bird 作为 DR 兼 Client 的路由软件（在实际测试环境中，可以使用其中任一款软件来实现 OSPF 的组网），通过 FRRouting 发布 VIP，实现 OSPF 场景下的多路径负载均衡。 环境准备1、创建三台虚拟机，每台虚拟机至少有一张可用的网卡安装 Linux 虚拟机，本文安装了三台 Ubuntu 24.04.1，安装过程参考 Mac安装虚拟机 2、在其中一台虚拟机上安装 birdbird安装方法 1sudo apt install bird2 3、在另外两台虚拟机上安装 FRRouting 以及 CorednsFRRouting安装方法 1sudo apt install frr Coredns 下载 123wget https:&#x2F;&#x2F;github.com&#x2F;coredns&#x2F;coredns&#x2F;releases&#x2F;download&#x2F;v1.12.0&#x2F;coredns_1.12.0_linux_arm64.tgztar -zxvf coredns_1.12.0_linux_arm64.tgzsudo mv coredns &#x2F;usr&#x2F;local&#x2F;bin&#x2F; 1coredns --version OSPF 建邻目标：以 Bird 节点作为 DR，实现 3 台虚拟机的建邻组网。 FRRouting 配置 OSPF开启 ospfd 进程 修改 daemons 文件，默认位置在 /etc/frr/daemons，将 ospfd 开关打开 1ospfd&#x3D;yes 重启 FRR，查看 ospfd 进程是否正常启动 1systemctl restart frr 12345678910111213141516171819202122232425262728root@ubuntu2:~$ systemctl status frr● frr.service - FRRouting Loaded: loaded (/etc/systemd/system/frr.service; enabled; preset: enabled) Active: active (running) since Sun 2024-12-08 16:47:09 UTC; 5s ago Docs: https://frrouting.readthedocs.io/en/latest/setup.html Process: 39653 ExecStart=/usr/lib/frr/frrinit.sh start (code=exited, status=0/SUCCESS) Main PID: 39664 (watchfrr) Status: \"FRR Operational\" Tasks: 10 (limit: 4550) Memory: 18.6M (peak: 32.1M) CPU: 117ms CGroup: /system.slice/frr.service ├─39664 /usr/lib/frr/watchfrr -d -F traditional zebra mgmtd ospfd staticd ├─39676 /usr/lib/frr/zebra -d -F traditional -A 127.0.0.1 -s 90000000 ├─39681 /usr/lib/frr/mgmtd -d -F traditional -A 127.0.0.1 ├─39683 /usr/lib/frr/ospfd -d -F traditional -A 127.0.0.1 └─39686 /usr/lib/frr/staticd -d -F traditional -A 127.0.0.1Dec 08 16:47:09 ubuntu2 frrinit.sh[39693]: [39693|ospfd] doneDec 08 16:47:09 ubuntu2 staticd[39686]: [VTVCM-Y2NW3] Configuration Read in Took: 00:00:00Dec 08 16:47:09 ubuntu2 frrinit.sh[39706]: [39706|staticd] doneDec 08 16:47:09 ubuntu2 watchfrr[39664]: [QDG3Y-BY5TN] zebra state -&gt; up : connect succeededDec 08 16:47:09 ubuntu2 frrinit.sh[39653]: * Started watchfrrDec 08 16:47:09 ubuntu2 watchfrr[39664]: [QDG3Y-BY5TN] mgmtd state -&gt; up : connect succeededDec 08 16:47:09 ubuntu2 watchfrr[39664]: [QDG3Y-BY5TN] ospfd state -&gt; up : connect succeededDec 08 16:47:09 ubuntu2 watchfrr[39664]: [QDG3Y-BY5TN] staticd state -&gt; up : connect succeededDec 08 16:47:09 ubuntu2 watchfrr[39664]: [KWE5Q-QNGFC] all daemons up, doing startup-complete notifyDec 08 16:47:09 ubuntu2 systemd[1]: Started frr.service - FRRouting. FRR 配置该 FRR 节点网卡信息 1234567891011121314guoyi@ubuntu2:~$ ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host noprefixroute valid_lft forever preferred_lft forever2: ens160: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:62:77:76 brd ff:ff:ff:ff:ff:ff altname enp2s0 inet 172.16.19.131/24 metric 100 brd 172.16.19.255 scope global dynamic ens160 valid_lft 1194sec preferred_lft 1194sec inet6 fe80::20c:29ff:fe62:7776/64 scope link valid_lft forever preferred_lft forever 使用 ens160 网卡作为 OSPF 网卡 123456789101112!interface ens160 ip ospf area 0.0.0.0 ip ospf dead-interval 20 ip ospf hello-interval 5 ip ospf priority 0exit!router ospf ospf router-id 172.16.19.131exit! ip ospf area 0.0.0.0 将该网卡配置为 OSPF 网卡，并设置 area 为 0.0.0.0 也可在 router ospf 下配置 network 172.16.19.0/24 area 0.0.0.0，但此配置会将所有该网段的网卡设置为 OSPF 网卡 ip ospf dead-interval 20、ip ospf hello-interval 5 设置 hello 和 dead 的时间间隔 需建邻的所有节点这两个配置需相同 ip ospf priority 0 此节点不竞选 DR/BDR ospf router-id 172.16.19.131 area 内该 OSPF 节点的唯一标识，一般用网卡 IP 来表示 Bird 配置 OSPF使用 ens256 网卡作为 OSPF 网卡 123456789protocol ospf v2 &#123; area 0 &#123; interface &quot;ens256&quot; &#123; priority 1; hello 10; dead 40; &#125;; &#125;;&#125; priority 1 参与竞选，且优先级最高 查看建邻BIRD 节点作为 DR，查看其他的节点状态，均建邻成功（Full） 12345bird&gt; show ospf neighborsospf1:Router ID Pri State DTime Interface Router IP172.16.19.131 0 Full&#x2F;Other 17.621 ens256 172.16.19.131172.16.19.132 0 Full&#x2F;Other 19.486 ens256 172.16.19.132 FRRouting 节点作为 Other，只需与 DR 节点建邻成功，Other 节点之间处于 2-Way 状态 12345ubuntu2# show ip ospf neighborNeighbor ID Pri State Up Time Dead Time Address Interface RXmtL RqstL DBsmL172.16.19.129 1 Full&#x2F;DR 3m18s 16.350s 172.16.19.130 ens160:172.16.19.131 0 0 0172.16.19.132 0 2-Way&#x2F;DROther 3m49s 15.307s 172.16.19.132 ens160:172.16.19.131 0 0 0 非默认路由网卡建邻问题使用非默认路由网卡作为 OSPF 网卡时，如开启严格的反向路由检查，收到的组播 224.0.0.5 的 hello 包会被 rp_filter 过滤掉，导致 ospfd 进程无法收到 hello 包，也就无法建邻。 解决方法：关闭或使用 loose 的反向路由检查。详细参考：rp_filter反向路由过滤 OSPF 多路径负载均衡OSPF 支持多路径的负载均衡，如两台 DNS Server，使用同样的 VIP，通过 OSPF 路由可以实现流量的负载均衡。 FRRouting 发布 VIP添加并开启虚拟网卡 vip_if0 12sudo ip link add vip_if0 type dummysudo ip link set vip_if0 up FRR 配置 vip_if0 网卡 123456!interface vip_if0 ip address 10.0.0.10&#x2F;32 ip ospf area 0.0.0.0exit! ip address 10.0.0.10/32 添加 10.0.0.10/32 作为 VIP ip ospf area 0.0.0.0 设置 vip_if0 为 OSPF 网卡，但此虚拟网卡实际无法建邻 BIRD 添加路由检查 BIRD 配置是否支持路由导出以及多路径路由 确认 BIRD 开启将学到的路由导出到内核路由表，确认 export all; 开启 123456789protocol kernel &#123; ipv4 &#123; # Connect protocol to IPv4 table by channel# table master4; # Default IPv4 table is master4# import all; # Import to table, default is import all export all; # Export to protocol. default is export none &#125;;# learn; # Learn alien routes from the kernel# kernel table 10; # Kernel table to synchronize with (default: main)&#125; 确认 OSPF 开启 ecmp，以支持 OSPF 多路径。ecmp 默认（不填写）为开启状态，limit 默认 16 123protocol ospf v2 &#123; ecmp &lt;switch&gt; [limit &lt;num&gt;];&#125; 查看 BIRD 是否学习到 VIP 路由，可以看到已经学习到了该 VIP 的两条路由 1234567bird&gt; show routeTable master4:10.0.0.10&#x2F;32 unicast [ospf1 05:38:47.681] * I (150&#x2F;20) [172.16.19.132] via 172.16.19.131 on ens256 weight 1 via 172.16.19.132 on ens256 weight 1172.16.19.0&#x2F;24 unicast [ospf1 04:35:44.681] * I (150&#x2F;10) [172.16.19.129] dev ens256 查看是否导入到了 Linux 路由表 123456root@ubuntu2404:/home/guoyi/workplace# ip route show...10.0.0.10 proto bird metric 32 nexthop via 172.16.19.131 dev ens256 weight 1 nexthop via 172.16.19.132 dev ens256 weight 1... 配置并运行 Coredns 添加 Coredns 配置及域名解析 /etc/coredns/Corefile 1234example.com &#123; log file &#x2F;etc&#x2F;coredns&#x2F;db.example.com&#125; /etc/coredns/db.example.com 1234567891011$TTL 3600@ IN SOA ns.example.com. admin.example.com. ( 1 ; Serial 3600 ; Refresh 1800 ; Retry 604800 ; Expire 86400 ) ; Minimum TTL@ IN NS ns.example.com.@ IN A 192.168.1.10ns IN A 192.168.1.10 停止 systemd-resolve 1systemctl stop systemd-resolved 运行 Coredns 1coredns -conf &#x2F;etc&#x2F;coredns&#x2F;Corefile 检查 Coredns 是否正常 1234567891011121314151617181920212223242526guoyi@ubuntu2:~$ dig @127.0.0.1 example.com; &lt;&lt;&gt;&gt; DiG 9.18.28-0ubuntu0.24.04.1-Ubuntu &lt;&lt;&gt;&gt; @127.0.0.1 example.com; (1 server found);; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 45115;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 1;; WARNING: recursion requested but not available;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 1232; COOKIE: a29f8e8fa133c213 (echoed);; QUESTION SECTION:;example.com. IN A;; ANSWER SECTION:example.com. 3600 IN A 192.168.1.10;; AUTHORITY SECTION:example.com. 3600 IN NS ns.example.com.;; Query time: 0 msec;; SERVER: 127.0.0.1#53(127.0.0.1) (UDP);; WHEN: Mon Dec 09 12:50:07 UTC 2024;; MSG SIZE rcvd: 118 打流在 BIRD 节点通过 dig VIP 打流，查看两个 Coredns 服务器日志是否负载均衡承接流量。 打流前先确认 BIRD 节点内核配置 net.ipv4.fib_multipath_hash_policy 1sysctl -a | grep net.ipv4.fib_multipath_hash_policy 该配置设置了多路径路由哈希策略，相同元组的包在多路径下会选择同一路径 net.ipv4.fib_multipath_hash_policy=0：{src_ip, dst_ip} net.ipv4.fib_multipath_hash_policy=1：{src_ip, src_port , dst_ip, dst_port, proto} 需将 net.ipv4.fib_multipath_hash_policy 设置为 1 1sysctl -w net.ipv4.fib_multipath_hash_policy=1 在 BIRD 节点打流到 VIP 1for i in &#123;1..1000&#125;; do dig @10.0.0.10 example.com; done 查看两个 Coredns 节点日志，可以看到两节点平分了 VIP 的流量","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://gy23333.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"FRRouting","slug":"FRRouting","permalink":"https://gy23333.github.io/tags/FRRouting/"},{"name":"BIRD","slug":"BIRD","permalink":"https://gy23333.github.io/tags/BIRD/"}]},{"title":"bird","slug":"bird","date":"2024-12-03T05:03:54.000Z","updated":"2024-12-09T13:14:57.909Z","comments":true,"path":"2024/12/03/bird/","link":"","permalink":"https://gy23333.github.io/2024/12/03/bird/","excerpt":"bird","text":"bird 安装 BIRDUbuntu 安装 bird 1sudo apt install bird2 检查 bird 是否安装成功 12345678910111213141516guoyi@ubuntu2404:~$ systemctl status bird● bird.service - BIRD Internet Routing Daemon Loaded: loaded (/usr/lib/systemd/system/bird.service; enabled; preset: enabled) Active: active (running) since Tue 2024-12-03 05:05:57 UTC; 5 days ago Main PID: 28186 (bird) Tasks: 1 (limit: 4542) Memory: 924.0K (peak: 1.9M) CPU: 4.824s CGroup: /system.slice/bird.service └─28186 /usr/sbin/bird -f -u bird -g birdDec 03 05:05:57 ubuntu2404 systemd[1]: Starting bird.service - BIRD Internet Routing Daemon...Dec 03 05:05:57 ubuntu2404 systemd[1]: Started bird.service - BIRD Internet Routing Daemon.Dec 03 05:05:57 ubuntu2404 (bird)[28186]: bird.service: Referenced but unset environment variable evaluates to an emp&gt;Dec 03 05:05:57 ubuntu2404 bird[28186]: Chosen router ID 172.16.19.129 according to interface ens160Dec 03 05:05:57 ubuntu2404 bird[28186]: Started birdc 命令通过 birdc 进入 重新加载配置 1configure 查看路由 1show route 查看 OSPF 邻居节点 1show ospf neighbors BIRD 配置默认配置路径 /etc/bird/bird.conf 参考 BIRD 中文文档","categories":[],"tags":[]},{"title":"rp_filter反向路由过滤","slug":"rp-filter反向路由过滤","date":"2024-11-22T15:54:54.000Z","updated":"2024-11-24T18:37:03.879Z","comments":true,"path":"2024/11/22/rp-filter反向路由过滤/","link":"","permalink":"https://gy23333.github.io/2024/11/22/rp-filter%E5%8F%8D%E5%90%91%E8%B7%AF%E7%94%B1%E8%BF%87%E6%BB%A4/","excerpt":"Reverse Path Filtering，Linux 内核对接收到的数据包的反向路由校验过滤，主要用于防止 IP 地址欺骗攻击。本文主要介绍该校验机制、系统配置方式以及过滤包查看方法。","text":"Reverse Path Filtering，Linux 内核对接收到的数据包的反向路由校验过滤，主要用于防止 IP 地址欺骗攻击。本文主要介绍该校验机制、系统配置方式以及过滤包查看方法。 反向路由校验机制反向路由校验，即在网卡收到数据包后，校验该数据包的反向路由是否匹配，如不匹配，则丢弃该包。具体流程如下： 对于网卡收到的数据包，Linux 内核会检查该数据包的源 IP 参照当前的路由表，判断如以该数据包的源 IP 作为目的 IP，返回路径的路由选择是否与当前接收接口一致 如不一致，则认为该数据包可能是伪造的，丢弃该数据包 如下图，eth1 网卡开启了严格的 rp_filter 检查，此时 eth1 网卡收到源 IP 为 172.16.19.24 的包，rp_filter 检查如果以 172.16.19.24 为目的 IP，根据路由表，匹配的网卡应该为 eth0，而不是收到包的 eth1，因此判断该数据包可能伪造源 IP，丢弃该包。 Linux 内核参数net.ipv4.conf.XXX.rp_filterLinux 内核参数详解 rp_filter 为 Linux 用于设置反向路由校验机制的内核参数，共有三种可配置值 0、1、2， rp_filter = 0：关闭反向路由校验。 rp_filter = 1：开启严格的反向路由校验。如果反向路由不是最佳路由，则丢弃该包。 rp_filter = 2：开启松散的反向路由校验。对于收到的数据包，只检查其源 IP 是否可达，即反向路由是否可通（任意网卡均可），如果反向路径不通，则丢弃该包。 rp_filter 分为三类：all、default、特定网卡。 default 用于生成网卡时设置默认的 rp_filter 值 每张网卡的 rp_filter 取 conf/{all,interface}/rp_filter 中的最大值 如下面配置，eth0 的 rp_filter 为 1（取 all 和 eth0 中的最大值），eth1 的 rp_filter 为 2（取 all 和 eth1 中的最大值） 123net.ipv4.conf.all.rp_filter = 1net.ipv4.conf.eth0.rp_filter = 0net.ipv4.conf.eth1.rp_filter = 2 查看 rp_filter1234567root@ubuntu2404:~# sysctl -a | grep rp_filternet.ipv4.conf.all.rp_filter = 2net.ipv4.conf.default.rp_filter = 2net.ipv4.conf.ens160.rp_filter = 2net.ipv4.conf.ens256.rp_filter = 2net.ipv4.conf.lo.rp_filter = 0... 设置 rp_filter临时设置（重启后失效） 12root@ubuntu2404:~# sysctl -w net.ipv4.conf.ens160.rp_filter=1net.ipv4.conf.ens160.rp_filter = 1 tcpdump 与 rp_filtertcpdump 依旧可以抓到被 rp_filter 过滤掉的包。 下图的五层网络分层模型中，收包是从下到上，发包是从上到下。 tcpdump 运行在链路层的网络设备层，而 rp_filter 运行在协议栈的网络层，对于收包流程来说，tcpdump 先于 rp_filter 进行，所以即使数据包会被 rp_filter 过滤掉，依旧可以通过 tcpdump 抓到该数据包。 rp_filter 日志默认情况下，内核并不会记录被 rp_filter 过滤掉的包，但可以通过 iptables 添加日志规则，模拟和预测哪些包会被 rp_filter 丢弃。 添加 iptables 日志规则（如需删除，则把其中的 -A 改成 -D） 1iptables -t raw -A PREROUTING -m rpfilter --invert -j LOG --log-prefix \"RP_FILTER_DROP: \" 查看添加的 iptables 日志规则 1234root@ubuntu2404:~# iptables -t raw -L PREROUTING -vChain PREROUTING (policy ACCEPT 299 packets, 20976 bytes) pkts bytes target prot opt in out source destination 299 20976 LOG all -- any any anywhere anywhere rpfilter invert LOG level warn prefix \"RP_FILTER_DROP: \" 查看内核日志 1dmesg -T | grep &quot;RP_FILTER_DROP&quot; 1234root@ubuntu2404:~# dmesg -T | grep \"RP_FILTER_DROP\" | tail -20[Sun Nov 24 18:27:49 2024] RP_FILTER_DROP: IN=ens256 OUT= MAC=00:0c:29:48:8d:03:ae:07:75:50:39:65:08:00 SRC=172.16.19.1 DST=172.16.19.129 LEN=88 TOS=0x0A PREC=0x40 TTL=64 ID=0 DF PROTO=TCP SPT=60402 DPT=22 WINDOW=2048 RES=0x00 ACK PSH URGP=0[Sun Nov 24 18:27:49 2024] RP_FILTER_DROP: IN=ens256 OUT= MAC=00:0c:29:48:8d:03:ae:07:75:50:39:65:08:00 SRC=172.16.19.1 DST=172.16.19.129 LEN=52 TOS=0x08 PREC=0x40 TTL=64 ID=0 DF PROTO=TCP SPT=60402 DPT=22 WINDOW=2047 RES=0x00 ACK URGP=0[Sun Nov 24 18:27:49 2024] RP_FILTER_DROP: IN=ens256 OUT= MAC=00:0c:29:48:8d:03:ae:07:75:50:39:65:08:00 SRC=172.16.19.1 DST=172.16.19.129 LEN=88 TOS=0x0A PREC=0x40 TTL=64 ID=0 DF PROTO=TCP SPT=60402 DPT=22 WINDOW=2048 RES=0x00 ACK PSH URGP=0","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://gy23333.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://gy23333.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Linux","slug":"Linux","permalink":"https://gy23333.github.io/tags/Linux/"}]},{"title":"Go调试器:Delve","slug":"Go调试器-Delve","date":"2024-11-18T17:06:33.000Z","updated":"2024-11-18T18:39:29.113Z","comments":true,"path":"2024/11/19/Go调试器-Delve/","link":"","permalink":"https://gy23333.github.io/2024/11/19/Go%E8%B0%83%E8%AF%95%E5%99%A8-Delve/","excerpt":"Go调试器:Delve","text":"Go调试器:Delve 安装1go install github.com&#x2F;go-delve&#x2F;delve&#x2F;cmd&#x2F;dlv@latest 检查安装是否成功 1dlv version 进入调试 调试源文件 1dlv debug main.go 调试可执行文件 1dlv exec .&#x2F;main 调试进程 1dlv attach &lt;PROCESS_ID&gt; 调试命令可以通过 help 查看所有命令 运行程序 命令 描述 call 恢复进程，调用函数 (实验阶段) continue(c) 继续运行程序，直到遇到断点或程序结束 next(n) 单步调试（跳过函数内部） step(s) 单步调试（进入函数内部） restart(r) 重新运行 stepout(so) 从当前函数跳出 断点 命令 描述 break(b) 设置断点 breakpoints(bp) 打印所有断点 clear 删除断点 clearall 删除所有断点 condition 设置条件断点 on 设置一个断点触发时执行的命令 toggle 打开/关闭 断点 查看变量 命令 描述 args 打印函数参数 display 每次程序停止时打印表达式的值 examinemem 解析给定地址的内存 locals 打印本地变量 print(p) 解析一个表达式 regs 打印寄存器信息 set 设置变量的值 vars 打印包内变量 whatis 打印类型信息","categories":[],"tags":[]},{"title":"算法题","slug":"算法题","date":"2024-11-17T14:58:09.000Z","updated":"2024-11-17T15:16:21.459Z","comments":true,"path":"2024/11/17/算法题/","link":"","permalink":"https://gy23333.github.io/2024/11/17/%E7%AE%97%E6%B3%95%E9%A2%98/","excerpt":"LeetCode Go 刷题记录","text":"LeetCode Go 刷题记录 哈希表参考 [力扣刷题攻略] Re：从零开始的力扣刷题生活","categories":[{"name":"算法","slug":"算法","permalink":"https://gy23333.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://gy23333.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"一致性哈希算法","slug":"一致性哈希算法","date":"2024-11-06T16:09:44.000Z","updated":"2024-11-12T18:01:02.564Z","comments":true,"path":"2024/11/07/一致性哈希算法/","link":"","permalink":"https://gy23333.github.io/2024/11/07/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/","excerpt":"一致性哈希，Consistent Hashing，用于分布式系统的负载均衡，解决了传统哈希算法的节点扩缩容问题。","text":"一致性哈希，Consistent Hashing，用于分布式系统的负载均衡，解决了传统哈希算法的节点扩缩容问题。 分布式系统在分布式系统中，集群由多台服务器组成，数据采用分布式缓存，期望将数据尽量均匀地分配缓存到各个服务器，每个服务器上有着不同的缓存，以分担压力。请求数据时，再到相应的服务器获取缓存。这部分工作由负载均衡层 LB 来完成。 分布式系统应满足下面要求： 对于同一个数据的请求落在相同的服务器上 数据分配尽量均匀 当服务器数量增减时，尽量减小原有数据分配变化 传统哈希算法传统哈希算法哈希算法采用取模运算，基于下面的公式，将 hash 值对机器数量取余，将数据的 key 映射到节点。 hash(key) \\% size 扩缩容问题服务器集群会因为业务量变化需求而扩缩容，增加或减少节点数，此时映射关系发生大量变化，缓存失效，需要进行数据迁移，以保证请求正常。数据迁移规模 O(M)，迁移成本极大，导致服务器瞬时压力巨大。 一致性哈希算法哈希环一致性哈希算法引入哈希环解决了扩缩容导致过多数据迁移问题。 一致性哈希算法同样采用了取模的方式，但与传统哈希不同，取模值固定为 $2^{32}$ hash(key) \\% 2^{32}可以把取模结果当做一个圆环，由 $2^{32}$ 个点组成，先将服务器取模映射到哈希环上，再将数据同样取模映射到环上，选择顺时针找到的第一个服务器存入。 此时添加一个节点，仅有少量的数据需要重新分配映射，大部分位置分配保持不变。 虚拟节点如果采用节点直接映射，可能存在节点分布不均匀问题，也就是 hash 偏斜。大部分的缓存落在少数几台服务器上，如果该台服务器发生故障，会导致瞬时大量数据迁移。 为了解决 hash 偏斜问题，引入虚拟节点。 将每个服务器映射为多个虚拟节点，数量足够多，以保证均匀分布。数据映射时先找到虚拟节点，再对应到相应的真实节点。 Go 实现一致性哈希","categories":[],"tags":[{"name":"Load Balancing","slug":"Load-Balancing","permalink":"https://gy23333.github.io/tags/Load-Balancing/"}]},{"title":"BGP 路由协议","slug":"BGP-路由协议","date":"2024-10-22T18:38:51.000Z","updated":"2024-11-11T03:57:58.125Z","comments":true,"path":"2024/10/23/BGP-路由协议/","link":"","permalink":"https://gy23333.github.io/2024/10/23/BGP-%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/","excerpt":"BGP 路由协议","text":"BGP 路由协议 BGP 路由选择策略对于同一个目的地址，路由器会收到多个路径，BGP 对这些路径进行选择分类，决定最终的路由选择 Available：可用路径 所有合法的可用路径 Best：最佳路径 通过 BGP 最佳路由选择策略，选出来的唯一一个路由，作为最佳路由 Select：选择路径 在 BGP 最佳路由选择策略中，前 8 步都与 Best Path 属性相同的路径 这些 Select Path 将会加入路由表，实现 BGP 负载均衡 BGP 最佳路由选择策略当路由器收到到同一个目的地址的多个 Available Path，BGP 最佳路由选择策略从中选出一条 Best Path。 以下是 BGP 最佳路径选择策略，按比较顺序排列： 优选权重（Weight）最高的路径 优选本地优先级（Local Preference）最高的路径 优选起本地生成的路径 本地内部生成的路由优先级高于从外部学到的路由 本地生成的路由，即通过network命令或aggregate命令手动注入的路由 优选 AS Path 长度最短的路径 AS Path：一个路由经过的自治系统（AS）序列 优先级比较 AS Path 长度，而非 AS Path 本身 路径 1 的 AS Path：65005 65004 65003 路径 2 的 AS Path：65006 65003 只比较两者的长度，路径 1 长度为 3，路径 2 长度为 2，优选路径 2 优选 Origin Type 优先级最高的路径 Origin Type 用于表示路由来源类型，共有三种： IGP：内部网关协议，Internal Gateway Protocol EGP：外部网关协议，Exterior Gateway Protocol Incomplete：不确定来源 优先级 IGP &gt; EGP &gt; Incomplete 优选 MED 最小的路径 MED，Multi-Exit Discriminator，多出口鉴别，只在两个 AS 之间交换，不会传到第三个 AS 两个 AS 之间可能有多条链路连接，MED 用于决定选择那条链路 MED 默认值：0 优选邻居路由器类型为 eBGP 先于 iBGP eBGP，external BGP，外部 BGP，不同 AS 之间的 BGP iBGP，internal BGP，内部 BGP，相同 AS 内部的 BGP 优选 eBGP 路由器，即优选跨 AZ 路径，到达这一步比较的路由，如同时有 eBGP 和 iBGP 路径，iBGP 路径是经过了内部转发再到 eBGP 路由器的绕行路径，所以优选直接到 eBGP 路由器的路径 优选到 BGP next hop 的 IGP 度量值最小的路径 IGP metric，内部路由度量值，在第七步中选择 iBGP 才需要比较步骤，否则跳过 IGP 越小，则去该下一跳的开销越小 到该步如存在多个路径条件都相同，则 BGP 负载均衡 优选来自 Route ID 最小的路由器的路径 优选 Cluster List 最短的路径 优选来自 IP 地址最小的 Neighbor 的路径 BGP 负载均衡BGP Multipath 允许给一个目的地址加载多个 BGP 路径到 IP 路由表，这些路由实现 BGP 负载均衡。这不影响上步中的 Best Path 的选择，依旧从多个路径中选择一条路径作为 Best Path。在此基础之上，可以选取多个路径作为 Select Path，一同加入路由表，实现多路径负载均衡。 Select Path 在路由选择策略中的前 8 步必须与 Best Path 完全相同，即有相同的 Weight、Local Preference、AS Path length、Origin Type、MED、eBGP/iBGP、IGP Metric Best Path 必然包含在 Select Path 中 maximum-paths 设置 BGP 最多允许的 Select Path 数量，如果设置为 1，则 Select Path 只能有一个，也就是 Best Path 参考 Select BGP Best Path Algorithm","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://gy23333.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://gy23333.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"路由协议","slug":"路由协议","permalink":"https://gy23333.github.io/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/"},{"name":"BGP","slug":"BGP","permalink":"https://gy23333.github.io/tags/BGP/"}]},{"title":"systemd","slug":"systemd","date":"2024-10-05T12:20:32.000Z","updated":"2024-11-11T03:57:58.130Z","comments":true,"path":"2024/10/05/systemd/","link":"","permalink":"https://gy23333.github.io/2024/10/05/systemd/","excerpt":"systemd 是 Linux 的系统和服务管理器。作为系统启动的第一个进程，初始化系统并且管理其他用户服务。","text":"systemd 是 Linux 的系统和服务管理器。作为系统启动的第一个进程，初始化系统并且管理其他用户服务。 概述systemd 提供了一套完整的系统启动和管理的解决方案，其中的 d 为守护进程（daemon）的缩写，即系统的守护进程。 查看 systemd 简介 1man systemd systemd 作为系统的第一个进程，PID = 1，其余所有进程都是 systemd 的子进程。 123456789101112131415root@ubuntu:~# pstree -psystemd(1)─┬─ModemManager(855)─┬─&#123;ModemManager&#125;(887) │ └─&#123;ModemManager&#125;(894) ├─NetworkManager(777)─┬─&#123;NetworkManager&#125;(854) │ └─&#123;NetworkManager&#125;(859) ├─VGAuthService(747) ├─accounts-daemon(766)─┬─&#123;accounts-daemon&#125;(778) │ └─&#123;accounts-daemon&#125;(811) ├─acpid(767) ├─avahi-daemon(770)───avahi-daemon(840) ├─bluetoothd(771) ├─colord(1484)─┬─&#123;colord&#125;(1486) │ └─&#123;colord&#125;(1488) ├─cron(773) ..... Unitsystemd 可以管理所有系统资源，unit 为 systemd 的基本管理单元，用于描述系统服务、资源、设备和其他对象，根据不同资源分为了 12 种 Unit。 Service unit：系统服务 Target unit：多个 Unit 构成的一个组 Device Unit：硬件设备 Mount Unit：文件系统的挂载点 Automount Unit：自动挂载点 Path Unit：文件或路径 Scope Unit：不是由 Systemd 启动的外部进程 Slice Unit：进程组 Snapshot Unit：Systemd 快照，可以切回某个快照 Socket Unit：进程间通信的 socket Swap Unit：swap 文件 Timer Unit：定时器 可通过 man systemd.service 查看各种 Unit 的简介。 配置每个 Unit 需设置对应类型的配置文件。Unit 配置分为三个区块：Unit、Service\\Timer\\Socket、Install Unit 区块Unit 的元数据，定义了 unit 的基本信息、依赖关系和启动顺序。 1234567[Unit]Description=服务或单元的描述Documentation=man:your-man-page(1) # 可选，文档链接Requires=其他-unit.service # 可选，定义强依赖Wants=其他-unit.service # 可选，定义弱依赖After=network.target # 可选，指定启动顺序Before=其他-unit.service # 可选，指定启动顺序 Description：简短描述 Documentation：文档地址，可以是手册页或 URL 依赖关系 例如：unit-A Requires/BindsTo/Wants/PartOf=unit-B.service Requires： 强依赖 unit-A 启动时，自动启动被依赖 unit-B，如果被依赖 unit-B 启动失败，则该 unit-A 也会启动失败 BindsTo： 强依赖 unit-A 启动时，自动启动被依赖 unit-B，如果被依赖 unit-B 启动失败，则该 unit-A 也会启动失败 unit-B 停止或者失败时，依赖 unit-B 的 unit-A 也会自动停止 Wants： 弱依赖 unit-A 启动时，自动启动被依赖 unit-B，但被依赖 unit-B 启动失败，也不会一些该 unit-A 启动 特性 Requires BindsTo Wants 启动行为 必须成功启动被依赖的 unit 必须成功启动被依赖的 unit 建议启动被依赖的 unit 停止行为 不会自动停止依赖它的 unit 自动停止依赖它的 unit 不会自动停止依赖它的 unit 依赖关系类型 单向强依赖 双向强依赖 弱依赖 适用场景 功能密切相关但生命周期不必一致的服务 需要同时运行并在同一生命周期内运行的服务 可能相互关联但非必需的服务 Conflicts：互斥关系，unit-A 和 unit-B 不能同时运行，当 unit-A 启动时，会自动停止 unit-B，反之亦然 PartOf：unit-A 是目标服务 unit-B 的一部分，当目标服务 unit-B 停止或被重启时，作为其一部分的 unit-A 也会停止或重启 启动顺序 例如：unit-A Before/After=unit-B.service Before：当前 unit A 应该在指定的 unit B 之前启动（A -&gt; B） After：当前 unit A 应该在指定的 unit B 之后启动（B -&gt; A） 顺序配置Before、After 只是设置一起启动时的顺序，A 服务启动时并不会自动启动 B 服务，如需设置自启动，需搭配依赖关系使用。 其他关系 Condition...：检查服务启动时的条件，如果条件不满足，服务将不会被启动，但不会导致启动失败 ConditionPathExists=：检查指定的文件或路径是否存在。如果路径存在，服务将启动 ConditionPathExistsGlob=：使用通配符检查路径是否匹配 ConditionPathIsDirectory=：检查指定路径是否是一个目录 ConditionPathIsSymbolicLink=：检查指定路径是否是一个符号链接 ConditionKernelCommandLine=：检查内核命令行参数是否包含指定的字符串 ConditionVirtualization=：检查当前系统是否运行在虚拟化环境中（如 KVM、LXC 等） ConditionHost=：检查主机名是否与指定值匹配 Assert...：对服务启动的条件进行强制检查。与 Condition 不同，如果指定的条件未满足，服务将不会启动，且系统会报告错误 AssertPathExists=：检查指定路径是否存在 AssertPathIsDirectory=：检查指定路径是否是目录 AssertPathIsSymbolicLink=：检查指定路径是否是符号链接 AssertKernelCommandLine=：检查内核命令行参数 AssertVirtualization=：检查当前系统是否在虚拟化环境中 类型区块Servicesystemd.service 是用于定义和管理系统服务的单位类型。 配置文件以 .service 结尾，主要用于描述如何启动、停止和管理服务。 .service 配置中，通过 [Service] 区块定义服务的启动和运行参数。 123456789101112[Service]Type=notifyEnvironmentFile=-/etc/default/sshExecStartPre=/usr/sbin/sshd -tExecStart=/usr/sbin/sshd -D $SSHD_OPTSExecReload=/usr/sbin/sshd -tExecReload=/bin/kill -HUP $MAINPIDKillMode=processRestart=on-failureRestartPreventExitStatus=255RuntimeDirectory=sshdRuntimeDirectoryMode=0755 启动类型 Type：配置服务如何通知systemd服务启动完成 simple（默认值）：systemd 调用完 ExecStart 后即认为服务启动成功，即使 ExecStart 运行失败，服务也启动成功 notify：启动时，服务通过 sd_notify() 发送一个 “READY=1” 信号，systemd 收到这个信号后才认为服务启动成功，再启动之后的 unit dbus：需设置 BusName=（如设置，自动为 dbus 类型），当 systemd 确认 BusName= 的 dbus 存在后，则认为服务启动成功 等等 启动命令 EnvironmentFile：启动时会加载这个配置的环境变量文件 ExecStartPre：启动服务之前执行的命令 如果 ExecStartPre 执行失败，则服务启动失败，不会执行 ExecStart 如果希望 ExecStartPre 执行失败也能继续执行 ExecStart，需在 ExecStartPre 加前缀 - 1ExecStartPre=-/usr/bin/check_dependencies 支持多个 ExecStartPre，按顺序执行 ExecStart（必选）：启动服务执行的命令 ExecStartPost：启动服务成功之后执行的命令 如果 Type 规定的启动没成功，则不会执行 ExecStartPost 终止类型 KillMode：停止服务时如何处理进程 control-group（默认值）：停止服务时，所有属于该服务 cgroup 的所有进程都会被杀死 process：停止服务时，只杀主进程，主进程产生的子进程不会被杀死 mixed：停止服务时，向主进程发送 SIGTERM 信号，接着向子进程发送 SIGKILL 信号 none：没有进程会被杀掉，只是执行服务的 ExecStop 命令 杀进程过程： 向进程发送KillSignal= 信号（默认为 SIGTERM） 等待进程被杀死 若等候 TimeoutStopSec= 时间（默认 90s）后，进程仍然未被杀死，向进程发送 FinalKillSignal= 信号（默认为 SIGKILL）强制杀死进程 终止命令 ExecStop字段：停止服务时执行的命令 ExecStopPost字段：停止服务之后执行的命令 重启类型 有时候，服务需要保持运行状态，如有意外奔溃，能自动拉起，可通过下面配置设置自拉起 123Restart&#x3D;alwaysRestartSec&#x3D;5StartLimitInterval&#x3D;0 Restart：重启机制，什么情况下会自动触发重启服务（systemctl stop/restart 触发的停止服务，不会被这里设置的重启机制拉起） no（默认值）：退出后不会重启 always：所有情况触发自动重启 on-success：只有正常退出时触发自动重启 on-failure：异常退出时触发自动重启 on-abnormal：只有被信号终止和超时，才会重启 on-abort：只有在收到没有捕捉到的信号终止时，才会重启 on-watchdog：超时退出，才会重启 退出原因 no always on-success on-failure on-abnormal on-abort on-watchdog systemctl stop 正常退出 restart restart 退出码不为“0” restart restart 进程被强制杀死 restart restart restart restart systemd操作超时 restart restart restart 看门狗超时 restart restart restart restart 正常退出：退出码为”0”， 或者进程收到 SIGHUP, SIGINT, SIGTERM, SIGPIPE 信号之一，并且退出码符合 SuccessExitStatus= 的设置 异常退出：包括退出码不为“0”、进程被强制杀死、systemd操作超时、看门狗超时 RestartSec：配合 Restart 使用，重新启动服务之前的睡眠时间，设置如异常退出后，等待多少秒再次启动，默认 100ms 123 |----RestartSec------|---------|-----------|--------------------|------------|---------- running stopping stopped starting running StartLimitInterval、StartLimitBurst：重启限制次数，在 StartLimitBurst= 时间内尝试重启超过 StartLimitInterval= 次则不再重启，默认为 10s 内 5 次，如需无限制，则设置 StartLimitInterval=0 重启命令 ExecReload字段：重启服务时执行的命令 Install 区块定义服务单元的安装和启用选项，指定如何将服务单元与目标（如启动目标或其他服务）关联。 12[Install]WantedBy=multi-user.target WantedBy：定义服务应该被哪些目标“需要”，这意味着在这些目标启动时，该服务也会被自动启动 示例说明服务所在 target 是 multi-user.target，这个设置很通用且重要 在 enable 这个服务后，在 /etc/systemd/system/multi-user.target.wants/ 的指定目录中创建了一个指向 /usr/lib/systemd/system/XXX.service 的符号链接 12root@ubuntu:~# systemctl enable nginxCreated symlink /etc/systemd/system/multi-user.target.wants/nginx.service → /usr/lib/systemd/system/nginx.service. 相当于为 multi-user.target 添加了 Wants=nginx 配置 当系统启动时, multi-user.target 启动，nginx.service 单元也会被启动 RequiredBy：类似于 WantedBy，但表示更强的依赖关系，如果目标启动失败，相关服务也不会启动 Alias：当前 Unit 的别名 Also：当前 Unit 启用（enable）或禁用（disable）时，会被同时（enable）或禁用（disable）的其他 Unit 配置路径配置文件存放在下面地址： 系统级目录：/lib/systemd/system/ Linux 系统提供的默认 unit 配置文件的存放位置 用户级目录：~/.config/systemd/user/ 用户级的 unit 配置文件，允许普通用户定义和管理自己的服务和任务。 本地配置目录：/etc/systemd/system/ 本地的 unit 配置文件，用户可以在这里创建或修改 unit 文件。 优先级顺序： /etc/systemd/system/（本地配置目录，最高优先级） /run/systemd/system/（临时配置，通常在运行时创建） /lib/systemd/system/（默认系统提供的配置） 优先级从高到低，如在高低优先级的目录下有同名 unit，则采用高优先级中的配置。 命令systemd 由一组系统命令组成，用来控制系统的方方面面。 systemctl参考链接：manpages、man systemctl systemctl 是 systemd 的主命令，用于控制 systemd 系统与服务。 命令格式：systemctl [OPTIONS...] COMMAND [UNIT...] 系统命令123456789101112131415161718# 列出 systemd 所有单位systemctl list-units# 通过 --type= 筛选出 unit 类型systemctl list-units --type=service# 通过 --state= 筛选出 unit 类型systemctl list-units --state=running# 列出 systemd 所有单元和状态systemctl list-unit-files# 列出已加载的套接字(socket)单元systemctl list-sockets# 列出已加载的定时器(timer)单元systemctl list-timers# 重新加载服务配置systemctl daemon-reload 单 Unit 命令1234567891011121314151617181920212223242526272829# 查看服务状态systemctl status [SERVICE]# 启动服务systemctl start [SERVICE]# 停止服务systemctl stop [SERVICE]# 重启服务systemctl restart [SERVICE]# 开机自启动服务systemctl enable [SERVICE]# 开机不自启动服务systemctl disable [SERVICE]# 显示服务信息systemctl show [SERVICE]# 读服务配置文件，等同于 cat 配置文件地址systemctl cat [SERVICE]# 编辑服务配置文件，相比直接 vim，编辑后可自动检查格式systemctl edit [SERVICE]# 显示指定 unit 的依赖关系systemctl list-dependencies [UNIT] journalctl参考链接：manpages、man journalctl journalctl 用来查看 systemd 日志，包括系统日志还有各 unit 日志。 服务：systemd-journald.service 命令格式：journalctl [OPTIONS...] [MATCHES...] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# 查看所有日志（默认情况下 ，只保存本次启动的日志）journalctl# 显示尾部指定行数的日志journalctl -n 20# 实时滚动显示最新日志journalctl -f# 查看内核日志（不显示应用日志）journalctl -k# 查看系统本次启动的日志journalctl -b# 查看上一次启动的日志journalctl -b -1# 查看指定时间的日志journalctl --since=\"2012-10-30 18:17:16\"journalctl --since \"20 min ago\"journalctl --since yesterdayjournalctl --since \"2015-01-10\" --until \"2015-01-11 03:00\"journalctl --since 09:00 --until \"1 hour ago\"# 查看指定服务的日志journalctl /usr/lib/systemd/systemd# 查看某个 Unit 的日志journalctl -u nginx.service# 合并显示多个 Unit 的日志journalctl -u nginx.service -u php-fpm.service --since today# 查看指定进程的日志journalctl _PID=1# 查看某个路径的脚本的日志journalctl /usr/bin/bash# 查看指定用户的日志journalctl _UID=33# 查看指定优先级（及其以上级别）的日志，共有8级# 0: emerg# 1: alert# 2: crit# 3: err# 4: warning# 5: notice# 6: info# 7: debugjournalctl -p err -b# 日志默认分页输出，--no-pager 改为正常的标准输出journalctl --no-pager# 以 JSON 格式（单行）输出journalctl -b -u nginx.service -o json# 以 JSON 格式（多行）输出，可读性更好journalctl -b -u nginx.service -o json-pretty# 显示日志占据的硬盘空间journalctl --disk-usage# 指定日志文件占据的最大空间journalctl --vacuum-size=1G# 指定日志文件保存多久journalctl --vacuum-time=1years loginctl参考链接：manpages、man loginctl loginctl命令用来控制 systemd 登录管理器（systemd-logind.service）。 服务：systemd-logind.service 命令格式：loginctl [OPTIONS...] {COMMAND} [NAME...] COMMAND 分为三种类型：用户、会话和席位 用户用户是操作系统中进行交互和操作的实体。在Linux中，每个用户都有一个唯一的用户名和用户ID（UID）。用户可以是普通用户、超级用户（root）等，拥有不同的权限。 会话会话是用户与系统之间的交互过程。当用户登录到Linux系统时，会创建一个会话。会话包含用户的环境设置、运行的程序、打开的文件等。一个用户可以同时拥有多个会话，例如在不同的终端或远程登录时。 席位席位（TTY或终端）是用户与系统之间交互的接口。在Linux中，每个物理或虚拟终端都被称为一个席位。用户可以通过这些席位输入命令并接收输出。现代Linux系统通常支持多个席位，例如通过虚拟终端（tty）或图形界面（X Window System）。 用户命令 列出当前登录用户 list-users 123456root@ubuntu:~# loginctl list-users UID USER 0 root1000 guoyi2 users listed. 显示用户状态user-status [USER...] 1234567891011121314151617181920212223242526root@ubuntu:~# loginctl user-status rootroot (0) Since: Sat 2024-10-05 01:40:47 PDT; 9h ago State: active Sessions: 321 *304 Linger: no Unit: user-0.slice ├─session-304.scope │ ├─57001 sshd: root@pts/1 │ ├─57094 -bash │ ├─58718 loginctl user-status root │ └─58719 pager ├─session-321.scope │ ├─58486 sshd: root@pts/2 │ └─58572 -bash └─user@0.service └─init.scope ├─57004 /lib/systemd/systemd --user └─57005 (sd-pam)Oct 05 01:40:48 ubuntu systemd[57004]: Condition check resulted in Sound System being sk&gt;Oct 05 01:40:48 ubuntu systemd[57004]: Listening on REST API socket for snapd user sessi&gt;Oct 05 01:40:48 ubuntu systemd[57004]: Listening on D-Bus User Message Bus Socket.Oct 05 01:40:48 ubuntu systemd[57004]: Reached target Sockets.Oct 05 01:40:48 ubuntu systemd[57004]: Reached target Basic System.Oct 05 01:40:48 ubuntu systemd[57004]: Condition check resulted in Sound Service being s 显示用户各属性show-user [USER...]，可以用 --all 选项查看缺省空置，使用 --property= 查看特定属性 12345678910111213141516root@ubuntu:~# loginctl show-user rootUID=0GID=0Name=rootTimestamp=Sat 2024-10-05 01:40:47 PDTTimestampMonotonic=574471117888RuntimePath=/run/user/0Service=user@0.serviceSlice=user-0.sliceDisplay=304State=activeSessions=321 304IdleHint=noIdleSinceHint=0IdleSinceHintMonotonic=0Linger=no 等等 会话命令 列出当前所有会话 list-sessions 1234567root@ubuntu:~# loginctl list-sessionsSESSION UID USER SEAT TTY 2 1000 guoyi seat0 tty2 304 0 root 321 0 root3 sessions listed. 显示简洁的会话状态信息session-status [ID...] 1234567891011121314root@ubuntu:~# loginctl session-status 304304 - root (0) Since: Sat 2024-10-05 01:40:47 PDT; 9h ago Leader: 57001 (sshd) Remote: 192.168.45.1 Service: sshd; type tty; class user State: active Unit: session-304.scope ├─57001 sshd: root@pts/1 ├─57094 -bash ├─58744 loginctl session-status 304 └─58745 pagerOct 05 01:40:48 ubuntu systemd[1]: Started Session 304 of user root. 显示会话的各项属性值show-session [ID...] 123456789101112131415161718192021root@ubuntu:~# loginctl show-session 321Id=321User=0Name=rootTimestamp=Sat 2024-10-05 10:31:06 PDTTimestampMonotonic=606290337700VTNr=0Remote=yesRemoteHost=192.168.45.1Service=sshdScope=session-321.scopeLeader=58486Audit=321Type=ttyClass=userActive=yesState=activeIdleHint=noIdleSinceHint=0IdleSinceHintMonotonic=0LockedHint=no 等等 席位命令 显示所有可用席位list-seats 12345root@ubuntu:~# loginctl list-seatsSEATseat01 seats listed. 等等 参考 官方文档","categories":[{"name":"Linux","slug":"Linux","permalink":"https://gy23333.github.io/categories/Linux/"}],"tags":[{"name":"systemd","slug":"systemd","permalink":"https://gy23333.github.io/tags/systemd/"},{"name":"Linux","slug":"Linux","permalink":"https://gy23333.github.io/tags/Linux/"}]},{"title":"Docker","slug":"Docker","date":"2024-09-19T05:48:28.000Z","updated":"2025-01-15T14:29:58.382Z","comments":true,"path":"2024/09/19/Docker/","link":"","permalink":"https://gy23333.github.io/2024/09/19/Docker/","excerpt":"基于 Go 的开源应用容器引擎 Docker","text":"基于 Go 的开源应用容器引擎 Docker 快速了解 Docker快速了解 docker 的小视频 【docker是什么？和kubernetes(k8s)是什么关系？-哔哩哔哩】 Docker 是一款能将程序和环境一起打包并运行的工具软件。Docker 作为中间层，使得应用和机器基础架构分离，从而实现不同架构下的快速交付部署。 程序和环境打包构建成一个容器镜像文件，根据 Dockerfile 构建出容器镜像，Dockerfile 中设置包括指定环境的基础镜像（如 ubuntu/centos、python/go 等等）以及后续需执行的命令（比如安装依赖、运行服务等）。 部署环境部署容器镜像，就会在 Linux 上以一个进程的形式运行该 docker 容器，利用操作系统的用户空间构建出应用所需的环境，运行相应服务。 Docker Registy：相当于 docker 镜像的代码仓，也就是镜像仓，可以将 docker 镜像推到 Registy，部署环境再从 Registy 拉取镜像。 Docker Compose：一整套服务经常包含多个 docker 镜像部署到单节点，这时候就可以使用 Docker Compose 来部署，通过 yaml 文件呢规定各个 docker 镜像间的部署顺序与其他部署配置信息。 Docker Swarm：解决一整套服务在多个节点间的部署问题，如迁移、扩缩容。 k8s：与 Docker Swarm 类似，也是解决一整套服务在多个节点间的部署问题，如迁移、扩缩容。 虚拟化过程物理机物理机存在的痛点： 各个应用会共享依赖库，所以有可能存在不同应用依赖有冲突的问题，比如需要同一个依赖的不同版本 低使用率，可能仅有几个应用在运行，却得占用一整台物理机 爆炸半径大，比如改变一个应用的依赖，可以会导致另一应用变得不可用 开关机慢 创建和搭建物理机慢 虚拟机物理机上的 Hypervisor 会从物理机分离出独立的资源池，在这个资源池中生成虚拟化硬件以及与物理机相同的上方结构。 Hypervisor 分为两类： Type 1：不依赖物理机上的 OS，比如 VMware、Hyper-V Type 2：依赖物理机上的 OS，比如 Virtual Box 虚拟机一定程度上缓解了物理机的问题。 应用运行在不同的虚拟机上，实现相互隔离，解决了依赖冲突问题 可以根据需要分配相应的规格，提高使用率 减小了爆炸半径 开关机变为分钟级 最大的好处：可以快速构建虚拟机 容器容器的载体可以是物理机也可以是虚拟机，和虚拟机的 Hypervisor 相对，容器通过 Container Runtime 控制。 容器与虚拟机的最大不同点： 虚拟机复制了一份 Linux 内核 容器并不存在内核，而是与载体的 OS 共用一个内核 容器的好处： 无依赖冲突问题 进一步提高了资源利用率。虚拟机还需要构造一套 OS，而容器可以直接依赖于宿主机的 OS 进一步减小了爆炸半径。每个容器所占的资源相对更少了，爆炸半径也就相对减小。不过其实隔离性是不如虚拟机的 开关容器时间短（秒级） 极快速部署 日常结构 Docker 架构Docker 采用 client-server 架构，由 Docker Client 发出指令，命令 Docker daemon 构建、运行、分发 Docker containers。Docker Client 和 Docker daemon 可以运行在同一个节点，也可以用 Docker Client 控制远程的 Docker daemon。 镜像 Image容器镜像是一个由程序和环境构建出的标准包，包括了用来运行容器所需的文件、二进制文件、库以及配置。 容器 ContainerUbuntu 中安装 Docker Enginehttps://docs.docker.com/engine/install/ubuntu/ 卸载老版本 1for pkg in docker.io docker-doc docker-compose docker-compose-v2 podman-docker containerd runc; do sudo apt-get remove $pkg; done 更新 Ubuntu 源列表 1apt-get update 安装 docker 依赖包 1apt-get install ca-certificates curl 添加 docker 官方 GPG 密钥 123install -m 0755 -d /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.ascchmod a+r /etc/apt/keyrings/docker.asc 添加 docker 官方库 1234echo \\ \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\ $(. /etc/os-release &amp;&amp; echo \"$VERSION_CODENAME\") stable\" | \\ sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null 更新 Ubuntu 源列表 1apt-get update 安装 docker 1sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 查看 docker 服务运行状态 1systemctl status docker 配置国内镜像1vim &#x2F;etc&#x2F;docker&#x2F;daemon.json 123456789&#123; &quot;registry-mirrors&quot;: [ &quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;, &quot;https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&quot;, &quot;https:&#x2F;&#x2F;hub-mirror.c.163.com&quot;, &quot;https:&#x2F;&#x2F;mirror.baidubce.com&quot;, &quot;https:&#x2F;&#x2F;ccr.ccs.tencentyun.com&quot; ]&#125; 12systemctl daemon-reloadsystemctl restart docker 123456789root@ubuntu2404:&#x2F;home&#x2F;guoyi# s... Registry Mirrors: https:&#x2F;&#x2F;registry.docker-cn.com&#x2F; https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&#x2F; https:&#x2F;&#x2F;hub-mirror.c.163.com&#x2F; https:&#x2F;&#x2F;mirror.baidubce.com&#x2F; https:&#x2F;&#x2F;ccr.ccs.tencentyun.com&#x2F;... Docker 从构建到部署Docker 镜像构建Docker 镜像仓Docker 容器部署Docker 命令查看正在运行的容器 1docker ps 查看所有容器 1docker ps -a 开启容器 1docker start &lt;CONTAINER ID&gt; 停止容器 1docker stop &lt;CONTAINER ID&gt; 执行命令 1docker exec -it &lt;CONTAINER ID&gt; &lt;CLI&gt; Docker ComposeDocker Swarm 与 k8s参考 docker 官网 https://www.youtube.com/watch?v=RqTEHSBrYFw","categories":[{"name":"Docker","slug":"Docker","permalink":"https://gy23333.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://gy23333.github.io/tags/Docker/"}]},{"title":"FRRouting","slug":"FRRouting","date":"2024-09-19T05:48:11.000Z","updated":"2024-12-08T17:40:21.299Z","comments":true,"path":"2024/09/19/FRRouting/","link":"","permalink":"https://gy23333.github.io/2024/09/19/FRRouting/","excerpt":"FRRouting（FRR）是一款提供 IP 路由服务的开源套件，支持 BGP、OSPF、RIP、IS-IS 等等路由协议。FRR 可以在网络栈中与其他路由器交换路由信息，做出路由策略决策，并将决策通知给其他层。","text":"FRRouting（FRR）是一款提供 IP 路由服务的开源套件，支持 BGP、OSPF、RIP、IS-IS 等等路由协议。FRR 可以在网络栈中与其他路由器交换路由信息，做出路由策略决策，并将决策通知给其他层。 FRR 安装两种安装方法 apt1sudo apt install frr 源码编译Ubuntu 22.04 安装 FRRouting 安装依赖123456789sudo apt updatesudo apt-get install \\ git autoconf automake libtool make libreadline-dev texinfo \\ pkg-config libpam0g-dev libjson-c-dev bison flex \\ libc-ares-dev python3-dev python3-sphinx \\ install-info build-essential libsnmp-dev perl \\ libcap-dev libelf-dev libunwind-dev \\ protobuf-c-compiler libprotobuf-c-devsudo apt-get install cmake libpcre2-dev 安装 libyang12345678git clone https:&#x2F;&#x2F;github.com&#x2F;CESNET&#x2F;libyang.gitcd libyanggit checkout v2.1.128mkdir build; cd buildcmake --install-prefix &#x2F;usr \\ -D CMAKE_BUILD_TYPE:String&#x3D;&quot;Release&quot; ..makesudo make install 配置 FRR 用户/用户组12345sudo groupadd -r -g 92 frrsudo groupadd -r -g 85 frrvtysudo adduser --system --ingroup frr --home &#x2F;var&#x2F;run&#x2F;frr&#x2F; \\ --gecos &quot;FRR suite&quot; --shell &#x2F;sbin&#x2F;nologin frrsudo usermod -a -G frrvty frr 安装 FRR123456789101112131415161718192021222324git clone https:&#x2F;&#x2F;github.com&#x2F;frrouting&#x2F;frr.git frrcd frr.&#x2F;bootstrap.sh.&#x2F;configure \\ --prefix&#x3D;&#x2F;usr \\ --includedir&#x3D;\\$&#123;prefix&#125;&#x2F;include \\ --bindir&#x3D;\\$&#123;prefix&#125;&#x2F;bin \\ --sbindir&#x3D;\\$&#123;prefix&#125;&#x2F;lib&#x2F;frr \\ --libdir&#x3D;\\$&#123;prefix&#125;&#x2F;lib&#x2F;frr \\ --libexecdir&#x3D;\\$&#123;prefix&#125;&#x2F;lib&#x2F;frr \\ --sysconfdir&#x3D;&#x2F;etc \\ --localstatedir&#x3D;&#x2F;var \\ --with-moduledir&#x3D;\\$&#123;prefix&#125;&#x2F;lib&#x2F;frr&#x2F;modules \\ --enable-configfile-mask&#x3D;0640 \\ --enable-logfile-mask&#x3D;0640 \\ --enable-snmp&#x3D;agentx \\ --enable-multipath&#x3D;64 \\ --enable-user&#x3D;frr \\ --enable-group&#x3D;frr \\ --enable-vty-group&#x3D;frrvty \\ --with-pkg-git-version \\ --with-pkg-extra-version&#x3D;-MyOwnFRRVersionmakesudo make install 生成配置123456sudo install -m 775 -o frr -g frr -d &#x2F;var&#x2F;log&#x2F;frrsudo install -m 775 -o frr -g frrvty -d &#x2F;etc&#x2F;frrsudo install -m 640 -o frr -g frrvty tools&#x2F;etc&#x2F;frr&#x2F;vtysh.conf &#x2F;etc&#x2F;frr&#x2F;vtysh.confsudo install -m 640 -o frr -g frr tools&#x2F;etc&#x2F;frr&#x2F;frr.conf &#x2F;etc&#x2F;frr&#x2F;frr.confsudo install -m 640 -o frr -g frr tools&#x2F;etc&#x2F;frr&#x2F;daemons.conf &#x2F;etc&#x2F;frr&#x2F;daemons.confsudo install -m 640 -o frr -g frr tools&#x2F;etc&#x2F;frr&#x2F;daemons &#x2F;etc&#x2F;frr&#x2F;daemons 启动服务123sudo install -m 644 tools&#x2F;frr.service &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;frr.servicesudo systemctl enable frrsudo systemctl start frr 查看安装完成的 FRR 123456789101112131415161718192021222324252627guoyi@ubuntu2:~/frr$ systemctl status frr● frr.service - FRRouting Loaded: loaded (/etc/systemd/system/frr.service; enabled; preset: enabled) Active: active (running) since Sun 2024-12-08 07:42:09 UTC; 7s ago Docs: https://frrouting.readthedocs.io/en/latest/setup.html Process: 38567 ExecStart=/usr/lib/frr/frrinit.sh start (code=exited, status=0/SUCCESS) Main PID: 38578 (watchfrr) Status: \"FRR Operational\" Tasks: 8 (limit: 4550) Memory: 14.5M (peak: 28.2M) CPU: 89ms CGroup: /system.slice/frr.service ├─38578 /usr/lib/frr/watchfrr -d -F traditional zebra mgmtd staticd ├─38589 /usr/lib/frr/zebra -d -F traditional -A 127.0.0.1 -s 90000000 ├─38594 /usr/lib/frr/mgmtd -d -F traditional -A 127.0.0.1 └─38596 /usr/lib/frr/staticd -d -F traditional -A 127.0.0.1Dec 08 07:42:09 ubuntu2 watchfrr[38578]: [VTVCM-Y2NW3] Configuration Read in Took: 00:00:00Dec 08 07:42:09 ubuntu2 frrinit.sh[38600]: [38600|zebra] doneDec 08 07:42:09 ubuntu2 frrinit.sh[38616]: [38616|staticd] doneDec 08 07:42:09 ubuntu2 frrinit.sh[38614]: [38614|watchfrr] doneDec 08 07:42:09 ubuntu2 watchfrr[38578]: [QDG3Y-BY5TN] zebra state -&gt; up : connect succeededDec 08 07:42:09 ubuntu2 watchfrr[38578]: [QDG3Y-BY5TN] mgmtd state -&gt; up : connect succeededDec 08 07:42:09 ubuntu2 watchfrr[38578]: [QDG3Y-BY5TN] staticd state -&gt; up : connect succeededDec 08 07:42:09 ubuntu2 watchfrr[38578]: [KWE5Q-QNGFC] all daemons up, doing startup-complete notifyDec 08 07:42:09 ubuntu2 frrinit.sh[38567]: * Started watchfrrDec 08 07:42:09 ubuntu2 systemd[1]: Started frr.service - FRRouting. FRR 基础Daemons 配置文件Daemons 配置文件用来设置 FRR 的哪些 daemon 需要在 FRR 启动时被激活，并且设置 daemon 启动时的参数。 通常放在 /etc/frr/daemons，如果修改了里面的内容，需要重启 FRR 服务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126# This file tells the frr package which daemons to start.## Sample configurations for these daemons can be found in# &#x2F;usr&#x2F;share&#x2F;doc&#x2F;frr&#x2F;examples&#x2F;.## ATTENTION:## When activating a daemon for the first time, a config file, even if it is# empty, has to be present *and* be owned by the user and group &quot;frr&quot;, else# the daemon will not be started by &#x2F;etc&#x2F;init.d&#x2F;frr. The permissions should# be u&#x3D;rw,g&#x3D;r,o&#x3D;.# When using &quot;vtysh&quot; such a config file is also needed. It should be owned by# group &quot;frrvty&quot; and set to ug&#x3D;rw,o&#x3D; though. Check &#x2F;etc&#x2F;pam.d&#x2F;frr, too.## The watchfrr, zebra and staticd daemons are always started.#bgpd&#x3D;noospfd&#x3D;yesospf6d&#x3D;noripd&#x3D;noripngd&#x3D;noisisd&#x3D;nopimd&#x3D;nopim6d&#x3D;noldpd&#x3D;nonhrpd&#x3D;noeigrpd&#x3D;nobabeld&#x3D;nosharpd&#x3D;nopbrd&#x3D;nobfdd&#x3D;nofabricd&#x3D;novrrpd&#x3D;nopathd&#x3D;no## If this option is set the &#x2F;etc&#x2F;init.d&#x2F;frr script automatically loads# the config via &quot;vtysh -b&quot; when the servers are started.# Check &#x2F;etc&#x2F;pam.d&#x2F;frr if you intend to use &quot;vtysh&quot;!#vtysh_enable&#x3D;yeszebra_options&#x3D;&quot; -A 127.0.0.1 -s 90000000&quot;mgmtd_options&#x3D;&quot; -A 127.0.0.1&quot;bgpd_options&#x3D;&quot; -A 127.0.0.1&quot;ospfd_options&#x3D;&quot; -A 127.0.0.1&quot;ospf6d_options&#x3D;&quot; -A ::1&quot;ripd_options&#x3D;&quot; -A 127.0.0.1&quot;ripngd_options&#x3D;&quot; -A ::1&quot;isisd_options&#x3D;&quot; -A 127.0.0.1&quot;pimd_options&#x3D;&quot; -A 127.0.0.1&quot;pim6d_options&#x3D;&quot; -A ::1&quot;ldpd_options&#x3D;&quot; -A 127.0.0.1&quot;nhrpd_options&#x3D;&quot; -A 127.0.0.1&quot;eigrpd_options&#x3D;&quot; -A 127.0.0.1&quot;babeld_options&#x3D;&quot; -A 127.0.0.1&quot;sharpd_options&#x3D;&quot; -A 127.0.0.1&quot;pbrd_options&#x3D;&quot; -A 127.0.0.1&quot;staticd_options&#x3D;&quot;-A 127.0.0.1&quot;bfdd_options&#x3D;&quot; -A 127.0.0.1&quot;fabricd_options&#x3D;&quot;-A 127.0.0.1&quot;vrrpd_options&#x3D;&quot; -A 127.0.0.1&quot;pathd_options&#x3D;&quot; -A 127.0.0.1&quot;# If you want to pass a common option to all daemons, you can use the# &quot;frr_global_options&quot; variable.##frr_global_options&#x3D;&quot;&quot;# The list of daemons to watch is automatically generated by the init script.# This variable can be used to pass options to watchfrr that will be passed# prior to the daemon list.## To make watchfrr create&#x2F;join the specified netns, add the the &quot;--netns&quot;# option here. It will only have an effect in &#x2F;etc&#x2F;frr&#x2F;&lt;somename&gt;&#x2F;daemons, and# you need to start FRR with &quot;&#x2F;usr&#x2F;lib&#x2F;frr&#x2F;frrinit.sh start &lt;somename&gt;&quot;.##watchfrr_options&#x3D;&quot;&quot;# configuration profile##frr_profile&#x3D;&quot;traditional&quot;#frr_profile&#x3D;&quot;datacenter&quot;# This is the maximum number of FD&#39;s that will be available. Upon startup this# is read by the control files and ulimit is called. Uncomment and use a# reasonable value for your setup if you are expecting a large number of peers# in say BGP.##MAX_FDS&#x3D;1024# Uncomment this option if you want to run FRR as a non-root user. Note that# you should know what you are doing since most of the daemons need root# to work. This could be useful if you want to run FRR in a container# for instance.# FRR_NO_ROOT&#x3D;&quot;yes&quot;# For any daemon, you can specify a &quot;wrap&quot; command to start instead of starting# the daemon directly. This will simply be prepended to the daemon invocation.# These variables have the form daemon_wrap, where &#39;daemon&#39; is the name of the# daemon (the same pattern as the daemon_options variables).## Note that when daemons are started, they are told to daemonize with the &#96;-d&#96;# option. This has several implications. For one, the init script expects that# when it invokes a daemon, the invocation returns immediately. If you add a# wrap command here, it must comply with this expectation and daemonize as# well, or the init script will never return. Furthermore, because daemons are# themselves daemonized with -d, you must ensure that your wrapper command is# capable of following child processes after a fork() if you need it to do so.## If your desired wrapper does not support daemonization, you can wrap it with# a utility program that daemonizes programs, such as &#39;daemonize&#39;. An example# of this might look like:## bgpd_wrap&#x3D;&quot;&#x2F;usr&#x2F;bin&#x2F;daemonize &#x2F;usr&#x2F;bin&#x2F;mywrapper&quot;## This is particularly useful for programs which record processes but lack# daemonization options, such as perf and rr.## If you wish to wrap all daemons in the same way, you may set the &quot;all_wrap&quot;# variable.##all_wrap&#x3D;&quot;&quot; crash 日志FRR 各个 daemon 的 crash 日志储存在固定位置，即 /var/tmp/frr/&lt;daemon&gt;[-&lt;instance&gt;].&lt;pid&gt;/crashlog 日志配置在 frr.conf 中可以配置日志文件输出 1log file &#x2F;var&#x2F;log&#x2F;frr&#x2F;frr.log [logging_level] vtyshroot 权限或者 frrvty 权限可以使用 vtysh 命令进入交互模式 show 命令 show ip ospf neighbor 查看 OSPF 邻居，其中 Neighbor ID：邻居的 Router ID Pri：邻居的 Priority State：邻居状态 1234568ade633bf9# show ip ospf neighborNeighbor ID Pri State Up Time Dead Time Address Interface RXmtL RqstL DBsmL12.12.0.2 1 Full/Backup 22h48m43s 37.418s 11.11.0.3 eth1:11.11.0.2 0 0 0 FRR 和其他路由器交换路由信息、 支持北向grpc接口 或 vtysh 命令 进入配置模式 1configure terminal 配置网卡 1interface ens38 VIP是192.168.1.1/24，你要发布到OSPF区域0，且设置成本为10 1234567891011121314vtyshconfigure terminalinterface eth0 ip address 192.168.1.1&#x2F;24!router ospf network 192.168.1.0&#x2F;24 area 0!interface eth0 ip ospf cost 10 endwrite memory 12345678910vtyshconfigure terminalinterface eth0 no ip address 192.168.1.1&#x2F;24!router ospf 1 no network 192.168.1.0&#x2F;24 area 0!interface eth0 ip ospf cost 10 1show ip route ospf 查看 DR 1show ip ospf neighbor 查看 ospf 路由 1show ip ospf route FRR 配置配置命令 查看当前配置 1show running-config 进入配置模式 1configure terminal 写到配置文件 1write memory 退回上一级 q prefix-list 配置prefix-list（前缀列表）用于匹配和过滤 IP 地址 定义 prefix-list下面只是定义一条前缀列表规则，如未设置应用，不会起任何作用 1ip prefix-list NAME [seq NUMBER] (permit|deny) PREFIX [le LEN] [ge LEN] NAME：定义的该前缀列表的名字，用于唯一标识该 prefix-list seq：规则序号，匹配的优先级，序号越小越先匹配，可自动设置，自动设置以 5 为增量 permit|deny：匹配到的前缀将被允许通过/被过滤掉 PREFIX：匹配的网络地址和前缀长度 le：匹配的最长子网掩码长度 ge：匹配的最短子网掩码长度 配置示例 123456&#x2F;&#x2F; 定义一个命名为 PLIST-1 的 prefix-list，拒绝所有前缀ip prefix-list PLIST-1 seq 5 deny 0.0.0.0&#x2F;0 le 32&#x2F;&#x2F; 定义一个命名为 PLIST-2 的 prefix-list，接受前缀 IP 为 1.1.1.1 和 2.2.2.2 的前缀ip prefix-list PLIST-2 seq 5 permit 1.1.1.1&#x2F;32ip prefix-list PLIST-2 seq 10 permit 2.2.2.2&#x2F;32 前缀匹配规则 优先匹配 seq 小的规则，逐条检查匹配，如果匹配上，则后续条目无需再检查 如果未设置任何 prefix-list，则视为所有 prefix 都 permit 默认拒绝：如果设置有 prefix-list，但未匹配到任何一条规则，则默认拒绝该 prefix 匹配规则： 检查 prefix IP 是否匹配 network/prefix-length 如果有设置 ge 或 le，则检查 prefix 长度是否在 &gt;=ge 以及 &lt;=le 范围内 比如 192.168.1.0/24 ge 25 le 30 IP 匹配范围 192.168.1.0 ~ 192.168.1.255 前缀长度在 25 ~ 30 192.168.1.0/24 不匹配（前缀长度不匹配）、192.168.1.0/25 匹配、192.168.1.30/28 匹配 查看 prefix-list1show ip prefix-list route-map 配置用于匹配和过滤路由 定义 route-map下面只是定义一条路由匹配规则，如未设置应用，不会起任何作用 123route-map ROUTE-MAP-NAME (permit|deny) ORDER match &lt;conditions&gt; set &lt;actions&gt; ROUTE-MAP-NAME：定义的该 route-map 的名字，用于唯一标识该 route-map permit|deny ：是否允许匹配的路由通过 ORDER：规则序号，匹配的优先级，序号越小越先匹配，可自动设置，自动设置以 10 为增量 match：匹配条件 set：设置动作，如果 match 匹配上了，则给该条路由执行设置动作 配置示例 1234567route-map EXAMPLE permit 10 match ip address prefix-list LIST-1 set local-preference 200route-map EXAMPLE permit 20 match ip address prefix-list LIST-2 set local-preference 100 match 匹配条件路由匹配条件，只有全部满足才算匹配 match ip address prefix-list PREFIX_LIST IP 地址被 prefix-list PREFIX_LIST 匹配并允许通过的路由则匹配 set 设置动作路由匹配规则 优先匹配 order 小的 route map，逐条检查匹配，如果匹配上，则后续条目无需再检查 默认拒绝：如果所有的 route map 都没匹配上，则默认拒绝该路由 匹配规则： 检查是否匹配上 match 的匹配规则，如果是匹配 prefix-list，需要被 prefix-list permit 才算匹配上该 match route-map 应用OSPF 组网搭建下面一个网络，使用 Docker 模拟出三台 FRR 路由器，并给其配网，其中有两个网段：Router 1 的 eth1 和 Router 2 的 eth1、Router 3 的 eth1 和 Router 2 的 eth2，使用 FRR 让 Router 1 和 Router 3 学习到到对方的路由。 1. Docker 模拟 FRR 路由器模拟 3 台 FRR 路由器 Docker 123docker run -d --privileged --net&#x3D;none --name frr-01 quay.io&#x2F;frrouting&#x2F;frr:10.0.0docker run -d --privileged --net&#x3D;none --name frr-02 quay.io&#x2F;frrouting&#x2F;frr:10.0.0docker run -d --privileged --net&#x3D;none --name frr-03 quay.io&#x2F;frrouting&#x2F;frr:10.0.0 查看 docker 进程 12345root@ubuntu:~# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES6185c04f06d1 quay.io/frrouting/frr:10.0.0 \"/sbin/tini -- /usr/…\" 2 minutes ago Up 2 minutes frr-031681fd9bd374 quay.io/frrouting/frr:10.0.0 \"/sbin/tini -- /usr/…\" 3 minutes ago Up 3 minutes frr-02568ade633bf9 quay.io/frrouting/frr:10.0.0 \"/sbin/tini -- /usr/…\" 24 hours ago Up 24 hours frr-01 2. OvS 配网由于安装 docker 容器时使用 --net=none 无网络，需根据拓扑对容器配网 查看各个路由器的网卡，当前各 docker 容器无网卡 1234567891011121314151617181920212223242526272829root@ubuntu:~# docker exec -it frr-01 ifconfiglo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B)root@ubuntu:~# docker exec -it frr-02 ifconfiglo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B)root@ubuntu:~# docker exec -it frr-03 ifconfiglo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) 安装 OvS 虚拟交换机用来搭建容器网络 1apt-get install openvswitch-switch 创建一个网桥交换机 1ovs-vsctl add-br brConn 如需删除，使用 ovs-vsctl del-br brConn 查看创建好的网桥 1234567root@ubuntu:~# ovs-vsctl showcb63c817-8d63-4d1f-b599-9950b0aeb2eb Bridge brConn Port brConn Interface brConn type: internal ovs_version: \"2.13.8\" 让三台 docker 路由器都连接到这个交换机，并配置 IP 1234ovs-docker add-port brConn eth1 frr-01 --ipaddress&#x3D;11.11.0.2&#x2F;24ovs-docker add-port brConn eth1 frr-02 --ipaddress&#x3D;11.11.0.3&#x2F;24ovs-docker add-port brConn eth2 frr-02 --ipaddress&#x3D;12.12.0.2&#x2F;24ovs-docker add-port brConn eth1 frr-03 --ipaddress&#x3D;12.12.0.3&#x2F;24 再次查看网桥 123456789101112131415root@ubuntu:~# ovs-vsctl showcb63c817-8d63-4d1f-b599-9950b0aeb2eb Bridge brConn Port brConn Interface brConn type: internal Port \"0021a5f25d344_l\" Interface \"0021a5f25d344_l\" Port \"1529171a9a294_l\" Interface \"1529171a9a294_l\" Port df2bf7ec96bd4_l Interface df2bf7ec96bd4_l Port a67433ae00b04_l Interface a67433ae00b04_l ovs_version: \"2.13.8\" 此时上各个 Docker 可以看到已配好的网卡 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465root@ubuntu:~# docker exec -it frr-01 ifconfigeth1 Link encap:Ethernet HWaddr 1A:CF:B4:C0:93:4B inet addr:11.11.0.2 Bcast:0.0.0.0 Mask:255.255.255.0 inet6 addr: fe80::18cf:b4ff:fec0:934b/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:165 errors:0 dropped:0 overruns:0 frame:0 TX packets:42 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:13826 (13.5 KiB) TX bytes:3036 (2.9 KiB)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B)root@ubuntu:~# docker exec -it frr-02 ifconfigeth1 Link encap:Ethernet HWaddr DE:38:AD:91:D8:24 inet addr:11.11.0.3 Bcast:0.0.0.0 Mask:255.255.255.0 inet6 addr: fe80::dc38:adff:fe91:d824/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:200 errors:0 dropped:0 overruns:0 frame:0 TX packets:42 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:16592 (16.2 KiB) TX bytes:3036 (2.9 KiB)eth2 Link encap:Ethernet HWaddr E2:4D:1E:69:47:D2 inet addr:12.12.0.2 Bcast:0.0.0.0 Mask:255.255.255.0 inet6 addr: fe80::e04d:1eff:fe69:47d2/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:190 errors:0 dropped:0 overruns:0 frame:0 TX packets:39 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:15768 (15.3 KiB) TX bytes:2798 (2.7 KiB)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B)root@ubuntu:~# docker exec -it frr-03 ifconfigeth1 Link encap:Ethernet HWaddr 16:47:A2:B7:F5:4F inet addr:12.12.0.3 Bcast:0.0.0.0 Mask:255.255.255.0 inet6 addr: fe80::1447:a2ff:feb7:f54f/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:182 errors:0 dropped:0 overruns:0 frame:0 TX packets:38 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:15112 (14.7 KiB) TX bytes:2756 (2.6 KiB)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) 3. FRR 组网由于 Router 1 eth1 和 Router 3 eth1 属于不同网段，在组网前两者间无路由，ping 不通 12345678root@ubuntu:~# docker exec -it frr-01 bash568ade633bf9:/# ping 12.12.0.3PING 12.12.0.3 (12.12.0.3): 56 data bytesping: sendto: Network unreachable568ade633bf9:/# route -neKernel IP routing tableDestination Gateway Genmask Flags MSS Window irtt Iface11.11.0.0 0.0.0.0 255.255.255.0 U 0 0 0 eth1 12345678root@ubuntu:~# docker exec -it frr-03 bash6185c04f06d1:/# ping 11.11.0.2PING 11.11.0.2 (11.11.0.2): 56 data bytesping: sendto: Network unreachable6185c04f06d1:/# route -neKernel IP routing tableDestination Gateway Genmask Flags MSS Window irtt Iface12.12.0.0 0.0.0.0 255.255.255.0 U 0 0 0 eth1 通过配置 FRR 使得两个网段学习到对方的路由，实现 OSPF 组网 FRR 开启 OSPF 进程 编辑 /etc/frr/daemons 1ospfd&#x3D;yes 重启 FRR 服务 1&#x2F;etc&#x2F;init.d&#x2F;frr restart vtysh 配置 FRR OSPF 1234--- frr-01 ---568ade633bf9# configure568ade633bf9(config)# router ospf568ade633bf9(config-router)# network 11.11.0.2/24 area 0 12345--- frr-02 ---1681fd9bd374# configure1681fd9bd374(config)# router ospf1681fd9bd374(config-router)# network 11.11.0.3/24 area 01681fd9bd374(config-router)# network 12.12.0.2/24 area 0 1234--- frr-03 ---6185c04f06d1# configure6185c04f06d1(config)# router ospf6185c04f06d1(config-router)# network 12.12.0.3/24 area 0 配置完毕后，frr-01 和 frr-03 的 OSPF 便能学习到对方的路由，互相能 ping 通 1234567891011--- frr-01 ---568ade633bf9# show ip ospf route============ OSPF network routing table ============N 11.11.0.0/24 [10] area: 0.0.0.0 directly attached to eth1N 12.12.0.0/24 [20] area: 0.0.0.0 via 11.11.0.3, eth1============ OSPF router routing table ========================= OSPF external routing table =========== 1234567891011--- frr-01 ---568ade633bf9:/# ping 12.12.0.3PING 12.12.0.3 (12.12.0.3): 56 data bytes64 bytes from 12.12.0.3: seq=0 ttl=63 time=0.725 ms64 bytes from 12.12.0.3: seq=1 ttl=63 time=0.225 ms64 bytes from 12.12.0.3: seq=2 ttl=63 time=0.128 ms64 bytes from 12.12.0.3: seq=3 ttl=63 time=0.205 ms^C--- 12.12.0.3 ping statistics ---4 packets transmitted, 4 packets received, 0% packet lossround-trip min/avg/max = 0.128/0.320/0.725 ms 1234567891011--- frr-03 ---6185c04f06d1# show ip ospf route============ OSPF network routing table ============N 11.11.0.0/24 [20] area: 0.0.0.0 via 12.12.0.2, eth1N 12.12.0.0/24 [10] area: 0.0.0.0 directly attached to eth1============ OSPF router routing table ========================= OSPF external routing table =========== 1234567891011--- frr-03 ---6185c04f06d1:/# ping 11.11.0.2PING 11.11.0.2 (11.11.0.2): 56 data bytes64 bytes from 11.11.0.2: seq=0 ttl=63 time=1.871 ms64 bytes from 11.11.0.2: seq=1 ttl=63 time=0.236 ms64 bytes from 11.11.0.2: seq=2 ttl=63 time=0.161 ms64 bytes from 11.11.0.2: seq=3 ttl=63 time=0.151 ms^C--- 11.11.0.2 ping statistics ---4 packets transmitted, 4 packets received, 0% packet lossround-trip min/avg/max = 0.151/0.604/1.871 ms DR 竞选参考 FRRouting 官网 Frrouting快速入门——OSPF组网（一）","categories":[],"tags":[]},{"title":"OSPF 路由协议","slug":"OSPF路由协议","date":"2024-09-18T17:38:42.000Z","updated":"2024-11-11T03:57:58.109Z","comments":true,"path":"2024/09/19/OSPF路由协议/","link":"","permalink":"https://gy23333.github.io/2024/09/19/OSPF%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/","excerpt":"OSPF 路由协议","text":"OSPF 路由协议 RIP 协议缺陷缺陷一：以跳数评估的路由并非最优路径RIP 路由协议选择跳数最短的路由，在下图中会选择 RTA —&gt; RTB 的路径。 但虽然 RTA —&gt; RTB 的路径跳数最短，但由于带宽的区别，对于大数据流走 RTA —&gt; RTC —&gt; RTD —&gt; RTB 反而快于跳数更短的 RTA —&gt; RTB 路径。 缺陷二：最大跳数15限制网络规模RIP 允许的跳数最大只有15条，如果跳数大于等于16跳，则会被视为不可达，无法学习到16跳网段的路由，从而限制了网络规模的大小。 缺陷三：更新路由发送全量路由信息，浪费网络资源RIP 每隔一段时间，都会向所有邻居发送全量的路由信息，十分消耗网络资源。 缺陷四：收敛速度慢 OSPF 链路状态路由协议 工作在 IP 层，IP 协议号 89 以组播地址 224.0.0.5 发送协议包 每个路由器将已知的链路状态信息发送给邻居，收敛后，每个路由器对全网链路状态的认识相同，并独立计算自己的路由 OSPF 工作过程1. 发现邻居在广播域中组播 hello 包，收到互相的 hello 包，确认是自己的邻居，则加入邻居表中 2. 建立邻接关系 并不是所有邻居都会建立邻接关系 网段的广播域中会选取 DR 和 BDR（副 DR，用于容灾），剩下的节点都是 DR_Others，该广播域中的所有路由器都只与 DR 和 BDR 建立邻接关系 只有和建立了邻接关系的邻居才会交换链路状态信息 只有在广播型网络中才会使用 DR 和 BDR，点到点（PPP，即一对一）不使用 DR 和 BDR 如此，可以减少交换信息的次数，路由更新更高效 3. 传递链路状态信息 每个节点都有一个 LSDB（链路状态数据库），里面的每一条是一个 LSA（链路状态公告） 每条 LSA 描述了网络中的一个路由器的编号、直连网段、cost 等信息 更新机制 触发更新或者每隔 30 分钟更新一次 触发更新：网络发生变化时，则无需等到 30 分钟周期，立即向邻接节点发送信息 增量更新，只发送邻居需要的 LSA 收敛后，网段内的所有路由器都有相同的 LSDB 路由信息交换过程 下面是 RTA 触发更新后，向 RTB 交换路由信息的过程 发送 RTA 所有 LSA 的摘要信息 RTB 比较收到的 LSA 摘要与自己本地的 LSA，发送请求，希望获得自己没有的 LSA 的详细信息 RTA 将要求的 LSA 发送给 RTB RTB 向 RTA 回复收到 4. 路由计算每台路由器根据 LSDB 算出每台路由器到自己的最短路径 OSPF 分区域管理LSDB 记录网络所有路由器的 LSA，所以当网络规模变大时，会导致每台路由器上都要消耗大量资源储存 LSDB，且 LSDB 信息收敛也会变得很慢，因此需要分区域管理。 每个区域内部的路由器的 LSDB 只需知道区域内的路由器的 LSA 不同区域之间通过 ASR（区域边界路由器）相连，同时有两边的 LSDB 非骨干区域之间不能直接通信，需要通过骨干区域（区域 0）进行转发。 如上图中有三个区域：区域 0、区域 1、区域 10.0.0.1，其中区域 1、区域 10.0.0.1 这样的非骨干区域不能直接通信，需要先发送给区域 0，再由区域 0 转发。 Hello 包Hello 包组成 功能：Hello 包用于发现邻居路由器，交换 OSPF 配置信息，并确认邻接状态。 内容：包括 Route ID、Priority、Hello 间隔、Dead 间隔等 12345678root@ubuntu:/etc/frr# tcpdump -i vip0 proto ospf -vvvtcpdump: listening on vip0, link-type EN10MB (Ethernet), capture size 262144 bytes11:15:29.874116 IP (tos 0xc0, ttl 1, id 22009, offset 0, flags [none], proto OSPF (89), length 64) ubuntu &gt; ospf-all.mcast.net: OSPFv2, Hello, length 44 Router-ID ubuntu, Backbone Area, Authentication Type: none (0) Options [External] Hello Timer 10s, Dead Timer 40s, Mask 255.255.255.255, Priority 1 Designated Router ubuntu 组播地址 ospf-all.mcast.netOSPF 以组播地址的方式发送 Hello 包，将 Hello 包发往组播地址 ospf-all.mcast.net（224.0.0.5），所有 OSPF 路由器都会监听该地址，如此即可确保域内所有 OSPF 路由器都收到。 Hello 包发送过程 定时发送：每个 OSPF 路由器按照配置的 Hello 间隔定期发送 Hello 包 包的构造：路由器构造 Hello 包，将其发送到多播地址 224.0.0.5 邻居发现：接收到 Hello 包的其他 OSPF 路由器会解析包中的信息，加入邻居表中 邻接关系维护：通过定期发送 Hello 包，OSPF 路由器可以维护与邻居的关系。如果在规定的 Dead 间隔内未收到某个邻居的 Hello 包，路由器将认为该邻居失效 DR 竞选广播型网络中需选出该广播域的 DR（指定路由） 和 BDR（备份指定路由，负责在 DR 失效时接管其功能） DR 竞选规则 Priority 大者优先：优先选择 Priority 较大的路由为 DR，如果 Priority 设置为 0，则不参与 DR 竞选 Route ID 大者优先：如果有多个 Priority 最大且相同的路由器，则选择其中 Route ID 最大的（Route ID 为路由器的唯一标识，通常是 IP，不可能相同） 示例：下面三个路由器中，A 的 Priority 最大，为 DR；B、C 的 Priority 相同，但 B 的 Route ID 大于 C，所以 B 为 BDR A 的优先级为 2，Router ID 为 1.1.1.1（DR） B 的优先级为 1，Router ID 为 2.2.2.2（BDR） C 的优先级为 1，Router ID 为 3.3.3.3 DR 竞选过程 Hello 消息：所有路由器定期组播 Hello 消息，其中包含本路由的 Priority、Route ID 等信息 优先级比较：根据竞选规则比较各个路由器，优先级最高的为 DR，次高的为 BDR 选举后，DR 和 BDR 会向所有的路由器广播 LSA，其他所有路由器将与 DR 和 BDR 建立邻接关系 邻居状态机 RIP 和 OSPF 比较 RIP（距离矢量路由协议） OSPF（链路状态路由协议） 最优路径选择 跳数 链路开销 更新触发 每 30s 触发更新或每隔30分钟 发送对象 广播到所有邻居 发到邻接路由器 发送信息 全量 RIP 路由表 链路状态信息摘要 参考 HUAWEI OSPF 配置","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://gy23333.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://gy23333.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"路由协议","slug":"路由协议","permalink":"https://gy23333.github.io/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/"},{"name":"OSPF","slug":"OSPF","permalink":"https://gy23333.github.io/tags/OSPF/"}]},{"title":"Go并发编程","slug":"Go并发编程","date":"2024-09-04T16:58:16.000Z","updated":"2024-11-11T03:57:58.107Z","comments":true,"path":"2024/09/05/Go并发编程/","link":"","permalink":"https://gy23333.github.io/2024/09/05/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/","excerpt":"Go 并发编程","text":"Go 并发编程 并发基本概念进程 Process 与线程 Thread 进程是系统进行资源分配和调度的一个基本单位，程序在操作系统中的一次执行过程 线程是进程的执行单位，是CPU调度和分派的基本单位 一个进程可以创建和撤销多个线程;同一个进程中的多个线程之间可以并发执行 并行 Concurrent 与并发 Paralled 并行：多个线程同时操作多个资源类 并发：多个线程交替操作同一资源类 进程 process 与线程 thread 与协程 coroutine 一个进程上可以跑多个线程，一个线程上可以跑多个协程 多个线程可以利用多个 CPU 并行，但一个线程内的多个协程是串行的，同一时刻只能有一个在运行，无法利用 CPU 多核，但不同线程内的协程之间可以并行 进程 process 线程 thread 协程 coroutine 切换者 操作系统 操作系统 用户 切换内容 页全局目录、内核栈、硬件上下文 内核栈、硬件上下文 硬件上下文 切换内容保存位置 内存 内核栈 用户栈或堆（变量） 状态切换 用户态 —&gt; 内核态 —&gt; 用户态 用户态 —&gt; 内核态 —&gt; 用户态 用户态 切换效率 低 中 高 进程、线程的切换者是操作系统，操作系统决定切换时刻，用户无感 协程的切换者是用户，由用户程序决定切换时间 进程切换内容：页全局目录、内核栈、硬件上下文，切换的内容保存在内存中，采用 用户态 —&gt; 内核态 —&gt; 用户态 线程切换内容：内核栈、硬件上下文，切换的内容保存在内核栈中，采用 用户态 —&gt; 内核态 —&gt; 用户态 协程切换内容：硬件上下文，切换的内容保存在用户栈或堆（变量）中，切换过程始终处于用户态 协程 GoroutineGo 不需要自己编写进程、线程、协程，直接使用 goroutine，在语言中内置了调度和上下文切换机制，可轻松开启上万 goroutine。 goroutine 协程概念上类似于线程，Go 程序可以智能地将 goroutine 分配给不同的 CPU，由Go的运行时（runtime）调度和管理的。 使用 goroutinegoroutine 使用时将任务包装成函数，通过 go 关键字开启 1go func() 如果 goroutine 没有执行完，但主线程已经结束，goroutine 也会跟着结束。 示例每两秒输出一次 go routine，每秒输出一次 hello，输出 10 次 hello 后结束 12345678910111213141516171819202122package mainimport ( \"fmt\" \"time\")func runtime() &#123; for &#123; fmt.Println(\"go routine\") time.Sleep(time.Second * 2) &#125;&#125;func main() &#123; go runtime() for i := 0; i &lt; 10; i++ &#123; fmt.Println(\"hello\") time.Sleep(time.Second) &#125;&#125; 协程调度GPM 模型goroutine 调度系统为 GPM 运行时（runtime）调度器，包括了 3 个部分—— goroutine G、处理器 P、线程 M G：goroutine 存放本 goroutine 的一些信息，以及与 P 绑定等信息 P：Processor，处理器 P 对 goroutine 队列进行调度 goroutine 与线程的中间层，管理着一组 goroutine 队列，储存所管 goroutine 运行的上下文 P 的数量决定了最大可并行数量，个数由 runtime.GOMAXPROCS 设置，最大 256，默认为 CPU 数 M：Machine，线程 Go 运行时对操作内核线程的虚拟，与内核线程一一对应 P 管理着一群 G，调度在 M 上运行。一般比例为 G : P : M = n : 1 : 1 调度机制： 把占用 CPU 时间过长的 goroutine 暂停，去运行后续的 goroutine 当自己队列的消费光了，则去取全局队列中的 goroutine 如全局队列也消费光了，则去抢其他 P 的 goroutine 如果一个 G 长时间占据着 M，runtime 就会新建一个 M，管理阻塞 G 的 P 会将其他的 G 都挂到新建的 M 上。当旧的 M 上的 G 运行完或者被判定为死掉时，就会回收旧有的 M。 由此可以看出，从调度角度看，goroutine 相较于线程的优势： goroutine 的调度由 runtime 调度器调度，全程在用户态 线程需要内核进行调度，需要内核态和用户态之间频繁切换 runtime 包runtime 运行时用来调度和管理 goroutine，可通过 runtime 包程序控制 goroutine 以及获取环境信息。 runtime.Gosched()释放当前 goroutine 的 CPU 时间片给其他 goroutine 执行，当前 goroutine 等待未来的时间片再执行。 示例 下面代码，运行后有两种可能： 一段数字 + 两个 hello CPU 时间片先给数字协程，再分配给 hello 主协程 两个 hello CPU 时间片先给 hello 主协程，主协程结束后程序直接结束，不输出数字，再分配数字协程 1234567891011121314151617package mainimport ( \"fmt\")func main() &#123; go func() &#123; for i := 0; i &lt; 100000; i++ &#123; fmt.Println(i) &#125; &#125;() // 主协程 for i := 0; i &lt; 2; i++ &#123; fmt.Println(\"hello\") &#125;&#125; 这时在主协程运行输出 hello 前，添加 runtime.Gosched()，会切到其他 goroutine 输出多次数字，等数字协程的时间片用完时，切回主协程输出 hello ，再切回数字协程输出数字，最后主协程输出 hello 后结束程序。 即输出：一段数字 + hello + 一段数字 + hello 1234567891011121314151617181920package mainimport ( \"fmt\" \"runtime\")func main() &#123; go func() &#123; for i := 0; i &lt; 100; i++ &#123; fmt.Println(i) &#125; &#125;() // 主协程 for i := 0; i &lt; 2; i++ &#123; // 切到其他进程先执行 runtime.Gosched() fmt.Println(\"hello\") &#125;&#125; runtime.Goexit()退出当前 goroutine，不过退出前还是会正常执行 defer 语句。 示例 下面代码，主协程休眠一秒，数字协程输出一段数字之后，主协程苏醒输出 hello 1234567891011121314151617package mainimport ( \"fmt\" \"time\")func main() &#123; go func() &#123; for i := 0; i &lt; 100; i++ &#123; // runtime.Goexit() fmt.Println(i) &#125; &#125;() time.Sleep(time.Second) fmt.Println(\"hello\")&#125; 添加 runtime.Goexit() 后，直接结束协程，不会输出数字，只输出 hello 123456789101112131415161718package mainimport ( \"fmt\" \"runtime\" \"time\")func main() &#123; go func() &#123; for i := 0; i &lt; 100; i++ &#123; runtime.Goexit() fmt.Println(i) &#125; &#125;() time.Sleep(time.Second) fmt.Println(\"hello\")&#125; runtime.GOMAXPROCS()设置可同时使用最大 CPU 核数，并返回之前的设置。 1func runtime.GOMAXPROCS(n int) int 其他运行时信息 获取 CPU 核数量 1runtime.NumCPU() 获取 GOROOT 路径 1runtime.GOROOT() 获取操作系统 1runtime.GOOS 数据共享临界资源临界资源：并发环境中多个进程/线程/协程共享的资源。 多个 goroutine 访问同一资源时，多个写 goroutine，会造成临界资源安全问题。 下面示例中，4 个售票员并发卖 10 张票，原本是希望卖到无票时所有售票员停止卖票，但同时读写就可能导致资源安全问题。 12345678910111213141516171819202122232425262728293031package mainimport ( \"fmt\" \"math/rand\" \"time\")var numTicket = 10func saleTicket(i int) &#123; rand.Seed(time.Now().UnixNano()) for &#123; if numTicket &gt; 0 &#123; time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond) numTicket-- fmt.Printf(\"Saler %d sales one ticket, left %d tickets.\\n\", i, numTicket) &#125; else &#123; fmt.Printf(\"Saler %d detects no ticket.\\n\", i) break &#125; &#125;&#125;func main() &#123; numSaler := 4 for i := 0; i &lt; numSaler; i++ &#123; go saleTicket(i) &#125; time.Sleep(5 * time.Second)&#125; 如这次跑的结果，最后三个售票员检查时还有余票，但卖时已经无票了，导致票成负数。 1234567891011121314151617Saler 3 sales one ticket, left 9 tickets.Saler 0 sales one ticket, left 8 tickets.Saler 0 sales one ticket, left 7 tickets.Saler 2 sales one ticket, left 6 tickets.Saler 1 sales one ticket, left 5 tickets.Saler 3 sales one ticket, left 4 tickets.Saler 1 sales one ticket, left 3 tickets.Saler 0 sales one ticket, left 2 tickets.Saler 2 sales one ticket, left 1 tickets.Saler 3 sales one ticket, left 0 tickets.Saler 3 detects no ticket.Saler 2 sales one ticket, left -1 tickets.Saler 2 detects no ticket.Saler 1 sales one ticket, left -2 tickets.Saler 1 detects no ticket.Saler 0 sales one ticket, left -3 tickets.Saler 0 detects no ticket. 互斥锁互斥锁 sync.Mutex多个 goroutine 同时操作同一个资源（临界区）会导致竞态问题，需要通过对资源上锁，确保同一时刻只有一个 goroutine 访问该共享资源。 声明一个互斥锁 1var mutex sync.Mutex 在使用资源前加锁，防止其他 goroutine 同时使用该资源 1mutex.Lock() 在使用完资源后解锁，释放该资源给其他 goroutine 使用 1mutex.Unlock() 上面的用例，在查看票数前加锁，再售票和退出前解锁，如此就不会出现多卖出票的情况。 123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( \"fmt\" \"math/rand\" \"sync\" \"time\")var mutex sync.Mutexvar numTicket = 10func saleTicket(i int) &#123; rand.Seed(time.Now().UnixNano()) for &#123; // 加锁 mutex.Lock() if numTicket &gt; 0 &#123; time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond) numTicket-- fmt.Printf(\"Saler %d sales one ticket, left %d tickets.\\n\", i, numTicket) &#125; else &#123; //解锁 mutex.Unlock() fmt.Printf(\"Saler %d detects no ticket.\\n\", i) break &#125; //解锁 mutex.Unlock() &#125;&#125;func main() &#123; numSaler := 4 for i := 0; i &lt; numSaler; i++ &#123; go saleTicket(i) &#125; time.Sleep(5 * time.Second)&#125; 读写互斥锁 sync.RWMutex互斥锁是完全互斥的，无关是读还是写。但其实并发读并不会出现资源竞争的问题，所以引入读写锁，不限制并发读，但限制并发读写、写写。 读 写 读 Y N 写 N N 声明一个读写互斥锁 1var mutex sync.RWMutex 在写资源前加写锁， 1mutex.Lock() 在写完资源后解写锁， 1mutex.Unlock() 在读资源前加读锁 1mutex.RLock() 在读完资源后解读锁 1mutex.RUnlock() 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( \"fmt\" \"sync\" \"time\")var ( x int64 wg sync.WaitGroup lock sync.Mutex rwlock sync.RWMutex)func write() &#123; rwlock.Lock() // 加写锁 x = x + 1 time.Sleep(10 * time.Millisecond) // 假设读操作耗时10毫秒 rwlock.Unlock() // 解写锁 wg.Done()&#125;func read() &#123; rwlock.RLock() // 加读锁 time.Sleep(time.Millisecond) // 假设读操作耗时1毫秒 rwlock.RUnlock() // 解读锁 wg.Done()&#125;func main() &#123; start := time.Now() for i := 0; i &lt; 10; i++ &#123; wg.Add(1) go write() &#125; for i := 0; i &lt; 1000; i++ &#123; wg.Add(1) go read() &#125; wg.Wait() end := time.Now() fmt.Println(end.Sub(start))&#125; 原子操作 atomic 原子操作即不能被中断的操作，对资源进行原子操作时，CPU 不会再对该资源进行其他操作。原子操作无锁，通过 CPU 指令直接实现。 通过互斥锁操作会涉及内核态的上下文切换，Go 可以调用 atomic 包在用户态完成原子操作来保证并发安全。 原子操作支持的类型：int32、int64、uint32、uint64、uintptr、unsafe.Pointer，即整数和指针 以 int64 为例，取变量地址用于操作 读取 1func atomic.LoadInt64(addr *int64) (val int64) 写入 1func atomic.StoreInt64(addr *int64, val int64) 修改 1func atomic.AddInt64(addr *int64, delta int64) (new int64) 交换 1func atomic.SwapInt64(addr *int64, new int64) (old int64) 比较交换，交换前先检查当前值是否是 old，如是则交换成 new，如不是则不交换 1func atomic.CompareAndSwapInt64(addr *int64, old int64, new int64) (swapped bool) 管道 ChannelGo 的并发模型是 CSP，Communicating Sequential Process，提倡使用通信共享内存，而不是通过共享内存方式进行通信。 Go 可以通过共享内存来实现数据共享，使用锁来防止竞态，但这不可避免的加大了性能问题。由此引入了管道 Channel 的概念，用于 goroutine 之间通信。 创建 ChannelChannel 是引用类型，每个 Channel 都需要定义其允许传输的数据类型。 1var ch chan 数据类型 //零值为nil 通道的零值为 nil，因此需要使用 make 来定义（缓冲区大小可缺省） 1ch := make(chan 数据类型 [, 缓冲区大小]) Channel 操作在定义了 Channel 后，可对其进行下面操作，以 int 类型为例 1ch := make(chan int) 发送 1ch &lt;- 10 当存在等待的接收者时，直接将数据发送给阻塞的接收者 当不存在等待的接收者，但缓冲区存在空余空间时，将数据写入缓冲区 当不存在等待的接收者，且不存在缓冲区或者缓冲区已满时，阻塞等待其他 goroutine 从 Channel 中接收数据 接收 123&lt;-ch //丢弃通道值data := &lt;-ch //接收通道值到datadata, ok := &lt;-ch //接收通道值到data，ok接收通道是否关闭（false，则通道已关闭） 当存在等待的发送者时，从阻塞的发送者或者缓冲区中获取数据 当不存在等待的发送者，但缓冲区存在数据时，从缓冲区接收数据 当不存在等待的发送者，且不存在缓冲区或者缓冲区不存在数据时，阻塞等待其他 goroutine 向 Channel 中发送数据 关闭，如果不再需要往通道发送值，则可以关闭通道，关闭通道不是必须的，可以自动通过垃圾回收机制回收 1close(ch) 关闭后的通道： 对关闭后的通道发送值会导致 panic 对关闭后的通道接收会一直获取到值，知道通道空 对关闭后且已经空的通道接收会得到对应数据类型的零值 关闭已经关闭的通道会导致 panic Channel缓冲区 nil 非空 空 满 非空非满 发送 阻塞 发送值 发送值 阻塞 发送值 接收 阻塞 接收值 阻塞 接收值 接收值 关闭 panic 关闭成功，读取所有数据后，返回零值 关闭成功，返回零值 关闭成功，读取所有数据后，返回零值 关闭成功，读取所有数据后，返回零值 无缓冲的通道无缓冲通道，又称阻塞通道、同步通道，定义 Channel 时不设置缓冲区大小即为无缓冲通道。 此类 Channel 发送和接收都无缓冲，所以无接收时发送会被阻塞，直到其他 goroutine 从该通道读取数据；同理，无发送时接收会被阻塞，直到其他 goroutine 发送到该通道。 下面错误用例，发送数据到 Channel，无接收，阻塞，无法运行到接收步骤，于是发生死锁报错 1fatal error: all goroutines are asleep - deadlock! 1234567891011package mainimport \"fmt\"func main() &#123; ch := make(chan int) ch &lt;- 10 //无接收发送，死锁 data := &lt;-ch fmt.Println(data) close(ch)&#125; 需要启动另一个 goroutine 接收，解开死锁 1234567891011121314151617181920212223package mainimport ( \"fmt\" \"sync\")var wg sync.WaitGroupfunc recvFromChannel(ch chan int) &#123; data := &lt;-ch fmt.Println(data) wg.Done()&#125;func main() &#123; ch := make(chan int) wg.Add(1) go recvFromChannel(ch) ch &lt;- 10 close(ch) wg.Wait()&#125; 有缓冲的通道定义 Channel 时设置缓冲区大小即可设置为有缓冲通道，在缓冲区有剩余时，即使无接收者，也不阻塞发送。 上述死锁用例，加上缓冲区，即可正常运行。 1234567891011package mainimport \"fmt\"func main() &#123; ch := make(chan int, 1) //创建容量为1的缓冲区的通道 ch &lt;- 10 data := &lt;-ch fmt.Println(data) close(ch)&#125; 单向通道有些 goroutine 函数调用 Channel 仅需发送或者接收，则可以使用单向通道进行限制。 只能发送的通道 1chan&lt;- int 只能接收的通道 1&lt;-chan int 下面例子，两个函数一个仅需要发送，一个仅需要接收，即可传入单向通道 12345678910111213141516171819202122232425262728package mainimport ( \"fmt\" \"sync\")var wg sync.WaitGroupfunc recvFromChannel(ch &lt;-chan int) &#123; //仅接收通道 data := &lt;-ch fmt.Println(data) wg.Done()&#125;func sendToChannel(ch chan&lt;- int) &#123; //仅发送通道 ch &lt;- 10 close(ch) wg.Done()&#125;func main() &#123; ch := make(chan int) wg.Add(2) go recvFromChannel(ch) go sendToChannel(ch) wg.Wait()&#125; 通道的遍历循环从通道取值的方法 方法一：使用 for 持续循环 123456789101112131415161718192021222324252627282930package mainimport ( \"fmt\" \"sync\")var wg sync.WaitGroupfunc sendToChannel(ch chan&lt;- int) &#123; for i := 0; i &lt; 10; i++ &#123; ch &lt;- i &#125; close(ch) wg.Done()&#125;func main() &#123; ch := make(chan int) wg.Add(1) go sendToChannel(ch) for &#123; data, ok := &lt;-ch if !ok &#123; break &#125; fmt.Println(data) &#125; wg.Wait()&#125; 方法二：for...range，既可以循环取值，并且在通道关闭后退出 1234567891011121314151617181920212223242526package mainimport ( \"fmt\" \"sync\")var wg sync.WaitGroupfunc sendToChannel(ch chan&lt;- int) &#123; for i := 0; i &lt; 10; i++ &#123; ch &lt;- i &#125; close(ch) wg.Done()&#125;func main() &#123; ch := make(chan int) wg.Add(1) go sendToChannel(ch) for data := range ch &#123; fmt.Println(data) &#125; wg.Wait()&#125; 通道的调度通过 select 随机运行一个接收到的 Channel 的 case 如果有可接收的 Channel，则随机运行其中一个 case 如果没有可接收的 Channel，则运行 default case 如果没有可接收的 Channel，且没有 default case，则会阻塞直到有接收到 Channel 使用无限 for 循环包裹 select，则可实现持续监听多个通道，触发相应操作。 123456789101112for &#123; select &#123; case data1, ok := &lt;-ch1: if !ok &#123; fmt.Println(\"ch1 closed.\") break &#125; // ch1处理 case &lt;-ch2: // ch2处理 &#125;&#125; sync 包sync.WaitGroup在多线程并发过程中，如果主协程结束，其他 goroutine 也会跟着结束，所以经常需要让主协程等待其他 goroutine 结束。使用 time.Sleep 过于生硬，不合适。于是引入了 sync.WaitGroup 处理该问题 。 (wg * WaitGroup) Add(delta int)：计数器 + delta (wg *WaitGroup) Done()：计数器 -1 (wg *WaitGroup) Wait()：阻塞直到计数器变为 0 每开一个并发 goroutine 就让计数器 +1，并发 goroutine 结束时则让计数器 -1，主协程调用 Wait() 阻塞直到所有 goroutine 结束，计数器清零。 123456789101112131415161718192021222324package mainimport ( \"fmt\" \"sync\")var wg sync.WaitGroup //声明一个WaitGroupfunc funcA() &#123; for i := 0; i &lt; 100; i++ &#123; fmt.Println(i) &#125; wg.Done() //一个goroutine结束，计数器-1&#125;func main() &#123; numGoroutine := 4 wg.Add(numGoroutine) //计数器+并发goroutine数 for i := 0; i &lt; numGoroutine; i++ &#123; go funcA() &#125; wg.Wait() //主协程阻塞直到所有goroutine跑完&#125; sync.Oncesync.Once 提供函数只执行一次的方法，如初始化配置、数据库连接此类并发只需要调用一次的函数，可用此方法 1func (o *Once) Do(f func()) 下面示例，funcA 和 funcB 都需要调用 InitConfig 函数，使用 sync.Once，可使得该函数只被调用一次。 12345678910111213141516171819202122232425262728293031323334package mainimport ( \"fmt\" \"sync\")var ( wg sync.WaitGroup once sync.Once //声明once)func InitConfig() &#123; fmt.Println(\"Init Configuration\")&#125;func funcA() &#123; once.Do(InitConfig) //并发只调用一次 fmt.Println(\"function A\") wg.Done()&#125;func funcB() &#123; once.Do(InitConfig) //并发只调用一次 fmt.Println(\"function B\") wg.Done()&#125;func main() &#123; wg.Add(2) go funcA() go funcB() wg.Wait()&#125; 输出 123Init Configurationfunction Bfunction A sync.MapGo 原生的 map 并不是并发安全的，需要额外加锁。sync 包提供 sync.Map 则是一种并发安全的 map，无需加锁。内置了诸如Store、Load、LoadOrStore、Delete、Range等操作方法。 123456789101112131415161718192021222324252627package mainimport ( \"fmt\" \"strconv\" \"sync\")var ( wg sync.WaitGroup once sync.Once)func main() &#123; m := sync.Map&#123;&#125; //定义map for i := 0; i &lt; 20; i++ &#123; wg.Add(1) go func(n int) &#123; key := strconv.Itoa(n) m.Store(key, n) //存值 value, _ := m.Load(key) //取值 fmt.Printf(\"key: %v, value: %v\\n\", key, value) wg.Done() &#125;(i) &#125; wg.Wait()&#125; 定时器周期性定时器 tickerticker 是周期性定时器，除非主动停止，就会一直循环计时下去。如果希望每隔一段时间执行一次，推荐使用 ticker 用法 作用 func time.NewTicker(d time.Duration) *time.Ticker 定义一个定时器 ticker，每隔一个间隔时间就会向 .C 通道发送当前时间 func (t *time.Ticker) Stop() 回收资源，否则会产生内存泄漏 &lt;-t.C 每隔一个设置的时间就会从通道接收到当前时间 以下示例，每隔 5s 输出当前时间 12345678910111213141516171819package mainimport ( \"fmt\" \"time\")func main() &#123; ticker := time.NewTicker(5 * time.Second) //定义5s一次的定时器 defer ticker.Stop() //回收资源 go func(t *time.Ticker) &#123; for &#123; fmt.Println(\"Time: \", time.Now().Format(\"2006-01-02 15:04:05\")) &lt;-t.C //每隔5s触发一次 &#125; &#125;(ticker) time.Sleep(15 * time.Second)&#125; 一次性定时器 timertimer 是一次性定时器，只计时一次，重新开始计时需要重置。如果希望只执行一次，或者需要重新设置间隔时间的，推荐使用 timer 用法 作用 func time.NewTimer(d time.Duration) *time.Timer 定义一个定时器 timer，过一个间隔时间后会向 .C 通道发送当前时间 &lt;-t.C 过一个设置的时间从通道接收到当前时间 func (t *time.Timer) Stop() bool 停止当前计时，如果当前在计时，则返回 true，并不会再发送到通道；如果不在计时中，则返回 fasle func (t *time.Timer) Reset(d time.Duration) bool 重置计时器，如果现在正在计时，则停止当前计时，重新计时（返回同 Stop） 以下示例，使用一次性计时器 timer 模拟周期性计时器 ticker 123456789101112131415161718192021222324252627package mainimport ( \"fmt\" \"time\")func main() &#123; timer := time.NewTimer(5 * time.Second) //定义一次性计时器timer fmt.Println(\"Time: \", time.Now().Format(\"2006-01-02 15:04:05\")) go func(t *time.Timer) &#123; times := 0 for &#123; &lt;-t.C //计时 fmt.Println(\"Time: \", time.Now().Format(\"2006-01-02 15:04:05\")) times++ t.Reset(5 * time.Second) //重新开始计时 if times &gt; 3 &#123; t.Stop() //停止计时 &#125; &#125; &#125;(timer) time.Sleep(30 * time.Second)&#125; 参考 并发编程 Golang 并发编程","categories":[{"name":"Golang","slug":"Golang","permalink":"https://gy23333.github.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://gy23333.github.io/tags/Golang/"}]},{"title":"Go学习路线","slug":"Go学习路线","date":"2024-09-04T15:38:51.000Z","updated":"2024-11-19T18:02:53.285Z","comments":true,"path":"2024/09/04/Go学习路线/","link":"","permalink":"https://gy23333.github.io/2024/09/04/Go%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/","excerpt":"Golang 学习路线梳理","text":"Golang 学习路线梳理 Go 基础 Go 基本语法 Go 并发编程 SQL 数据结构与算法 网络编程 命令行工具 cobra Web 框架 Gin 数据库 PostgreSQL MongoDB Redis Mysql kafka 日志 zap logrus 微服务 gRPC goKit 云原生 gitlab Docker Kubernetes Promethues 其他 Opentelemetry Promethues https://github.com/talkgo/read https://www.topgoer.com https://www.liwenzhou.com/posts/Go/golang-menu/","categories":[{"name":"Golang","slug":"Golang","permalink":"https://gy23333.github.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://gy23333.github.io/tags/Golang/"},{"name":"学习路线","slug":"学习路线","permalink":"https://gy23333.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"}]},{"title":"TRex 教程","slug":"TRex-教程","date":"2024-08-23T14:18:42.000Z","updated":"2024-11-11T03:57:58.117Z","comments":true,"path":"2024/08/23/TRex-教程/","link":"","permalink":"https://gy23333.github.io/2024/08/23/TRex-%E6%95%99%E7%A8%8B/","excerpt":"TRex 是基于 DPDK 的一个开源、低成本的流量生成器，支持生成 L3～7 流量，提供有状态、无状态两种模式。","text":"TRex 是基于 DPDK 的一个开源、低成本的流量生成器，支持生成 L3～7 流量，提供有状态、无状态两种模式。 TRex 架构TRex 之所以能够产生相比其他流量生成器更大的流量，原因是使用了 DPDK。 传统的工具，比如 iperf，如果想要生成包，需要走 Linux 内核，经过绑定的 socket API、 TCP/IP 栈、设备驱动这样一套完整的流程，最终才能到达物理网卡。 而 TRex 使用 DPDK，这意味着它可以绕过 Linux 内核态协议栈，直接控制物理网卡，应用单独实现包处理过程，不用经历内核/用户态切换、内存拷贝、冗余的 TCP/IP 协议栈等步骤。 安装 进入安装目录，比如 /opt/trex 下载 TRex 压缩包 1wget --no-cache --no-check-certificate https://trex-tgn.cisco.com/trex/release/latest 解压 TRex 压缩包 1tar -xzvf latest 网卡配置TRex 需要 DPDK 绑定网卡，通过 TRex 提供的脚本可以查看或修改网卡 查看网卡状态123456789101112131415root@ubuntu:/opt/trex/v3.05# ./dpdk_setup_ports.py -sNetwork devices using DPDK-compatible driver============================================&lt;none&gt;Network devices using kernel driver===================================0000:02:01.0 '82545EM Gigabit Ethernet Controller (Copper)' if=ens33 drv=e1000 unused=igb_uio,vfio-pci,uio_pci_generic *Active*0000:02:05.0 '82545EM Gigabit Ethernet Controller (Copper)' if=ens37 drv=e1000 unused=igb_uio,vfio-pci,uio_pci_generic0000:02:06.0 '82545EM Gigabit Ethernet Controller (Copper)' if=ens38 drv=e1000 unused=igb_uio,vfio-pci,uio_pci_genericOther network devices=====================&lt;none&gt; 当前三张网卡都绑定在 kernel 下，DPDK 未绑定网卡 Active的网卡为 ssh 使用的管理网卡，不可以设置在 TRex 配置文件中，分配给 DPDK 在运行 TRex 时，会自动将 TRex 配置文件中interfaces网卡绑定 DPDK TRex 配置官方文档 Yaml 格式配置文件，用来配置 TRex 服务器，包括： 每个网卡的源、目的 IP 和 MAC 地址 屏蔽网卡，保证 TRex 不使用管理网卡作为流量网卡 在运行 TRex 服务器时，通过 --cfg配置，如果未设置，则使用默认路径/etc/trex_cfg.yaml，TRex 提供了一些示例 TRex 配置文件在 $TREX_ROOT/cfg 配置项 port_limit：（必选）网卡数量，绑定 DPDK 的网卡数量，必须和interfaces中的网卡数量对应 version：（必选）必须是 2 interfaces：（必选）TRex 使用的网卡 PCI，顺序有意义，对应port_info中的顺序 必须是偶数个，成对存在，按顺序分别为 clinet 和 server 网卡 如是奇数个网卡，可以使用dummy填充，但每对网卡对必须有非dummy 的网卡 通过 ./dpdk_setup_ports.py -s 查看网卡 PCI 不能填入 ssh 使用的网卡 c：分配给每个网卡对的线程数，会被运行时的命令行参数-c覆盖 services_core：（非必选）用来跑 scapy、PyBird、Emu 这些 service 的核，如果未设置，则会采用以下逻辑 low_end 开启，使用 low_end_core low_end 未开启，使用 master_thread_id low_end 未开启，使用 master_thread_id，使用 core 0 port_info：（必选） 网卡信息，每项按顺序对应interfaces中的网卡 （必选）对于每张网卡，都必须要设置目的 MAC 地址，有两种设置方式： 直接设置dest_mac 设置default_gw，在未设置dest_mac时，TRex 会对default_gw这个 IP 发送 ARP 请求，使用回复的结果作为目的 MAC 地址 dest_mac：目的 MAC 地址，该网卡打流将打往这个 MAC 地址 default_gw：默认网关，用于生成目的 MAC 地址 src_mac：（非必选）该网卡生成流量的源 MAC 地址，如果未设置，将使用该网卡的 MAC 地址作为源 MAC 地址 platform：（非必选） master_thread_id：控制线程使用的线程 id latency_thread_id：RX 线程使用的线程 id，用来计算延迟 dual_if： 与interfaces中的网卡对一一对应 socket：该网卡对被分配的 NUMA 节点 threads：该网卡对用来发包的线程 id 示例123456789101112131415- port_limit : 2 version : 2#List of interfaces. Change to suit your setup. Use ./dpdk_setup_ports.py -s to see available options interfaces : [\"03:00.0\",\"03:00.1\"] port_info : # Port IPs. Change to suit your needs. In case of loopback, you can leave as is. - ip : 1.1.1.1 default_gw : 2.2.2.2 - ip : 2.2.2.2 default_gw : 1.1.1.1 platform : master_thread_id : 0 latency_thread_id : 7 dual_if : - socket : 0 threads : [1,2,3,4,5,6] Traffic 模版配置官方文档 Stateful 模式时需配置 Traffic 模版，用以生成流量。 运行 TRex 时，通过配置-f &lt;file&gt;参数来设置流量模版 yaml 文件。 配置项 duration：测试持续时间，即打多久的流量，单位 s。会被运行时的命令行参数-d覆盖 generator： 生成流量的 IP 依据clients_start、clients_end、servers_start、servers_end、dual_port_mask clients_start、clients_end、servers_start、servers_end 分别设置了 client 和 server 的 IP 池，该范围即限定了 client 和 server 的总数 dual_port_mask 设置网卡对的偏移量，使得可以为每个网卡对配置不同的静态路由，如需要发送同样的范围，则设置为0.0.0.0 下面示例中，如果 TRex 配置设置了两个网卡对（4张网卡），则分配 IP 如下 ```powershellport pair-0 (0,1) —&gt; C (16.0.0.1-16.0.0.128 ) &lt;-&gt; S( 48.0.0.1 - 48.0.0.128)port pair-1 (2,3) —&gt; C (17.0.0.129-17.0.0.255 ) &lt;-&gt; S( 49.0.0.129 - 49.0.0.255) + mask (“1.0.0.0”)12345678910 - client 和 server 数量即为设置范围的数量，都是 255，不会因为网卡数量而变化 - 网卡对偏移量为&#96;dual_port_mask&#96;，第二对网卡对比第一对偏移 &#96;1.0.0.0&#96;- 如果 &#96;dual_port_mask&#96; 设置为&#96;0.0.0.0&#96;，依旧设置 TRex 配置两个网卡对（4张网卡），则分配 IP 如下 - &#96;&#96;&#96;powershell port pair-0 (0,1) --&gt; C (16.0.0.1-16.0.0.128 ) &lt;-&gt; S( 48.0.0.1 - 48.0.0.128) port pair-1 (2,3) --&gt; C (16.0.0.129-16.0.0.255 ) &lt;-&gt; S( 48.0.0.129 - 48.0.0.255) 生成流量的 IP 范围 client IP 范围：网卡对中的 client 发送流量的源 IP、网卡对中的 server 发送流量的目的 IP server IP 范围：网卡对中的 client 发送流量的目的 IP、网卡对中的 server 发送流量的源 IP clients_per_gb：已废弃 min_clients：已废弃 cap_info name：pcap文件，流量模版文件 只允许单数据流 生成流量时使用该流量模版，并将 IP 替换为 client 和 server 的 IP 池中的 IP cps：每秒连接数，实际连接数需乘以运行时设置的 -m ipg：报文间隙，单位 ms rtt：设置与ipg相同的值 w：定义一个burst中该template生成几个flow，默认为 1 示例123456789101112131415161718- duration : 10.0 generator : distribution : \"seq\" clients_start : \"16.0.0.1\" clients_end : \"16.0.0.255\" servers_start : \"48.0.0.1\" servers_end : \"48.0.0.255\" clients_per_gb : 201 min_clients : 101 dual_port_mask : \"1.0.0.0\" tcp_aging : 1 udp_aging : 1 cap_info : - name: cap2/dns.pcap cps : 1.0 ipg : 10000 rtt : 10000 w : 1 运行命令行参数通过./t-rex-64运行 TRex 服务器，添加参数设置有状态/无状态以及其他选项 1./t-rex-64 [mode] &lt;options&gt; 使用 ./t-rex-64 -h查看细节 设置 mode： -f &lt;file&gt;：运行有状态模式，需设置流量模版 yaml 文件 -i：运行无状态模式 可选参数： --cfg &lt;file&gt;：TRex 配置文件，如果未设置，则使用默认路径/etc/trex_cfg.yaml -c &lt;num&gt;：给每个网卡对分配的线程数，会覆盖 TRex 配置中的c -m &lt;num&gt;：流量放大倍数，生成基础流量大小乘以这个倍数的流量 -d：持续时间，单位 s，默认3600s Stateful 示例使用下面测试交换机性能示例来理解 Stateful 运行模式。 该示例配置有一台 TRex 机器和一台交换机。 Trex 机器有两张网卡绑定 DPDK，port 1 作为模拟 client 的网卡，port 2 作为模拟 server 的网卡 交换机配置有两条静态路由，如下图所示，可以将16.0.0.0/8的包传到 TRex 的 port 0，将48.0.0.0/8的包传到 TRex 的 port 1 根据下面配置，运行 TRex 有状态模式 ./t-rex-64 -f traffic.yaml，打流流程如下 Port 0 发包 TRex 配置中的interfaces网卡对中的前一张网卡 port 0 作为 client 发包 发包使用 Traffic 模版配置中的 cap_info 中的第一个包，也就是其中的 DNS query 请求 发送的包中的源目的 IP 会随机被替换为 Traffic 模版中的配置的范围，其中，源 IP 范围 16.0.0.1(clients_start) ~ 16.0.0.255(clients_end)，目的 IP 范围 48.0.0.1(servers_start) ~ 48.0.255.255(servers_end) 包被发往 TRex 配置中设置的 port 0 网卡的目的 MAC 地址 dest_mac，本示例即通过默认网卡 default_gw 得到的目的 MAC 地址 Port 1 收包 交换机 port 2 收到 TRex 机器 port 1 发来的目的 IP 为48.0.0.1~ 48.0.255.255的包，根据路由，将其通过 port 3 转发到 TRex 机器的 port 1 TRex 配置中的interfaces网卡对中的后一张网卡 port 1 作为 server 收包 Port 1 发包 TRex 配置中的interfaces网卡对中的后一张网卡 port 1 作为 server 发包 发包使用 Traffic 模版配置中的 cap_info 中的第二个包，也就是其中的 DNS response 回复 发送的包中的源目的 IP 会随机被替换为 Traffic 模版中的配置的范围，其中，源 IP 范围48.0.0.1(servers_start) ~ 48.0.255.255(servers_end)，目的 IP 范围 16.0.0.1(clients_start) ~ 16.0.0.255(clients_end) 包被发往 TRex 配置中设置的 port 1 网卡的目的 MAC 地址 dest_mac，本示例即通过默认网卡 default_gw 得到的目的 MAC 地址 Port 0 收包 交换机 port 3 收到 TRex 机器 port 2 发来的目的 IP 为16.0.0.1 ~ 16.0.0.255的包，根据路由，将其通过 port 2 转发到 TRex 机器的 port 0 TRex 配置中的interfaces网卡对中的后一张网卡 port 0 作为 server 收包 TRex 配置 1234567891011121314151617- port_limit : 2 #对应下面的网卡数量 version : 2 interfaces : [\"06:00.0\",\"06:00.1\"] #port0、port1的PCI，网卡对，前一个为模拟client的网卡，后一个为模拟server的网卡 c : 6 #对应下面的每对网卡几个发包threads port_info : #port0的配置 - ip : 11.11.11.11 #port0的IP default_gw : 11.11.11.1 #port2（port0的网关）的IP，由此推出port0网卡发包时的目的MAC地址 #port1的配置 - ip : 12.12.12.12 #port1的IP default_gw : 12.12.12.1 #port3（port1的网关）的IP，由此推出port1网卡发包时的目的MAC地址 platform : master_thread_id : 0 latency_thread_id : 7 dual_if : - socket : 0 threads : [1,2,3,4,5,6] Traffic 模版配置 123456789101112131415161718- duration : 10.0 generator : distribution : \"seq\" clients_start : \"16.0.0.1\" clients_end : \"16.0.0.255\" servers_start : \"48.0.0.1\" servers_end : \"48.0.255.255\" clients_per_gb : 201 min_clients : 101 dual_port_mask : \"1.0.0.0\" tcp_aging : 1 udp_aging : 1 cap_info : - name: cap2/dns.pcap cps : 1.0 ipg : 10000 rtt : 10000 w : 1 pcap 包模版 1234root@ubuntu:/opt/trex/v3.05# tcpdump -r cap2/dns.pcapreading from file cap2/dns.pcap, link-type EN10MB (Ethernet)-7:00:00.000000 IP 21.0.0.2.1030 &gt; 22.0.0.12.domain: 48 A? www.cisco.com. (31)-7:00:00.020944 IP 22.0.0.12.domain &gt; 21.0.0.2.1030: 48* 1/0/0 A 100.100.100.100 (47) 示例Stateful在 Linux 虚拟机上演示 Stateful 模式简单示例，直接将流量从 ens37 打到 ens38，再从 ens38 回复到 ens37，配置如下 初始网卡信息123456789101112131415root@ubuntu:/opt/trex/v3.05# ./dpdk_setup_ports.py -sNetwork devices using DPDK-compatible driver============================================&lt;none&gt;Network devices using kernel driver===================================0000:02:01.0 '82545EM Gigabit Ethernet Controller (Copper)' if=ens33 drv=e1000 unused=igb_uio,vfio-pci,uio_pci_generic *Active*0000:02:05.0 '82545EM Gigabit Ethernet Controller (Copper)' if=ens37 drv=e1000 unused=igb_uio,vfio-pci,uio_pci_generic0000:02:06.0 '82545EM Gigabit Ethernet Controller (Copper)' if=ens38 drv=e1000 unused=igb_uio,vfio-pci,uio_pci_genericOther network devices=====================&lt;none&gt; 12345678910111213141516171819202122232425262728root@ubuntu:/opt/trex/v3.05# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 00:0c:29:f6:9c:9a brd ff:ff:ff:ff:ff:ff altname enp2s1 inet 192.168.0.106/24 brd 192.168.0.255 scope global dynamic noprefixroute ens33 valid_lft 6304sec preferred_lft 6304sec inet6 fe80::dbd1:95a:915f:65a7/64 scope link noprefixroute valid_lft forever preferred_lft forever3: ens37: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 00:0c:29:f6:9c:a4 brd ff:ff:ff:ff:ff:ff altname enp2s5 inet 192.168.45.137/24 brd 192.168.45.255 scope global dynamic noprefixroute ens37 valid_lft 904sec preferred_lft 904sec inet6 fe80::205c:eff4:8197:d72f/64 scope link noprefixroute valid_lft forever preferred_lft forever4: ens38: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 00:0c:29:f6:9c:ae brd ff:ff:ff:ff:ff:ff altname enp2s6 inet 192.168.45.138/24 brd 192.168.45.255 scope global dynamic noprefixroute ens38 valid_lft 903sec preferred_lft 903sec inet6 fe80::99b1:de77:f189:6869/64 scope link noprefixroute valid_lft forever preferred_lft forever TRex 配置1234567891011121314- port_limit : 2 version : 2 interfaces : [\"02:05.0\",\"02:06.0\"] port_info : - ip : 192.168.45.137 dest_mac : 00:0c:29:f6:9c:ae - ip : 192.168.45.138 dest_mac : 00:0c:29:f6:9c:a4 platform : master_thread_id : 0 latency_thread_id : 1 dual_if : - socket : 0 threads : [2] Traffic 配置123456789101112131415161718- duration : 10.0 generator : distribution : \"seq\" clients_start : \"16.0.0.1\" clients_end : \"16.0.0.255\" servers_start : \"48.0.0.1\" servers_end : \"48.0.0.255\" clients_per_gb : 201 min_clients : 101 dual_port_mask : \"1.0.0.0\" tcp_aging : 1 udp_aging : 1 cap_info : - name: cap2/dns.pcap cps : 1.0 ipg : 10000 rtt : 10000 w : 1 运行1./t-rex-64 -f /opt/trex/config/traffic.yaml -d 10 运行过程中，实时状态显示如下 123456789101112131415161718192021222324252627282930-Per port stats table #两张网卡当前的状态 ports | 0 | 1 ----------------------------------------------------------------------------------------- opackets | 2 | 2 #当前总发包数 obytes | 154 | 186 #当前总发包比特 ipackets | 2 | 2 #当前总收包数 ibytes | 186 | 154 #当前总收包比特 ierrors | 0 | 0 oerrors | 0 | 0 Tx Bw | 282.57 bps | 341.28 bps-Global stats enabled Cpu Utilization : 0.2 % 0.0 Gb/core #CPU占用率 Platform_factor : 1.0 Total-Tx : 623.85 bps #实际发包 byte per second Total-Rx : 623.85 bps #实际收包 byte per second Total-PPS : 0.92 pps #实际 packet per second Total-CPS : 0.46 cps #实际 connect per second Expected-PPS : 2.00 pps #期望 packet per second Expected-CPS : 1.00 cps #期望 connect per second Expected-BPS : 1.36 Kbps #期望 byte per second# Client 数量 Active-flows : 0 Clients : 255 Socket-util : 0.0000 %# Server 数量 Open-flows : 2 Servers : 255 Socket : 2 Socket/Clients : 0.0 drop-rate : 0.00 bps #丢包率 current time : 3.9 sec #已测试时间 test duration : 6.1 sec #剩余测试时间 最终结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 ================== interface sum ==================------------------------ per core stats core id : 1------------------------------------------------ per core per if stats id : 1------------------------ port 0, queue id :0 - client ---------------------------- port 1, queue id :0 - server ---------------------------- ================== generators ==================normal------------- min_delta : 10 usec cnt : 0 high_cnt : 0 max_d_time : 0 usec sliding_average : 0 usec precent : -nan % histogram ----------- m_total_bytes : 1.49 Kbytes m_total_pkt : 18.00 pkt m_total_open_flows : 9.00 flows m_total_pkt : 18 m_total_open_flows : 9 m_total_close_flows : 9 m_total_bytes : 1530 ---------------port : 0------------ opackets : 9 obytes : 693 ipackets : 9 ibytes : 837 Tx : 290.02 bpsport : 1------------ opackets : 9 obytes : 837 ipackets : 9 ibytes : 693 Tx : 350.28 bps Cpu Utilization : 0.4 % 0.0 Gb/core Platform_factor : 1.0 Total-Tx : 640.30 bps Total-Rx : 640.30 bps Total-PPS : 0.94 pps Total-CPS : 0.47 cps Expected-PPS : 2.00 pps Expected-CPS : 1.00 cps Expected-BPS : 1.36 Kbps Active-flows : 0 Clients : 255 Socket-util : 0.0000 % Open-flows : 9 Servers : 255 Socket : 0 Socket/Clients : 0.0 drop-rate : 0.00 bps summary stats -------------- Total-pkt-drop : 0 pkts Total-tx-bytes : 1530 bytes Total-tx-sw-bytes : 0 bytes Total-rx-bytes : 1530 byte Total-tx-pkt : 18 pkts Total-rx-pkt : 18 pkts Total-sw-tx-pkt : 0 pkts Total-sw-err : 0 pkts Total ARP sent : 2 pkts Total ARP received : 1 pkts 问题记录初始化 EAL 环境失败如运行 TRex 遇到下面 EAL 环境报错，则需设置大页 123456789root@ubuntu:/opt/trex/v3.05# ./t-rex-64 -f /opt/trex/config/traffic.yamlWARNING: tried to configure 2 hugepages for socket 0, but result is: 1The ports are bound/configured.Starting TRex v3.04 please wait ...EAL: FATAL: Cannot get hugepage information.EAL: Cannot get hugepage information. You might need to run ./trex-cfg onceEAL: Error - exiting with code: 1 Cause: Invalid EAL arguments 设置 1024 个 2048kB 大页，即写入 1024 到 hugepages-2048kB 下的 nr_hugepages 文件（初始为 0） 12root@ubuntu:/opt/trex/v3.05# echo 1024 | tee /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages1024 重新运行，即可正常 参考链接https://trex-tgn.cisco.com https://blog.csdn.net/shaoyunzhe/article/details/132344878 https://www.youtube.com/watch?v=ginboH5cCyA","categories":[],"tags":[{"name":"DPDK","slug":"DPDK","permalink":"https://gy23333.github.io/tags/DPDK/"},{"name":"TRex","slug":"TRex","permalink":"https://gy23333.github.io/tags/TRex/"}]},{"title":"日语语法","slug":"日语语法","date":"2024-04-13T18:08:41.000Z","updated":"2024-11-11T03:57:58.125Z","comments":true,"path":"2024/04/14/日语语法/","link":"","permalink":"https://gy23333.github.io/2024/04/14/%E6%97%A5%E8%AF%AD%E8%AF%AD%E6%B3%95/","excerpt":"XXX","text":"XXX 语法A は B です A は B では ありません じゃ ありません A は B ですか A の B 場所 に 何 が ありなす 場所 に 誰 が います 何 は 場所 に あります 誰 は 場所 に います 場所 に 何 も ありません 場所 に 誰 も いません 場所 へ 行きます 場所「時間」 から、場所「時間」 まで 車 で 行きます 何を 动词动作对象 + を ご飯を食べる 場所で 动词在某地做某事 図書館で勉強する Aか BA 或 B 休みは土曜日か月曜日です 手段/原料で 动词 日本語で手紙を書きます 誰に 何を あげます给某人 森さんにお土産をあげました 誰に・から 何を もらいます从某人那里得倒 森さんにお土産をもらいました 森さんからお土産をもらいました 誰に 会います见谁 森さんに駅で会いました 何が 好きです 情感的对象后面加 が 好き、嫌い、怖い 森さんは映画が好きです 能力的对象后面加 が 分かります、できます、苦手です、上手です 森さんは料理が苦手です 名や 名（など）比如什么、什么 森さんはビールーやお茶などが好きです 动词分类一类动词（五段动词） う段非る 書く（かく）、探す（さがす）、勝つ（かつ） あ段+る、う段+る、お段+る 困る（こまる）、怒る（おこる）、やる 特例 切る（きる）、帰る（かえる）、走る（はしる） 二类动词 い段+る 起きる（おきる） え段+る 食べる（たべる） 三类动词 来る（くる） 名 ＋ する 勉強する 动词变形（ます型）一类 う段 =&gt; い段 + ます 書く ＝＞ 書きます 困る ＝＞ 困ります 切る ＝＞ 切ります 二类 る ＝＞ ます 起きる ＝＞ 起きます 食べる ＝＞ 食べます 三类 来る ＝＞ きます する ＝＞ します 勉強する ＝＞ 勉強します 时态以及肯否定一般现在：ます 一般现在（否）：ません 过去：ました 过去（否）：ませんでした 形容词分类一类形容词 い 结尾 汉字 ＋ い 寒い、暖かい 二类形容词 汉字 綺麗（きれい） 时态一类现在肯定：XX い 今日は暑いです 现在否定：い → くない 或 XX く ありません 今日は暑くないです 今日は暑くありません 过去肯定：い → かった 昨日は暑かったです 过去否定：い → くなかった 或 く ありませんでした 昨日は暑くなかったです 一类形容词 名词 二类现在肯定：二类形容词 ＋ です 过去肯定：二类形容词 ＋ でした 否定：二类形容词 ＋ ではありません 过去否定：二类形容词 ＋ ではありませんでした 二类形容词 な 名词","categories":[],"tags":[]},{"title":"DPDK","slug":"DPDK","date":"2024-01-14T16:47:35.000Z","updated":"2024-11-11T03:57:58.124Z","comments":true,"path":"2024/01/15/DPDK/","link":"","permalink":"https://gy23333.github.io/2024/01/15/DPDK/","excerpt":"DPDK 学习","text":"DPDK 学习 DPDK 概述包处理基于系统是网络终端还是中间件，包处理会有不同的范围。一般来说，包含了包的接收和传输、包头的解析、包的修改以及转发，这些步骤发生在多个协义层。 对于网络终端，包会发给本地应用进行更多的处理，如包的加解密、隧道覆盖，这些都可能是包处理、会话建立及结束的一部分。 对于中间件，包会被转发给网络中的下一跳。一般这种系统需要处理大量的进出数据包，功能包括包查询、访问控制、QoS 等等。 传统包处理在 DPDK 前，Linux 一般的网卡包处理过程如下： 包的数据帧抵达网卡 网卡把包的帧以 DMA（Direct Memory Access）的方式写到内存 网卡硬中断通知 CPU 有包到达 CPU 响应硬中断，简单处理后，发出软中断，尽量快速释放 CPU 资源 ksoftirqd 内核线程检测到软中断后，调用网卡驱动注册的 poll 函数开始轮询收包 帧从 RingBuffer 摘下，收到的包交给 Linux 内核的各个协议栈处理 如果最终收包的应用在用户态，包中的信息会从内核态拷贝到用户态 如果最终收包的应用在内核态，包中的信息直接在内核态被处理 在上述包处理过程中，Linux 采用了 NAPI 和 Netmap两个机制来加快包处理过程 NAPI 即轮询收包，一次处理多个数据包，处理结束后，再回到中断状态 Netmap 则是数据包通过共享池的方式，减少包从内核态到用户态的复制 但这依旧不够，如何使包处理性能更强？待解决的问题如下： Linux 包处理过程需要在内核态和用户态之间转换，任务切换、cache 替换等都会带来不小的开销 随着 CPU 核数越来越多，早期为了适应 CPU 核数较少的分时调度机制限制了处理性能 由上述问题，期望的包处理框架应具有如下能力： 一个软件方式可以在 x86 CPU 进行包处理 自定义包处理 能使用多核架构，具有高性能 将一般的 Linux 系统调教为包处理环境 DPDK 特性DPDK 就是回应上述期待的包处理技术，DPDK 拥有下面这些特性： 轮询 为网卡的收发包分配独立的核，不需要与其他任务共享核，因此该类核可以无限循环地检查是否有包到达以及是否需要发送包 该方法减少了中断服务导致的上下文切换等开销 用户态驱动 在大多数期间下，包最后都会被发到用户态，但 Linux 网卡驱动在内核态 用户态驱动可以避免包从内核态到用户态不必要的内存拷贝，并避免系统调用开销 用户驱动更加灵活，可自定义，不受限于内核现有的数据格式与行为定义 CPU 亲和 DPDK 虽然工作在用户态，但线程调度依旧依赖内核 线程在不同的核间切换，由于缓存未命中和缓存写回，会导致性能的下降 同一核内不同任务切换，每次切换都需要保存当前状态寄存器到堆栈中，并恢复切换后的进程的状态信息，带来了额外的开销 CPU 亲和，即将进程或线程绑定到一个或多个特定的 CPU，进一步可独占该核，而不会迁移到其他核 如此，独占固定的核运行 DPDK，既避免了核之间的切换，提高了缓存命中率，又使得该核不用频繁的进行任务切换，减少了任务切换的开销 低访存开销 包处理大量的 I/O 需要频繁地访存，需要降低访存带来的开销 如采用大页技术降低 TLB miss 软件调优 一系列调优方式，如 cache line 对齐、cache line 共享等等 DPDK 框架下面是 DPDK 的基本模块，作为开发包处理系统的基础层，可以用软件模拟大部分的网络功能。 在最底部的内核态有三个模块 ：KNI、IGB_UIO、VFIO，其中 KNI，Kernel Network Interface，内核网络接口，提供 DPDK 和内核交换报文的解决方案。 KNI 模拟了一个虚拟网卡，提供 DPDK 与 Linux 内核之间通讯，允许报文被用户态接收后转发到 Linux 内核协议栈。 IGB_UIO，通过 UIO 技术，在初始化过程中将网卡硬件寄存器映射到用户态。 UIO 技术是一种用户态 I/O 框架，支持将用户态驱动的很少一部分运行在内核空间，大部分则运行在用户空间 IGB_UIO 则是 UIO 的，形态上是一种网卡驱动，网卡绑定 IGB_UIO 驱动后，相当于隔离了内核的网卡驱动，同时 IGB_UIO 还能够完成网卡中断内核态的初始化，并将中断信号映射到用户态 VFIO，可以安全地把设备 I/O、中断、DMA 等暴露到用户空间，从而可以在用户空间完成设备驱动的架构 在上层的用户态，DPDK由很多库组成，主要包括：核心部件库（Core Libs）、平台相关模块（platform）、网卡轮询模式驱动模块（PMD-natives &amp; virtual）、QoS 库、报文转发分类算法（classify 算法）等几大类。 核心部件库（Core Libs）：提供环境抽象层（EAL）、大页内存、缓存池、定时器以及无锁环等基础组件 PMD 库：提供所有用户态驱动，以便通过轮询和线程绑定得到高网络吞吐量。支持各种本地或者虚拟网卡 Classify 库：支持精确匹配（exact match）、最长后缀匹配（LPM，longest prefix match）、通配符匹配（ACL，access control list）和 cuckoo hash 算法，这些算法用来包处理中的查表操作 加速器 API：支持包安全（CryptoDev）、数据压缩（CompressionDev）和用于内核间通信的事件建模器（EventDev） QoS 库：提供网络服务质量相关组件，如限速（Meter）和调度（Sched） 平台相关模块： POWER：能耗管理，运行时调整 CPU 时钟频率，可以根据分组接收频率动态调整 CPU 频率，或进入 CPU 的不同休眠状态 KNI：通过 kni.ko 模块将数据报文从用户态传递到内核态协议栈，以便用户进程使用传统的 Socket 接口对相关报文进行处理 Packet Framework 和 DISTRIB 为搭建更复杂的多核流水线处理模型提供了基础的组件 核心组件核心组件是用来做高性能包处理 app 的一系列库。 大页技术物理内存和虚拟内存CPU 的内存管理包含两个概念： 物理内存：即安装在计算机的物理内存条 虚拟内存：虚拟的内存地址 多进程操作系统，进程不能直接访问物理内存，避免不安全行为，每个进程都维护了一套自己的虚拟地址，由 CPU 的内存管理单元（MMU）将虚拟地址转换到物理地址，再通过物理地址访问实际的物理内存，保证各个进程之间内存不互相干涉。 转换过程对进程是全透明的，进程可认为程序直接通过虚拟地址访问虚拟内存得到了数据，实际是通过虚拟地址映射到的物理地址在物理内存得到的数据。 内存分页分页是整个虚拟和物理内存空间切成一段段固定尺寸的大小的页（Page），在 Linux 的缺省配置，页大小为 4 KB。 分页机制下，虚拟地址分为了页号和页内偏移量两个部分 根据虚拟页号，在页表中找到对应的物理页号 在物理页号对应的物理内存页上，加上页内偏移量，得到物理内存地址 多级页表但分页方式依旧有缺陷，假如每个进程的虚拟内存有 4GB，采用默认的页大小 4KB，也就是需要对应 1M 个物理页，即需要 1M 个页表项，每个页表项 4B，那么每个进程都需要 4MB 的大小空间用于存储页表。100 个进程就会需要 400 MB 空间。 由此引出多级页表，将虚拟页号和物理页号的对应拆成多级，对于相同的物理页数量，映射使用的页表总大小减小。 以二级页表为例，虚拟地址分为了一级页号、二级页号和页内偏移量三个部分 在一级页表，根据一级页号找到对应的二级页表地址 在二级页表地址对应的二级页表上，根据二级页号找到对应的物理页号 在物理页号对应的物理内存页上，加上页内偏移量，得到物理内存地址 TLB多级页表虽然解决了空间问题，但是多了几道地址转换的查表，时间成本增加。 由此引入 TLB（Translation Lookaside Buffer）快表，程序有局部性，对于一个程序而言，往往访问的都是内存的某些区域，所以可以将进程经常访问的页表项存入 Cache 中，这个 Cache 即是 TLB 快表。 在之前的步骤前加上查询 TLB 快表的流程，TLB 快表中存储了经常访问的虚拟页号到物理页号的映射。 先查询 TLB，如果查到了，则直接快速拿到物理地址 如果 TLB 未能查到，也就是 TLB miss，则按照正常地流程步骤获取物理地址，并将其加入 TLB 中 大页TLB 的大小有限，即可以存储的快速查找的虚拟页号到物理页号的映射有限。 在 Linux 的缺省配置，页大小为 4 KB。但也支持更大的尺寸，如 2MB 或 1 GB 的大页，这样虽然 TLB 的页表项数量不变，但是每一项对应的物理页面的大小增加，可以由 TLB 直接命中的范围也就增加了。 TLB 命中概率增加，TLB miss 发生概率减小，如此大大增加了访存效率。 激活大页设置大页，2MB 的大页设置 1024 个 1echo 1024 &gt; /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages 查看大页设置 12345678910root@ubuntu:~# cat /proc/meminfo |grep HuAnonHugePages: 0 kBShmemHugePages: 0 kBFileHugePages: 0 kBHugePages_Total: 1024HugePages_Free: 1024HugePages_Rsvd: 0HugePages_Surp: 0Hugepagesize: 2048 kBHugetlb: 2097152 kB 环境抽象层 EALEAL（Environment Abstraction Layer，环境抽象层）用于获取底层资源。EAL 可以使用通用接口，屏蔽应用和库的环境特殊性，同时负责初始化分配资源。 EAL 主要提供下列典型服务： DPDK 的加载和启动：DPDK 和指定的程序链接成一个独立的进程，并以某种方式加载 CPU 亲和性和分配处理：DPDK 提供机制将执行单元绑定到特定的核上，就像创建一个执行程序一样。 系统内存分配：EAL 实现了不同区域内存的分配，例如为设备接口提供了物理内存。 PCI 地址抽象：EAL 提供了对 PCI 地址空间的访问接口。 跟踪调试功能：日志信息，堆栈打印、异常挂起等等。 公用功能：提供了标准 libc 不提供的自旋锁、原子计数器等。 CPU 特征辨识：用于决定 CPU 运行时的一些特殊功能，决定当前 CPU 支持的特性，以便编译对应的二进制文件。 中断处理：提供接口用于向中断注册/解注册回掉函数。 告警功能：提供接口用于设置/取消指定时间环境下运行的毁掉函数。 EAL 参数EAL parameters 内核初始化与启动内核的初始化由 rte_eal_init() 函数完成，待所有核完成初始化后，通过 `rte_eal_remote_launch() ` 函数启动各个核上的应用，具体过程如下 MAIN lcore 启动 main() 函数 MAIN lcore 调用 rte_eal_init() 进行各种初始化 命令行参数 -l 可以设置运行 lcore，第一个作为 MAIN lcore，剩下的作为 WORKER lcores，如不设置， 在 MAIN lcore 中主要包括内存、日志、PCI 等初始化工作 在 WORKER lcores 启动线程，并使之处于 WAIT 状态 MAIN lcore 等待所有逻辑核初始化完毕 其他初始化工作，如初始化 lib 库和驱动 MAIN lcore 调用 rte_eal_remote_launch(func, arg, worker_id) 函数，给 WORKER lcore 分配 function 并启动 发送信息到对应 worker_id 的 WORKER lcore，确认该核处在 WAIT 状态 WORKER lcore 接收到信息，切换到 RUNNING 状态，并执行 function 带 arg 参数 WORKER lcore 执行 function 完毕后，切换回 WAIT 状态，function 的返回值可以通过 rte_eal_wait_lcore() 读取 MAIN lcore 调用 rte_cal_mp_wait_Icore() 函数，等待所有 WORKER lcores 完成 app 如果不设置等待，MAIN lcore 会直接结束，不知道其他核的运行情况 等待所有的核完成 function 切回 WAIT 状态 关闭与清理环境在 MAIN lcore 程序的最后运行 rte_eal_cleanup() 函数，用于清理 EAL 环境。rte_eal_cleanup() 将会释放 rte_eal_init() 分配的内存，在清理之后，DPDK 函数就无法再被调用了。 内存管理MEMPOOL Libraryrte_pktmbuf_pool_create rte_pktmbuf_pool_create_by_ops rte_mempool_lookup rte_mempool_free DPDK 环境搭建以 Ubuntu 20.04.6 安装 DPDK 23.11 为例 依赖 安装 C 编译器 1apt install build-essential 安装 meson 和 ninja 1pip3 install meson ninja 安装 pyelftools 1pip3 install pyelftools 安装 NUMA Library 1apt install libnuma-dev 大页设置大页 1echo 1024 &gt; /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages DPDK 安装 下载解压 123wget http://fast.dpdk.org/rel/dpdk-23.11.tar.xztar xJf dpdk-23.11.tar.xzcd dpdk-23.11 设置编译选项 1meson setup build 编译 1234cd buildninjameson installldconfig DPDK 与网卡官方实例Hello World编译运行 编译 123cd buildmeson configure -Dexamples=helloworldninja 运行 12echo 1024 &gt; /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepagescd build 1234567891011root@ubuntu:/opt/dpdk-23.11/build# ./examples/dpdk-helloworldEAL: Detected CPU lcores: 3EAL: Detected NUMA nodes: 1EAL: Detected static linkage of DPDKEAL: Multi-process socket /var/run/dpdk/rte/mp_socketEAL: Selected IOVA mode 'PA'EAL: VFIO support initializedTELEMETRY: No legacy callbacks, legacy socket not createdhello from core 1hello from core 2hello from core 0 代码解析建立一个多核（线程）运行环境，每个线程打印hello from core 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* SPDX-License-Identifier: BSD-3-Clause * Copyright(c) 2010-2014 Intel Corporation */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;errno.h&gt;#include &lt;sys/queue.h&gt;#include &lt;rte_memory.h&gt;#include &lt;rte_launch.h&gt;#include &lt;rte_eal.h&gt;#include &lt;rte_per_lcore.h&gt;#include &lt;rte_lcore.h&gt;#include &lt;rte_debug.h&gt;/* Launch a function on lcore. 8&lt; */static intlcore_hello(__rte_unused void *arg)&#123; unsigned lcore_id; lcore_id = rte_lcore_id(); printf(\"hello from core %u\\n\", lcore_id); return 0;&#125;/* &gt;8 End of launching function on lcore. *//* Initialization of Environment Abstraction Layer (EAL). 8&lt; */intmain(int argc, char **argv)&#123; int ret; unsigned lcore_id; ret = rte_eal_init(argc, argv); if (ret &lt; 0) rte_panic(\"Cannot init EAL\\n\"); /* &gt;8 End of initialization of Environment Abstraction Layer */ /* Launches the function on each lcore. 8&lt; */ RTE_LCORE_FOREACH_WORKER(lcore_id) &#123; /* Simpler equivalent. 8&lt; */ rte_eal_remote_launch(lcore_hello, NULL, lcore_id); /* &gt;8 End of simpler equivalent. */ &#125; /* call it on main lcore too */ lcore_hello(NULL); /* &gt;8 End of launching the function on each lcore. */ rte_eal_mp_wait_lcore(); /* clean up the EAL */ rte_eal_cleanup(); return 0;&#125; 参考 DPDK 官方文档 《深入浅出DPDK》 https://zzqcn.github.io/opensource/dpdk/index.html","categories":[],"tags":[{"name":"DPDK","slug":"DPDK","permalink":"https://gy23333.github.io/tags/DPDK/"}]},{"title":"Neovim","slug":"Neovim","date":"2023-10-12T15:53:52.000Z","updated":"2024-11-17T16:04:07.060Z","comments":true,"path":"2023/10/12/Neovim/","link":"","permalink":"https://gy23333.github.io/2023/10/12/Neovim/","excerpt":"vim","text":"vim Neovim 安装Linux对于 Ubuntu，安装更新版本的 Neovim 添加源 1sudo add-apt-repository ppa:neovim-ppa&#x2F;unstable 更新源 1sudo apt-get update 安装 Neovim 1sudo apt-get install neovim 安装后输入 nvim 即可进入 如果依旧想要输入 vim 进入，可使用链接替换 1alias vim&#x3D;&#39;nvim&#39; Mac对于 mac， 1brew install neovim 在 ~/.bash_profile 中添加 1alias vim&#x3D;&#39;nvim&#39; 1source ~&#x2F;.bash_profile Vim 模式普通模式打开 Vim 直接进入的就是普通模式，主要用于浏览文件、执行复制粘贴删除等的操作 输入模式普通模式下输入 i 进入输入模式，输入 Esc 退出输入模式回到普通模式 命令模式普通模式下输入 : 进入命令模式 可视模式普通模式下输入 v 进入可视模式，用于选中 普通模式光标移动可以使用方向键进行移动，但更多地使用 hjkl 移动光标 快捷键 指令 h 左移 j 下移 k 上移 l 右移 4h 左移4格 w (word) 跳转到下一个单词的开头 b (beginning) 跳转到前一个单词的开头 gg 跳转到文件开头 G 跳转到文件结尾 Ctrl+u (PgUp) 向上翻页 Ctrl+d (PgDown) 向下翻页 fr (find r) 移动到下一个 r 复制粘贴复制键 y (yank)，粘贴键 p (paste) 快捷键 指令 yaw (yank all word) 复制整个单词 y4j 复制本行以及下4行（一共5行） yfr 复制到 r 为止的内容（包括 r） p 粘贴 删除删除键 d (delete)，操作与复制同理 改变改变键 c (change)，操作与复制同理，删除选中内容并进入输入模式 查找 快捷键 指令 / 从上往下查找 ? 从下往上查找 n 下一个 N 上一个 命令模式命令 :h &lt;plugin name&gt; 查看插件说明书 窗口 快捷键 指令 :b&lt;N&gt; 跳到第 N 个 Tab :b &lt;file name&gt; 跳到相应文件名的 Tab :bn 跳到上一个的 Tab :bp 跳到下一个的 Tab 快捷键 快捷键 指令 &lt;Ctrl-w&gt; + h/j/k/l 切换聚焦窗口 &lt;Ctrl-w&gt; + w 切换聚焦到下一个窗口 LazyVimhttp://www.lazyvim.org 【【教完必会】别再说配置neovim麻烦了！给我1分钟就够！— Lazyvim教程】https://www.bilibili.com/video/BV1ds4y1P7Rs?vd_source=c44e01a0c037484413d7d1b782385f3e 插件常用操作光标跳转 跳转到周围特定字母 s 进入查找状态 输入待查找字母，标亮周围该字母，并附上标签 输入标签，跳转到特定位置 目录树侧边栏的目录树由 NeoTree 插件驱动 显示/隐藏侧边栏 Space -&gt; e 查看快捷键 ? 终端 唤出/隐藏终端：ctrl + \\ Buffer 切换下一个 Buffer：SHIFT + l 切换上一个 Buffer：SHIFT + h LSP安装 输入:Mason 进入 Mason LSPLazyvim 默认配置 LSP MasonMason 用来做 LSP 的包管理 进入 Mason 管理窗口 有两种方法： :Mason leader -&gt; c -&gt; m 在这个窗口适用文件的各种查找操作 搜索包 可以通过 Language Filter 过滤出指定语言：CTRL + f 或者和文件一样，通过 / 或其他搜索 安装包 移动到相应包，按 i 卸载包 移动到相应包，按 X 操作跳转查看 查看定义：g —&gt; d 跳转到定义：g —&gt; D 查看引用：g —&gt; r 查看详情：K 查找替换 变量重命名：Leader —&gt; c —&gt; r 配置新建 nvim 的配置文件夹 ~/.config/nvim ，结构如下 1234567891011121314151617181920├── init.vim 入口文件，这里负责加载所有lua文件夹里的文件└── lua 所有 lua 配置文件 ├── basic.lua Neovim 的基础配置 ├── keybindings.lua 快捷键配置 ├── lsp 内置 LSP (Language Server Protocol) 配置 │ ├── diagnostic_signs.lua │ ├── language_servers.lua │ └── nvim-cmp-config.lua ├── plugin-config 各个插件配置在这个文件夹 │ ├── bufferline.lua │ ├── comment.lua │ ├── nvim-autopairs.lua │ ├── nvim-colorizer.lua │ ├── nvim-tree.lua │ ├── nvim-treesitter.lua │ ├── rust-tools.lua │ ├── surround.lua │ ├── telescope.lua │ └── which-key.lua └── plugins.lua 插件安装管理 nvim 在下次启动时会自动查看其中的内容进行更新，当然也可以在编辑后直接使用 :so 命令当重新载入。 以 ~/.config/nvim/init.lua 作为入口，lua 文件夹放置不同的模块 插件使用插件管理器 lazy.vim 进行插件管理 安装 lazyvim 新建 lua/lazynvim-init.lua 12345678910111213local lazypath = vim.fn.stdpath(\"data\") .. \"/lazy/lazy.nvim\"if not vim.loop.fs_stat(lazypath) then vim.fn.system(&#123; \"git\", \"clone\", \"--filter=blob:none\", \"https://github.com/folke/lazy.nvim.git\", \"--branch=stable\", -- latest stable release lazypath, &#125;)endvim.opt.rtp:prepend(lazypath)require(\"lazy\").setup(&#123;&#125;) 在 init.lua 中 1require(\"lazynvim-init\") 如此后，便可输入 :Lazy 打开 安装插件 以安装 nvim-tree 为例 在 lua 文件夹下新建 plugins 目录 在 lazynvim-init.lua 中的 setup 中将 plugins 目录添加为参数 1require(\"lazy\").setup(\"plugins\") 在 lua/plugins 下添加文件 plugin-nvim-tree.lua 12345678910return &#123; &#123; \"nvim-tree/nvim-tree.lua\", version = \"*\", dependencies = &#123;\"nvim-tree/nvim-web-devicons\"&#125;, config = function() require(\"nvim-tree\").setup &#123;&#125; end &#125;&#125; &quot;nvim-tree/nvim-tree.lua&quot;：插件在 github 上的短 url version：下载的版本，* 表示自动更新最新版本 dependencies = {&quot;nvim-tree/nvim-web-devicons&quot;}：依赖插件 config = ... ...：当插件启动加载以后，则会执行该 config 的代码 重新打开 vim 即可自动加载插件 常用插件主题插件 TokyoNight123456789return &#123; &#123; \"folke/tokyonight.nvim\", version = \"*\", config = function() require(\"tokyonight\").setup &#123;&#125; end &#125;&#125; 文件树插件 nvim-tree 下载 nerd fornt 字体 Linux 1wget -c https:&#x2F;&#x2F;github.com&#x2F;ryanoasis&#x2F;nerd-fonts&#x2F;releases&#x2F;download&#x2F;v3.0.2&#x2F;DejaVuSansMono.zip 1sudo unzip DejaVuSansMono.zip -d &#x2F;usr&#x2F;share&#x2F;fonts&#x2F;DejaVuSansMono 1234cd &#x2F;usr&#x2F;share&#x2F;fonts&#x2F;SourceCodeProsudo mkfontscale # 生成核心字体信息sudo mkfontdir # 生成字体文件夹sudo fc-cache -fv # 刷新系统字体缓存 Mac https://joit.info/essay/a5f51f2cbbb240d7a992d481fc09f7e0 下载字体后在配置里配置 Terminal 字体 12brew tap homebrew&#x2F;cask-fontsbrew install --cask font-hack-nerd-font 12345678910return &#123; &#123; \"nvim-tree/nvim-tree.lua\", version = \"*\", dependencies = &#123;\"nvim-tree/nvim-web-devicons\"&#125;, config = function() require(\"nvim-tree\").setup &#123;&#125; end &#125;&#125; 相关命令： 快捷键 指令 g? 查看帮助 &lt;C-k&gt; 查看信息 r 重命名 o 开文件 a 创建新文件 d 删除文件 c 复制文件 p 粘贴文件 x 剪切文件 J 跳到顶部的文件/文件夹 K 跳到底部的文件/文件夹 &lt; / &gt; 跳到上一个/下一个兄弟文件/文件夹 y 复制文件名 Y 复制相对地址 gy 复制绝对地址 状态栏插件 lualine.nvim123456789return &#123; &#123; \"nvim-lualine/lualine.nvim\", version = \"*\", config = function() require(\"lualine\").setup &#123;&#125; end &#125;&#125; 页插件 bufferline.nvim12345678910return &#123; &#123; \"akinsho/bufferline.nvim\", version = \"*\", config = function() vim.opt.termguicolors = true require(\"bufferline\").setup&#123;&#125; end &#125;&#125; 参考 https://zhuanlan.zhihu.com/p/571617696 lazy.vim官网 lazy-nvim插件管理器基础入门 【全程讲解】Neovim从零配置成属于你的个人编辑器 Lazyvim官方文档","categories":[],"tags":[]},{"title":"Linux 网络","slug":"Linux-网络","date":"2023-10-11T15:15:53.000Z","updated":"2024-11-11T03:57:58.129Z","comments":true,"path":"2023/10/11/Linux-网络/","link":"","permalink":"https://gy23333.github.io/2023/10/11/Linux-%E7%BD%91%E7%BB%9C/","excerpt":"","text":"内核如何收包 参考 Linux 网络栈接收数据","categories":[],"tags":[]},{"title":"gRPC与Go","slug":"gRPC与Go","date":"2023-09-19T17:29:19.000Z","updated":"2024-11-25T16:50:02.572Z","comments":true,"path":"2023/09/20/gRPC与Go/","link":"","permalink":"https://gy23333.github.io/2023/09/20/gRPC%E4%B8%8EGo/","excerpt":"gRPC，由 google 开发的一种远程过程调用协议。gRPC 支持多种语言之间的调用，本文主要讲述 gRPC 基于 Go 的实现。","text":"gRPC，由 google 开发的一种远程过程调用协议。gRPC 支持多种语言之间的调用，本文主要讲述 gRPC 基于 Go 的实现。 gRPC 简介 gRPC 使用 Protocol Buffer 作为其接口定义语言，使得 gRPC 客户端可以跨机器、跨语言调用 gRPC 服务器的方法。 Protocol Buffer 定义接口的输入参数和返回类型 gRPC 服务端：实现接口方法，并运行 gRPC Server gRPC 客户端：调用 gRPC Stub （相当于 gRPC Server 在客户端的代理，拥有与 Server 实现的接口方法）的接口 环境安装Mac 安装 go gRPC 所需环境 protobuf安装 protobuf 1brew install protobuf 检查安装是否成功 12❯ protoc --versionlibprotoc 28.3 protoc-gen-go、protoc-gen-go-grpc安装 protoc-gen-go、protoc-gen-go-grpc 1go install google.golang.org&#x2F;protobuf&#x2F;cmd&#x2F;protoc-gen-go@latest 1go install google.golang.org&#x2F;grpc&#x2F;cmd&#x2F;protoc-gen-go-grpc@latest 安装完成后，可以在 ${GOPATH}/bin 下看到 protoc-gen-go 和 protoc-gen-go-grpc 确认 ${GOPATH}/bin 已添加到环境变量的 PATH 中 ProtobufProtobuf 是 google 开发的序列化数据格式，定义交换的数据格式，序列化和反序列化数据到各种语言，实现跨语言、跨平台通信。 Protobuf 版本.proto 文件的开头需要注明使用的 Protobuf 版本号，Protobuf 共有 editions、proto2、proto3 三种版本，建议使用 proto3，下面说明均以 proto3 为例。 1syntax = \"proto3\"; 如不声明，默认使用 proto2。 数据类型基础类型Protobuf 支持多种内置数据类型，并可以映射到各种语言，以 Go 语言为例： Protobuf Go数据类型 备注 double float64 float float32 int32 int32 负数会占用更多字节 int64 int64 uint32 uint32 字节长度会依据数字大小变化 uint64 uint64 sint32 int32 与 int32 同表示 32 位整数，但 sin32 更适合处理负数场景，正负数相同字节数 sint64 int64 fixed32 uint32 与 uint32 同表示 32 位正整数，fixed32 在处理大于 $2^{28}$ 的数时更高效，永远是 4 字节 fixed64 uint64 sfixed32 int32 sfixed64 int64 bool bool string string bytes []byte 定义的 enum 和 message 也可作为数据类型。 repeated用于描述数组，可重复各种基础类型，包括内置类型、 enum 和 message 1234message Example &#123; repeated int32 numbers = 1; // 一个整数列表 repeated string names = 2; // 一个字符串列表&#125; map用于键值对结构，第一位为 key 类型，第二位 value 类型 1234message Example &#123; map&lt;string, int32&gt; scores = 1; // 键为字符串，值为整数 map&lt;int32, string&gt; ids = 2; // 键为整数，值为字符串&#125; key 和 value 的类型可以是基础类型，包括内置类型、 enum 和 message ，但不能是 repeated，如果希望 value 为数组，需要先用 message 包装这个 repeated 123456message Class &#123; message StudentList &#123; repeated string name = 1; &#125; map&lt;string, StudentList&gt; class_map = 1;&#125; enumenum 枚举类型，类型名采用驼峰命名方式，字段命名采用大写字母加下划线分隔方式。 123456789101112131415161718// 定义一个 enum 类型enum Corpus &#123; CORPUS_UNSPECIFIED = 0; CORPUS_UNIVERSAL = 1; CORPUS_WEB = 2; CORPUS_IMAGES = 3; CORPUS_LOCAL = 4; CORPUS_NEWS = 5; CORPUS_PRODUCTS = 6; CORPUS_VIDEO = 7;&#125;message SearchRequest &#123; string query = 1; int32 page_number = 2; int32 results_per_page = 3; Corpus corpus = 4; // 使用 enum 类型字段&#125; enum 的默认值为其 0 值，所以必须在第一位定义 0 值。 enum 可以通过添加 option allow_alias = true; 允许使用别名。 1234567enum EnumAllowingAlias &#123; option allow_alias = true; // 允许别名 EAA_UNSPECIFIED = 0; EAA_STARTED = 1; // EAA_STARTED 和 EAA_RUNNING互为别名 EAA_RUNNING = 1; EAA_FINISHED = 2;&#125; messagemessage 消息类型，类型名采用驼峰命名方式，字段命名采用小写字母加下划线分隔方式。 12345message SearchRequest &#123; string query = 1; int32 page_number = 2; int32 results_per_page = 3;&#125; 每个字段都要分配唯一的数值标签 tag。已有序号不能随意改动，不然会导致调用失败，在后面添加新 tag 字段不影响旧有调用。 message 类型里支持嵌套其他 message 或 enum 定义. 12345678message SearchResponse &#123; message Result &#123; string url = 1; string title = 2; repeated string snippets = 3; &#125; repeated Result results = 1;&#125; 在 parent message 外也可以引用到嵌套的 message 类型. 123message SomeOtherMessage &#123; SearchResponse.Result result = 1;&#125; service定义远程调用方法作为客户端与服务端的约定，服务端需实现此接口，用户端调用此接口 123service SearchService &#123; rpc Search(SearchRequest) returns (SearchResponse);&#125; 生成代码编辑完 .proto 文件后，便可生成各种语言的代码，供客户端和服务端使用，以 Go 语言为例，生成代码命令如下： 一个简单的 gRPC实现客户端向服务端查询用户的信息 Protocol Buffer参考 gRPC 官方文档 Go-gRPC 使用教程","categories":[{"name":"Golang","slug":"Golang","permalink":"https://gy23333.github.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://gy23333.github.io/tags/Golang/"},{"name":"gRPC","slug":"gRPC","permalink":"https://gy23333.github.io/tags/gRPC/"}]},{"title":"git","slug":"git","date":"2023-07-31T17:11:30.000Z","updated":"2024-11-11T03:57:58.127Z","comments":true,"path":"2023/08/01/git/","link":"","permalink":"https://gy23333.github.io/2023/08/01/git/","excerpt":"Git 常用命令以及使用场景","text":"Git 常用命令以及使用场景 文件状态 初始化新仓 1go init 此时里面的所有文件都是“未跟踪”状态 将文件添加到暂存区 1git add &lt;name&gt; 提交 1git commit -m &quot;message&quot; 命令查看 git 配置1git config --list 创建新仓库初始化新仓 1go init 此时会在目录下新增一个 .git 隐藏目录，用于跟踪管理版本库 克隆已有项目1git clone &lt;HTTP or SSH&gt; 添加修改将修改过的文件修改为缓存状态 1git add &lt;name&gt; 取消缓存状态通过 add 设置的缓存状态，可以通过 reset 取消 1git reset HEAD &lt;name&gt; git clone 速度慢添加 git 的域名映射 查询 ip 123456789101112131415(base) ➜ ~ nslookup github.global.ssl.fastly.NetServer: 192.168.1.1Address: 192.168.1.1#53Non-authoritative answer:Name: github.global.ssl.fastly.NetAddress: 173.252.88.67(base) ➜ ~ nslookup github.comServer: 192.168.1.1Address: 192.168.1.1#53Non-authoritative answer:Name: github.comAddress: 20.205.243.166 在 /etc/hosts 添加域名映射 1220.205.243.166 github.com173.252.88.67 github.global.ssl.fastly.Net 刷新 DNS 缓存 1sudo killall -HUP mDNSResponder","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://gy23333.github.io/tags/git/"}]},{"title":"Python","slug":"Python","date":"2023-05-29T16:47:12.000Z","updated":"2024-11-22T15:57:39.319Z","comments":true,"path":"2023/05/30/Python/","link":"","permalink":"https://gy23333.github.io/2023/05/30/Python/","excerpt":"Python 学习记录","text":"Python 学习记录 基本语法注释123456# 单行注释\"\"\"多行注释多行注释\"\"\" 行与缩进不使用 {}，而是使用缩进的方式来表示代码块 1234if True: print (\"True\")else: print (\"False\") 多行语句过长的语句采用 \\ 换行 123total = item_one + \\ item_two + \\ item_three 在 [], {}, 或 () 中的多行语句，不需要使用反斜杠 \\ 12total = ['item_one', 'item_two', 'item_three', 'item_four', 'item_five'] 引入模块引入整个模块 1import somemodule 引入模块中的部分函数 1from somemodule import somefunction 变量赋值Python 中的变量赋值不需要类型声明，所以每个变量在使用前都必须赋值。 1a = 1 多个变量赋值 1a, b = 1, 'abc' 允许连等 1a = b = 1 Number支持 int、float、bool、complex 可以用 type() 来查询变量所指的对象类型 12a, b, c, d = 1, 1.5, True, 4+3jprint(type(a), type(b), type(c), type(d)) 输出： 1&lt;class &#39;int&#39;&gt; &lt;class &#39;float&#39;&gt; &lt;class &#39;bool&#39;&gt; &lt;class &#39;complex&#39;&gt; 数值运算与其他语言不同，python 中 \\ 和 \\\\ 都是除法，但是 \\ 得一浮点数，\\\\ 得一整数 1234&gt;&gt;&gt; 1 / 20.5&gt;&gt;&gt; 1 // 20 ** 表示乘方，x ** y 即 $x^y$ 12&gt;&gt;&gt; 2 ** 532 类型转换转换成数字类型直接用 int()、float() 这样的强制类型转换 1234567&gt;&gt;&gt; a, b, c = 1, 1.2, '123'&gt;&gt;&gt; float(a)1.0&gt;&gt;&gt; int(b)1&gt;&gt;&gt; int(c)123 String可以用 &#39; 或 &quot; 来创建字符串 Python 不支持单字符类型，单字符也当作字符串处理 索引与截取字符串索引，前面从 0 开始，后面从 -1 开始 字符串截取 1str[上标 : 下标] 范围是 [上标, 下标)，不包括下标 123456789&gt;&gt;&gt; str = 'python'&gt;&gt;&gt; str[0:3]'pyt'&gt;&gt;&gt; str[2:-1]'tho'&gt;&gt;&gt; str[1:]'ython'&gt;&gt;&gt; str[:-1]'pytho' List列表 List 的数据项不需要是相同的类型，索引方式与 String 相同 1234567&gt;&gt;&gt; list = [1, 2, \"Red\"]&gt;&gt;&gt; list[0]1&gt;&gt;&gt; list[-1]'Red'&gt;&gt;&gt; list[1:][2, 'Red'] 使用 append() 方法来添加列表项 123&gt;&gt;&gt; list.append(\"Green\")&gt;&gt;&gt; list[1, 2, 'Red', 'Green'] 也可用 + 或 * 来扩展 List 12&gt;&gt;&gt; [1, 2, 3] + [4, 5, 6][1, 2, 3, 4, 5, 6] 12&gt;&gt;&gt; [1] * 3[1, 1, 1] 使用 del 语句来删除列表的的元素 123&gt;&gt;&gt; del list[2]&gt;&gt;&gt; list[1, 2, 'Green'] 求长度 12&gt;&gt;&gt; len([1, 2, 3])3 判断元素是否在 List 中 12&gt;&gt;&gt; 1 in [1, 2, 3]True 遍历 List 12for x in [1, 2, 3]: ... 判断两个 List 是否相同，需引入 operator 模块 12345import operatorlist1, list2, list3 = [1, 2], [1, 2], [2, 3]print(operator.eq(list1, list2)) # Trueprint(operator.eq(list1, list3)) # False Tuple元祖 Tuple 与 List 类似，但是 Tuple 不能修改 Dictionary数据类型转换运算符部分运算符 运算符 描述 实例 ** 语句ifwhileforbreakcontinuepass命令行参数函数模块类文件异常测试","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://gy23333.github.io/tags/python/"}]},{"title":"GDB调试工具","slug":"GDB调试工具","date":"2023-04-17T05:20:36.000Z","updated":"2024-11-11T03:57:58.107Z","comments":true,"path":"2023/04/17/GDB调试工具/","link":"","permalink":"https://gy23333.github.io/2023/04/17/GDB%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/","excerpt":"GDB调试器的","text":"GDB调试器的 GDB可以完成以下功能： 开始并设置参数 打断点 GDB支持多种语言，常见的比如 C、C++、Go 搭建环境 安装GDB 1brew install gdb 如brew下载缓慢，也可以在官网下载 查看GDB版本 QuickStart","categories":[],"tags":[{"name":"GDB","slug":"GDB","permalink":"https://gy23333.github.io/tags/GDB/"}]},{"title":"Linux学习","slug":"Linux学习","date":"2023-03-19T14:39:41.000Z","updated":"2024-12-08T07:08:55.750Z","comments":true,"path":"2023/03/19/Linux学习/","link":"","permalink":"https://gy23333.github.io/2023/03/19/Linux%E5%AD%A6%E4%B9%A0/","excerpt":"基于Linux Ubuntu的学习","text":"基于Linux Ubuntu的学习 Linux 虚拟机环境搭建Linux虚拟机的安装 安装 VMware 下载 Linux OS 镜像（注意 Mac 需要下载 arm 架构版本） Ubuntu 下载地址：ubuntu-24.04.1-live-server-arm64.iso Centos 将iso文件拖拽到VMware中 虚拟机网络模式虚拟机和宿主机的网络拓扑关系有三种模式：桥接模式、主机模式、NAT 模式 VMware的三种网络模式 桥接模式虚拟机网卡通过虚拟交换机 VMnet0 与宿主机网卡进行桥接，虚拟机网卡和宿主机网卡在拓扑处于同等地位，相当于局域网中的一台独立的主机。 桥接模式可以访问外网，但是需要占用该网段 IP，如果 IP 资源紧缺，使用 NAT 模式。 主机模式虚拟机网卡和宿主机网卡都连在虚拟交换机 VMnet1 上，虚拟机与外界隔开成独立的系统，只与主机相互通信。 NAT 模式在宿主机上建立单独的专用网络，虚拟机与主机之间都可以相互通信，虚拟机与外界通讯时，数据会被包裹，以主机的名义发出去。 Virtual Networking Mode VM —&gt; Host VM &lt;— Host VM1 &lt;—&gt; VM2 VM —&gt; Net VM &lt;— Net Bridge + + + + + Host-Only + + + - - NAT + + - + + NAT Network + + + + + SSHSSH连接虚拟机 虚拟机安装 openssh-server 1sudo apt install openssh-server 开启 sshd 服务 1systemctl start sshd 设置虚拟机网卡，至少需要一张 NAT 模式网卡用于 ssh 连接，查看该网卡 1ip a 网卡 IP 为 192.168.45.136 ssh 连接虚拟机 1ssh guoyi@192.168.45.136 设置 ssh 别名将下面直接登入方式改为别名登录 1ssh guoyi@192.168.45.136 在 ~/.ssh/config 文件中添加远端服务器信息 1234Host Ubuntu HostName 192.168.45.136 User guoyi Port 22 即可用别名 Ubuntu 进行登录 1ssh Ubuntu 设置免密登录 查看本机的 ~/.ssh 文件夹是否有公私钥对，没有则生成一对 1ssh-keygen 默认命名为 id_rsa，也可输入自定义名字，如 mac_key，密码无需设置，自动生成私钥 mac_key 和公钥 mac_key.pub 两个文件 将公钥上传到服务器 1ssh-copy-id -i mac_key.pub Ubuntu 此命令自动将公钥传到 Ubuntu 所指服务器和用户的 .ssh/known_hosts 文件中 （Mac 额外步骤）本机添加私钥文件 1ssh-add -K mac_key 上面三步设置完成后，即可免密登录服务器 开启 root 用户登录Ubuntu默认不允许直接 ssh 到 root 用户，需在服务器上开启 root 用户登录开关 在 Ubuntu 服务器的 /etc/ssh/sshd_config 中，取消 PermitRootLogin 参数的注释，并将由其 prohibit-password 改为 yes 1PermitRootLogin yes 重启 sshd 1systemctl restart sshd apt 更新 apt，有些包找不到，可能是因为 apt 没更新 1apt update Linux目录结构Linux的目录同样为树形结构，最顶级的根目录为/ 绝对路径 从根目录/写起，例如/usr/share/doc 相对路径 Linux基础命令 ls 查看当前目录下的所有目录和文件 cat &lt;文件路径&gt; 查看文件内容 clear 清空命令行 rpm命令redhat package manager，包管理命令 rpm -q &lt;package name&gt; ：查看包是否安装 rpm -qi &lt;package name&gt; ：查看包的详细信息 rpm -ql &lt;package name&gt; ：查看包列表（里面的文件） vim打开并编辑文件 1vi &lt;文件路径&gt; i 切换到输入模式 ESC``:wq保存并退出 yumyum 是 Shell 前端软件包管理器，提供了方便的安装、卸载、更新软件包的命令 yum的安装磁盘扩展根目录查看当前磁盘占用情况，可以看到根目录占用率很高，且在 /dev/mapper/ubuntu--vg-ubuntu--lv 分区 1234567891011guoyi@ubuntu2404:~$ df -hFilesystem Size Used Avail Use% Mounted ontmpfs 391M 1.7M 389M 1% /runefivarfs 256K 32K 225K 13% /sys/firmware/efi/efivars/dev/mapper/ubuntu--vg-ubuntu--lv 9.8G 8.3G 974M 90% /tmpfs 2.0G 0 2.0G 0% /dev/shmtmpfs 5.0M 8.0K 5.0M 1% /run/lock/dev/nvme0n1p2 1.7G 105M 1.5G 7% /boot/dev/nvme0n1p1 952M 6.4M 945M 1% /boot/efitmpfs 391M 124K 391M 1% /run/user/1000/dev/sr0 2.4G 2.4G 0 100% /media/guoyi/Ubuntu-Server 24.04.1 LTS arm64 查看当前磁盘分区，ubuntu--vg-ubuntu--lv 在 nvme0n1p3 下 123456789101112131415guoyi@ubuntu2404:~$ lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTSloop0 7:0 0 4K 1 loop /snap/bare/5loop1 7:1 0 68.8M 1 loop /snap/core22/1666loop2 7:2 0 250.3M 1 loop /snap/firefox/5236loop3 7:3 0 483.3M 1 loop /snap/gnome-42-2204/178loop4 7:4 0 91.7M 1 loop /snap/gtk-common-themes/1535loop5 7:5 0 33.7M 1 loop /snap/snapd/21761loop6 7:6 0 144.1M 1 loop /snap/thunderbird/560sr0 11:0 1 2.3G 0 rom /media/guoyi/Ubuntu-Server 24.04.1 LTS arm64nvme0n1 259:0 0 50G 0 disk├─nvme0n1p1 259:1 0 953M 0 part /boot/efi├─nvme0n1p2 259:2 0 1.8G 0 part /boot└─nvme0n1p3 259:3 0 11.9G 0 part └─ubuntu--vg-ubuntu--lv 252:0 0 10G 0 lvm / 扩展步骤： 通过 VMWare 扩展磁盘 通过 Disks 或者 GParted 软件将 nvme0n1p3 分区扩展 将剩余空间分配给 /dev/mapper/ubuntu--vg-ubuntu--lv 分区 1sudo lvextend -r -l +100%FREE &#x2F;dev&#x2F;mapper&#x2F;ubuntu--vg-ubuntu--lv 查看磁盘情况 123456789101112131415161718192021222324252627guoyi@ubuntu2404:~$ lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTSloop0 7:0 0 4K 1 loop /snap/bare/5loop1 7:1 0 68.8M 1 loop /snap/core22/1666loop2 7:2 0 250.3M 1 loop /snap/firefox/5236loop3 7:3 0 483.3M 1 loop /snap/gnome-42-2204/178loop4 7:4 0 91.7M 1 loop /snap/gtk-common-themes/1535loop5 7:5 0 33.7M 1 loop /snap/snapd/21761loop6 7:6 0 144.1M 1 loop /snap/thunderbird/560sr0 11:0 1 2.3G 0 rom /media/guoyi/Ubuntu-Server 24.04.1 LTS arm64nvme0n1 259:0 0 50G 0 disk├─nvme0n1p1 259:1 0 953M 0 part /boot/efi├─nvme0n1p2 259:2 0 1.8G 0 part /boot└─nvme0n1p3 259:3 0 47.3G 0 part └─ubuntu--vg-ubuntu--lv 252:0 0 47.3G 0 lvm / guoyi@ubuntu2404:~$ df -hFilesystem Size Used Avail Use% Mounted ontmpfs 391M 1.7M 389M 1% /runefivarfs 256K 32K 225K 13% /sys/firmware/efi/efivars/dev/mapper/ubuntu--vg-ubuntu--lv 47G 8.3G 37G 19% /tmpfs 2.0G 0 2.0G 0% /dev/shmtmpfs 5.0M 8.0K 5.0M 1% /run/lock/dev/nvme0n1p2 1.7G 105M 1.5G 7% /boot/dev/nvme0n1p1 952M 6.4M 945M 1% /boot/efitmpfs 391M 128K 391M 1% /run/user/1000/dev/sr0 2.4G 2.4G 0 100% /media/guoyi/Ubuntu-Server 24.04.1 LTS arm64 问题记录su root 时，报错 Authentication failure首次 su root 时，需先录入密码 1sudo passwd root 否则会出现 Authentication failure 的报错","categories":[],"tags":[]},{"title":"DNS与Bind","slug":"DNS与Bind","date":"2023-03-19T13:15:53.000Z","updated":"2024-11-11T03:57:58.128Z","comments":true,"path":"2023/03/19/DNS与Bind/","link":"","permalink":"https://gy23333.github.io/2023/03/19/DNS%E4%B8%8EBind/","excerpt":"基于《DNS与Bind》的学习","text":"基于《DNS与Bind》的学习 DNS基础TCP/IP网络依赖IP地址进行设备间通信，但是数字形式的IP地址难以记忆，所以使用域名（如www.google.com）解析成IP地址，以便访问该网络设备。 本机上的/etc/hosts中存放了部分域名到IP地址的映射，可以手工维护，分散式管理映射。 如在mac中的Finder中按下Shift+command+G，输入/etc/hosts，即可找到本机的名称解析配置文件。 但hosts文件不可能存下所有的（域名，IP地址）映射，于是便引入了DNS。 域名系统（Domain Name System，DNS）通过分布式的数据库来实现IP地址和域名的映射。 DNS基于C/S架构，服务端端口号UDP53、TCP53。 DNS域名结构DNS采用分布式的数据库，是一个逆向的树形结构。 DNS树每个节点代表一个域 根域名服务器 最高层的域就是根域root，全球共13台根域名服务器，根域即是一个点 . ，通常都省略不写。 顶级域名服务器 又称一级域名，常见的有”.com”、”.org”、”.net”、”.cn”等。 剩下的域为二级、三级、四级域，最多可达127级域名。 FQDN 全称域名 = 主机名 + 域名 以 www.baidu.com 和 tieba.baidu.com 为例baidu.com 为域名，www 和 tieba 都是 baidu.com 下的主机，一个域下可以定义多台主机，只需配置好主机名和对应主机的IP地址即可。 www.baidu.com本该有一个根域名的 .，即 www.baidu.com.，但根域名的 . 一般省略不写。 DNS查询方法迭代查询 递归查询 缓存和更新域名解析顺序 查找 /etc/hosts DNS软件BINDBIND是一款提供DNS服务的软件，Centos安装BIND作为DNS服务器，程序名称为named BIND相关程序包有4个： bind：服务器 bind-libs：相关库 bind-utils：客户端工具 bind-chroot：安全包 Bind安装在Centos上使用yum安装的bind 切换到root用户，以获取权限 1su root 使用yum安装Bind 1yum -y install bind 安装完bind后，相关程序包存在依赖性，也会一起安装，可以用rpm查看是否顺带安装了相关程序包 1rpm -qi bind-libs 1rpm -qi bind-utils 1rpm -qi bind-chroot 如缺少bind-libs、bind-utils，建议单独安装 BIND包相关文件查询BIND包相关文件列表 1rpm -ql bind 里面的常用文件介绍： BIND主程序：/usr/sbin/named 主配置文件：/etc/named.conf 数据库目录：/var/named 启动DNS服务启动named程序，本机即可充当DNS服务器 1systemctl start named 查看DNS服务器方法一：可视化页面中查看DNS右上角 Wired Settings -&gt; Wired的设置 -&gt; DNS 方法二：查看DNS客户机配置文件（/etc/resolv.conf）/etc/resolv.conf是DNS客户机配置文件 1cat &#x2F;etc&#x2F;resolv.conf 查看该文件 123# Generated by NetworkManagersearch localdomainnameserver 192.168.45.2 查看nameserver项，可以看出使用的DNS服务器的IP地址为192.168.45.2 方法三：查看网卡配置文件（/etc/sysconfig/network-scripts/ifcfg-ens33）每种Linux系统的网卡配置文件路径不同，详见 相关文件配置 -&gt; 网卡配置文件 1cat &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33 查看DNS配置选项 设置DNS服务器CentOS配置网卡为静态IPDHCP协议会自动动态配置IP和DNS服务器，为了方便学习DNS，建议改为静态IP模式学习。 如本身就是静态IP，请跳过此步。 查看是静态IP还是动态IP可以在网卡配置文件中查看采用的是DHCP协议还是静态IP 查看网卡配置文件 1cat &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33 显示 123456789101112131415TYPE&#x3D;&quot;Ethernet&quot;PROXY_METHOD&#x3D;&quot;none&quot;BROWSER_ONLY&#x3D;&quot;no&quot;BOOTPROTO&#x3D;&quot;dhcp&quot;DEFROUTE&#x3D;&quot;yes&quot;IPV4_FAILURE_FATAL&#x3D;&quot;no&quot;IPV6INIT&#x3D;&quot;yes&quot;IPV6_AUTOCONF&#x3D;&quot;yes&quot;IPV6_DEFROUTE&#x3D;&quot;yes&quot;IPV6_FAILURE_FATAL&#x3D;&quot;no&quot;IPV6_ADDR_GEN_MODE&#x3D;&quot;stable-privacy&quot;NAME&#x3D;&quot;ens33&quot;UUID&#x3D;&quot;0a5c00b5-f7bc-49cf-9a58-11ca6df07fe2&quot;DEVICE&#x3D;&quot;ens33&quot;ONBOOT&#x3D;&quot;yes&quot; 查看BOOTPROTO选项，如果是dhcp，则采用DHCP协议；如是static，则采用静态IP 配置网卡为静态IP 打开网卡配置文件 1vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33 修改配置 12BOOTPROTO&#x3D;staticONBOOT&#x3D;yes 增加配置 查看网络配置，手动填入 123IPADDR&#x3D;192.168.45.130NETMASK&#x3D;255.255.255.0GATEWAY&#x3D;192.168.45.2 重启网卡 1nmcli connection reload 1nmcli connection up ens33 或者 1systemctl restart network 此时，网卡配置文件内容如下 123456789101112131415161718TYPE&#x3D;EthernetPROXY_METHOD&#x3D;noneBROWSER_ONLY&#x3D;noBOOTPROTO&#x3D;staticDEFROUTE&#x3D;yesIPV4_FAILURE_FATAL&#x3D;noIPV6INIT&#x3D;yesIPV6_AUTOCONF&#x3D;yesIPV6_DEFROUTE&#x3D;yesIPV6_FAILURE_FATAL&#x3D;noIPV6_ADDR_GEN_MODE&#x3D;stable-privacyNAME&#x3D;ens33UUID&#x3D;0a5c00b5-f7bc-49cf-9a58-11ca6df07fe2DEVICE&#x3D;ens33ONBOOT&#x3D;yesIPADDR&#x3D;192.168.45.130NETMASK&#x3D;255.255.255.0GATEWAY&#x3D;192.168.45.2 没有配置DNS服务器，查看DNS服务器，也都是为空 此时，尝试ping一下域名 1ping baidu.com 没有DNS服务器，域名解析失败 设置DNS服务器 编辑网卡配置文件，修改DNS服务器，如尝试加入本机IP作为DNS服务器 1vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33 加入一行DNS配置，127.0.0.1是送回地址，指本机。 1DNS1&#x3D;127.0.0.1 如有多个DNS服务器，则DNS1、DNS2依次类推 重启该网卡 1nmcli connection reload 1nmcli connection up ens33 重新查看DNS服务器 1cat &#x2F;etc&#x2F;resolv.conf 显示 1nameserver 127.0.0.1 可以看到127.0.0.1添加进了DNS服务器中，此时本机既是DNS服务器，又是DNS的客户端 启动BIND的DNS服务 1systemctl start named ping一下域名 1ping baidu.com ping成功，本机作为DNS服务器完成了baidu.com的域名解析 多IP配置一台虚拟机可以配置多个静态IP，即多网卡。 上面的DNS配置只利用了单网卡ens33，同时作为DNS服务器和客户机。 可以配置多个IP地址，分别作为DNS服务器和客户机。 多IP配置12 主DNS配置相关文件配置DNS客户机配置文件 /etc/resolv.conf/etc/resolv.conf是DNS客户机配置文件，用于设置DNS服务器的IP地址及DNS域名，供域名解析器（resolver）使用。 每一行以一个关键字开头，后接一个或多个由空格隔开的参数。 关键字关键字有四个：（nameserver是必填项，其余的关键字都是可选） nameserver 表明DNS服务器的IP地址 可以有多行，按顺序查询，如果前面的IP无响应，则查询下一个IP domain 声明主机的域名 很多程序用到它，如邮件系统；当为没有域名的主机进行DNS查询时，也要用到。如果没有域名，主机名将被使用，删除所有在第一个点( .)前面的内容 search 它的多个参数指明域名查询顺序。当要查询没有域名的主机，主机将在由search声明的域中分别查找 如要域名 www 解析，但 www 无法解析，如配置中有 search baidu.com ，则在www后加上 . + baidu.com ，对 www.baidu.com重新进行解析 domain和search不能共存；如果同时存在，后面出现的将会被使用 sortlist 允许将得到域名结果进行特定的排序。它的参数为网络/掩码对，允许任意的排列顺序 域名解析顺序 查找 etc/hosts 根据 nameserver 指定的DNS服务器解析域名 如果所有的 nameserver 都找不到域名，则进行search补全，重新走1～2步 示例分析查看/etc/resolv.conf文件 1cat &#x2F;etc&#x2F;resolv.conf 如 123# Generated by NetworkManagersearch localdomainnameserver 192.168.45.2 网卡配置文件 /etc/sysconfig/network-scripts/ifcfg-ens33Centos可在/etc/sysconfig/network-scripts目录下查找网卡配置文件，Linux传统网卡设备命名是eth0、eth1这样的，而Centos提供了不同的命名规则，比如ens33（Ubuntu的网卡配置文件有所不同） 查看网卡配置文件 1cat &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33 123456789101112131415TYPE&#x3D;Ethernet #网卡类型：为以太网PROXY_METHOD&#x3D;none # 代理方式：关闭状态BROWSER_ONLY&#x3D;no # 只是浏览器：否BOOTPROTO&#x3D;dhcp # 网卡的引导协议：DHCP[中文名称: 动态主机配置协议]DEFROUTE&#x3D;yes # 默认路由：是IPV4_FAILURE_FATAL&#x3D;no # 是不开启IPV4致命错误检测：否IPV6INIT&#x3D;yes # IPV6是否自动初始化: 是IPV6_AUTOCONF&#x3D;yes # IPV6是否自动配置：是IPV6_DEFROUTE&#x3D;yes # IPV6是否可以为默认路由：是IPV6_FAILURE_FATAL&#x3D;no # 是不开启IPV6致命错误检测：否IPV6_ADDR_GEN_MODE&#x3D;stable-privacy # IPV6地址生成模型：stable-privacyNAME&#x3D;ens33 # 网卡物理设备名称UUID&#x3D;0a5c00b5-f7bc-49cf-9a58-11ca6df07fe2 # 通用唯一识别码, 每一个网卡都会有, 不能重复, 否两台linux只有一台网卡可用DEVICE&#x3D;ens33 # 网卡设备名称, 必须和 &#96;NAME&#96; 值一样ONBOOT&#x3D;yes # 是否开机启动，要想网卡开机就启动或通过 &#96;systemctl restart network&#96;控制网卡,必须设置为 &#96;yes&#96; 参考 Linux DNS服务Bind最全教程","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://gy23333.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"DNS","slug":"DNS","permalink":"https://gy23333.github.io/tags/DNS/"},{"name":"BIND","slug":"BIND","permalink":"https://gy23333.github.io/tags/BIND/"}]},{"title":"Go基本语法","slug":"Go基本语法","date":"2023-03-15T14:27:26.000Z","updated":"2024-11-11T03:57:58.122Z","comments":true,"path":"2023/03/15/Go基本语法/","link":"","permalink":"https://gy23333.github.io/2023/03/15/Go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"GoLang基本语法","text":"GoLang基本语法 环境配置 go下载地址 配置环境变量，命令行输入 1export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;go&#x2F;bin:$PATH 此时可在命令行中使用go命令 新建一个test.go文件 1234567package mainimport \"fmt\"func main() &#123; fmt.Println(\"Hello, World!\")&#125; 在命令行中输入，即可运行 1go run test.go 入门go的基本结构和语法一个简单的go程序： 123456789// 定义包package main// 调用包import \"fmt\"func main() &#123; fmt.Print(\"Hello, World!\")&#125; 包声明 必须在非注释的第一行进行包声明 1package main 每个Go应用程序都必须包含一个main包 引入包 1import \"fmt\" 行分隔符 go中每一行代表一个语句结束，结尾不需要加像C那样加; 输入输出Printf 格式化字符串使用fmt.Printf来格式化输出字符串 1fmt.Printf(格式化样式, 参数列表…) 格 式 描 述 %s 字符串 %f 浮点数 %d 十进制整型 %b 二进制整型 %o 八进制整型 %x 十六进制整型 %X 十六进制整型，字母大写方式显示 123name := \"John\"age := 23fmt.Printf(\"%s is %d\", name, age) 输出: John is 23 变量和常量变量变量名由字母、数字、下划线组成，其中首个字符不能为数字 使用 var 来声明变量 1var identifier type 可以一次声明多个变量 1var identifier1, identifier2 type 例如 12var str string = \"Hello\"var num1, num2 int = 1, 2 如果没有初始化，则变量默认为零值 1234567891011package mainimport \"fmt\"func main() &#123; var i int var f float64 var b bool var s string fmt.Printf(\"%v %v %v %q\\n\", i, f, b, s)&#125; 输出： 0 0 false “” 可以根据值自行判断变量类型 1var str, num = \"Hello\", 1 可省略var，使用关键字:= 1str, num := \"Hello\", 1 常量常量不会被修改，数据类型只可以是布尔型、数字型和字符串型。 1const identifier [type] = value 因为可以通过value来判断数据类型，所有type可省略 显式表示 1const str string = \"abc\" 隐式表示 1const str = \"abc\" 可以一次声明多个常量 1const str, num = \"Hello\", 1 或者用枚举： 12345const ( str = \"Hello\" a = 1 b) 这里，a和b都是1，b会继承a的=1 iotaiota是一个可以被编译器修改的特殊常量，代表了位于const的第几行，如第 n 行 =iota 则为 n 12345678const ( a = iota // 0 b // 1 c = \"hello\" d // \"hello\" e = iota // 4 f // 5) 数据结构数组概述数组，是相同元素类型的集合。 数组由两个维度描述： 元素类型 最多存储的元素个数 只有这两个条件都相同的数组才是同一类型 初始化访问和赋值声明数组 1var variable_name [SIZE] variable_type 示例： 1var nums [5] int 初始化数组 1var nums = [5]int&#123;1,2,3,4,5&#125; 1nums := [5]int&#123;1, 2, 3, 4, 5&#125; 如果数组长度不确定，可以用...代替，编译器会根据元素个数自行推断数组的长度 1nums := [...]int&#123;1, 2, 3, 4, 5&#125; 可以通过下标，只初始化特定的几个 12//初始化 nums[1] = 2.1 , nums[3] = 1.6nums := [5]float64&#123;1: 2.1, 3: 1.6&#125; 多维数组以二维数组为例 1var arrayName [ x ][ y ] variable_type 示例： 每行的结尾都要加, 1234nums := [2][3]int&#123; &#123;0, 1, 2&#125;, &#123;3, 4, 5&#125;,&#125; 或 123456nums := [][]int&#123;&#125;row1 := []int&#123;0, 1, 2&#125;row2 := []int&#123;3, 4, 5&#125;nums = append(nums, row1)nums = append(nums, row2) 数组作为函数参数一维数组做参数： 设定数组大小 123func f1(nums [10]int) &#123; ...&#125; 未设定数组大小 123func f1(nums []int) &#123; ...&#125; 指针go中指针的规则与C类似 &amp;用来取地址，*用来取内容 定义指针： 1var var_name *var-type 空指针当一个指针被定义后没有分配到任何变量时，即为一个空指针 nil 指针数组 &amp; 数组指针 指针数组 数组指针 是一个数组 是一个指针 每个元素都是一个指针 指向一个数组 12345n1, n2, n3 := 1, 2, 3nums := [3]int&#123;n1, n2, n3&#125; //普通数组ptrs := [3]*int&#123;&amp;n1, &amp;n2, &amp;n3&#125; //指针数组nums_ptr1 := &amp;nums //数组指针var nums_ptr2 *[3]int = &amp;nums //数组指针 结构体定义结构体 123456type struct_variable_type struct &#123; member definition member definition ... member definition&#125; 声明结构体变量 1variable_name := structure_variable_type &#123;value1, value2...valuen&#125; 1variable_name := structure_variable_type &#123; key1: value1, key2: value2..., keyn: valuen&#125; 通过 . 来访问结构体成员 示例： 1234567891011121314package mainimport \"fmt\"type Book struct &#123; title string author string id int&#125;func main() &#123; book := Book&#123;id: 1, title: \"BookName\", author: \"John\"&#125; fmt.Println(book.id, book.title, book.author)&#125; 结构体指针（与C不同）同样用 . 来访问结构体成员 12book_ptr := &amp;bookfmt.Println(book_ptr.id, book_ptr.title, book_ptr.author) Slice 切片与C++中的 vector 类似，长度不固定的动态数组，可以追加元素 定义切片 定义一个未指定大小的数组 1var identifier []type 也可以使用 make() 函数来创建切片 1slice1 := make([]type, len, capacity) 初始化切片 直接初始化切片，声明一个未指定大小的数组 1s := []int&#123;1,2,3&#125; 通过引用数组/切片初始化切片 如有一数组/切片arr，可以通过引用这个数组/切片来初始化切片 引用全部的数组 1s := arr[:] 引用从下标 startIndex 到 endIndex-1 的部分 1s := arr[startIndex:endIndex] 引用从下标 startIndex 到 最后一个元素 的部分 1s := arr[startIndex:] 引用从 第一个元素 到 endIndex-1 的部分 1s := arr[:endIndex] len() 和 cap() len(s) 获取切片长度 cap(s) 获取切片容量 12s := make([]int, 3, 5)fmt.Println(len(s), cap(s), s) //3 5 [0 0 0] append()append扩展切片，原切片不变，返回的新切片在原切片上加上扩展项 1new_slice = append(old_slice []Type, elems ...Type) append()的原理： 如果 old slice 的 capacity够加，则 new slice 直接在 old slice 的内存上追加，共享内存；如果capacity不够加，则 new slice 不与 old slice 共享内存，而是另开一片内存，复制 old slice 的数据 示例： old slice 的 capacity 不够加 12345s1 := []int&#123;0&#125;s2 := append(s1, 1, 2) //s1的cap不够，s2与s1不共内存fmt.Println(s1, s2) //[0] [0 1 2]s1[0] = -1 //s2与s1不共内存，s1修改，不影响s2fmt.Println(s1, s2) //[-1] [0 1 2] old slice 的 capacity 够加 12345s1 := make([]int, 1, 3)s2 := append(s1, 1, 2) //s1的cap足够，s2与s1共内存fmt.Println(s1, s2) //[0] [0 1 2]s1[0] = -1 //s4与s3共内存，s3修改，s4也会相应变化fmt.Println(s1, s2) //[-1] [-1 1 2] copy()copy复制切片，必须创造一个比原切片 capacity 更大的新切片，才能复制过来 1copy(new_slice, old_slice) copy 和 = 的区别： = 赋值拷贝，会将原来slice的地址拷贝，新旧slice共享内存 copy 将slice内容进行拷贝，新旧slice不共享内存 1234567891011s1 := []int&#123;0, 1, 2&#125;s2 := s1 //`=`赋值，指向同一片内存s3 := make([]int, len(s1), 2*cap(s1))copy(s3, s1) //copy复制，不共享内存fmt.Println(s1, s2, s3) //[0 1 2] [0 1 2] [0 1 2]s1[0] = -1fmt.Println(s1, s2, s3) //[-1 1 2] [-1 1 2] [0 1 2] Map 集合无序的键值对，与C++中的map类似，但与C++中的map不同， 定义 Map 使用 make 函数 1map_variable := make(map[KeyType]ValueType, initialCapacity) initialCapacity 可选填，用于指定 Map 的初始容量。Map 的容量是指 Map 中可以保存的键值对的数量。 示例： 12345// 创建一个空的 Mapm1 := make(map[string]int)// 创建一个初始容量为 10 的 Mapm2 := make(map[string]int, 10) 使用 map 关键字 1234567m1 := map[string]int&#123;&#125;m2 := map[string]int&#123; \"a\": 1, \"b\": 2, \"c\": 3,&#125; 常用操作 获取元素 123v1 := m[\"a\"] v2, ok := m[\"d\"] // 如果键不存在，v2为该类型的零值，ok=false 修改元素 1m[\"a\"] = 2 删除元素 1delete(m, \"a\") 获取长度 1l := len(m) 遍历 map 123for k, v := range m &#123; ...&#125; 控制结构条件语句if 语句与C中类似，但是条件语句不需要用括号包住 1234567if condition1 &#123; ...&#125; else if condition2 &#123; ...&#125; else &#123; ...&#125; switch 语句12345678switch expression &#123;case val1: ...case val2: ...default: ...&#125; 先执行 expression 从上往下依次找匹配的 case go中的 switch 默认自带 break，匹配成功后，就不会执行其他 case 如果希望匹配成功后继续执行后面的 case，可以使用 fallthrough 示例1: 12345678switch tag &#123;case 0: f1()case 1, 2: f2()default: f3()&#125; 示例2: expression 可以为空 12345678switch &#123;case tag == 0: f1()case tag == 1, tag == 2: f2()default: f3()&#125; Type Switchswitch还可以用来判断某个 interface 变量中实际存储的变量类型 123456789101112var x interface&#123;&#125;switch i := x.(type) &#123;case nil: f1()case int: f2()case float64: f3()default: f4()&#125; fallthrough如果在 case 的最后加上了 fallthrough，则无论紧接着的下一条 case 为 ture 还是 false，都会执行。 示例1: 123456789101112131415161718tag := 1switch &#123;case tag == 0: // false fmt.Println(\"0\") // 不执行 fallthroughcase tag == 1: // true fmt.Println(\"1\") // 执行 fallthrough // 下一个case无条件执行case tag == 2: // 不必判断，直接执行 fmt.Println(\"2\") // 执行 // 这里其实有个默认的 breakcase tag == 3: fmt.Println(\"3\") // 不执行 fallthroughdefault: fmt.Println(\"default\") // 不执行&#125; 输出：12 示例2: 123456789101112131415161718tag := 1switch &#123;case tag == 0: // false fmt.Println(\"0\") // 不执行 fallthroughcase tag == 1: // true fmt.Println(\"1\") // 执行 fallthrough // 下一个case无条件执行case tag == 2: // 不必判断，直接执行 fmt.Println(\"2\") // 执行 fallthrough // 下一个case无条件执行case tag == 3: // 不必判断，直接执行 fmt.Println(\"3\") // 执行 fallthrough // 下一个case无条件执行default: // 不必判断，直接执行 fmt.Println(\"default\") // 执行&#125; 输出：123default select 语句select 类似于 switch，但是 select 只能用于通道操作 select 会监听所有通道，一旦有通道准备好，就随机选择其中一个通道执行 如果所有通道都没准备好，则执行 default 如果没有 default，select 将阻塞，直到某个通道可以运行 多个case匹配时，switch从上至下匹配第一个，select随机匹配一个 1234567891011select &#123;// 随机执行一个准备好了的通道case &lt;- channel1: ...case value := &lt;- channel2: ...case channel3 &lt;- value: ...default:// 所有通道都没有准备好，执行的代码&#125; 示例： 12345678910111213141516171819202122232425262728293031323334package mainimport \"fmt\"func main() &#123; // 定义两个通道 ch1 := make(chan string) ch2 := make(chan string) // 启动两个 goroutine，分别从两个通道中获取数据 go func() &#123; for &#123; ch1 &lt;- \"from 1\" &#125; &#125;() go func() &#123; for &#123; ch2 &lt;- \"from 2\" &#125; &#125;() // 使用 select 语句非阻塞地从两个通道中获取数据 for i := 0; i &lt; 10; i++ &#123; select &#123; case msg1 := &lt;-ch1: fmt.Println(msg1) case msg2 := &lt;-ch2: fmt.Println(msg2) default: // 如果两个通道都没有可用的数据，则执行这里的语句 fmt.Println(\"no message received\") &#125; &#125;&#125; 输出：no message receivedfrom 1from 2from 1from 2no message receivedno message receivedfrom 2from 1no message received 循环语句for 语句go的 for 语句有多种用法： 与C的 for 相似的用法 123for init; condition; post &#123; ...&#125; 与C的 while 相似的用法 只留下 condition 项，则只需判断 condition 123for condition &#123; ...&#125; 与C的 while(1) 相似的用法 三项都不填，则无限循环 123for &#123; ...&#125; range格式 for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环 123for key, value := range oldMap &#123; newMap[key] = value&#125; 也可以只提取 key 或者 value 123for key := range oldMap &#123; ...&#125; 只提取 value 时，需要用 _, 占掉 key 的位置 123for _, value := range oldMap &#123; ...&#125; break与C中的break用法相似，但多一个标号的功能： 在多重循环中，可以使用标号 label 跳出指定的循环。 示例： 不加标号时，与C一样，只会 break 掉最里面的那层循环 123456789101112package mainimport \"fmt\"func main() &#123; for i := 0; i &lt; 3; i++ &#123; for j := 0; j &lt; 3; j++ &#123; // break掉这层循环 fmt.Printf(\"i = %d, j = %d\\n\", i, j) break &#125; &#125;&#125; 输出：i = 0, j = 0i = 1, j = 0i = 2, j = 0 加上标号后，会 break 掉标号的那层循环 12345678910111213package mainimport \"fmt\"func main() &#123;re: for i := 0; i &lt; 3; i++ &#123; // break掉标号re这层循环 for j := 0; j &lt; 3; j++ &#123; fmt.Printf(\"i = %d, j = %d\\n\", i, j) break re &#125; &#125;&#125; 输出：i = 0, j = 0 continue与 break 一样，可以通过标号 label 指定需要 continue 的循环 函数函数的定义123func function_name( [parameter list] ) [return_types] &#123; ...&#125; parameter list 参数列表，选填，可以无参，格式为 parameter_name1 type1, parameter_name2 type2, ... return_types 返回类型，选填，可以无返回值（相当于C中的void），也可以返回多个值，格式为 (type1, type2, ...) 示例1： 1234567func max(num1, num2 int) int &#123; if num1 &gt; num2 &#123; return num1 &#125; else &#123; return num2 &#125;&#125; 示例2: 123func swap(x, y string) (string, string) &#123; return y, x&#125; 1y, x := swap(\"hello\", \"world\") 引用传递参数与C中的指针类似，传递地址指针 12345func swap(x *int, y *int) &#123; temp := *x *x = *y *y = temp&#125; 函数变量1234567891011121314151617package mainimport \"fmt\"func main() &#123; // 声明函数变量 findMax := func(num1, num2 int) int &#123; if num1 &gt; num2 &#123; return num1 &#125; else &#123; return num2 &#125; &#125; max := findMax(1, 2) fmt.Println(max)&#125; 闭包闭包包含两点： 存在函数外部定义，但在函数内部引用的自由变量 脱离了形成闭包的上下文，闭包也能照常使用这些自由变量，通常称这些自由变量为捕获变量 go语言中函数是头等对象，闭包可以充当C++中类的变量功能，也经常称闭包为有状态的函数 示例： 12345678910111213141516171819202122232425262728293031package mainimport \"fmt\"// getSequence函数的返回值为一个函数func getSequence() func() int &#123; i := 0 // 闭包函数 return func() int &#123; //返回函数内部，使用了返回函数外部定义的变量i i++ return i &#125;&#125;func main() &#123; //声明一个函数变量，此时会执行getSequence函数，令i=0，并定义一个累加函数nextNumber nextNumber1 := getSequence() nextNumber2 := getSequence() // 即使getSequence执行结束，依旧可以通过nextNumber调用闭包函数，并使用i // nextNumber每调用一次，i加一 fmt.Println(nextNumber1()) // 输出1 fmt.Println(nextNumber1()) // 输出2 fmt.Println(nextNumber1()) // 输出3 //两个闭包函数互不影响 fmt.Println(nextNumber2()) // 输出1 fmt.Println(nextNumber2()) // 输出2 fmt.Println(nextNumber2()) // 输出3&#125; getSequence返回一个闭包函数 变量i就是在闭包外定义，闭包内使用的变量 即使脱离了闭包的上下文，在main中，也可以调用nextNumber闭包函数，并使用定义在getSequence中的局部变量变量i nextNumber1 := getSequence() 和 nextNumber2 := getSequence() 分别独立，各自的捕获变量i不影响 方法在其他语言中，函数和方法是一样的，但在go中有所区别 方法是一种有接收者的特殊函数，可以实现C++类的函数功能 接受者可以是命名类型或者结构体类型的一个值或者是一个指针 123func (variable_name variable_data_type) function_name() [return_type]&#123; ...&#125; variable_name 接受者名 variable_data_type 接受者类型 示例： 12345678910111213141516171819package mainimport \"fmt\"// 圆的结构体type Circle struct &#123; radius float64&#125;// 方法，接受者必须为为 c Circlefunc (c Circle) getArea() float64 &#123; return 3.14 * c.radius * c.radius&#125;func main() &#123; var c1 Circle c1.radius = 1 fmt.Println(c1.getArea()) //调用求面积的方法&#125; 类型转换数值类型转换格式： 1type_name(expression) 示例： 12var v1 int = 10var v2 float64 = float64(v1) 字符串类型转换 string 转 int 使用 strconv.Atoi 将 string 转换为 int，第二个返回值为可能发生的错误，可以用 _ 来忽略这个错误 1234567891011121314151617package mainimport ( \"fmt\" \"strconv\")func main() &#123; str := \"10\" num, err := strconv.Atoi(str) if err != nil &#123; fmt.Println(err) &#125; else &#123; fmt.Println(num) &#125;&#125; int 转 string 使用 strconv.Itoa 将 int 转换为 string 12num := 10str := strconv.Itoa(num) string 转 float 使用 strconv.ParseFloat 将 string 转换为 float，第二个参数为 bitSize，用来选择究竟是64位还是32位的 float 12str := \"3.14\"num, err := strconv.ParseFloat(str, 64) 接口类型转换接口go 通过接口实现了C++中多态的效果。 接口把所有的具有共性的方法定义在一起 隐式实现，不用声明某个struct实现了那个接口，如果一个struct实现了一个接口定义的所有方法，那么它就自动地实现了该接口 12345678910111213141516171819202122/* 定义接口 */type interface_name interface &#123; method_name1 [return_type] method_name2 [return_type] method_name3 [return_type] ... method_namen [return_type]&#125;/* 定义结构体 */type struct_name struct &#123; /* variables */&#125;/* 实现接口方法 */func (struct_name_variable struct_name) method_name1() [return_type] &#123; /* 方法实现 */&#125;...func (struct_name_variable struct_name) method_namen() [return_type] &#123; /* 方法实现*/&#125; 示例： 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport \"fmt\"// 接口声明type Sleeper interface &#123; sleep() //声明方法&#125;type Cat struct &#123; name string&#125;type Dog struct &#123; name string&#125;// Cat和Dog都分别实现了Sleeper的sleep方法func (c Cat) sleep() &#123; fmt.Printf(\"Cat %s is sleeping\\n\", c.name)&#125;func (d Dog) sleep() &#123; fmt.Printf(\"Dog %s is sleeping\\n\", d.name)&#125;// AnimalSleep函数实现了一个函数多个状态，也就是多态func AnimalSleep(s Sleeper) &#123; s.sleep()&#125;func main() &#123; var s Sleeper s = Cat&#123;name: \"cici\"&#125; AnimalSleep(s) //Cat cici is sleeping s = Dog&#123;name: \"dodo\"&#125; AnimalSleep(s) //Dog dodo is sleeping&#125; 定义一个 Sleeper 接口，Cat 和 Dog 都实现了Sleeper 接口的所有方法，所以隐式实现了接口。 如此 AnimalSleep() 函数实现了一个函数多个状态，也就是多态 错误处理函数定义时，使用 errors.New 返回错误信息 123456789func Sqrt(f float64) (float64, error) &#123; // 错误时，返回错误信息 if f &lt; 0 &#123; return 0, errors.New(\"math: square root of negative number\") &#125; // 实现 ...&#125; 调用函数时，接收返回的错误信息err 12345result, err:= Sqrt(-1)if err != nil &#123; fmt.Println(err)&#125; 并发编程goroutine 线程goroutine 是轻量级线程，通过 go 关键字开启，如此可以同时多个线程并发进行。 同一个程序中的所有 goroutine 共享同一个地址空间。 格式： 1go func(x, y, z) 如此，就开启了一个新的线程 func(x, y, z) 示例： 12345678910111213141516171819202122232425package mainimport ( \"fmt\" \"time\")func eat() &#123; for i := 0; i &lt; 3; i++ &#123; time.Sleep(100 * time.Millisecond) fmt.Println(\"eating\") &#125;&#125;func drink() &#123; for i := 0; i &lt; 3; i++ &#123; time.Sleep(100 * time.Millisecond) fmt.Println(\"drinking\") &#125;&#125;func main() &#123; go eat() // 开启一个eat线程 drink() // eat和drink两个线程并发执行&#125; 输出：drinkingeatingdrinkingeatingeatingdrinking 可以看出 eat 和 drink 两个线程并发执行，一下输出 eating，一下输出 drinking channel 通道通道是用来传递数据的一种数据结构，可用于两个 goroutine 之间通过传递值来同步运行和通讯 发送和接收用 &lt;- 来发送和接收数据 1ch &lt;- value // 把 value 发送到通道 ch 12v := &lt;-ch // 从 ch 接收数据 // 并把值赋给 v 12&lt;-ch // 从 ch 接收数据 // 并丢弃值 定义通道利用 chan 关键字定义通道，使用 make 创建一个引用，当复制一个channel或用于函数参数传递时，实际只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象 不带缓冲区的通道（默认） 1ch := make(chan int) 如此定义了一个不带缓冲区的通道，通道可以传递 int 参数 带缓冲区的通道 1ch := make(chan int, 100) 如此定义了一个带缓冲区的通道，缓冲区大小为100 默认不带缓冲区，发送端发送数据，同时必须有接收端相应的接收数据。如果迟迟没有接收，发送方会阻塞直到接收方从通道中接收了值。 123456789package mainimport \"fmt\"func main() &#123; ch := make(chan int) //没有缓冲区的通道 ch &lt;- 1 //这里发送端会直接卡死，一直卡在这里等待接收端的出现 fmt.Println(&lt;-ch) //无法运行到此&#125; 带缓冲区的通道允许发送端和接收端异步，发送端可以先把数据放进缓存区内，发送端进程进行向下进行，不需要等待接收端接收。 但如果缓冲区满了，发送端同样会像不带缓冲区的通道那样卡住，直到有接收方从通道中接收了值。 123456789package mainimport \"fmt\"func main() &#123; ch := make(chan int, 1) //有大小为1缓冲区的通道 ch &lt;- 1 //1放入缓冲区，不会卡住 fmt.Println(&lt;-ch) //可以运行输出1&#125; 关闭通道关闭通道后，不会再发送数据到通道上了 1close(ch) 接收端在接收时，可以通过额外的第二个变量来判断通道是否关闭 1v, ok := &lt;- ch 遍历通道与数组、切片相同，使用 range 关键字来遍历通道 123for v := range ch &#123; ...&#125; 规则： 遍历一个空的通道（nil）时，阻塞 遍历一个 阻塞 &amp;&amp; 未关闭 的通道（nil）时，阻塞 遍历一个 阻塞 &amp;&amp; 已关闭 的通道（nil）时，不做任何操作 遍历一个 非阻塞 &amp;&amp; 未关闭 的通道（nil）时，接收所有缓存数据，然后阻塞 遍历一个 非阻塞 &amp;&amp; 已关闭 的通道（nil）时，接收所有缓存数据，然后返回 上下文问题记录单引号、双引号、反引号 单引号 &#39;&#39;：包裹字符 双引号 &quot;&quot;：包裹字符串，会解析其中的转义符 反引号 ````：包裹字符串，不会解析其中的转义符 12fmt.Print(\"Hello, World!\\n\") //双引号，会解析其中的转义符fmt.Print(`Hello, World!\\n`) //反引号，不会解析其中的转义符 输出： Hello, World!Hello, World!\\n% Go modulesgo modules 是 go 的依赖包管理工具 go 的包管理发展在引入 go modules 之前，go 管理依赖包先是用 GOPATH，后来用 go vender GOPATHgo path 理论上并不算是包管理工具，需要手动管理依赖包，写程序代码必须放在 $GOPATH/src 目录下，且依赖包没有版本可言 go vendor解决了包管理问题，所有依赖包下载到项目的 vendor 目录下 go modules 的使用首先要确定 go 语言的版本，至少需是 v1.11 以上版本 1go version 环境设置查看 go 的环境变量 1go env 其中与 Go Modules 相关的环境设置如下 GO111MODULE1go env -w GO111MODULE&#x3D;on 参考 Go语言圣经（中文版）","categories":[{"name":"Golang","slug":"Golang","permalink":"https://gy23333.github.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://gy23333.github.io/tags/Golang/"},{"name":"语言基本语法","slug":"语言基本语法","permalink":"https://gy23333.github.io/tags/%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"}]},{"title":"排序","slug":"排序","date":"2023-02-11T19:00:36.000Z","updated":"2024-11-11T03:57:58.132Z","comments":true,"path":"2023/02/12/排序/","link":"","permalink":"https://gy23333.github.io/2023/02/12/%E6%8E%92%E5%BA%8F/","excerpt":"排序算法总结","text":"排序算法总结 概述可根据数据结构和算法动态可视化网站，更加形象地学习。 直接插入排序算法思想每次将一个待排序的记录插入到已排序好的序列中。 (49) 38 65 97 76 13 27 49(38 49) 65 97 76 13 27 49(38 49 65) 97 76 13 27 49(38 49 65 97) 76 13 27 49(38 49 65 76 97) 13 27 49(13 38 49 65 76 97) 27 49(13 27 38 49 65 76 97) 49(13 27 38 49 49 65 76 97) ()表示已排好序的部分 代码实现123456789101112131415161718//直接插入排序template &lt;typename T&gt;class Insertion &#123;public: static void sort(vector&lt;T&gt; &amp;nums);&#125;;template &lt;typename T&gt;void Insertion&lt;T&gt;::sort(vector&lt;T&gt; &amp;nums) &#123; //每次选一个未排序的元素 for (int i = 1; i &lt; nums.size(); i++) &#123; //从后往前，依次检查前面已排序好的元素 for (int j = i-1; j &gt;= 0 &amp;&amp; nums[j] &gt; nums[j+1]; j--) &#123; //与待排序的元素对比，如果逆序，则交换 swap(nums[j], nums[j+1]); &#125; &#125;&#125; 性能分析 空间复杂度： $O(1)$ 时间复杂度 最好时间复杂度（全部有序）：$O(n)$ 共 $n-1$ 趟，每趟只需比对一次关键字，不用移动元素。 最坏时间复杂度（全部逆序）：$O(n^2)$ 共 $n-1$ 趟，每趟（如第 $i$ 趟）对比 $i$ 次，移动 $i$ 次。 平均时间复杂度：$O(n^2)$ 稳定性 稳定。每次插入元素都是从前往后比较移动，所以不会出现相同元素相对位置变化。 适用性：顺序表和链表 希尔排序算法思想希尔排序是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。 每轮把记录按下标的一定增量分组 $L[i, i+d, i+2d,…,i+kd]$ ，对每组直接插入排序； 逐渐减少增量，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 49 38 65 13 76 13 27 57 （d = 4）49 13 27 13 76 38 65 57 （d = 2）27 13 49 13 65 38 76 57 （d = 1）13 13 27 38 49 57 65 76 代码实现123456789101112131415161718192021222324//希尔排序template &lt;typename T&gt;class Shell &#123;public: static void sort(vector&lt;T&gt; &amp;nums);&#125;;template &lt;typename T&gt;void Shell&lt;T&gt;::sort(vector&lt;T&gt; &amp;nums) &#123; int N = nums.size(); //增量d初始为N/2，每次减一半，直到为1 for (int d = N/2; d &gt;= 1; d /= 2) &#123; //增量为d的直接插入排序 //[0,d-1]在所属子表中已排序好，从d开始，选一个未排序的元素 for (int i = d; i &lt; N; i++) &#123; //[..., i-2d, i-d]已排好序 //从后往前，依次检测前面已排序好的元素 for (int j = i-d; j &gt;= 0 &amp;&amp; nums[j] &gt; nums[j+d]; j -= d) &#123; //与待排序的元素对比，如果逆序，则交换 swap(nums[j], nums[j+d]); &#125; &#125; &#125;&#125; 性能分析 空间复杂度： $O(1)$ 时间复杂度 最坏时间复杂度 $O(n^2)$ 最好时间复杂度（全部有序）：$O(n)$ 当n在某个特定范围时，可达 $O(n^{1.3})$ 稳定性 不稳定。如果两相同元素划分到不同子表，可能会改变相对位置。 适用性：顺序表 冒泡排序算法思想 每趟从前往后（或从后往前）两两相邻元素比较，如逆序，则交换 每趟可冒泡出最大的元素到最后 (1)49 38 65 97 76 13 27 4938 49 65 97 76 13 27 4938 49 65 97 76 13 27 4938 49 65 97 76 13 27 4938 49 65 76 97 13 27 4938 49 65 76 13 97 27 4938 49 65 76 13 27 97 4938 49 65 76 13 27 49 (97) (2)38 49 65 76 13 27 49 (97)38 49 65 76 13 27 49 (97)…38 49 65 13 27 49 (76 97) …… (n-1)(13 27 38 49 49 65 76 97) 代码实现1234567891011121314151617181920212223242526//冒泡排序template &lt;typename T&gt;class Bubble &#123;public: static void sort(vector&lt;T&gt; &amp;nums);&#125;;template &lt;typename T&gt;void Bubble&lt;T&gt;::sort(vector&lt;T&gt; &amp;nums) &#123; //冒泡N-1趟 for (int i = 0; i &lt; nums.size()-1; i++) &#123; bool flag = false; //表示发生过交换 //第i趟冒泡范围[0,N-i-1]，后i个已经排序好 for (int j = 0; j &lt; nums.size()-i-1; j++) &#123; //逆序，则交换 if (nums[j] &gt; nums[j+1]) &#123; swap(nums[j], nums[j+1]); flag = true; &#125; &#125; //如该趟未发生交换，则已全部有序，直接返回 if (!flag) &#123; return; &#125; &#125;&#125; 性能分析 空间复杂度： $O(1)$ 时间复杂度 最好时间复杂度（全部有序）：$O(n)$ 只需冒泡一趟，比较 $n$ 次，交换 $0$ 次，时间复杂度为$O(n)$ 最坏时间复杂度（全部逆序）： $O(n^2)$ 共冒泡 $n-1$ 趟 第 $i$ 趟，比较 $n-i-1$ 次，交换 $n-i-1$ 次 比较次数 = 交换次数 = $(n-1)+(n-2)+…+1 =n(n-1)/2$ 时间复杂度 $O(n^2)$ 平均时间复杂度： $O(n^2)$ 稳定性 稳定。只在相邻逆序时交换，不改变相同元素的相对位置。 适用性：顺序表和链表 快速排序算法思想每趟排序确定一个元素 $x$ 的最终位置，将数据分为$x$ 两个部分。再对这两个部分递归进行排序。 (1)：确定49的位置，与49比较，左边部分小于49，右边部分大于49 49 38 65 97 76 13 27 49 49 38 65 97 76 13 27 49 low high 49 38 65 97 76 13 27 49 low high 49 27 38 65 97 76 13 49 low high 49 27 38 65 97 76 13 49 low high 49 27 38 65 97 76 13 49 low high 49 27 38 97 76 13 65 49 low high 49 27 38 97 76 13 65 49 low high 49 27 38 13 97 76 65 49 low high 49 27 38 13 97 76 65 49 low high 49 27 38 13 76 97 65 49 low high 49 27 38 13 76 97 65 49 low high 49 27 38 13 76 97 65 49 l=h 27 38 13 49 76 97 65 49 &lt;49 l=h &gt;49 再分别对左右两边 $[27, 38, 13]$ 、 $[76, 97, 65, 49]$ 进行递归排序。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//快速排序template &lt;typename T&gt;class Quick &#123;public: static void sort(vector&lt;T&gt; &amp;nums);private: static void sort(vector&lt;T&gt; &amp;nums, int low, int high); static int partition(vector&lt;T&gt; &amp;nums, int low, int high);&#125;;//排序函数template &lt;typename T&gt;void Quick&lt;T&gt;::sort(vector&lt;T&gt; &amp;nums) &#123; sort(nums, 0, nums.size()-1);&#125;//对[low, high]部分排序template &lt;typename T&gt;void Quick&lt;T&gt;::sort(vector&lt;T&gt; &amp;nums, int low, int high) &#123; if (low &gt;= high) &#123; return; //跳出递归 &#125; int pivot_pos = partition(nums, low, high); //切分 sort(nums, low, pivot_pos-1); //排序左边部分 sort(nums, pivot_pos+1, high); //排序右边部分&#125;//快速排序划分template &lt;typename T&gt;int Quick&lt;T&gt;::partition(vector&lt;T&gt; &amp;nums, int low, int high) &#123; T pivot = nums[low]; //第一个元素为枢轴 //low和high比较交换，直到 low &gt;= high while (low &lt; high) &#123; //high左移，直到第一个小于pivot的出现 while (nums[high] &gt;= pivot &amp;&amp; low &lt; high) &#123; high--; &#125; nums[low] = nums[high]; //小于pivot的high与low交换 //low右移，直到第一个大于pivot的出现 while (nums[low] &lt;= pivot &amp;&amp; low &lt; high) &#123; low++; &#125; nums[high] = nums[low]; //大于pivot的low与high交换 &#125; //pivot填入中间位置 nums[low] = pivot; return low;&#125; 性能分析 空间复杂度 需要调用递归栈，相当于分别用n个枢轴建立一个二叉树，空间复杂度即为递归层数，也就是二叉树高度。 最好空间复杂度：$O(log_2n)$ 枢轴划分均匀，二叉树为完全二叉树，高度为 $log_2n$ 最坏时间复杂度 $O(n)$ 枢轴划分极不均匀，如每个都划分成只有大于pivot或小于pivot，二叉树每个节点的度都为1，高度为 $n$ 时间复杂度 时间复杂度为 $O(n*递归层数)$ 最好时间复杂度（划分均匀）：$O(nlog_2N)$ 最坏时间复杂度（划分极不均匀）： $O(n^2)$ 平均时间复杂度： $O(nlog_2N)$ 稳定性 不稳定。交换时，可能把相对位置更后的元素交换到更前的位置。 | 49 | 38 | 65 | 16 | 76 | 13 | 57 | 16 | |——|——|——|:—-|:—-|:—-|:—-|:—————| | 49 | | | | | | | | | | 38 | 65 | 16 | 76 | 13 | 27 |16| | low| | | | | | | high | | | | | | | | | 49 | | 16 | 38 | 65 | 16 | 76 | 13 | 27 | | | low| | | | | | | high | 适用性：顺序表 简单选择排序算法思想最简单的一种排序方法。每次找到最小的那个元素，和第一个元素交换。 49 38 65 97 76 13 27 49(13) 38 65 97 76 49 27 49(13 27) 65 97 76 49 38 49(13 27 38) 97 76 49 65 49(13 27 38 49) 76 97 65 49(13 27 38 49 49) 97 65 76(13 27 38 49 49 65) 97 76(13 27 38 49 49 65 76) 97(13 27 38 49 49 65 76 97) 代码实现12345678910111213141516171819//简单选择排序template &lt;typename T&gt;class Selection &#123;public: static void sort(vector&lt;T&gt; &amp;nums);&#125;;template &lt;typename T&gt;void Selection&lt;T&gt;::sort(vector&lt;T&gt; &amp;nums) &#123; for (int i = 0; i &lt; nums.size()-1; i++) &#123; int min_pos = i; for (int j = i; j &lt; nums.size(); j++) &#123; if (nums[j] &lt; nums[min_pos]) &#123; min_pos = j; &#125; &#125; swap(nums[i], nums[min_pos]); &#125;&#125; 性能分析 空间复杂度：$O(1)$ 时间复杂度：$O(n^2)$ 无论是有序、无序、乱序，都需要 $n-1$ 趟选出最小值，第i趟选最小值都需要对比 $n-i$ 次。即 $(n-1)+(n-2)+…+1 = n(n-1)/2$ 稳定性 不稳定。交换时，可能把相对位置更前的元素换到后面去。 2 2 11 2 21 2 2 适用性：顺序表和链表 堆排序算法思想先建立大根堆/小根堆，再基于大根堆/小根堆进行排序。 二叉树的顺序存储完全二叉树可以顺序存储为序列，如下面序列和完全二叉树的对应 t[0] t[1] t[2] t[3] t[4] t[5] t[6] t[7] t[8] t[9] 1 2 3 4 5 6 7 8 9 graph TD A((1)) B((2)) C((3)) D((4)) E((5)) F((6)) G((7)) H((8)) I((9)) A---B; A---C; B---D; B---E; C---F; C---G; D---H; D---I; 对于共有 $n$ 个结点完全二叉树，序号为 $i$ 结点 $i$ 的左孩子： $2i$ $i$ 的右孩子： $2i+1$ $i$ 的父结点： $\\lfloor i/2 \\rfloor$ $i$ 所在层次： $\\lfloor log_2(n+1) \\rfloor$ $i$ 是否有左孩子： $2i \\le n?$ $i$ 是否有右孩子： $2i+1 \\le n?$ $i$ 是否是叶子结点： $i \\ge \\lfloor n/2 \\rfloor?$ 堆的定义堆分为大根堆/小根堆，即更大的为根/更小的为根 大根堆：根 &gt;= 左、右 | | 87 | 45 | 78 | 32 | 17 | 65 | 53 | 9 | |—-|—-|—-|—-|:—|:—|:—|:—|:—| &lt;pre class=&quot;mermaid&quot;&gt; graph TD A((87)) B((45)) C((78)) D((32)) E((17)) F((65)) G((53)) H((9)) A---B; A---C; B---D; B---E; C---F; C---G; D---H;&lt;/pre&gt; 小根堆：根 &lt;= 左、右 | | 9 | 45 | 17 | 65 | 53 | 32 | 87 | 78 | |—-|—-|—-|—-|:—|:—|:—|:—|:—| &lt;pre class=&quot;mermaid&quot;&gt; graph TD A((9)) B((45)) C((17)) D((65)) E((53)) F((32)) G((87)) H((78)) A---B; A---C; B---D; B---E; C---F; C---G; D---H;&lt;/pre&gt; 堆的建立以大根堆为例， 把所有的非叶子结点检查一遍，如果不满足大根堆要求，则进行调整。 基于堆进行排序代码实现性能分析归并排序算法思想代码实现性能分析参考 数据结构和算法动态可视化","categories":[{"name":"算法","slug":"算法","permalink":"https://gy23333.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://gy23333.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://gy23333.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"栈","slug":"栈","date":"2023-02-10T13:35:45.000Z","updated":"2024-11-11T03:57:58.131Z","comments":true,"path":"2023/02/10/栈/","link":"","permalink":"https://gy23333.github.io/2023/02/10/%E6%A0%88/","excerpt":"栈相关","text":"栈相关 栈的实现用数组实现栈（顺序栈）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//Stack.hpp#ifndef Stack_hpp#define Stack_hpp#include &lt;iostream&gt;using namespace std;//顺序栈template &lt;typename T&gt;class Stack &#123; T *data; //成员数组 int top; //栈顶指针，当前栈顶元素的位置 int size; //栈中元素的最大个数public: Stack(); ~Stack(); bool is_empty(); //判断栈空 bool is_full(); //判断栈满 void push(const T &amp;elem); //入栈 void pop(); //出栈 T get_top(); //访问栈顶元素&#125;;//栈初始化//初始栈空，栈顶指针指向-1，初始空间为10template &lt;typename T&gt;Stack&lt;T&gt;::Stack() : top(-1), size(10) &#123; data = new T[size]; //申请一个初始为10的空间&#125;//销毁栈template &lt;typename T&gt;Stack&lt;T&gt;::~Stack() &#123; delete [] data; data = nullptr;&#125;//判断栈空template &lt;typename T&gt;bool Stack&lt;T&gt;::is_empty() &#123; if (top == -1) &#123; return true; &#125; else &#123; return false; &#125;&#125;//判断栈满template &lt;typename T&gt;bool Stack&lt;T&gt;::is_full() &#123; if (top == size-1) &#123; return true; &#125; else &#123; return false; &#125;&#125;//入栈template &lt;typename T&gt;void Stack&lt;T&gt;::push(const T &amp;elem) &#123; if (is_full()) &#123; throw out_of_range(\"Stack&lt;&gt;::push(): 栈满\"); &#125; else &#123; data[++top] = elem; &#125;&#125;//出栈template &lt;typename T&gt;void Stack&lt;T&gt;::pop() &#123; if (is_empty()) &#123; throw out_of_range(\"Stack&lt;&gt;::pop(): 栈空\"); &#125; else &#123; top--; &#125;&#125;//访问栈顶元素template &lt;typename T&gt;T Stack&lt;T&gt;::get_top() &#123; if (is_empty()) &#123; throw out_of_range(\"Stack&lt;&gt;::top(): 栈空\"); &#125; else &#123; return data[top]; &#125;&#125;#endif 用链表实现栈（链栈）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//Stack.hpp#ifndef Stack_hpp#define Stack_hpp#include &lt;iostream&gt;using namespace std;//结点template &lt;typename T&gt;struct node &#123; T data; //数据域 node *next; //指针域&#125;;//链栈template &lt;typename T&gt;class Stack &#123; node&lt;T&gt; *top; //栈顶指针public: Stack(); ~Stack(); bool is_empty(); //判断栈空 void push(const T &amp;elem); //入栈 void pop(); //出栈 T get_top(); //访问栈顶元素&#125;;//栈初始化template &lt;typename T&gt;Stack&lt;T&gt;::Stack() &#123; top = nullptr; //初始为空&#125;//销毁栈template &lt;typename T&gt;Stack&lt;T&gt;::~Stack() &#123; node&lt;T&gt; *ptr = nullptr; while (!is_empty()) &#123; ptr = top-&gt;next; delete top; top = ptr; &#125;&#125;//判断栈空template &lt;typename T&gt;bool Stack&lt;T&gt;::is_empty() &#123; if (top == nullptr) &#123; return true; &#125; else &#123; return false; &#125;&#125;//入栈template &lt;typename T&gt;void Stack&lt;T&gt;::push(const T &amp;elem) &#123; node&lt;T&gt; *ptr = new node&lt;T&gt;; ptr-&gt;data = elem; ptr-&gt;next = top; top = ptr;&#125;//出栈template &lt;typename T&gt;void Stack&lt;T&gt;::pop() &#123; if (is_empty()) &#123; throw out_of_range(\"Stack&lt;&gt;::pop(): 栈空\"); &#125; else &#123; node&lt;T&gt; *ptr = top-&gt;next; delete top; top = ptr; &#125;&#125;//访问栈顶元素template &lt;typename T&gt;T Stack&lt;T&gt;::get_top() &#123; if (is_empty()) &#123; throw out_of_range(\"Stack&lt;&gt;::top(): 栈空\"); &#125; else &#123; return top-&gt;data; &#125;&#125;#endif stack（栈）函数方法 代码 功能 s.push(x) 将x压入栈顶 s.top() 返回栈顶的元素 s.pop() 删除栈顶的元素 s.size() 返回栈中元素的个数 s.empty() 检查栈是否为空,若为空返回true,否则返回false","categories":[{"name":"算法","slug":"算法","permalink":"https://gy23333.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://gy23333.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"栈","slug":"栈","permalink":"https://gy23333.github.io/tags/%E6%A0%88/"}]},{"title":"VSCode环境配置","slug":"VSCode环境配置","date":"2023-01-24T08:26:59.000Z","updated":"2024-11-11T03:57:58.111Z","comments":true,"path":"2023/01/24/VSCode环境配置/","link":"","permalink":"https://gy23333.github.io/2023/01/24/VSCode%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"VSCode上的一些环境配置记录。","text":"VSCode上的一些环境配置记录。 C/C++环境配置运行环境 VSCode上安装插件C/C++、Code Runner 配置Code Runner 点击Code Runner的设置-&gt;扩展设置 建议勾选Clear Previous Output、Ignore Selection、Run In Terminal、Save All Files Before Run、Save File Before Run 建议不勾选Preserve Focus 设置中建议勾选 Files: Auto Save的afterDelay 设置中建议不勾选 C_Cpp: Debug Shortcut 调试环境在需调试的cpp文件上 生成tasks.json文件 打开命令面板command+shift+P 打开配置任务Tasks: Configure Task 选择clang++ 生成活动文件，即生成tasks.json文件 生成launch.json文件 切换到运行和调试页面 点击创建 launch.json 文件，即生成launch.json文件 编辑launch.json文件 点击添加配置 -&gt; C/C++：(lldb)启动，并编辑下面配置 修改&quot;program&quot;: &quot;${fileDirname}/${fileBasenameNoExtension}&quot;, 即程序可执行文件的完整路径：当前打开的文件的完整目录名 / 当前打开的文件的文件名 (不包含文件扩展名) 修改&quot;externalConsole&quot;: true, 添加&quot;preLaunchTask&quot;: &quot;C/C++: clang++ 生成活动文件&quot; 即调试会话开始前要运行的任务，tasks.json文件的label配置 点击调试 参考 Mac用Visual Studio Code编写C/C++ 苹果电脑VS Code快速编写C/C++教程-哔哩哔哩","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://gy23333.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"环境配置","slug":"环境配置","permalink":"https://gy23333.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"VSCode","slug":"VSCode","permalink":"https://gy23333.github.io/tags/VSCode/"},{"name":"C/C++","slug":"C-C","permalink":"https://gy23333.github.io/tags/C-C/"}]},{"title":"栈的应用——表达式求值","slug":"栈的应用——表达式求值","date":"2023-01-17T18:06:05.000Z","updated":"2024-11-11T03:57:58.124Z","comments":true,"path":"2023/01/18/栈的应用——表达式求值/","link":"","permalink":"https://gy23333.github.io/2023/01/18/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/","excerpt":"利用栈对表达式进行求解","text":"利用栈对表达式进行求解 描述输入一个表达式（用字符串表示），求这个表达式的值。 保证字符串中的有效字符包括【0-9】、+、-、 *、/ 、(、 )、[、]、{ 、}，且表达式一定合法。 输入描述： 输入一个算术表达式 输出描述： 得到计算结果 示例一 输入：$3+2{1+2[-4/(8-6)+7]}$输出：25 示例二 输入：$5-3+96(6-10-2)$输出：-322 中缀表达式的计算将中缀转后缀、后缀表达式的计算两个步骤合并。 初始化两个栈，操作数栈和运算符栈 从左到右扫描中缀表达式， 当扫描到操作数时，将操作数压入操作数栈 当扫描到运算符时， 如果是界限符， 遇到左括号’(‘、’[‘、’{‘，压入运算符栈 遇到右括号’)’、’]’、’}’，依次弹出栈内的运算符，直到弹出左括号时结束 如果是其他运算符， 依次弹出优先级大于等于当前运算符的所有运算符，直到遇到左括号或栈空 当前运算符入栈 扫描完全部字符后，依次将剩下的运算符全部弹出 每弹出一个运算符，就要弹出两个操作数，先弹出的为右操作数，后弹出的为左操作数，计算$[左操作数 \\ 运算符\\ 右操作数]$，将结果压入操作数栈 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std;//弹出一个运算符和两个操作数，计算后的结果压入操作数栈void pop_count_push (stack&lt;int&gt;&amp; v_num, stack&lt;char&gt;&amp; v_sign) &#123; //运算符出栈 char sign = v_sign.top(); v_sign.pop(); //操作数出栈，先弹出的为右操作数，后弹出的为左操作数 int num1 = v_num.top(); //右操作数 v_num.pop(); int num2 = v_num.top(); //左操作数 v_num.pop(); //计算【左操作数 运算符 右操作数】 int res; switch (sign) &#123; case '+': res = num2 + num1; break; case '-': res = num2 - num1; break; case '*': res = num2 * num1; break; case '/': res = num2 / num1; break; default: break; &#125; //结果压入操作数栈 v_num.push(res);&#125;//判断运算符优先级，乘除为2，加减为1int priority (char c) &#123; if (c == '*' || c == '/') &#123; return 2; &#125; else &#123; return 1; &#125;&#125;//计算中缀表达式int count_expression (string str) &#123; stack&lt;int&gt; v_num; //操作数栈 stack&lt;char&gt; v_sign; //运算符栈 //如果开始或左括号后直接跟“-”号，则补0（即-4变0-4） for (int i = 0; i &lt; str.length(); ++i) &#123; if (i == 0 &amp;&amp; str[i] == '-') &#123; str = \"0\" + str; &#125; else if (str[i] == '-' &amp;&amp; (str[i - 1] == '(' || str[i - 1] == '[' || str[i - 1] == '&#123;')) &#123; str.insert(i, \"0\"); &#125; &#125; //从左到右扫描中缀表达式 bool flag = false; //前一位为符号位为false，为数位为true（用于计算多位数） for (char c : str) &#123; //当扫描到操作数时，将操作数压入操作数栈 if (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; //前一位为符号位，则直接压入本位 if (!flag) &#123; flag = true; v_num.push(c - '0'); &#125; //前一位为数位，则将上一个数出栈，乘10，再加上本位 else &#123; int num = v_num.top() * 10 + (c - '0'); v_num.pop(); v_num.push(num); //新数入栈 &#125; &#125; //当扫描到运算符时 else &#123; flag = false; //当扫描到左括号时，压入运算符栈 if (c == '(' || c == '[' || c == '&#123;') &#123; v_sign.push(c); &#125; //当扫描到右括号时，依次弹出栈内的运算符，直到弹出左括号时结束 else if (c == ')' || c == ']' || c == '&#125;') &#123; //当栈顶不是左括号时，继续弹出运算符计算 while (v_sign.top() != '(' &amp;&amp; v_sign.top() != '[' &amp;&amp; v_sign.top() != '&#123;') &#123; pop_count_push(v_num, v_sign); &#125; //弹出左括号 v_sign.pop(); &#125; //当扫描到其他运算符时 else &#123; //遇到左括号或栈空前，一直弹出优先级大于等于当前的运算符 while (!v_sign.empty()) &#123; if (v_sign.top() == '(' || v_sign.top() == '[' || v_sign.top() == '&#123;') &#123; break; &#125; //栈顶运算符的优先级大于等于当前的运算符，则弹出运算符计算 if (priority(v_sign.top()) &gt;= priority(c)) &#123; pop_count_push(v_num, v_sign); &#125; else &#123; break; //否则结束弹出 &#125; &#125; //当前运算符入栈 v_sign.push(c); &#125; &#125; &#125; //将剩下的运算符全部弹出 while (!v_sign.empty()) &#123; pop_count_push(v_num, v_sign); &#125; int result = v_num.top(); return result;&#125;int main () &#123; string str; cin &gt;&gt; str; cout &lt;&lt; count_expression(str) &lt;&lt; endl;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://gy23333.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://gy23333.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"栈","slug":"栈","permalink":"https://gy23333.github.io/tags/%E6%A0%88/"},{"name":"表达式求值","slug":"表达式求值","permalink":"https://gy23333.github.io/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"}]},{"title":"深度优先搜索（DFS）算法","slug":"深度优先搜索（DFS）算法","date":"2023-01-13T18:30:43.000Z","updated":"2024-11-11T03:57:58.115Z","comments":true,"path":"2023/01/14/深度优先搜索（DFS）算法/","link":"","permalink":"https://gy23333.github.io/2023/01/14/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88DFS%EF%BC%89%E7%AE%97%E6%B3%95/","excerpt":"图的深度优先搜索（DFS）类似于树的先序遍历，尽可能“深”地搜索一个图。","text":"图的深度优先搜索（DFS）类似于树的先序遍历，尽可能“深”地搜索一个图。 DFS 算法基本思想首先访问某一起始顶点v，再由v出发，访问与v邻接且未访问过的顶点w，在以w为起始顶点出发，访问与w邻接且未访问过的顶点…… 1234567891011void DFS (Graph G, int v) &#123; //从顶点v出发，深度优先遍历图G visit(v); //访问v visited[v] = true; //标记v已访问 //依次对v的所有未访问过的邻接顶点深度优先遍历 for (w = FirstNeighbor(G, v); w &gt;= 0; w = NextNeighbor(G, v, w)) &#123; //遍历邻接顶点 if (!visited[w]) &#123; //未访问过 DFS(G, w); &#125; &#125;&#125; 以下图为例，采用深度优先搜索，且以字母顺序优先，遍历顺序如下： \\begin{aligned} a -> b -> c &-> e \\\\ -> d &-> f \\\\ &-> g \\end{aligned}graph LR a((a)) b((b)) c((c)) d((d)) e((e)) f((f)) g((g)) a --- b & c b --- c & d c --- e d --- f & g 性能分析 空间复杂度 DPS利用递归，需要一个以每个顶点为起点的DFS函数递归工作栈，空间复杂度为 $O(|V|)$ （$|V|$ 表示顶点的个数） 时间复杂度 遍历图实际上是对每一个顶点查找其邻接点的过程，时间复杂度取决于图的存储结构。 邻接矩阵 查找每个顶点的邻接点的时间为 $O(|V|)$，总时间复杂度 $O(|V^2|)$ 邻接表 查找所有顶点的邻接点的时间为 $O(|E|)$，（即有多少条边，查找多少次邻接点），访问顶点所需时间为 $O(|V|)$，总时间复杂度 $O(|V|+|E|)$ DFS 例题迷宫问题描述定义一个二维数组 N*M ，如 5 × 5 数组下所示： maze[5][5] = \\begin{pmatrix} 0, 1, 0, 0, 0,\\\\ 0, 1, 1, 1, 0,\\\\ 0, 0, 0, 0, 0,\\\\ 0, 1, 1, 1, 0,\\\\ 0, 0, 0, 1, 0,\\\\ \\end{pmatrix}它表示一个迷宫，其中的$1$表示墙壁，$0$表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的路线。入口点为$[0,0]$，既第一格是可以走的路。 数据范围：$2\\leq n,m \\leq 10$，输入的内容只包含 $0、1$ 输入描述： 输入两个整数，分别表示二维数组的行数，列数。再输入相应的数组，其中的1表示墙壁，0表示可以走的路。数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。 输出描述： 左上角到右下角的最短路径 示例一 输入：5 50 1 0 0 00 1 1 1 00 0 0 0 00 1 1 1 00 0 0 1 0输出：(0,0)(1,0)(2,0)(2,1)(2,2)(2,3)(2,4)(3,4)(4,4) 分析从迷宫左上角的起点开始，对迷宫进行深度优先遍历，把$1$当作已访问过的点，$0$当作未访问过的点。先尽量“深”地遍历未访问的点，若周围的点都被访问过，则则证明此路不通，回溯到上一个还有未访问的邻接点的点，重新开始深度优先遍历。 对于深度优先遍历的当前点， 如果该点未访问过，（如果是回溯到该点，则已访问过，不需要进行这两步） 将该点加入临时路径，该点标记为已访问 如果该点为终点，则当前路径为最终路径 如果存在未访问过的邻接点，则按（下、右、上、左）的优先顺序，访问邻接点，即对该邻接点进行递归的深度优先遍历 如果邻接点都已访问，则进行回溯 重新修改该点为未访问，将该点弹出临时路径 （利用递归自动实现）通过函数栈回到上一个点的遍历访问，查看剩下的优先顺序的邻接点是否未访问，如不存在未访问的，则继续向上一个点回溯，直到回溯到的点还剩有未访问的邻接点，重新开始深度遍历 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;pair&lt;int, int&gt;&gt; final_path; //最终路径//深度优先搜索，maze为迷宫地图，(n, m)为迷宫矩阵的行、列数，(i, j)为当前访问点，tmp_path为当前路径void DFS (vector&lt;vector&lt;int&gt;&gt; &amp;maze, int n, int m, int i, int j, vector&lt;pair&lt;int, int&gt;&gt; &amp;tmp_path) &#123; tmp_path.push_back(&#123;i, j&#125;); //将该点加入临时路径 maze[i][j] = 1; //将该点标记为已访问 if (i == n-1 &amp;&amp; j == m-1) &#123; //如果该点为终点 final_path = tmp_path; //当前路径为最终路径 return; &#125; if (i+1 &lt; n &amp;&amp; maze[i+1][j] == 0) &#123; //如有下邻接点且未访问过 DFS(maze, n, m, i+1, j, tmp_path); //深度优先遍历下邻接点 &#125; if (j+1 &lt; m &amp;&amp; maze[i][j+1] == 0) &#123; //如有右邻接点且未访问过 DFS(maze, n, m, i, j+1, tmp_path); //深度优先遍历右邻接点 &#125; if (i-1 &gt;= 0 &amp;&amp; maze[i-1][j] == 0) &#123; //如有上邻接点且未访问过 DFS(maze, n, m, i-1, j, tmp_path); //深度优先遍历上邻接点 &#125; if (j-1 &gt;= 0 &amp;&amp; maze[i][j-1] == 0) &#123; //如有左邻接点且未访问过 DFS(maze, n, m, i, j-1, tmp_path); //深度优先遍历左邻接点 &#125; //如果邻接点都已访问，则进行回溯 maze[i][j] = 0; tmp_path.pop_back();&#125;int main () &#123; int n, m; //矩阵长宽 while (cin &gt;&gt; n &gt;&gt; m) &#123; vector&lt;vector&lt;int&gt;&gt; maze(n, vector&lt;int&gt;(m, 0)); //迷宫地图 for (int i = 0 ; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; cin &gt;&gt; maze[i][j]; &#125; &#125; vector&lt;pair&lt;int, int&gt;&gt; tmp_path; DFS(maze, n, m, 0, 0, tmp_path); //深度优先搜索得迷宫解 for (pair&lt;int, int&gt; point : final_path) &#123; cout &lt;&lt; \"(\" &lt;&lt; point.first &lt;&lt; \",\" &lt;&lt; point.second &lt;&lt; \")\" &lt;&lt; endl; &#125; &#125; return 0;&#125; 数独游戏描述玩家需要根据9X9盘面上的已知数字，推算出所有剩余空格的数字，并且满足每一行、每一列、每一个3X3粗线宫内的数字均含1-9，并且不重复。 例如：(0代表空缺位) 数据范围：输入一个 9*9 的矩阵 输入描述： 包含已知数字的9X9盘面数组（空缺位以数字0表示） 输出描述： 完整的9X9盘面数组 示例一 输入：0 9 2 4 8 1 7 6 34 1 3 7 6 2 9 8 58 6 7 3 5 9 4 1 26 2 4 1 9 5 3 7 87 5 9 8 4 3 1 2 61 3 8 6 2 7 5 9 42 7 1 5 3 8 6 4 93 8 6 9 1 4 2 5 70 4 5 2 7 6 8 3 1输出：5 9 2 4 8 1 7 6 34 1 3 7 6 2 9 8 58 6 7 3 5 9 4 1 26 2 4 1 9 5 3 7 87 5 9 8 4 3 1 2 61 3 8 6 2 7 5 9 42 7 1 5 3 8 6 4 93 8 6 9 1 4 2 5 79 4 5 2 7 6 8 3 1 示例二 输入：0 0 8 7 1 9 2 4 59 0 5 2 3 4 0 8 60 7 4 8 0 6 1 0 37 0 3 0 9 2 0 0 05 0 0 0 0 0 0 0 08 6 1 4 0 3 5 2 94 0 0 0 2 0 0 0 80 0 0 0 0 0 0 7 01 0 7 0 6 8 0 5 0输出：6 3 8 7 1 9 2 4 59 1 5 2 3 4 7 8 62 7 4 8 5 6 1 9 37 4 3 5 9 2 8 6 15 9 2 6 8 1 4 3 78 6 1 4 7 3 5 2 94 5 6 3 2 7 9 1 83 8 9 1 4 5 6 7 21 2 7 9 6 8 3 5 4 分析深度优先遍历所有的空缺位，对于每个空缺位， 找出目前该空缺位所有可能的取值 如果存在可能的取值 将可能的取值之一填入 如果当前为最后一个空缺点，且有可能的取值，则求得最终结果 深度优先搜索下一个空缺位 如果不存在可能的取值 该位恢复成空缺位 回溯回上一个空缺位，换一个可能的取值 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;pair&lt;int, int&gt;&gt; blank; //空缺位int final_mp[9][9]; //最终矩阵bool final_flag = false; //已求得最终矩阵标志//找到该点可能的取值vector&lt;int&gt; find_possible_num (int mp[][9], pair&lt;int, int&gt; p) &#123; bool flag[9] = &#123;false&#125;; //相应行、列、3X3粗线宫内出现过的数字为true int row = p.first, col = p.second; //p所在行、列 //检验所在行 for (int j = 0; j &lt; 9; ++j) &#123; //如果不是空缺位，且该数字没有出现过 if (j != col &amp;&amp; mp[row][j] != 0 &amp;&amp; !flag[mp[row][j] - 1]) &#123; flag[mp[row][j] - 1] = true; &#125; &#125; //检验所在列 for (int i = 0; i &lt; 9; ++i) &#123; //如果不是空缺位，且该数字没有出现过 if (i != row &amp;&amp; mp[i][col] != 0 &amp;&amp; !flag[mp[i][col] - 1]) &#123; flag[mp[i][col] - 1] = true; &#125; &#125; //检验所在3X3粗线宫 for (int i = (row/3)*3; i &lt; (row/3)*3 + 3; ++i) &#123; for (int j = (col/3)*3; j &lt; (col/3)*3 + 3; ++j) &#123; //如果不是空缺位，且该数字没有出现过 if (!(i == row &amp;&amp; j == col) &amp;&amp; mp[i][j] != 0 &amp;&amp; !flag[mp[i][j] - 1]) &#123; flag[mp[i][j] - 1] = true; &#125; &#125; &#125; vector&lt;int&gt; possible_num; for (int i = 0; i &lt; 9; ++i) &#123; if (!flag[i]) &#123; possible_num.push_back(i+1); &#125; &#125; return possible_num;&#125;//深度优先搜索，mp为目前数独表，n_blank为当前求的空缺位序号void DFS (int mp[][9], int &amp;n_blank) &#123; vector&lt;int&gt; possible_num = find_possible_num(mp, blank[n_blank]); int row = blank[n_blank].first, col = blank[n_blank].second; //空缺位所在行、列 bool f = false; if (row &gt;= 7 &amp;&amp; !f) &#123; f = true; &#125; //依次递归填入可能的值 for (int num : possible_num) &#123; mp[row][col] = num; //将可能的值填入该空缺位 //如果是最后一个空缺位，结束递归遍历 if (n_blank == blank.size()-1) &#123; //将当前矩阵复制到最终矩阵上 for (int i = 0; i &lt; 9; ++i) &#123; for (int j = 0; j &lt; 9; ++j) &#123; final_mp[i][j] = mp[i][j]; &#125; &#125; final_flag = true; return; &#125; DFS(mp, ++n_blank); //向下一个空缺位深度优先搜索 if (final_flag) &#123; //如已求得最终矩阵，则跳出循环 break; &#125; &#125; //如果可能的值都不成立，则进行回溯 mp[row][col] = 0; //恢复空缺位 n_blank--; //回到上一个空缺位&#125;int main () &#123; int mp[9][9]; for (int i = 0; i &lt; 9; ++i) &#123; for (int j = 0; j &lt; 9; ++j) &#123; cin &gt;&gt; mp[i][j]; if (mp[i][j] == 0) &#123; //0表示空缺位 blank.push_back(&#123;i, j&#125;); //将空缺位压入blank中 &#125; &#125; &#125; int n_blank = 0; //从0号空缺位开始深度优先遍历 DFS(mp, n_blank); for (int i = 0; i &lt; 9; ++i) &#123; for (int j = 0; j &lt; 9; ++j) &#123; cout &lt;&lt; final_mp[i][j] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://gy23333.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://gy23333.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"深度优先搜索（DFS）","slug":"深度优先搜索（DFS）","permalink":"https://gy23333.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88DFS%EF%BC%89/"},{"name":"图","slug":"图","permalink":"https://gy23333.github.io/tags/%E5%9B%BE/"}]},{"title":"动态规划","slug":"动态规划","date":"2023-01-08T10:16:25.000Z","updated":"2024-11-11T03:57:58.109Z","comments":true,"path":"2023/01/08/动态规划/","link":"","permalink":"https://gy23333.github.io/2023/01/08/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"动态规划（dynamic programming）算法是解决多阶段决策过程最优化问题的一种常用方法，利用动态规划，可以解决很多贪婪算法或分治算活不能解决的。 最核心的思想，就在于拆分子问题，记住过往，减少重复计算。","text":"动态规划（dynamic programming）算法是解决多阶段决策过程最优化问题的一种常用方法，利用动态规划，可以解决很多贪婪算法或分治算活不能解决的。 最核心的思想，就在于拆分子问题，记住过往，减少重复计算。 引入一个典型的动态规划问题： 求序列 nums = [1,5,2,4,3]的最长递增子序列长度。 直观可以看出最长递增子序列有[1,2,4]或[1,2,3]，长度为3。 暴力枚举/暴力搜索首先容易想到的就是暴力枚举/暴力搜索方法。 先利用递归分别计算从每个位置出发的子序列，然后取其中长度的最大值。 序列nums = [1,5,2,4,3]，如果从1出发，到5、2、4、3都是递增的，则可得下式（设f(x)为从x出发的最长递增子序列长度） f(1) = max\\{f(5),f(2),f(4),f(3)\\}+1由此可递归求得，从1出发最长递增子序列长度。 graph TD A((1)) B((5)) C((2)) D((4)) E((3)) F((4)) G((3)) A-->B; A-->C; A-->D; A-->E; C-->F; C-->G; 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;//计算从序号i开始的最长递增子序列长度int L (vector&lt;int&gt; nums, int i) &#123; if (i == nums.size() - 1) &#123; return 1; &#125; int max_len = 1; for (int j = i+1; j &lt; nums.size(); ++j) &#123; if (nums[j] &gt; nums[i]) &#123; max_len = max(max_len, L(nums, j) + 1); &#125; &#125; return max_len;&#125;//计算序列的最长递增子序列长度int length_of_LIS (vector&lt;int&gt; nums) &#123; int max_len = 1; for (int i = 0; i &lt; nums.size(); ++i) &#123; max_len = max(max_len, L(nums, i)); &#125; return max_len;&#125;int main () &#123; vector&lt;int&gt; nums = &#123;1,5,2,4,3&#125;; cout &lt;&lt; length_of_LIS(nums);&#125; 时间复杂度： 每个子序列都需要遍历一次，判断是否是递增序列，时间复杂度为$O(2^n)$，每个子序列至多遍历n次，总时间复杂度为$O(n*2^n)$。 时间复杂度为指数级别的算法，以下针对这个问题进行优化。 记忆化搜索/剪枝暴力枚举中存在大量重复计算问题，如下图中在2的子树中遍历了4，后面又遍历了一次4，重复计算了两次。 所以可以用一个哈希表记录已计算的“从i开始的最长子序列长度”，用空间换取时间上的缩短。 graph TD A((1)) B((5)) C((2)) D((4)) E((3)) F((4)) G((3)) A-->B; A-->C; A-->D; A-->E; C-->F; C-->G; 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;//用map记录已计算过的 L(i)map&lt;int, int&gt; memo;//计算从序号i开始的最长递增子序列长度int L (vector&lt;int&gt; nums, int i) &#123; //如果memo中存在 L(i)，则直接返回记录值 if (memo.count(i)) &#123; return memo[i]; &#125; if (i == nums.size() - 1) &#123; return 1; &#125; int max_len = 1; for (int j = i+1; j &lt; nums.size(); ++j) &#123; if (nums[j] &gt; nums[i]) &#123; max_len = max(max_len, L(nums, j) + 1); &#125; &#125; memo[i] = max_len; //添加新记录 return max_len;&#125;//计算序列的最长递增子序列长度int length_of_LIS (vector&lt;int&gt; nums) &#123; int max_len = 1; for (int i = 0; i &lt; nums.size(); ++i) &#123; max_len = max(max_len, L(nums, i)); &#125; return max_len;&#125;int main () &#123; vector&lt;int&gt; nums = &#123;1,5,2,4,3&#125;; cout &lt;&lt; length_of_LIS(nums);&#125; 迭代/非递归的实现将上面的方法归纳成非递归的形式。 序列 nums = [1,5,2,4,3] \\begin{aligned} L(0) &= max\\{L(1),L(2),L(3),L(4)\\}+1 \\\\ L(1) &= max\\{\\cancel{L(2)},\\cancel{L(3)},\\cancel{L(4)}\\}+1\\\\ L(2) &= max\\{L(3),L(4)\\}+1\\\\ L(3) &= max\\{\\cancel{L(4)}\\}+1\\\\ L(4) &= 1 \\end{aligned}可以看出，只要从后往前依次计算，就可以通过迭代方法计算出所有的$L(i)$ 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;//计算序列的最长递增子序列长度int length_of_LIS (vector&lt;int&gt; nums) &#123; vector&lt;int&gt; L(nums.size(), 1); //从倒数第二个开始，从后往前计算L(i) for (int i = L.size() - 2; i &gt;= 0; --i) &#123; for (int j = i+1; j &lt; L.size(); ++j) &#123; if (nums[j] &gt; nums[i]) &#123; L[i] = max(L[i], L[j]+1); &#125; &#125; &#125; //返回L(i)中的最大值 int max_length = 1; for (int l : L) &#123; if (l &gt; max_length) &#123; max_length = l; &#125; &#125; return max_length;&#125;int main () &#123; vector&lt;int&gt; nums = &#123;1,5,2,4,3&#125;; cout &lt;&lt; length_of_LIS(nums);&#125; 时间复杂度为$O(n^2)$，相比暴力搜索的$O(n*2^n)$，时间大大降低。 动态规划的基本思想和基本概念基本思想 将待求解的问题分解成若干个子问题，层层分解，直到问题可以直接解决 对于重复出现的子问题，只在第一次遇到的时候进行求解，并将结果保存起来，下次遇到时直接引用答案 基本概念 阶段：把问题分为具有一定次序的若干阶段，即第n个子问题就是第n个阶段。 状态：每个阶段开始时所处的状态，即在求第n个阶段的解时，已求得的第n-1个阶段的解，就是当前的状态。 决策：目前已知第n-1个阶段的状态，可以通过决策，确定下一个阶段的状态 状态转移方程：从第n-1个阶段的状态到第n个阶段的状态的方程 动态规划例题最长回文子串求字符串中最长的回文子串，回文子串即左右对称的串，如ABBA、ABCBA。 分析步骤 分解问题 判断某字符串是否为回文串，可以分解为两个子问题： 去掉头尾两个字符后，剩下的字符串为回文串 头尾两个字符相同 如果满足以上条件，则该字符串为回文串。 初始化 拆解到最后，如果只剩一个字符，则一定是回文串；如果剩两个字符，两字符相同是回文串。 状态转移方程 设 $dp[i][j]$ 表示从$i$到$j$的子串是否是回文串。 dp[i][j] =\\left\\{ \\begin{array}{ll} 1 & i=j \\\\ s[i]==s[j]?1:0 & j-i=1 \\\\ s[i]==s[j] \\&\\& dp[i+1][j-1] & j-i>1 \\end{array}\\right. 代码实现采用迭代的形式，在计算长串的 $dp[i][j]$ 前，必须要已知 $dp[i+1][j-1]$ ，即要保证左下角的状态已求，所以遍历顺序如下，遍历列优先的上三角。 \\begin{pmatrix} 1 & 2 & 4 &7\\\\ * & 3 & 5 &8\\\\ * & * & 6 &9\\\\ * & * & * &10\\\\ \\end{pmatrix}12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int length_of_LPS (string str) &#123; vector&lt;vector&lt;bool&gt;&gt; dp(str.length(), vector&lt;bool&gt;(str.length(), false)); int max_length = 0; for (int j = 0; j &lt; dp[0].size(); ++j) &#123; for (int i = 0; i &lt;= j; ++i) &#123; if (i == j) &#123; dp[i][j] = true; &#125; else if (j - i == 1) &#123; dp[i][j] = str[i] == str[j]; &#125; else &#123; dp[i][j] = (str[i] == str[j]) &amp;&amp; dp[i+1][j-1]; &#125; if (dp[i][j] &amp;&amp; j - i + 1 &gt; max_length) &#123; max_length = j - i + 1; &#125; &#125; &#125; return max_length;&#125;int main () &#123; string str; cin &gt;&gt; str; cout &lt;&lt; length_of_LPS(str) &lt;&lt; endl;&#125; 正则表达式匹配一个字符串 s 和一个字符规律 p，实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。 . 匹配任意单个字符 * 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖整个字符串 s 的，而不是部分字符串。 示例一 输入：s = “aa”p = “a*”输出：true 解释：因为 * 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。 示例二 输入：s = “ab”p = “.*”输出：true 解释：.* 表示可匹配零个或多个（*）任意字符（.）。 提示： 1 &lt;= s.length &lt;= 20 1 &lt;= p.length &lt;= 30 s 只包含从 a-z 的小写字母。 p 只包含从 a-z 的小写字母，以及字符 . 和 *。 保证每次出现字符 * 时，前面都匹配到有效的字符 问题分析关键在于处理&#39;*&#39;问题，&#39;*&#39;需要搭配前面的一个字符使用。如， &#39;a*&#39;可以表示0～N个&#39;a&#39;，即&quot;&quot;、&quot;a&quot;、&quot;aa&quot;、&quot;aaa&quot;等 &#39;.*&#39;可以表示0～N个&#39;.&#39;，即可以表示任意字符串 状态定义定义 $dp[i][j]$ 表示s的前i个字符和p的前j个字符是否匹配。 状态转移 如 $p[j]$ 为小写字母 $s[0,i]$ 和 $p[0,j]$ 的匹配问题，可以分解为两个子问题，即 $s[0,i-1]$ 和 $p[0,j-1]$ 匹配，且 $s[i]$ 和 $p[j]$ 相同 dp[i][j] = dp[i-1][j-1] \\& s[i]=p[j] 如 $p[j]$ 为&#39;.&#39; 只要$s[0,i-1]$ 和 $p[0,j-1]$ 匹配，则$s[0,i]$ 和 $p[0,j]$ 也一定匹配 dp[i][j] = dp[i-1][j-1] 如 $p[j]$ 为&#39;*&#39; 需要与前一个字符 $p[j-1]$ 一起计算，可对 $p[j-1]$ 匹配 $k$ 次，如&quot;a*&quot;， 匹配 $0$ 次 s = &quot;bc&quot; p = &quot;bca*&quot; &quot;a*&quot;匹配 $0$ 次，即&quot;a*&quot;相当于&quot;&quot;，p = &quot;bca*&quot; 化为 &quot;bc&quot; dp[i][j] = dp[i][j-2] 匹配 $1$ 次 s = &quot;bca&quot; p = &quot;bca*&quot; &quot;a*&quot;匹配 $1$ 次，即&quot;a*&quot;相当于&quot;a&quot; 如匹配，则$s[0,i]$一个字符为a，且$s[0,i]$去除掉 $1$ 个a后、$p[0,j]$去除掉 &quot;a*&quot;后，查看是否匹配 dp[i][j] = dp[i-1][j-2] \\& s[i] = p[j-1] 匹配 $k$ 次 $s[0,i]$ 和 $p[0,j]$ 的匹配问题，可以分解为 $s[0,i]$的后 $k$ 个是否都为a $s[0,i]$去除掉 $k$ 个a后、$p[0,j]$去除掉 &quot;a*&quot;后，查看是否匹配 \\begin{aligned} &dp[i][j] = dp[i-k][j-2] \\\\ \\& \\\\ &s[i-k+1] = s[i-k+2] = ... = s[i] = p[j-1] \\end{aligned} 即 $p[j]$ 为&#39;*&#39;时，转移矩阵只要匹配 $0、1…k$ 次有一个成立，则$s[0,i]$ 和 $p[0,j]$ 匹配 \\begin{aligned} dp[i][j] = & dp[i][j-2] （匹配0次） \\\\ or\\ & dp[i-1][j-2] \\& s[i] = p[j-1] （匹配1次）\\\\ ... \\\\ or\\ & dp[i-k][j-2] \\& s[i-k+1,..., i] = p[j-1] （匹配k次） \\end{aligned} 匹配 $0$ 次，即 s = &quot;bc&quot; p = &quot;bca*&quot; dp[i][j] = dp[i][j-2] 匹配 $k$ 次 需要有一个前提，即 $s[i]$ 等于 $p[j-1]$ s = &quot;bcaa&quot; p = &quot;bca*&quot;，如果 $s$ 去掉一个a也匹配，即&quot;bca&quot; &quot;bca*&quot;匹配，则$s[0,i]$ 和 $p[0,j]$ 匹配（如 $p[j-1]=’.’$ ，也相当于 $s[i]=p[j-1]$ 成立） dp[i][j] = dp[i-1][j] \\& s[i]=p[j-1] 总状态转移矩阵 dp[i][j] =\\left\\{ \\begin{array}{ll} dp[i-1][j-1]\\ \\&\\ s[i]=p[j] &p[j]\\in[a,z]\\\\ dp[i-1][j-1] & p[j] = \\ .\\\\ dp[i][j-2]\\ or\\ \\{dp[i-1][j]\\ \\&\\ (s[i]=p[j-1] \\ ||\\ p[j-1]='.' \\}& p[j] = \\ * \\end{array}\\right.初始化$s$ 的长度为 m，$p$ 的长度为 n，需要考虑空串的匹配问题，所以状态大小设置为$dp[m+1][n+1]$ 要求 $dp[i][j]$ 需先有左上角的 $dp[i-1][j-1]$ 、$dp[i][j-2]$ 、$dp[i-1][j]$ ，所以初始化应先求出左边和上边，即$dp[…][0]$ 、$dp[0][…]$ 两个空串必然匹配，所以 $dp[0][0] = true$ 空串p = &quot;&quot;和任意非空s不匹配，即 $dp[1…n][0] = false$ 空串s = &quot;&quot;和奇数长度的p不可能匹配，和偶数长度的p可能匹配，如p = &quot;a*b*c*&quot;，所以当 $p[j] = ‘*’$ 时，$dp[0][j] = dp[0][j-2]$ 代码实现123456789101112131415161718192021222324252627class Solution &#123;public: static bool isMatch(string s, string p) &#123; int n = s.size(), m = p.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(m+1, false)); //初始化 dp[0][0] = true; //默认实现了dp[1...n][0]的初始化 //dp[0][1...m]的初始化 for (int j = 2; j &lt;= m &amp;&amp; p[j-1] == '*'; j += 2) &#123; dp[0][j] = true; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (s[i-1] == p[j-1] || p[j-1] == '.') &#123; dp[i][j] = dp[i-1][j-1]; &#125; else if (p[j-1] == '*') &#123; dp[i][j] = dp[i][j-2] || ((s[i-1] == p[j-2] || p[j-2] == '.') &amp;&amp; dp[i-1][j]); &#125; &#125; &#125; return dp[n][m]; &#125;&#125;; 称砝码现有n种砝码，重量互不相等，分别为 m1,m2,m3…mn ，每种砝码对应的数量为 x1,x2,x3…xn，问能称出多少种不同的重量。（注：称重重量包括 0） 输入描述： 对于每组测试数据： 第一行：n —- 砝码的种数(范围[1,10]) 第二行：m1 m2 m3 … mn —- 每种砝码的重量(范围[1,2000]) 第三行：x1 x2 x3 …. xn —- 每种砝码对应的数量(范围[1,10]) 输出描述： 利用给定的砝码可以称出的不同的重量数 示例一 输入：21 22 1输出：5 示例二 输入：310 191 1036 6 5输出：254 代码实现递归实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;map&gt;using namespace std;map&lt;vector&lt;vector&lt;int&gt;&gt;, set&lt;int&gt;&gt; memo;set&lt;int&gt; different_sum(vector&lt;vector&lt;int&gt;&gt; v) &#123; if (memo.count(v)) &#123; return memo[v]; &#125; set&lt;int&gt; s; int n = 0; for (int i = 0; i &lt; v.size(); ++i) &#123; n += v[i][1]; if (v[i][1] != 0) &#123; break; &#125; &#125; if (n == 0) &#123; s.insert(0); return s; &#125; for (int i = 0; i &lt; v.size(); ++i) &#123; if (v[i][1] != 0) &#123; vector&lt;vector&lt;int&gt;&gt; t = v; t[i][1] -= 1; for (int j : different_sum(t)) &#123; s.insert(j); s.insert(j + v[i][0]); &#125; &#125; &#125; memo[v] = s; return s;&#125;int main () &#123; int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; v(n, vector&lt;int&gt;(2, 0)); for (int i = 0; i &lt; 2*n; ++i) &#123; if (i &lt; n) &#123; cin &gt;&gt; v[i][0]; &#125; else if (i &gt;= n) &#123; cin &gt;&gt; v[i-n][1]; &#125; &#125; cout &lt;&lt; different_sum(v).size() &lt;&lt; endl;&#125; 迭代方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;int main () &#123; int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; v(n, vector&lt;int&gt;(2, 0)); for (int i = 0; i &lt; 2*n; ++i) &#123; if (i &lt; n) &#123; cin &gt;&gt; v[i][0]; &#125; else if (i &gt;= n) &#123; cin &gt;&gt; v[i-n][1]; &#125; &#125; set&lt;int&gt; s; s.insert(0); bool flag = false; for (int i = 0; i &lt; n; ++i) &#123; if (v[i][1] != 0) &#123; flag = true; break; &#125; &#125; while (flag) &#123; for (int i = 0; i &lt; n; ++i) &#123; if (v[i][1] != 0) &#123; set&lt;int&gt; s_copy = s; for (int j : s_copy) &#123; s.insert(j + v[i][0]); &#125; s.insert(v[i][0]); v[i][1] --; &#125; &#125; flag = false; for (int i = 0; i &lt; n; ++i) &#123; if (v[i][1] != 0) &#123; flag = true; break; &#125; &#125; &#125; cout &lt;&lt; s.size() &lt;&lt; endl;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://gy23333.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://gy23333.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://gy23333.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"匈牙利算法","slug":"匈牙利算法","date":"2023-01-07T07:13:56.000Z","updated":"2024-11-11T03:57:58.108Z","comments":true,"path":"2023/01/07/匈牙利算法/","link":"","permalink":"https://gy23333.github.io/2023/01/07/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/","excerpt":"","text":"","categories":[{"name":"算法","slug":"算法","permalink":"https://gy23333.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://gy23333.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Makefile教程","slug":"Makefile教程","date":"2022-01-13T09:27:19.000Z","updated":"2024-11-11T03:57:58.132Z","comments":true,"path":"2022/01/13/Makefile教程/","link":"","permalink":"https://gy23333.github.io/2022/01/13/Makefile%E6%95%99%E7%A8%8B/","excerpt":"一份简单的Makefile介绍入门，帮助在Linux系统下编译C/C++。","text":"一份简单的Makefile介绍入门，帮助在Linux系统下编译C/C++。 引出如果有一个test.cpp文件，在命令行里输入 1g++ test.cpp -o test 即可对cpp文件进行编译，生成test可执行文件。 如此，每次对cpp文件进行修改后，都要重新输入该命令进行编译，过程复杂且重复。 所以，可以将这些命令打包成makefile文件，定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作。 在该文件夹下生成一个空文件，命名为Makeflie或makefile makefile12test: test.cpp g++ test.cpp -o test 第二行的开头为Tab键，如为空格键则会出现makefile:2: *** missing separator. Stop.的报错。VSCode中默认Tab键转化为空格，如需输入Tab键，关闭设置中Editor: Insert Spaces选项。 在命令行中输入 1make 即可对test.cpp文件进行编译，效果与gcc test.cpp -o test相同。 Makefile的规则Makefile的基础框架12target: prerequisites command target（目标）：可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label） prerequisites（依赖）：生成该target所依赖的文件和target command（命令）：该target要执行的命令（任意的shell命令） target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。 一个示例123456789101112131415161718192021222324edit : main.o kbd.o command.o display.o \\insert.o search.o files.o utils.o cc -o edit main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.omain.o : main.c defs.h cc -c main.ckbd.o : kbd.c defs.h command.h cc -c kbd.ccommand.o : command.c defs.h command.h cc -c command.cdisplay.o : display.c defs.h buffer.h cc -c display.cinsert.o : insert.c defs.h buffer.h cc -c insert.csearch.o : search.c defs.h buffer.h cc -c search.cfiles.o : files.c defs.h buffer.h command.h cc -c files.cutils.o : utils.c defs.h cc -c utils.cclean : rm edit main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.o Makefile中使用变量在makefile中使用变量类似于C/C++中的宏。 定义一个变量objects 1objects = main.o kbd.o command.o display.o 则可以在makefile中以$(objects)的方式来使用这个变量。 123456789101112131415161718192021222324objects = main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.oedit : $(objects) cc -o edit $(objects)main.o : main.c defs.h cc -c main.ckbd.o : kbd.c defs.h command.h cc -c kbd.ccommand.o : command.c defs.h command.h cc -c command.cdisplay.o : display.c defs.h buffer.h cc -c display.cinsert.o : insert.c defs.h buffer.h cc -c insert.csearch.o : search.c defs.h buffer.h cc -c search.cfiles.o : files.c defs.h buffer.h command.h cc -c files.cutils.o : utils.c defs.h cc -c utils.cclean : rm edit $(objects) 隐晦规则make可以自动识别和推倒指令。只要make看到一个 .o 文件，它就会自动的把 .c 文件加在依赖关系中，如果make找到一个whatever.o ，那么 whatever.c 就会是 whatever.o 的依赖文件， cc -c whatever.c 就会被推导出来。 1234567891011121314151617objects = main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.oedit : $(objects) cc -o edit $(objects)main.o : defs.hkbd.o : defs.h command.hcommand.o : defs.h command.hdisplay.o : defs.h buffer.hinsert.o : defs.h buffer.hsearch.o : defs.h buffer.hfiles.o : defs.h buffer.h command.hutils.o : defs.h.PHONY : cleanclean : -rm edit $(objects) .PHONY表示clean是个伪目标文件。 由于很多.o文件都依赖相同的.h文件，在此之上，可以进一步简化。 123456789101112objects = main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.oedit : $(objects) cc -o edit $(objects)$(objects) : defs.hkbd.o command.o files.o : command.hdisplay.o insert.o search.o files.o : buffer.h.PHONY : cleanclean : -rm edit $(objects) 清空目标文件的规则每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。 12clean : rm edit $(objects) 更为稳健的做法是： 123.PHONY : cleanclean : -rm edit $(objects) .PHONY 表示clean是一个“伪目标”。 在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。 Makefile的运行输入make命令后， 在当前目录下找名字叫“Makefile”或“makefile”的文件； 找文件中的第一个目标文件（target），并把这个文件作为最终的目标文件； 如果最终的目标文件不存在，或是最终的目标文件所依赖的后面的 .o 文件的文件修改时间要比最终的目标文件新，则执行后面所定义的命令来生成最终的目标文件； 如果最终的目标文件所依赖的 .o 文件也不存在，那么make会在当前文件中找目标为 .o 文件的依赖性，如果找到则再根据那一个规则生成 .o 文件； make会生成 .o 文件，然后再用 .o 文件生成make的最终的目标文件。 如果target与第一个目标文件没有任何关联（如clean），则该命令不会执行。如要执行clean，则需另外输入make clean命令。 参考 Makefile的写法（b站视频教程） 跟我一起写Makefile","categories":[],"tags":[{"name":"Makefile","slug":"Makefile","permalink":"https://gy23333.github.io/tags/Makefile/"}]},{"title":"雾天图像理解算法研究","slug":"雾天图像理解算法研究","date":"2021-04-04T13:47:00.000Z","updated":"2024-11-11T03:57:58.121Z","comments":true,"path":"2021/04/04/雾天图像理解算法研究/","link":"","permalink":"https://gy23333.github.io/2021/04/04/%E9%9B%BE%E5%A4%A9%E5%9B%BE%E5%83%8F%E7%90%86%E8%A7%A3%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/","excerpt":"在自动驾驶的过程中，图像语义分割是其视觉系统中很重要的一环，现有的不少算法在晴天条件下对图像进行处理表现良好，但是一旦出现如雾天等恶劣天气，原有系统对图像的处理效果将大大降低。 本课题旨在通过算法途径，以图像复原为手段，提升图像理解算法在雾天条件下的感知能力，基于大气退化物理模型对雾天图像进行语义分割。","text":"在自动驾驶的过程中，图像语义分割是其视觉系统中很重要的一环，现有的不少算法在晴天条件下对图像进行处理表现良好，但是一旦出现如雾天等恶劣天气，原有系统对图像的处理效果将大大降低。 本课题旨在通过算法途径，以图像复原为手段，提升图像理解算法在雾天条件下的感知能力，基于大气退化物理模型对雾天图像进行语义分割。 摘要本毕业设计研究的主要内容是自动驾驶环境下雾天图像的语义分割。作为自动驾驶汽车视觉系统中的重要一环，语义分割的准确度直接影响了自动驾驶汽车的安全性能。现有的语义分割算法在晴朗天气下表现良好，但是在一旦遇到如大雾等不良天气，其分割效果就会大打折扣。为了解决雾天图像的语义分割问题，本次实验利用基于雾天成像物理模型的深度卷积神经网络对雾天图像进行复原，恢复出去雾图像，再在去雾图像上进行语义分割，提高雾天环境下语义分割的准确度。 针对自然条件下难以获得同一场景的无雾/有雾图像对数据的问题，本文选择Cityscapes室外街景晴天图像来合成有雾图像。通过双目视差恢复出原始深度映射，再基于分割进行深度的补全，依照设定的大气散射系数，由深度图像得到相应的传输率图像，再根据雾天大气退化原理合成不同浓度下的有雾图像。该方法合成的有雾图像效果逼真，为后续神经网络的训练提供了大量的无雾/有雾图像对。 针对语义分割受到雾天场景影响的问题，本文提出了一个先图像复原再语义分割的框架。基于雾天大气退化模型，先对传输率进行估计，再生成相应的去雾图像。本文构建了一个深度卷积网络以增大模型的表达能力，同时为了避免网络加深导致的梯度消失问题，引入了残差模块。对网络的去雾效果从视觉指标和定量化指标（PSNR、SSIM）两个维度进行评价，验证了该网络去雾的有效性。 为了进一步验证图像复原工作对语义分割的促进作用，本文将AOD-Net和本文算法模型所得的去雾图像分别输入语义分割网络，与数据集标签进行比较，得到分割的准确度。实验证明，本文提出的去雾网络相比于AOD-Net不仅在图像质量评价指标上有着显著提升，还进一步提升了语义分割的准确度，验证了本文网络对雾天场景语义分割的巨大促进作用。 关键词：雾天图像的合成；深度卷积网络；单幅图像去雾；雾天图像的语义分割 合成雾图参考Semantic Foggy Scene Understanding with Synthetic Data 雾天图像退化模型光线在大气中传播的过程中会接触到空气中的颗粒，形成散射，使得原方向上的光线强度衰减，能量发散到其他方向。随着雾的浓度的增大，空气中的颗粒也就愈加密集，光的散射程度也随之增加。 雾天图像退化模型中，光学传感器接收到的光分为两个部分：一是目标物体反射的光，反射光从目标物体传播到光学传感器，途中会受到空气颗粒的散射，导致光强减小；二是周围的环境光，也叫大气光，由大气中其他光源散射至光学传感器。 根据能量守恒定律，目标物体反射光中散射掉的比例应等于大气光散射到光学传感器的比例，由此可以得到以下雾成像机理的线性模型 I(x)=J(x)t(x)+A(1-t(x))其中，I(x)为有雾图像，J(x)为晴天图像，t(x)为中间介质透射率（即目标物体反射光中成功到达相机，没有被散射掉的光的比例），A为全局大气光强。有雾图像I(x)可分为衰减模型J(x)t(x)和环境光模型A(1-t(x))。 雾合成根据雾成像机制公式 I(x)=R(x)t(x)+L(1-t(x))要从晴图R(x)得到雾图I(x)，还需要两个参数——中间透射率t(x)和大气光L。 求中间透射率t(x)数据集通过双目相机对街道进行拍摄，再通过双目匹配算法可以得到以下输入： 晴图左通道R 晴图右通道Q 双目相机参数 预估视差D 无视差值D的所有像素点集合 计算中间透射率t(x)的步骤： 通过视差D计算出大致的深度图d 去噪，完成一个以米为单位的深度图d’ 从深度图d’得场景距离图l","categories":[],"tags":[]},{"title":"Daily English Dictation","slug":"Daily-English-Dictation","date":"2021-01-05T18:18:59.000Z","updated":"2024-11-11T03:57:58.122Z","comments":true,"path":"2021/01/06/Daily-English-Dictation/","link":"","permalink":"https://gy23333.github.io/2021/01/06/Daily-English-Dictation/","excerpt":"关于B站Coach Shane老师的每日英语听写 Daily English Dictation 1-400的学习记录。","text":"关于B站Coach Shane老师的每日英语听写 Daily English Dictation 1-400的学习记录。 D1 Mother Teresa, who received a Nobel Peace Price for her work on behalf of the poor, dies in Calcutta, India — She was 87 years old. dies 用一般现在时表过去发生的事，给人身临其境的感觉。 D2 Jerry, what time do you have (de yuh ave) ? I have (ave) five o’clock. what time 两相同音，保留第二个，即 wha time 7 Hs：he, her, him, his, have, has, had 连读时，去掉h发音，即 have(ave) D3 There are three things I have(ave) learned Never to(t’) discuss with people, religion, politics and the Great Pumpkin! Never 重度第一音，表示决心 to的7种发音：to, tah, tuh, t’, dah, duh, d’ 其中较为常用的是：t’, d’ D4 Don’t ever (Don-ever) let(le) somebody tell you you can’t(can) do something(sump’n). 强音：S, N, L 弱音：d, t, th 当强音遇到了弱音，弱音省略，即 Don’t(Don) can’t同样因为强弱音原则变成can，但是重音与表肯定的can又区别。表否定的can’t读作短促的can something(sump’n) D5 I have come here to(d’) chew bubblegum and(an) kick ass… and(an) I’m(ahm) all out of (outta) bubblegum! to的7种发音：to, tah, tuh, t’, dah, duh, d’ 其中较为常用的是：t’, d’ and(an) 强弱音原则 I’m(ahm) out of (outta) D6 The secret of life is just(juss) to(t’) live every moment. D7 Another rogue trader has cost a bank billions. D8 German, Rolf Buchholz, is the (ize) man with the most(mos) piercings, he’s got 453! is the (ize) 强弱音原则 with the 相似音留后一个 453 -&gt; four hu-nerd fivety three D9 A satellite that was carried to(t’) space aboard the shuttle Discovery twenty(tweny) years age, is about to(t’) fall to(d’) Earth, but noboby knows where the debris(d’-bree) will hit. D10 It’s a (I’sa) lofty, probably impossible goal. D11* New York swept the Tampa Bay Rays by identical 4-2 scores in a day-night doubleheader Wednesday. Doubleheader 一天连赛两场 以同样的4比2的比分连赢两场 D12* Jim Henson, creator of(o’) the Muppets - from Kermit the Frog to Sesame Street, is born in Greenville , MS.","categories":[{"name":"英语","slug":"英语","permalink":"https://gy23333.github.io/categories/%E8%8B%B1%E8%AF%AD/"}],"tags":[{"name":"Coach-Shane","slug":"Coach-Shane","permalink":"https://gy23333.github.io/tags/Coach-Shane/"}]},{"title":"HTML基础教程","slug":"HTML基础教程","date":"2020-07-08T13:53:33.000Z","updated":"2024-11-11T03:57:58.116Z","comments":true,"path":"2020/07/08/HTML基础教程/","link":"","permalink":"https://gy23333.github.io/2020/07/08/HTML%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/","excerpt":"HTML基础知识总结。","text":"HTML基础知识总结。 HTML标签基本标签 标签 描述 注释 &lt;html&gt; HTML &lt;body&gt; 主体 &lt;h1&gt;～&lt;h6&gt; 标题 从一级标题到六级标题，由大到小 &lt;p&gt; 段落 浏览器会自动地在段落的前后添加空行，如果在不产生一个新段落的情况下进行换行用&lt;br /&gt; &lt;br /&gt; 换行 &lt;a&gt; 链接 例&lt;a href=&quot;http://www.w3school.com.cn&quot;&gt;This is a link&lt;/a&gt; &lt;img&gt; 图像 例&lt;img src=&quot;XXXX.jpg&quot; width=&quot;104&quot; height=&quot;142&quot; /&gt; &lt;hr /&gt; 水平线 &lt;q&gt; 短引用 &lt;blockquote&gt; 长引用 &lt;abbr&gt; 缩略词 表格 标签 描述 &lt;table&gt; 表格 &lt;caption&gt; 标题 &lt;th&gt; 表头 &lt;tr&gt; 行 &lt;td&gt; 单元 123456789101112&lt;table border=\"1\"&gt; &lt;th&gt;head1&lt;/th&gt; &lt;th&gt;head2&lt;/th&gt; &lt;tr&gt; &lt;td&gt;row 1, cell 1&lt;/td&gt; &lt;td&gt;row 1, cell 2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 2, cell 1&lt;/td&gt; &lt;td&gt;row 2, cell 2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; border=&quot;1&quot;则显示边框，border=&quot;0&quot;则不显示边框。 列表 标签 描述 &lt;ol&gt; 有序列表 &lt;ul&gt; 无序列表 &lt;li&gt; 列表项 无序列表1234&lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt; 有序列表1234&lt;ol&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt;&lt;/ol&gt;","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://gy23333.github.io/tags/HTML/"}]},{"title":"人工智能概述","slug":"人工智能概述","date":"2020-07-07T14:35:38.000Z","updated":"2024-11-11T03:57:58.121Z","comments":true,"path":"2020/07/07/人工智能概述/","link":"","permalink":"https://gy23333.github.io/2020/07/07/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%BF%B0/","excerpt":"《人工智能及其应用》第一章绪论笔记总结。","text":"《人工智能及其应用》第一章绪论笔记总结。 人工智能的定义与发展人工智能的定义&emsp;&emsp;人工智能的几种定义： 智能 人的智能是人类理解和学习事物的能力，或者说，智能是思考和理解的能力而不是本能做事的能力。 智能是一种应用知识处理环境的能力或由目标准则衡量的抽象思考能力。 智能机器 一种能够呈现出人类智能行为的机器，而这种智能行为是人类用大脑思考问题或创造思想。 是一种能够在不确定环境中执行各种拟人任务达到预期目标的机器。 人工智能（学科）","categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://gy23333.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"人工智能","slug":"人工智能","permalink":"https://gy23333.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}]},{"title":"有序搜索——八数码问题","slug":"有序搜索——八数码问题","date":"2020-06-13T09:15:22.000Z","updated":"2024-11-11T03:57:58.114Z","comments":true,"path":"2020/06/13/有序搜索——八数码问题/","link":"","permalink":"https://gy23333.github.io/2020/06/13/%E6%9C%89%E5%BA%8F%E6%90%9C%E7%B4%A2%E2%80%94%E2%80%94%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/","excerpt":"有序搜索（ordered search）又称最佳优先搜索，设计估价函数选择最有希望的节点最为下一个要扩展的节点。","text":"有序搜索（ordered search）又称最佳优先搜索，设计估价函数选择最有希望的节点最为下一个要扩展的节点。 有序搜索算法 把起始节点S放到OPEN表中，计算$f(S)$并把其值与节点$S$联系起来。 如果OPEN是个空表，则失败退出，无解。 从OPEN表中选择一个$f$值最小的节点$i$。如果有几个节点合格，当其中有一个为目标节点时，则选择此目标节点，否则就选择其中任一个节点作为节点。 把节点$i$从OPEN表中移出，并把它放入 CLOSED的扩展节点表中。 如果$i$是一个目标节点，则成功退出，求得一个解。 扩展节点$i$，生成其全部后继节点。对于$i$的每一个后继节点$j$： 计算$f(j)$。 如果$j$既不在OPEN表中，又不在 CLOSED表中，则用估价函数$f$把它添OPEN表。从$j$加一指向其父节点$i$的指针，以便一旦找到目标节点时记住一个解答路径。 如果$j$已在OPEN表或 CLOSED表中，比较刚刚对$j$计算过的$f$值和前面计算过的该节点在表中的$f$值。如果新的$f$值较小，则 以此新值取代旧值。 从$j$指向$i$，而不是指向它的父节点。 如果节点$j$在 CLOSED表中，则把它移回OPEN表 转向（2），即GOTO（2）。 &emsp;&emsp;其中，最为重要的就是估价函数的设计。 八数码问题&emsp;&emsp;八数码问题由8个编有1到8并放在$3 \\times 3$方格棋盘上的可走动的棋子组成。棋盘上总有一个格是空的，以便让空格周围的棋子走进空格，即移动空格。将棋盘状态由初始状态变换成目标状态。 &emsp;&emsp;比如有下面左图的初始状态转为下面右图的目标状态。 \\begin{bmatrix} 2 & 8 & 3 \\\\ 1 & 6 & 4 \\\\ 7 & 0 & 5 \\end{bmatrix} \\quad \\quad -> \\quad \\quad \\begin{bmatrix} 1 & 2 & 3 \\\\ 8 & 0 & 4 \\\\ 7 & 6 & 5 \\end{bmatrix}利用有序搜索求解八数码 利用逆转棋子数来判断目标状态是否可达 如初始状态和目标状态的逆转棋子数同奇偶，则目标状态可达；否则，目标状态不可达。 &emsp;&emsp;逆转棋子数：将棋盘转为一维数组，从该数组中取出一对数，如前面的数大于后面的数，则为一个逆序。棋盘的逆转棋子数则为该棋盘逆序的总数。 &emsp;&emsp;如棋盘 \\begin{bmatrix} 2 & 8 & 3 \\\\ 1 & 6 & 4 \\\\ 7 & 0 & 5\\end{bmatrix}\\quad \\quad -> \\quad \\quad \\begin{bmatrix} 2 & 8 & 3 & 1 & 6 & 4 & 7 & 5 \\end{bmatrix} 该棋盘的逆转棋子数为 $1+6+1+0+3+2+1+0 = 14$ 代入有序搜索算法 main.m123456789101112131415161718192021222324252627282930313233343536373839404142434445clear;clc;h_select = 2;S = [2,8,3; 1 6 4; 7,0,5]; %起始节点G = [1,2,3; 8,0,4; 7,6,5]; %目标节点reachFlag = true;% 需逆转数目同奇偶才可达if mod(H3(S),2) ~= mod(H3(G),2) disp(\"Fail\"); reachFlag = false;endOPEN = initOPEN(S,G, h_select); %初始化OPEN表CLOSED = &#123;&#125;; %初始化CLOSED为空表while reachFlag % OPEN表为空，则失败，跳出循环 if isempty(OPEN) disp(\"Fail\"); break; end % 对OPEN表中的节点排序筛出f最小节点Node，并将Node从OPEN中删除 [Node, OPEN] = removeMinf(OPEN); % 将Node加入CLOSED表 CLOSED&#123;1, length(CLOSED)+1&#125; = Node; disp(['第',num2str(length(CLOSED)),'步， ',... '第',num2str(CLOSED&#123;1,length(CLOSED)&#125;.depth),'层， ',... '总代价',num2str(CLOSED&#123;1,length(CLOSED)&#125;.f)]); disp(CLOSED&#123;1,length(CLOSED)&#125;.state); % 如果Node节点为目标结点，则成功，退出 if isequal(Node.state,G) disp(\"Success\"); break; end % 扩展节点 [OPEN, CLOSED] = expand(Node, G, OPEN, CLOSED, h_select);end 扩展节点 扩展i，得后继节点j，计算f(j)，提供返回的指针，利用f(j)对OPEN表重新排序，调整亲子关系及指针。 expand.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263function [OPEN, CLOSED] = expand(Node, G, OPEN, CLOSED, h_select)%expand 扩展结点% Node为当前节点，G为目标节点，OPEN为OPEN表，CLOSED为CLOSED表% OPEN为扩展后的OPEN表，CLOSED为扩展后的CLOSED表% 生成后继节点neighbor_states = [];len = 0;[m,n] = find(Node.state==0); %找到节点的0位置[r, c] = size(Node.state);% 空格向左的后继节点if n ~= 1 len = len+1; neighbor_states(:,:,len) = moveLeft(Node.state);end% 空格向右的后继节点if n ~= c len = len+1; neighbor_states(:,:,len) = moveRight(Node.state);end% 空格向上的后继节点if m ~= 1 len = len+1; neighbor_states(:,:,len) = moveUp(Node.state);end% 空格向下的后继节点if m ~= r len = len+1; neighbor_states(:,:,len) = moveDown(Node.state);end% 对每个后继节点for i = 1:size(neighbor_states,3) neighborNode.state = neighbor_states(:,:,i); %节点状态 neighborNode.parent = length(CLOSED); %父节点 % 计算f neighborNode.depth = Node.depth+1; %节点深度 switch h_select case 1 %估计函数1:取一格局与目的格局相比，其位置不符的棋子数目。 neighborNode.h = H1(neighborNode.state, G); case 2 %估价函数2：各棋子移到目的位置所需移动距离的总和。 neighborNode.h = H2(neighborNode.state, G); case 3 %估价函数3：对每一对逆转棋子乘以一个倍数。 neighborNode.h = H3(neighborNode.state); case 4 %估价函数4：将位置不符棋子数目的总和与3倍棋子逆转数目相加。 neighborNode.h = H1(neighborNode.state, G) ... + H3(neighborNode.state); case 5 %估价函数5：各棋子与目的位置欧式距离平方的总和。 neighborNode.h = H5(neighborNode.state, G); end neighborNode.f = neighborNode.depth + neighborNode.h; % 添加节点 [OPEN, CLOSED] = addNode(neighborNode, OPEN, CLOSED);endend 估价函数 估价函数1 取一格局与目的格局相比，其位置不符的棋子数目。 H1.m1234567891011121314151617function wrongNum = H1(N, G)%H1 估价函数1 计算节点N相对于目标棋局错放的棋子个数% N为当前节点，G为目标节点% WrongNum为错放的棋子个数[r, c] = size(N);wrongNum = 0;% 计算节点N相对于目标棋局错放的棋子个数for i = 1:r for j = 1:c % 错放棋子且0位不算在错放个数内 if N(i,j) &amp;&amp; N(i,j)~=G(i,j) wrongNum = wrongNum+1; end endendend 估价函数2 各棋子移到目的位置所需移动距离的总和。 H2.m1234567891011function h = H2(N, G)%H2 估价函数2 各棋子移到目的位置所需移动距离的总和% N为当前节点，G为目标节点% h为所需移动距离的总和h = 0;for i = 1:8 [a,b] = find(N==i); [c,d] = find(G==i); h = h + abs(c-a) + abs(d-b);endend 估价函数3 对每一对逆转棋子乘以一个倍数，这里为$\\times 3$。 H3.m123456789101112131415function h = H3(N)%H3 估价函数3 对每一对逆转棋子乘以一个倍数。% N为当前节点% h为3倍逆转棋子数h = 0;N1 = [N(1,:),N(2,:),N(3,:)];for i = 1:9 for j = i+1:9 if N1(i) &gt; N1(j) &amp;&amp; N1(i)~=0 &amp;&amp; N1(j)~=0 h = h+1; end endendh = h*3;end 估价函数4 将位置不符棋子数目的总和与3倍棋子逆转数目相加。 12%估价函数4：将位置不符棋子数目的总和与3倍棋子逆转数目相加。neighborNode.h = H1(neighborNode.state, G) + H3(neighborNode.state); 估价函数5（自己设计） 各棋子与目的位置欧式距离平方的总和。 H5.m1234567891011function h = H5(N, G)%H5 估价函数5 欧式距离的平方的总和% N为当前节点，G为目标节点% h为欧式距离的平方的总和h = 0;for i = 1:8 [a,b] = find(N==i); [c,d] = find(G==i); h = h + (c-a)^2 + (d-b)^2;endend 例题&emsp;&emsp;利用有序搜索解例题（左图为初始状态，右图为目标状态） \\begin{bmatrix} 2 & 8 & 3 \\\\ 1 & 6 & 4 \\\\ 7 & 0 & 5 \\end{bmatrix} \\quad \\quad -> \\quad \\quad \\begin{bmatrix} 1 & 2 & 3 \\\\ 8 & 0 & 4 \\\\ 7 & 6 & 5 \\end{bmatrix} 估价函数1 取一格局与目的格局相比，其位置不符的棋子数目。 利用估价函数1运行，搜索成功一共经历7个扩展节点。 估价函数2 各棋子移到目的位置所需移动距离的总和。 利用估价函数2运行，搜索成功一共经历6个扩展节点。 估价函数3 对每一对逆转棋子乘以一个倍数，这里为$\\times 3$。 利用估价函数3运行，搜索成功一共经历8个扩展节点。 估价函数4 将位置不符棋子数目的总和与3倍棋子逆转数目相加。 利用估价函数4运行，搜索成功一共经历6个扩展节点。 估价函数5 各棋子与目的位置欧式距离平方的总和。 利用估价函数5运行，搜索成功一共经历6个扩展节点。 &emsp;&emsp;对于该八数码例题，估价函数2、4、5扩展节点最少，即估价函数2、4、5的搜索效率最高。 Matlab GUI&emsp;&emsp;从mainPage.m开始运行，可打开八数码GUI页面。（其中初始节点和目标节点可编辑）","categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://gy23333.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"人工智能","slug":"人工智能","permalink":"https://gy23333.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"有序搜索","slug":"有序搜索","permalink":"https://gy23333.github.io/tags/%E6%9C%89%E5%BA%8F%E6%90%9C%E7%B4%A2/"},{"name":"八数码问题","slug":"八数码问题","permalink":"https://gy23333.github.io/tags/%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/"}]},{"title":"问题归约——梵塔问题","slug":"问题归约——梵塔问题","date":"2020-05-11T00:35:33.000Z","updated":"2024-11-11T03:57:58.129Z","comments":true,"path":"2020/05/11/问题归约——梵塔问题/","link":"","permalink":"https://gy23333.github.io/2020/05/11/%E9%97%AE%E9%A2%98%E5%BD%92%E7%BA%A6%E2%80%94%E2%80%94%E6%A2%B5%E5%A1%94%E9%97%AE%E9%A2%98/","excerpt":"问题归约（problem reduction）是一种基于状态空间的问题描述与求解方法。已知问题的描述，通过一系列变换把此问题最终变为一个本原问题集合。","text":"问题归约（problem reduction）是一种基于状态空间的问题描述与求解方法。已知问题的描述，通过一系列变换把此问题最终变为一个本原问题集合。 梵塔问题描述&emsp;&emsp;有3根柱子1、2、3柱和N个不同尺寸的圆盘，初始圆盘套在1柱上，盘的尺寸由下到上依次变小。要求将圆盘全部搬到3柱，搬运过程中要遵守下面规定： 每次只能移动一个圆盘； 大盘不能叠在小盘上面。 求解思路&emsp;&emsp;原问题可以拆分成下列子问题。（以4圆盘问题为例，圆盘从小到大分别是A、B、C、D） 移动圆盘A、B和C至柱2（3圆盘问题） 移动圆盘D到柱3（单圆盘问题） 移动圆盘A、B和C至柱3（3圆盘问题） 如此将4圆盘问题化为两个3圆盘问题和一个单圆盘问题，而3圆盘问题还可继续分解，直到化为单圆盘问题（本原问题）的集合。这便是问题归约。 Matlab代码调用代码1234567891011121314151617clear; %清除变量% 设置的圆盘个数nn = 4;if n &lt; 1 fprintf('圆盘个数需为正整数。\\n');else HannoiStep = hannoi(n, 'A', 'B', 'C'); % 解梵塔问题 HannoiStep clear hannoi % 清除hannoi文件的变量 if n &lt;= 7 StepAnimation(HannoiStep); % 动画演示步骤 else fprintf('圆盘太多了，没位置画，圆盘数1～7可以演示。\\n'); endend 核心代码hannoi.m1234567891011121314151617181920212223242526272829303132% n个圆盘，返回步骤矩阵function HannoiStep = hannoi(n, A, B, C)% 创建步骤矩阵persistent steps;if isempty(steps) steps = ones(1,n);end% 如果是一个圆盘，直接从A移动到Cif n == 1 [r, ~] = size(steps); step = steps(r,:); step(1) = C-'A'+1; steps = [steps; step];% fprintf('1 号碟 : %s ---&gt; %s\\n', A, C); HannoiStep = steps;else % 否则，先将n-1个圆盘从A经过C移动到B hannoi(n-1, A, C, B); % 将第n个圆盘从A移动到C [r, ~] = size(steps); step = steps(r,:); step(n) = C-'A'+1; steps = [steps; step];% fprintf('%d 号碟 : %s ---&gt; %s\\n', n, A, C); % 将n-1个圆盘从B经过A移动到C hannoi(n-1, B, A, C); HannoiStep = steps;endend 动画代码StepAnimation.m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function StepAnimation(HannoiStep)[r,~] = size(HannoiStep);for index = 1 : 1 : r step = HannoiStep(index,:); pause_times = 1; DrawFrame(step) pause(pause_times); if index &lt; r clf; % 清除图形 endendendfunction DrawFrame(step)[~,n] = size(step); % n为圆盘数% 初始颜色数组coArray = [ [0 0.4470 0.7410]; [0.8500 0.3250 0.0980]; [0.4660 0.6740 0.1880]; [0.9290 0.6940 0.1250]; [0.3010 0.7450 0.9330]; [0.4940 0.1840 0.5560]; [0.6350 0.0780 0.1840]; ]; % 初始x坐标数组xArray = linspace(0.5,1.5,n);for i = 1:3 subplot(1,3,i); axis([-1.5,1.5,0,3]); % 绘制柱 line([0 0],[0.5 3],'LineWidth',10,'Color',[0.3 0.3 0.3]); line([-1.5 1.5],[0.5 0.5],'LineWidth',10,'Color',[0.3 0.3 0.3]); % 绘制圆盘 for index = n : -1 : 1 % 如果该圆盘在这根柱上 if step(index) == i Ynum = 0; for j = n : -1 : index+1 if step(j) == i Ynum = Ynum+1; end end % 画圆盘 line([-xArray(index) xArray(index)],[0.7+0.3*Ynum... 0.7+0.3*Ynum],'LineWidth',30,'Color',coArray(index,:)); end end axis off;endend 解答&emsp;&emsp;以4圆盘问题为例，运行上述代码，可求解。 与或图 步骤 HannoiStep =\\begin{bmatrix} 1\\quad 1\\quad 1\\quad 1\\\\ 2\\quad 1\\quad 1\\quad 1\\\\ 2\\quad 3\\quad 1\\quad 1\\\\ 3\\quad 3\\quad 1\\quad 1\\\\ 3\\quad 3\\quad 2\\quad 1\\\\ 1\\quad 3\\quad 2\\quad 1\\\\ 1\\quad 2\\quad 2\\quad 1\\\\ 2\\quad 2\\quad 2\\quad 1\\\\ 2\\quad 2\\quad 2\\quad 3\\\\ 3\\quad 2\\quad 2\\quad 3\\\\ 3\\quad 1\\quad 2\\quad 3\\\\ 1\\quad 1\\quad 2\\quad 3\\\\ 1\\quad 1\\quad 3\\quad 3\\\\ 2\\quad 1\\quad 3\\quad 3\\\\ 2\\quad 3\\quad 3\\quad 3\\\\ 3\\quad 3\\quad 3\\quad 3\\\\ \\end{bmatrix}","categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://gy23333.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"人工智能","slug":"人工智能","permalink":"https://gy23333.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"问题归约","slug":"问题归约","permalink":"https://gy23333.github.io/tags/%E9%97%AE%E9%A2%98%E5%BD%92%E7%BA%A6/"},{"name":"梵塔问题","slug":"梵塔问题","permalink":"https://gy23333.github.io/tags/%E6%A2%B5%E5%A1%94%E9%97%AE%E9%A2%98/"}]},{"title":"SURF算子","slug":"SURF算子","date":"2020-04-24T08:44:51.000Z","updated":"2024-11-11T03:57:58.115Z","comments":true,"path":"2020/04/24/SURF算子/","link":"","permalink":"https://gy23333.github.io/2020/04/24/SURF%E7%AE%97%E5%AD%90/","excerpt":"&emsp;&emsp;SURF (Speeded Up Robust Features, 加速稳健特征) 是一个稳健的图像识别和描述算法，首先于2006年发表在ECCV大会上。这个算法可被用于计算机视觉任务，如物件识别和3D重构。他部分的灵感来自于SIFT算法。SURF标准的版本比SIFT要快数倍，并且其作者声称在不同图像变换方面比SIFT更加稳健。","text":"&emsp;&emsp;SURF (Speeded Up Robust Features, 加速稳健特征) 是一个稳健的图像识别和描述算法，首先于2006年发表在ECCV大会上。这个算法可被用于计算机视觉任务，如物件识别和3D重构。他部分的灵感来自于SIFT算法。SURF标准的版本比SIFT要快数倍，并且其作者声称在不同图像变换方面比SIFT更加稳健。 SURF算子——原理特征点检测基于Hessian矩阵的特征点检测&emsp;&emsp;对于输入图像中的一点$X=(x,y)$，其Hessian矩阵定义如下 H(X,\\sigma)= \\begin{bmatrix} L_{xx}(X,\\sigma)&L_{xy}(X,\\sigma)\\\\ L_{xy}(X,\\sigma)&L_{yy}(X,\\sigma) \\end{bmatrix}其中$\\sigma$为Hessian矩阵的尺度，$L_{xx}$是高斯二阶偏导数$\\frac {\\partial^2}{\\partial x^2}g(\\sigma)$与输入图像在点$X$处的卷积，其余类似。 &emsp;&emsp;行列式的值$det(H)$即为点$X$处的响应 det(H)=L_{xx}L_{yy}-L_{xy}^2基于Box滤波器的Hessian矩阵近似计算&emsp;&emsp;利用Box滤波器做Hessian矩阵近似计算，加快计算速度。 在LoG算子中， h(x,y)=e^{-\\frac {x^2+y^2}{2\\sigma^2}} \\triangledown^2h(r)=(\\frac{r^2-\\sigma^2}{\\sigma^4})e^{-\\frac {r^2}{2\\sigma^2}},\\quad r^2=x^2+y^2 &emsp;&emsp;可以用Box滤波器近似计算$\\triangledown^2h(r)$ &emsp;&emsp;如此对高斯二阶微分模板进行简化，从而降低计算量，高斯二阶导数函数的离散化和截断会造成一定的误差。 &emsp;&emsp;利用简化后的Box滤波模版对图像进行卷积，得到Hessian矩阵的近似计算 H(X,N)= \\begin{bmatrix} D_{xx}(X,N)&D_{xy}(X,N)\\\\ D_{xy}(X,N)&D_{yy}(X,N) \\end{bmatrix}其中，N为Box滤波器的大小。 &emsp;&emsp;行列式的值$det(H)$即为点$X$处的响应（但是要加上权重） det(H_{approx})=D_{xx}D_{yy}-(wD_{xy})^2,\\quad w \\approx 0.9其中，权重$w$为平衡因子 w=\\frac {|L_{xy}(1.2)|_F|D_{yy}(9)|_F}{|L_{yy}(1.2)|_F|D_{xy}(9)|_F}=0.912...\\approx 0.9基于积分图的Box滤波器快速计算&emsp;&emsp;利用积分图快速计算Box卷积滤波。 &emsp;&emsp;积分图是输入图像经过像素间的累加运算得到的新图像。任意一点$(x,y)$的值是从输入图像的左上角到这个点所构成的矩形区域内所有点的灰度值之和。 &emsp;&emsp;每个点的积分可以用迭代的方式获得 II(x,y)=II(x,y-1)+S(x-1,y)+I(x,y) &emsp;&emsp;计算矩阵ABCD中像素和只需要积分图中A、B、C、D四点的值和3次加法运算 尺度金字塔构建&emsp;&emsp;一般尺度金字塔采用对图像的下采样，使用同一个滤波器滤波。 &emsp;&emsp;在SURF算子中，由于积分图和Box滤波的计算便利性，固定图像尺度，上采样滤波器。 &emsp;&emsp;与SIFT算子类似， 将尺度空间划分为若干组(Octaves)，每组又由若干固定层（Interval）组成 每组尺度金字塔的各层尺度成等差数列 不同组的尺度金字塔的公差等比增长（$O,S$为组索引、层索引，从$0$开始） Filter Size = 3\\times[2^{o+1}\\times (s+1)+1] &emsp;&emsp;为了保持尺度空间的连续性，相邻组尺度金字塔有部分层重叠（SIFT中同样，$S+3$个图才能得到$S$个尺度的特征点检测结果） 特征点定位 非极大抑制 与SIFT中的做法相似， 每组中选相邻3层Hessian行列式图像，对于中间层图像中的每个待比较点，选取同层的8个相邻点和上下层的9个相邻点进行比较 若该点值大于其他26点，则为特征点 尺度空间插值 与SIFT中的做法相同，得到亚像素级的特征值，减小不同组第一层之间的差异。 特征点描述特征点主方向&emsp;&emsp;为了保证特征描述子具有旋转不变性，与SIFT一样，需要对每个特征点分配一个主方向。 选择以特征点为中心、半径为$6s$（$s$为特征点的尺度）的圆形邻域 计算该圆形邻域内各点的$x$、$y$方向Haar小波响应（Haar小波边长取$4s$） 计算图像的Haar小波响应，实际上就是对图像进行梯度运算，只不过需要利用积分图，提高梯度计算效率。 用$\\sigma = 2.5s$的高斯函数对响应加权 以特征点为中心，张角为$\\pi /3$的扇形滑动窗口，计算窗口内的Haar小波响应值$dx$、$dy$的累加 m_w=\\sum\\limits_w dx+\\sum\\limits_w dy\\\\ \\theta_w=\\arctan(\\sum\\limits_w dx/\\sum\\limits_w dy) 特征点主方向为最大的Haar响应累加值所对应的方向 \\theta = \\theta_w|max\\{m_w\\} Haar小波响应和描述符 构建以特征点为中心、方向为特征点主方向、边长为$20s$的正方形区域 将区域划分成$4\\times 4$子块 每个子块均匀采样$5\\times 5$个样本点 计算各采样点的Haar小波响应（Haar小波边长为$2s$） 用以特征点为中心点，$\\sigma =3.3s$的高斯函数对响应加权 在各子块内统计$\\sum dx$、$\\sum |dx|$、$\\sum dy$、$\\sum |dy|$形成子块特征向量 每个子块统计一个四维特征向量$\\vec v$ \\vec v = (\\sum dx,\\sum |dx|,\\sum dy,\\sum |dy|) 将$4\\times 4$个子块的特征向量$\\vec v$相连，得长度为64的特征向量，具有亮度不变性 将特征向量归一化，具有对比度不变性 SURF描述子对于不同纹理的区分性 快速索引匹配 在检测阶段，记录拉普拉斯算子的符号（Hessian矩阵的迹的符号） 在匹配阶段，匹配拉普拉斯算子符号相同的特征，从而降低运算量 参考 Paper: SURF: Speeded Up Robust Features SenitCo: 图像特征之SURF特征匹配","categories":[{"name":"Computer Vision","slug":"Computer-Vision","permalink":"https://gy23333.github.io/categories/Computer-Vision/"}],"tags":[{"name":"SURF算子","slug":"SURF算子","permalink":"https://gy23333.github.io/tags/SURF%E7%AE%97%E5%AD%90/"},{"name":"特征描述","slug":"特征描述","permalink":"https://gy23333.github.io/tags/%E7%89%B9%E5%BE%81%E6%8F%8F%E8%BF%B0/"}]},{"title":"SIFT算子","slug":"SIFT算子","date":"2020-04-22T06:56:50.000Z","updated":"2024-11-11T03:57:58.121Z","comments":true,"path":"2020/04/22/SIFT算子/","link":"","permalink":"https://gy23333.github.io/2020/04/22/SIFT%E7%AE%97%E5%AD%90/","excerpt":"&emsp;&emsp;尺度不变特征转换(Scale-invariant feature transform 或 SIFT)是一种机器视觉的算法用来侦测与描述影像中的局部性特征，它在空间尺度中寻找极值点，并提取出其位置、尺度、旋转不变数，融特征点和描述于一体。","text":"&emsp;&emsp;尺度不变特征转换(Scale-invariant feature transform 或 SIFT)是一种机器视觉的算法用来侦测与描述影像中的局部性特征，它在空间尺度中寻找极值点，并提取出其位置、尺度、旋转不变数，融特征点和描述于一体。 SIFT算子——算法尺度空间极值检测&emsp;&emsp;图像在不同的尺度下用高斯滤波器进行卷积，然后利用连续高斯模糊化图像差异来找出关键点。 高斯金字塔构建&emsp;&emsp;图像的尺度空间被定义为一个函数 $L(x,y,\\sigma)$，它是由可变尺度高斯函数$G(x,y,\\sigma)$与输入图像$I(x,y)$的卷积产生的。 L(x,y,\\sigma)=G(x,y,\\sigma)*I(x,y) G(x,y,\\sigma)=\\frac1{2\\pi \\sigma^2}e^{-\\frac{x^2+y^2}{2\\sigma ^2}}$\\sigma$是尺度坐标(尺度变化因子)，$\\sigma$大小决定图像的平滑程度，$\\sigma$值越大图像模糊得越严重。大尺度对应图像的概貌特征，小尺度对应图像的细节特征。一般根据$3\\sigma$原则，高斯核矩阵的大小设为$(6\\sigma +1)\\times (6\\sigma +1)$。 &emsp;&emsp;SIFT算子中的高斯金字塔由多个组（Octave）组成，而每个组（Octave）由多层（Interval）组成。 &emsp;&emsp;每组图像的第一层由上一组的第一层高斯金字塔降采样而得，每组的下一层由上一层高斯滤波而得。 &emsp;&emsp;先按高斯金字塔将原图像化为多组（Octave），后一组的尺寸是前一组的$\\frac 12$。每组再由第一层进行高斯滤波，同组的图像尺寸相同。 &emsp;&emsp;在降采样时，高斯金字塔中一组(Octive)的底层图像是由前一组图像的倒数第3张图像隔点采样得到。 &emsp;&emsp;金字塔组数（Octave）可由原始图像和塔顶图像的大小之比算得。Octave = \\log_2 \\frac {min(width_0,height_0)}{min(width,height)}式中，$width_0、height_0$分别为原始图像的宽高，$width、height$为塔顶图像的宽高。 &emsp;&emsp;每组分为$S$个尺度间隔（做$S$次高斯滤波），相邻两个尺度的$\\sigma$之比为： k=2^{\\frac 1S}则每一组包含$1$，$2^{\\frac 1S}$，$2^{\\frac 2S}$，…，2，一共$(S+1)$幅图像（即$(S+1)$层）。 &emsp;&emsp;尺度参数$\\sigma$的取值与金字塔的组数和层数相关。设第一组第一层的尺度参数取值为$\\sigma (0,0) = \\sigma _0$，则第$m$组第$n$层的$\\sigma$取值为\\sigma(0,0)=\\sigma_0,\\quad\\sigma(o,s)=2^{o}\\times k^{s}\\times \\sigma_0 = 2^{o}\\times 2^{\\frac sS}\\times \\sigma_0=2^{o+\\frac sS}\\times \\sigma_0 高斯差分金字塔（DoG金字塔）&emsp;&emsp;DoG金字塔计算简单，提供了LoG算子良好的近似，LoG算子的极值相较于Hessian、Harris等算子，能提供更稳定的图像特征，且具有尺度不变性。 &emsp;&emsp;高斯差分图像由高斯金字塔中同一组(Octave)内相邻层(Interval)的图像作差得到。 D(x,y,\\sigma)=L(x,y,k\\sigma)-L(x,y,\\sigma) &emsp;&emsp;高斯金字塔一级$S$个图像，将得到DoG金字塔一级$(S-1)$个图像。 空间极值点检测&emsp;&emsp;对DoG金字塔中的每个像素，在三维领域内判断是否是极值点（最大值/最小值）。如果是极值点，则该点暂定为图像在该尺度下的一个特征点。 三维领域：中间检测点与其同尺度的8个邻域像素点以及上下相邻两层对应的$9\\times 2$个像素点一共$3\\times 9-1=26$个点作比较。 &emsp;&emsp;该步的极值点检测可以确定极值点的位置（像素级）和尺度，极值点的大小反映了极值处的对比度（反差）。 &emsp;&emsp;为了每组（Octave）得到$S$个尺度的极值结果，需要DoG金字塔每组$S+2$个图像，需要高斯金字塔每组$S+3$个图像。 关键点定位亚像素（子像素）精确定位&emsp;&emsp;在DoG尺度空间检测到的极值点是离散的，通过三元二次函数拟合来精确确定关键点的位置和尺度，达到亚像素精度。 &emsp;&emsp;将原点移到极值点处，并将高斯差分在该极值点处展开，保留一阶项及二阶项，得到： D(X)=D+\\frac {\\partial D^T}{\\partial X}+\\frac 12 X^T\\frac {\\partial ^2 D}{\\partial X^2}X其中，$X=(x,y,\\sigma )^T$ &emsp;&emsp;令$D’(X)=0$，得极值点的偏移量 \\hat X = -(\\frac {\\partial^2 D}{\\partial X^2})^{-1}\\frac {\\partial D}{\\partial X}如此得到亚像素精度的极值点$\\hat X$。 &emsp;&emsp;利用$\\hat X$得到新的高斯差分值$D(\\hat X)$ D(\\hat X)=D+\\frac 12 \\frac {\\partial D^T}{\\partial X}\\hat X设置对比度阈值$T$，当$|D(\\hat X)|&lt;T$时，去除该对比度低的不稳定极值点$\\hat X$。 去除边缘点&emsp;&emsp;由于DoG算子对边缘点很敏感，在边缘处也有很大的响应值，需要剔除不稳定的边缘响应点。 &emsp;&emsp;在极值点处，利用$D(X)$计算Hessian矩阵 H= \\begin{bmatrix} D_{xx}&D_{xy}\\\\ D_{yx}&D_{yy} \\end{bmatrix}&emsp;&emsp;$D(X)$的主曲率与$H$的特征值成正比，在边缘梯度方向比较大，对应一个大的特征值$\\alpha$；在沿着边缘的方向上比较小，对应一个小的特征值$\\beta$。（两个特征值的之比为$r = \\alpha/\\beta$） 两特征值的和等于$H$的迹$Tr(H)$ Tr(H)=D_{xx}+D_{yy}=\\alpha + \\beta两特征值的积等于$H$的行列式$det(H)$ det(H)=D_{xx}D_{yy}-D_{xy}D_{yx}则有 \\frac {Tr^2(H)}{det(H)}=\\frac {(\\alpha + \\beta)^2}{\\alpha \\beta}=\\frac {(r+1)^2}{r}当两特征值相等，即$r=1$时，$\\frac {(r+1)^2}{r}$最小。$r$越大，$\\frac {(r+1)^2}{r}$越大。 &emsp;&emsp;边缘点对应的特征值之比$r$比其他的点大，所以设置一个关于$r$的阈值$T_r$，当$\\frac {Tr^2(H)}{det(H)} &gt; \\frac {(T_r+1)^2}{T_r}$时，判断该极值点为边缘点，去除该点。 获取关键点主方向&emsp;&emsp;为了使特征描述子具有旋转不变性，需要利用关键点邻域像素的梯度方向分布特性为每个关键点指定方向参数。 &emsp;&emsp;根据关键点的尺度，在高斯金字塔对应图像的关键点位置处的局部区域计算梯度方向直方图，计算每个点的梯度幅值和方向。（一般取大小为$3\\sigma$的领域） 梯度幅值$m$： m(x,y)=\\sqrt{[L(x+1,y)-L(x-1,y)]^2+[L(x,y+1)-L(x,y-1)]^2}梯度方向$\\theta$： \\theta (x,y)=\\tan^{-1}\\frac {L(x,y+1)-L(x,y-1)}{L(x+1,y)-L(x-1,y)}&emsp;&emsp;将$[0\\circ, 360\\circ]$分为多个柱，梯度幅值加到对应的梯度方向的柱上，选出直方图的峰值为该关键点的主方向。 关键点描述&emsp;&emsp;到上述步骤已经获得了关键点的位置、尺度以及方向。关键点的描述利用关键点及其周围像素，计算块内梯度直方图，生成特征向量，用于描述每个关键点。 确定用于计算关键点描述的局部区域&emsp;&emsp;描述子梯度方向直方图由关键点所在尺度的模糊图像计算产生，局部区域的半径$radius$：（$\\sigma_{oct}$为关键点所在组的组内尺度） radius = \\frac {3\\sigma_{oct}\\times \\sqrt2 \\times (d+1)}{2},\\quad d = 4&emsp;&emsp;除上面的方法以外，还可以直接使用直径$diameter$：（$\\sigma 为关键点所在尺度$） diameter = 6\\sigma +1根据关键点主方向变换坐标系&emsp;&emsp;将坐标轴旋转至关键点主方向，以确保旋转不变性。旋转后采样点的新坐标为 \\begin{bmatrix} x'\\\\ y' \\end{bmatrix} = \\begin{bmatrix} \\cos \\theta&-\\sin \\theta\\\\ \\sin \\theta&\\cos \\theta \\end{bmatrix} \\begin{bmatrix} x\\\\ y \\end{bmatrix} ,\\quad x,y \\in [-radius,radius] 计算关键点描述&emsp;&emsp;在局部区域内对每个像素点求其梯度幅值和方向，生成方向直方图。 &emsp;&emsp;梯度幅值高斯（$\\sigma$为局部区域大小的一半）加权：离关键点越近，对关键点描述的作用越大。 &emsp;&emsp;基于像素位置和梯度方向的三线性插值：将梯度方向和位置分解再加权。避免梯度方向直方图在分块边界和梯度方向量化的边界处的突然变化。 归一化关键点描述&emsp;&emsp;向量归一化：克服光照的影响，主要是增益的影响。 &emsp;&emsp;方向直方图每个方向上梯度幅值限制在一定门限值以下（门限一般取0.2，像素灰度值在0~1范围内）：克服相机饱和、光照对3D表面不同方位影响不同等非线性光照情形。 SIFT算子——应用 关键点匹配 场景匹配 全景拼接 图像检索 笔迹鉴定 参考 Paper: Distinctive Image Features from Scale-Invariant Keypoints 图像特征之SIFT特征匹配 SIFT算法详解 SIFT特征提取分析 SIFT特征提取 Sift中尺度空间、高斯金字塔、差分金字塔（DOG金字塔）、图像金字塔","categories":[{"name":"Computer Vision","slug":"Computer-Vision","permalink":"https://gy23333.github.io/categories/Computer-Vision/"}],"tags":[{"name":"特征描述","slug":"特征描述","permalink":"https://gy23333.github.io/tags/%E7%89%B9%E5%BE%81%E6%8F%8F%E8%BF%B0/"},{"name":"SIFT算子","slug":"SIFT算子","permalink":"https://gy23333.github.io/tags/SIFT%E7%AE%97%E5%AD%90/"}]},{"title":"图像的傅立叶变换","slug":"图像的傅立叶变换","date":"2020-04-17T02:35:02.000Z","updated":"2024-11-11T03:57:58.131Z","comments":true,"path":"2020/04/17/图像的傅立叶变换/","link":"","permalink":"https://gy23333.github.io/2020/04/17/%E5%9B%BE%E5%83%8F%E7%9A%84%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/","excerpt":"&emsp;&emsp;空域上的图像利于人眼分析，但是对于计算机来说分析困难，所以在很多情况下（比如滤波），需要在频域对图像进行处理。傅立叶变换把信号拆分成不同频率sin的组合，即可将空域的图像化到频域。","text":"&emsp;&emsp;空域上的图像利于人眼分析，但是对于计算机来说分析困难，所以在很多情况下（比如滤波），需要在频域对图像进行处理。傅立叶变换把信号拆分成不同频率sin的组合，即可将空域的图像化到频域。 傅立叶变换一维傅立叶变换&emsp;&emsp;一维傅立叶变换，即任何信号都可以拆分成 $A\\sin (wx+\\varPhi )$ 的组合。 连续的傅立叶变换 H(w)=\\int_{-\\infty}^{\\infty}h(x)e^{-jwx}dx离散的傅立叶变换（DFT） H(k)=\\frac 1N\\sum\\limits_{x=0}^{N-1}h(x)e^{-j\\frac{2\\pi kx}{N}}\\ ,\\quad k= -N/2..N/2快速傅立叶变换（FFT）时间复杂度：$N\\log N$ &emsp;&emsp;对于每个频率w来说，都有一个$A\\sin (wx+\\varPhi )$，其中 幅值（R为H(w)的实部，I为H(w)的虚部）构成频谱图 A=\\pm\\sqrt{R(w)^2+I(w)^2}相位（R为H(w)的实部，I为H(w)的虚部）构成相位图 \\varPhi = \\arctan\\frac {I(w)}{R(w)}二维傅立叶变换&emsp;&emsp;图像的傅立叶变换是二维的傅立叶变换。 二维的连续傅立叶变换 F(u,v)=\\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}f(x,y)e^{-j(ux+vy)}dxdy二维离散的傅立叶变换（对于$M\\times N$的图像） F(u,v)=\\sum\\limits_{x=0}^{M-1}\\sum\\limits_{y=0}^{N-1}f(x,y)e^{-j2\\pi (\\frac{ux}{M}+\\frac{vy}{N})}\\ ,\\quad u = 0,1,2,···,M-1\\ , \\quad v = 0,1,2,···,N-1&emsp;&emsp;如此图像从$(x,y)$的空域矩阵，变成了$(u,v)$的频域矩阵。（频域矩阵的大小与原空间域矩阵大小相同） 幅值（R为H(u,v)的实部，I为H(u,v)的虚部） A=\\pm\\sqrt{R(u,v)^2+I(u,v)^2}相位（R为H(u,v)的实部，I为H(u,v)的虚部） \\varPhi = \\arctan\\frac {I(u,v)}{R(u,v)} 一维傅立叶变换的三角函数系是$sin(wx)$、$cos(wx)$以及常数$1$，二维傅立叶变换的三角函数系是$sin(ux+vy)$、$cos(ux+vy)$和常数$1$。 频谱图频谱图生成图像频谱图生成Matlab代码如下 12345678img = imread('Lenna.jpg');img = rgb2gray(img);img = double(img);f1 = fft2(img); % 二维快速傅里叶变换 f2 = fftshift(f1); % FFT频谱平移magnitude1 = log(1+abs(f1)); % （未中心化）频谱对数变换（由于幅度值范围很大，所以要取对数处理）magnitude2 = log(1+abs(f2)); % （中心化）imshow(magnitude2,[]),title('频谱图'); 二维傅里叶变换&emsp;&emsp;首先需将图像进行二维傅里叶变换，得到未中心化的频谱图。此时频谱图中间区域是高频，而四个角则是DC低频分量。 频谱的中心化&emsp;&emsp;DFT具有周期性，且频谱图关于原点对称。 &emsp;&emsp;在原图像乘以系数$(-1)^{x+y}$，再进行傅立叶变换，可以得到中心化的频谱图（中间低频、四周高频）。相当于对未中心化的频谱图的四个象限进行对调：1 &lt;—&gt; 3、2 &lt;—&gt; 4 频谱图进行中心化 如此得到最终的频谱图 频率分布&emsp;&emsp;经过频谱居中后的频谱中，中间最亮的点是最低频率，属于直流分量（DC分量）。越往边外走，频率越高。所以，频谱图中的四个角和X,Y轴的尽头都是高频。 &emsp;&emsp;频谱图的亮度表示对应频率的幅度的大小。 平移和旋转 原图像平移，频谱图不变； 原图像旋转，频谱随着原图像旋转相同的角度。 Matlab代码 12345678910111213141516171819202122232425Isize = 512;Rwidth = 50;Rlength = 3*Rwidth; Irect = zeros(Isize);Irect(floor((Isize - Rlength)/2) + 1:floor((Isize - Rlength)/2) + Rlength,... (floor(Isize - Rwidth)/2) + 1:floor((Isize - Rwidth)/2) + Rwidth) = 1;Idft = fft2(Irect);subplot(2,3,1),imshow(Irect),title('原图');subplot(2,3,4),imshow(log(abs(fftshift(Idft))+1),[]),title('原图的频谱图'); Irect = zeros(Isize);Irect(floor((Isize - Rlength)/2) + 150 + 1:floor((Isize - Rlength)/2) + 150 + Rlength,... (floor(Isize - Rwidth)/2) + 1 + 200:floor((Isize - Rwidth)/2) + Rwidth + 200) = 1;Idft = fft2(Irect);subplot(2,3,2),imshow(Irect),title('平移');subplot(2,3,5),imshow(log(abs(fftshift(Idft))+1),[]),title('平移后的频谱图');Irect = zeros(Isize);Irect(floor((Isize - Rlength)/2) + 1:floor((Isize - Rlength)/2) + Rlength,... (floor(Isize - Rwidth)/2) + 1:floor((Isize - Rwidth)/2) + Rwidth) = 1;Irot = imrotate(Irect, 45, 'crop', 'bilinear');Idft = fft2(Irot);subplot(2,3,3),imshow(Irot),title('旋转');subplot(2,3,6),imshow(log(abs(fftshift(Idft))+1),[]),title('旋转后的频谱图'); 方向性&emsp;&emsp;在二维傅里叶变换中，空间域中横向的周期变化会反应在频谱图中的Y轴上，而空间域中纵向的周期变化会反应在频谱图中的X轴上。空间域中东南方向的周期变化会反应在频谱图中的东北方向，反之亦然。 Matlab代码 123456789101112131415Isize = 512;Irect = zeros(Isize);Irect(floor(Isize/2)+1:Isize, 1:Isize) = 0.1;Irect(1:floor(Isize/2), 1:Isize) = 1;Idft = fft2(Irect);subplot(2,2,1),imshow(Irect);subplot(2,2,3),imshow(log(abs(fftshift(Idft))+1),[]);Irect = zeros(Isize);Irect(1:Isize, floor(Isize/2)+1:Isize) = 0.1;Irect(1:Isize, 1:floor(Isize/2)) = 1;Idft = fft2(Irect);subplot(2,2,2),imshow(Irect);subplot(2,2,4),imshow(log(abs(fftshift(Idft))+1),[]); 参考 图像的傅里叶变换的频谱特征 一（周期性，能量分布，fftshift，交错性） 图像的傅里叶变换的频谱特征 三（平移，旋转，相位的重要性） WiKi 傅立叶变换 二维图像的傅立叶变换","categories":[{"name":"Computer Vision","slug":"Computer-Vision","permalink":"https://gy23333.github.io/categories/Computer-Vision/"}],"tags":[{"name":"傅立叶变换","slug":"傅立叶变换","permalink":"https://gy23333.github.io/tags/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/"}]},{"title":"图像金字塔","slug":"图像金字塔","date":"2020-04-16T13:26:43.000Z","updated":"2024-11-11T03:57:58.110Z","comments":true,"path":"2020/04/16/图像金字塔/","link":"","permalink":"https://gy23333.github.io/2020/04/16/%E5%9B%BE%E5%83%8F%E9%87%91%E5%AD%97%E5%A1%94/","excerpt":"&emsp;&emsp;金字塔是一种图像多尺度信号表示法，其中信号或图像要经过反复的平滑和二次采样。通过对原始图像进行多尺度像素采样的方式，生成N个不同分辨率的图像。把具有最高级别分辨率的图像放在底部，以金字塔形状排列。","text":"&emsp;&emsp;金字塔是一种图像多尺度信号表示法，其中信号或图像要经过反复的平滑和二次采样。通过对原始图像进行多尺度像素采样的方式，生成N个不同分辨率的图像。把具有最高级别分辨率的图像放在底部，以金字塔形状排列。 引入问题：假设要进行人脸识别，但是人脸与摄像头之间距离忽远忽近，单一分辨率的识别算法无法识别所有距离下的人脸特征。 &emsp;&emsp;图像金字塔是一种以多分辨率来解释图像的结构，通过对原始图像进行多尺度像素采样的方式，生成N个不同分辨率的图像。&emsp;&emsp;把具有最高级别分辨率的图像放在底部，以金字塔形状排列，往上是一系列像素（尺寸）逐渐降低的图像，一直到金字塔的顶部只包含一个像素点的图像，这就构成了传统意义上的图像金字塔。 两种采样方式： 升采样：分辨率逐渐升高，图像变大 降采样：分辨率逐渐下降，图像变小 降采样&emsp;&emsp;降采样使图像分辨率逐渐下降的同时要保证不出现错误（失真）。 奈奎斯特采样定理&emsp;&emsp;为了不失真地恢复模拟信号，采样频率应该大于模拟信号频谱中最高频率的2倍。 F_s \\geq 2F_{max}混叠 &emsp;&emsp;如果不能满足上述采样条件，采样后信号的频率就会重叠，即高于采样频率一半的频率成分将被重建成低于采样频率一半的信号。这种频谱的重叠导致的失真称为混叠，而重建出来的信号称为原信号的混叠替身，因为这两个信号有同样的样本值。 &emsp;&emsp;下图对正弦信号的采样未符合奈奎斯特采样定理，恢复模拟信号时失真。 &emsp;&emsp;如果原信号中包含的最高频率成分$F_{max} &gt; \\frac{F_s}{2}$ ，则在离散信号谱中相应周期的谱会出现重叠，最终恢复的模拟信号失真。 &emsp;&emsp;反之，如果$F_{max} &lt; \\frac{F_s}{2}$ ，即采样频率大于分析信号中最高频谱成分的2倍，则采样后离散信号频谱中不会出现频率混叠。 &emsp;&emsp;一个频率正好是采样频率一半的弦波信号，通常会混叠成另一相同频率的波弦信号，但它的相位和幅度改变了。以下两种措施可避免混叠的发生： 提高采样频率，使之达到最高信号频率的两倍以上； 引入低通滤波器 &emsp;&emsp;高斯金字塔即是引入了高斯滤波器作为低通滤波器，从而抑制高频分量，避免混叠导致降采样后的图像失真。 &emsp;&emsp;下图中，上行是未滤波的采样，可以看出后期出现了失真；下行是经过高斯滤波的下采样，后期虽然有数据损失，但是未发生失真。 高斯金字塔&emsp;&emsp;高斯金字塔是通过高斯平滑和亚采样获得下采样图像。 降采样&emsp;&emsp;为了获取层级为$G_{i+1}$的金字塔图像，采用如下方法: 对图像$G_i$进行高斯内核卷积 将所有偶数行和列去除 得到的图像即为$G_{i+1}$的图像，显而易见，结果图像只有原图像素点数的四分之一。通过对输入图像$G_i$(原始图像)不停迭代以上步骤就会得到整个金字塔。同时，向下取样会逐渐丢失图像的信息。 升采样&emsp;&emsp;如果想放大图像，则需要通过向上取样操作得到，具体做法如下： 将图像在每个方向扩大为原来的两倍，新增的行和列以0填充 使用先前同样的内核(乘以4)与放大后的图像卷积，获得 “新增像素”的近似值 （或者用双线性插值：先行求均值插入，再列求均值插入） 得到的图像即为放大后的图像，但是与原来的图像相比比较模糊，因为在缩放的过程中已经丢失了一些信息，如果想在缩小和放大整个过程中减少信息的丢失，这些数据形成了拉普拉斯金字塔。 &emsp;&emsp;下面两图分别是Lenna原图和经过高斯金字塔降采样再升采样后的图像，可以看出处理后的图像丢失了部分信息，所以升采样并不完全是降采样的逆。 高斯金字塔C++代码12345678910111213141516171819202122232425262728293031323334353637383940#include \"iostream\"#include \"opencv2/imgproc.hpp\"#include \"opencv2/imgcodecs.hpp\"#include \"opencv2/highgui.hpp\"using namespace std;using namespace cv;int main( int argc, char** argv )&#123; cout &lt;&lt; \"\\n Zoom In-Out demo \\n \" \"------------------ \\n\" \" * [i] -&gt; Zoom in \\n\" \" * [o] -&gt; Zoom out \\n\" \" * [ESC] -&gt; Close program \\n\" &lt;&lt; endl; const char* filename = argc &gt;=2 ? argv[1] : \"/Users/yogo/Downloads/CV/高斯金字塔/Gaussian pyramid/Gaussian pyramid/Lenna.png\"; // Loads an image Mat src = imread( samples::findFile( filename ) ); // Check if image is loaded fine if(src.empty())&#123; printf(\" Error opening image\\n\"); printf(\" Program Arguments: [image_name -- default chicky_512.png] \\n\"); return EXIT_FAILURE; &#125; for(;;) &#123; imwrite(\"result3.png\", src); char c; cin &gt;&gt; c; if( c == 27 ) &#123; break; &#125; else if( c == 'i' ) &#123; pyrUp( src, src, Size( src.cols*2, src.rows*2 ) ); printf( \"** Zoom In: Image x 2 \\n\" ); &#125; else if( c == 'o' ) &#123; pyrDown( src, src, Size( src.cols/2, src.rows/2 ) ); printf( \"** Zoom Out: Image / 2 \\n\" ); &#125; &#125; return EXIT_SUCCESS;&#125; 一些问题滤波模版大小问题&emsp;&emsp;按高斯分布，理论上需要一个无限大的卷积核。但实际上，仅需要取均值周围3倍标准差内的值（高斯核单边大小为3σ），以外部分直接去掉即可。 &emsp;&emsp;如果模版取得太小，边界后出现高频振荡。 图像边缘问题&emsp;&emsp;图像的边缘做卷积时，需要在边缘点周围填充值。 clip filter（black）：填0 wrap around：图像周期出现，即把图像平移到边缘 copy edge：边缘复制 reflect across edge：镜像反转 拉普拉斯金字塔&emsp;&emsp;拉普拉斯金字塔每一层的图像为同一层高斯金字塔的图像减去上一层的图像进行上采样并高斯模糊的结果。 L_i = G_i-UP(G_{i+1})*g_{5\\times 5} &emsp;&emsp;拉普拉斯金字塔即是高斯金字塔每层丢掉的高频部分。 小波金字塔&emsp;&emsp;二维离散小波分解将二维图像分解为多尺度表达， 原图像可以由多尺度小波系数精确重建。 &emsp;&emsp;频域告诉我们场景里有什么东西，空域告诉在什么位置。高频往往对应的是边缘，所以相对于图像的低频成分来说，图像的高频成分的空间定位需求很高，不应该损失空间表达能力。对于低频的部分则要求频域的分辨能力更强。即，高频要求空域上的高分辨率，低频要求频域上的高分辨率。 &emsp;&emsp;在傅立叶变换上无法做到对高低频不同的分辨能力，而小波分解可以做到。 小波变换&emsp;&emsp;小波变换是线性的。 \\vec F = U \\vec f哈尔变换&emsp;&emsp;哈尔变换是一种最简单又可以反应出时变频谱（time-variant spectrum）的表示方法。其观念与傅里叶变换相近。傅里叶变换的原理是利用正弦波与余弦波来对信号进行调变；而哈尔变换则是利用哈尔函数来对信号进行调变。哈尔函数也含有正弦函数系和余弦函数系所拥有的正交性，也就是说不同的哈尔函数是互相正交的，其内积为零。 &emsp;&emsp;将信号分解成低频和高频。以$N=2$为例，第一行是做均值，分出低频；第二行是做差值，分出高频。低频部分可以继续分解。（N取决于信号的维数，加权需要归一化） N=2\\ ,\\quad U= \\begin{bmatrix} 1&1\\\\ 1&-1 \\end{bmatrix} \\\\ N=4\\ ,\\quad U= \\begin{bmatrix} 1&1&1&1\\\\ 1&1&-1&-1\\\\ 1&-1&0&0\\\\ 0&0&1&-1\\\\ \\end{bmatrix} \\\\ . \\\\ . \\\\ .&emsp;&emsp;下面$N=8$的小波，前2行为低频部分（第2行为低频的高频部分），第3、4行为次高频部分，后4行为高频部分。 \\begin{bmatrix} \\frac18&\\frac18&\\frac18&\\frac18&\\frac18&\\frac18&\\frac18&\\frac18\\\\ \\frac18&\\frac18&\\frac18&\\frac18&-\\frac18&-\\frac18&-\\frac18&-\\frac18\\\\ \\frac14&\\frac14&-\\frac14&-\\frac14&0&0&0&0\\\\ 0&0&0&0&\\frac14&\\frac14&-\\frac14&-\\frac14\\\\ \\frac12&-\\frac12&0&0&0&0&0&0\\\\ 0&0&\\frac12&-\\frac12&0&0&0&0\\\\ 0&0&0&0&\\frac12&-\\frac12&0&0\\\\ 0&0&0&0&0&0&\\frac12&-\\frac12\\\\ \\end{bmatrix}哈尔变换特点： 不需要乘法（只有相加或加减），容易实现 输入与输出个数相同 对$(64,2,3,61,60,6,7,57)$做Haar小波变换\\begin{bmatrix}\\frac18&\\frac18&\\frac18&\\frac18&\\frac18&\\frac18&\\frac18&\\frac18\\\\\\frac18&\\frac18&\\frac18&\\frac18&-\\frac18&-\\frac18&-\\frac18&-\\frac18\\\\\\frac14&\\frac14&-\\frac14&-\\frac14&0&0&0&0\\\\0&0&0&0&\\frac14&\\frac14&-\\frac14&-\\frac14\\\\\\frac12&-\\frac12&0&0&0&0&0&0\\\\0&0&\\frac12&-\\frac12&0&0&0&0\\\\0&0&0&0&\\frac12&-\\frac12&0&0\\\\0&0&0&0&0&0&\\frac12&-\\frac12\\\\\\end{bmatrix}\\begin{bmatrix}64\\\\2\\\\3\\\\61\\\\60\\\\6\\\\7\\\\57\\\\\\end{bmatrix}=\\begin{bmatrix}32.5\\\\0\\\\0.5\\\\0.5\\\\31\\\\-29\\\\27\\\\-25\\\\\\end{bmatrix} 哈尔变换+降采样例如：一个一维的图像$[2,4,6,8,10,12,14,16]$ 求均值（低频）：相邻两个取均值，得$[3,7,11,15]$。这个新的图像分辨率就成了原来的一半(8/2=4)。 求差值（高频）：上面的均值我们存储了图像的整体信息。但是很多细节信息我们丢掉了，所以我们同时要记录图像的细节信息，这样在重构时能够恢复图像的全部信息。下面是求第m个差值的公式： b_m=\\frac {a_{2m}−a_{2m+1}}2&emsp;&emsp;经过计算我们得到了结果$[-1,-1,-1,-1]$。这个新的分辨率也成了原来的一半(8/2=4)。 哈尔小波金字塔&emsp;&emsp;小波金字塔，先将图像分为高频和低频，其中的低频成分继续分解。 每一步分解：先水平分解成高频、低频； 在将水平方向的分解的结果继续分解，得到四幅图——水平高垂直高、水平高垂直低、水平低垂直高、水平低垂直低 下一步分解：将水平低垂直低的图重复上述分解，即得到小波金字塔。 每次分解都是降采样，并且可以用原始图像大小空间表达出全部小波分解结果。 小波的优缺点 小波的优点 不是过完备的，即可以用原始图像大小空间表达出全部小波分解结果。 适合图像压缩，系数比较稀疏 可分层的运算，比较快速 小波的缺点 子带 只做了水平垂直方向，其他方向不理想 空间分配不合理 空域上小的移动，会导致小波分解的系数产生大的差异 可控方向的金字塔&emsp;&emsp;设计不同方向的滤波器，将图像分解成不同的滤波结果，这些滤波结果又可以继续抽样划分。 可控方向的金字塔的优点 子带划分时可以做方向的细分 子带的稳定性好，不会产生突变 可以根据需要选择滤波器组 可控方向的金字塔的缺点 过完备 需要各向同性的滤波器进行补充 图像金字塔的作用 多尺度 在有不同大小的图像分析时，算法不变，通过金字塔改变尺度 去噪 纹理分析 目标识别 图像拼接 图像融合 参考 图像中的各种金字塔 图像金字塔总结 图像金字塔的算法构建图示 高斯金字塔、拉普拉斯金字塔 图像多分尺度处理技术 opencv 官方文档 WiKi百科：金字塔（图像处理）) WiKi百科：降采样 WiKi百科：采样定理 WiKi百科：哈尔小波变换","categories":[{"name":"Computer Vision","slug":"Computer-Vision","permalink":"https://gy23333.github.io/categories/Computer-Vision/"}],"tags":[{"name":"高斯金字塔","slug":"高斯金字塔","permalink":"https://gy23333.github.io/tags/%E9%AB%98%E6%96%AF%E9%87%91%E5%AD%97%E5%A1%94/"},{"name":"拉普拉斯金字塔","slug":"拉普拉斯金字塔","permalink":"https://gy23333.github.io/tags/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E9%87%91%E5%AD%97%E5%A1%94/"},{"name":"小波金字塔","slug":"小波金字塔","permalink":"https://gy23333.github.io/tags/%E5%B0%8F%E6%B3%A2%E9%87%91%E5%AD%97%E5%A1%94/"}]},{"title":"Xcode调用Mac摄像头","slug":"Xcode调用Mac摄像头","date":"2020-03-30T17:04:38.000Z","updated":"2024-11-11T03:57:58.130Z","comments":true,"path":"2020/03/31/Xcode调用Mac摄像头/","link":"","permalink":"https://gy23333.github.io/2020/03/31/Xcode%E8%B0%83%E7%94%A8Mac%E6%91%84%E5%83%8F%E5%A4%B4/","excerpt":"&emsp;&emsp;Xcode中OpenCV C++调用Mac摄像头。由于在macOS 10.14中加入了隐私管理，直接调用摄像头会出现报错1OpenCV: not authorized to capture video (status 0), requesting... OpenCV: camera failed to properly initialize!&emsp;&emsp;所以涉及摄像头这类隐私问题的项目必须添加Info.plist，在这注册摄像头权限。","text":"&emsp;&emsp;Xcode中OpenCV C++调用Mac摄像头。由于在macOS 10.14中加入了隐私管理，直接调用摄像头会出现报错1OpenCV: not authorized to capture video (status 0), requesting... OpenCV: camera failed to properly initialize!&emsp;&emsp;所以涉及摄像头这类隐私问题的项目必须添加Info.plist，在这注册摄像头权限。 注册摄像头权限&emsp;&emsp;Photo Booth作为Mac原生的调用摄像头的app，天生带有设置权限的Info.plist，我们只需要将Photo Booth的Info.plist稍作修改，便可应用于我们的程序中。 &emsp;&emsp;当然，首先我们得在Xcode里配置OpenCV。 1、在/System/Applications/Photo Booth.app中右击“显示包文件”，找到其中的/System/Applications/Photo Booth.app/Contents/Info.plist，将这个Info.plist拷贝用于修改。 2、修改Info.plist &emsp;&emsp;将原本的Info.plist进行下列修改。 3、将Info.plist移入Xcode项目中 &emsp;&emsp;在Xcode项目的Product文件中右击里面的项目“Show In Folder”，将修改后的Info.plist添加到该文件夹中。 &emsp;&emsp;摄像头注册配置完成。 OpenCV C++ 调用摄像头1234567891011121314151617#include &lt;opencv2/opencv.hpp&gt;using namespace cv;using namespace std;int main()&#123; //读取视频或摄像头 VideoCapture capture(0); while (true)&#123; Mat frame; capture &gt;&gt; frame; imshow(\"读取视频\", frame); waitKey(30); //延时30 &#125; return 0;&#125;","categories":[{"name":"图像处理","slug":"图像处理","permalink":"https://gy23333.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://gy23333.github.io/tags/C/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://gy23333.github.io/tags/OpenCV/"},{"name":"Xcode","slug":"Xcode","permalink":"https://gy23333.github.io/tags/Xcode/"},{"name":"Mac","slug":"Mac","permalink":"https://gy23333.github.io/tags/Mac/"},{"name":"摄像头权限","slug":"摄像头权限","permalink":"https://gy23333.github.io/tags/%E6%91%84%E5%83%8F%E5%A4%B4%E6%9D%83%E9%99%90/"}]},{"title":"《计算机网络-自顶向下方法》笔记","slug":"《计算机网络-自顶向下方法》笔记","date":"2020-03-16T12:54:15.000Z","updated":"2024-12-25T15:48:02.856Z","comments":true,"path":"2020/03/16/《计算机网络-自顶向下方法》笔记/","link":"","permalink":"https://gy23333.github.io/2020/03/16/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0/","excerpt":"计算机网络课堂笔记，参考用书《计算机网络-自顶向下方法》。","text":"计算机网络课堂笔记，参考用书《计算机网络-自顶向下方法》。 计算机网络和因特网计算机网络​ 起源是为了形成一个自主、自治、互联的计算机通信系统。 构成描述​ 因特网也被称为“网中网”，我们所用的网络都是大网中的小网（套娃）。 接入网络的设备——网络边缘 主机（host） = 端系统（end system） 运行的联网app 通信链路（communication link）——接入网 媒介：同轴电缆、铜线、光纤、无线电频谱 传输速率：带宽 bps 分组交换机（packet switch）——网络核心 路由器（router）和 链路层交换机（link-layer switch） 协议：控制发送、接收信息。比如，TCP, IP, HTTP等等。每个层次有每个层次的协议。 网络标准 因特网工程任务组（IETF）： 制定网络标准的组织 请求评论（RFC）：IETF的标准文档 服务描述 为应用程序提供服务的基础设施 即用户使用应用。 应用程序编程接口 即编写应用。 网络边缘（Network Edge）​ 与因特网相接的计算机及其他设备位于因特网的边缘，称为端系统。 端系统 = 主机，可以被划为下面两种： 客户（client） 服务器（server）：比如有企业存储大量数据的大型数据中心（data centers） 接入网（Access Networks）​ 网络边缘的端系统 通过 接入网（物理链路） 连接到 边缘路由器（端系统到任何其他远程端系统的路径上的第一台路由器）。 家庭接入：DSL、电缆、FTTH、拨号和卫星 数字用户线（digital subscriber line，DSL） ​ 利用电话线路接入网络。其中 ADSL是非对称的数字用户线，基本都用ADSL，因为一般下行的数据量都远大于上行的数据量，所以要设计成非平衡的链路。 ​ 采用独占的频分多路复用来传输。因为利用的是原有的电话线路，所以需要将DSL传输的网络信号（上行、下行）和电话信号通过频分多路复用来区分开来。 频段 传输信号 0~4K 电话语音线路 4K~50K 上行信号 50K~1M 下行信号 电缆因特网接入（cable Internet access） 利用有线电视网接入网络。结构上，通过粗的同轴电缆接入社区，再用细的同轴电缆接入每家每户。 采用共享的频分多路复用来传输。 混合光纤同轴电缆（HFC） ​ 同轴电缆和光纤节点相连再接入边缘路由器。 ​ 不对称的竞争式协议，最高可达到30Mbps的下行速率和2Mbps的上行速率。由于采用竞争式协议，在用户少时使用体验优于普通的电缆因特网接入，但是在用户多时容易造成卡顿。 企业（家庭）接入：以太网和WiFi 以太网：使用双绞铜线与一台以太网交换机相连，速率可达到100Mbps、1Gbps、10Gbps。 WiFi：IEEE802.11技术无线LAN，范围在几十米内。 广义无线接入：4G和5G​ 详见第六章 物理媒体（Physical Media） 导引型媒体（guided media）：信号在固体媒体中传输，比如光缆、双绞铜线和同轴电缆。 非导引型媒体（unguided media）：电波在空气中传播，比如无线局域网或数字卫星频道。 网络核心（Network Core）​ 网络核心：由端系统的分组交换机和链路构成的网状网络。下图标亮部分即使网络核心。 ​ 一共有三种交换方式：报文交换（很少使用）、分组交换和电路交换 分组交换（Packet Switching）​ 端系统之间彼此传输报文，分组交换中，将长报文划分为分组，分组再通过通信链路和分组交换机（分为路由器和链路层交换机）传送。 存储转发传输（Store-and-Forward Transmission） ​ 分组交换和报文交换都采用了存储转发的传输形式。但分组交换的存储转发以分组为单位，即交换机接收到整个分组后才能输出该分组的数据；而报文交换的存储转发单位为报文，需要交换机接收到整个报文后才能输出。 ​ 传输相同大小的数据包，分组交换比报文交换更快。下面是分组交换传输3L大小的报文的时间流，报文分为3个大小为L的分组，根据分组交换原理，一共耗费了 4L/R 时间完成传输（即存储转发时延）。而如果使用报文传输同样的3L大小的报文则需要耗费 6L/R 时间。 排队时延（Queuing Delay）和分组丢失（Packet Loss） ​ 分组交换机有有一个输出缓存（output buffer），分组可能会在分组交换机上排队等待输出，造成排队时延。 ​ 分组交换机的缓存空间是有限的，所以在过于拥堵时会产生分组丢失（丢包）。 转发表（Forwarding Table）和路由选择协议（Routing Protocol） 路由：分组中包括IP地址； 转发：路由器中将目的地址映射为输出链路。 电路交换（Circuit Switching）​ 端到端连接（end- to-end connection）：在发送数据之前，必须先在发送和接收两端建立端到端连接，并预留一部分带宽。而分组交换不预留，所以会造成排队和丢包。 频分多路复用（FDM）​ 链路中的每条连接专用一个频段。 时分多路复用（TDM）​ 远距离传输会有衰减，所以考虑用数字信号进行传输。在时域上对信号进行采样，接收时再将采样信号恢复。 ​ TDM在时域上被划分为固定的帧（frame），每帧又被划分为固定数量的时隙（slot），链路中的每条连接专用一个时隙。 分组交换 &amp; 电路交换​ 分组交换的性能优于电路交换，适用于随机数据，可以满足更多用户。 ​ 电路交换需要预留带宽，相当于固定了链路用户的数量。而分组交换不需要预留带宽，用户使用网络是有一定概率的，在一个时刻较多人使用的概率其实相对较低，所以一条链路可以给更多的用户使用。 ​ 电路交换适用于特殊情况，比如要保障传输数据能力。 网络结构​ 网络结构是网中之网，具有层次结构。 ISP：ISP分为许多层级，比如第一层ISP（tier-1 ISP）、区域ISP（regional ISP）、接入ISP（access ISP）。端系统通过接入ISP与因特网相连，全球的ISP通过各个层级相连，形成了互联网的互联。 因特网交换点（Internet Exchange Point，IXP）：由第三方公司创建，IXP是一个汇合点，多个ISP在此处对等。 协议（Protocol）​ 协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及报文发送和/或接收一条报文或其他时间所采取的动作。 ​ 协议三大要素： 语法（Syntax）：每一段内容符合一定规则的格式，比如一个报文前8位是原地址，后八个是目的地址（只是举例，不要当真）之类。 语义（Semantics）：每一段内容需要代表某种意义，比如原地址部分的二进制到底是指哪个地址。 同步（Timing）：通信的过程，即每一段任务的执行顺序。 协议层次（Protocol Layer）及其服务模型五层因特网协议栈​ 因特网协议栈由5个层次组成：物理层、链路层、网络层、传输层和应用层。因特网协议栈是一个理想模型。 ​ 下层为上层提供服务。越下面的层，越靠近硬件；越上面的层，越靠近用户。 层次 功能 应用层（Application Layer） 支持网络应用，应用协议仅仅是网络应用的一个组成部分，运行在不同主机上的进程则使用应用层协议进行通信。 传输层（Transport Layer） 负责为信源和信宿提供应用程序进程间的数据传输服务，这一层上主要定义了两个传输协议，传输控制协议即TCP和用户数据报协议UDP。 网络层（Network Layer） 负责将数据报独立地从信源发送到信宿，主要解决路由选择、拥塞控制和网络互联等问题。 链路层（Link Layer） 负责将IP数据报封装成合适在物理网络上传输的帧格式并传输，或将从物理网络接收到的帧解封，取出IP数据报交给网络层。 物理层（Physical Layer） 负责将比特流在结点间传输，即负责物理传输。该层的协议既与链路有关也与传输介质有关。 OSI模型​ OSI模型由国际标准化组织（ISO）制定，实际并没有应用，只有理论。 ​ OSI模型由7层组成：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。 封装（Encapsulation）​ 在发送端， 应用层：将 应用层报文（application-layer message）M传送给传输层； 传输层：接收报文M，附上传输层首部信息Ht（包括差错检测位信息等），构成 传输层报文段（transport-layer segment），将其传递给网络层； 网络层：接收传输层报文段，附上网络层首部信息Hn（包括源和目的地址等），构成 网络层数据段（network-layer datagram），将其传递给网络层； 链路层：接收网络层数据段，附上链路层首部信息Hl，构成 链路层帧（link-layer frame），将其传递给物理层； 物理层：负责比特流物理传输。 在接收端以反方向重构报文段。 物理层概述​ 在两个物理媒体间进行比特流传输，上层都是逻辑链接，只有物理层是实际的物理连接。 物理层基本目标 保证发送信号“0”和“1”的正确性以及发送和接收的一致性； 比特流传输的模式、速度、持续时间和信号失真； 接口设计：引脚数目、功能等等； 信号传输的程序：如何安排传输过程和事件次序。 物理层的基本特性 机械特性：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等； 电气特性：指明传输模式、电压范围、编码、阻抗匹配、传输速率以及传输距离等等； 功能特性：指明各条物理线路的功能，比如某条线上出现的某一电平的电压表示何种意义， 物理接口信号线按功能分为四类：数据线、控制线、定时线和地线； 规程特性：指明各物理线路工作规程和时序的关系，比如对于不同功能的各种可能事件的出现顺序， 信号传输的模式：单工（仅单向通行）、半双工（双方通，但一个时刻仅一方通）、全双工（双方随时通）。 基本通信原理基本概念 数据（data）：对于客观事实描述的物理符号，包括数字、文本、语言、图像等等； 信息（information）：数据的集合； 信号（signal）：数据传输中的表现形式，比如模拟信号、数字信号； 信道（channel）：往固定方向传输信息的媒介。 模拟传输VS数字传输 传输方式 优点 缺点 模拟 对信道有高利用率 不抗噪 数字 信号不易失真 需要更宽的带宽 信道特性 码元（Symbol）：承载信息量的基本信号单位。 ​ 下面是马原分级数 N 与所需bit位数 n 的关系（N个离散的值需要n个bits） n=log_2N 波特率（Baud rate）：传输码元的速率。 比特率（Bit rate）：传输比特的速率。 波特率与比特率的关系 bit\\ rate(b/s)=baud\\ rate*n 信道容量（Channel capacity）：在一个信道中能够可靠地传送信息时可达速率的最小上界，单位 bps。 频带宽度（Frequency bandwidth）：信道允许的信号频率范围，单位 Hz。 Frequency\\ bandwidth = maximum\\ bandwidth-minimum\\ bandwidth 传输延迟（Transmission delay）：包括发送到接受的处理事件、电信号的响应时间、中间介质的传输时间。 奈奎斯特定理（Nyquist’s Law） 对于理想的低通信号，在一个频带宽度为 W 的信道，其码元的最大传输速率 = 2W Baud 对于理想的带通信号，在一个频带宽度为 W 的信道，其码元的最大传输速率 = W Baud 香农定理（Shannon’s Formula） 信道的信息传输速率C（单位：bps） C=Wlog_2(1+S/N) W - 带宽，单位 Hz S - 信道的平均信号功率 N - 信道的高斯噪声功率 S/N - 信号功率与噪声功率之比（也可以叫信噪比） 一般情况下，信噪比不用 $S/N$ 表示，而是 $10log_{10}S/N$ ，单位为dB。 模拟/数字信号传输​ 模拟信道只能传输模拟信号，数字信道只能传输数字信号。 调制解调器​ 数字/模拟信号 经过 调制 变成 模拟信号，如此可在 模拟信道 上传输，再经过 解调 变成 数字/模拟信号。 编码解码器​ 数字/模拟信号 经过 编码 变成 数字信号，如此可在 数字信道 上传输，再经过 解码 变成 数字/模拟信号。 调制（Modulation）：数字信号到模拟信号​ 从数字信号到模拟信号的调制主要有三种方法： 调幅（Amplitude Modulation，AM） 把数字信号转化成不同幅度的正弦信号。 调频（Frequency Modulation，FM） 把数字信号转化成不同频率的正弦信号。 调相（Phase Modulation，PM） 把数字信号转化成不同相位的正弦信号。 脉码调制（Pulse Code Modulation, PCM）​ 模拟信号变成数字信号。 脉码调制步骤： 采样（Sampling system） 采样频率是信号频率的两倍，则可不失真地恢复原始信号。 量化（Quantify） 取整采样信号。 编码（Coding） 量化后的信号编码成二进制。 数字信号编码（Digital signal coding）​ 数字信号到数字信号。 不归零编码（Non-Return-To-Zero, NRZ）​ 主要介绍两种不归零编码。 Non-Return-To-Zero Level (NRZ-L) Coding ​ 高电平表示“1”，低电平表示“0”。 NRZ-L的优点：简单好实现 NRZ-L的缺点： 难以分清二进制一位的开始和结束，所以必须要带同步时钟（外同步）来同步。可以把上图的虚线当作是同步时钟，当把虚线去掉是，相同电平的信号就不好判断开始和结束了。 在传输全“1”或全“0”信号时，此时传输的只有直流分量（傅立叶分不出正弦或余弦分量），这样线路上会有比较大的噪声。 反向不归零编码（NRZ-I） ​ 遇“1”反向。只能解决NRZ-L的部分问题（全“1”问题，不再是直流） 外同步（External synchronization） ​ 给系统一个同步时钟信号，设置一个周期的宽度。 ​ 外同步有诸多不便，于是有了自同步的曼切斯特编码。 曼切斯特编码（Manchester encoding）​ 每个编码由两段组成，“1”：先高后低；“0”：先低后高（可以反过来定义）。 曼切斯特编码的优点（解决了不归零编码的问题）： 自同步，不需要同步时钟； 直流分量为0。 曼切斯特编码的缺点： 基频增加：基频是不归零编码的两倍，从而比特率变成了不归零编码的一半； 二义性：组合情况有两种。 差分曼切斯特编码（Differential Manchester encoding）​ 解决曼切斯特编码的二义性。 “1”：自己的前半波与前一个编码的后半波相同； “0”：自己的前半波与前一个编码的后半波相反。 有两种画法，初始为高、初始为低，两种画法结果对称。 ​ 差分曼切斯特编码的优点： 解决NRZ问题 解决二义性问题 ​ 差分曼切斯特编码的缺点（同曼切斯特编码）： 基频翻倍 高频噪声增加 块编码（Block encoding） 将原信号每 m bits 分为一块； 把 m bits 的每块映射成 n bits 的块（m &lt; n）； 将 n bits 的块重新组合起来。 多路复用（Multiplexing）频分多路复用（Frequency division multiplexing，FDM）​ 见 频分多路复用 。 时分多路复用（Time division multiplexing，TDM）​ 见 时分多路复用 。 波分多路复用（Wavelength division multiplexing，WDM）​ 和FDM原理相同，但主要在光波中采用。 码分多路复用（Code division multiplexing，CDM）举例说明 ​ 每台设备都给一个不同向量的码片，比如手机A的码片为A，手机B的码片为B。不同设备的码片正交，即 \\begin{cases} A\\times B = 0\\\\ A\\times A = 1 \\end{cases}​ 要向手机A发送数据a，向手机B发送数据b，则在信道中发送 $a\\times A + b\\times B$。 ​ 在手机A接收数据时，将接收到的信号乘A。 (a\\times A + b\\times B) \\times A = a\\times A\\times A + b\\times B \\times A = a​ 同理手机B，如此两台设备同时利用一条信道传输，并成功分离各自的数据。 延时、丢包、吞吐量延时（delay）​ 现实中的计算机系统不是理想系统，事件是随机突发的，所以不可避免的存在延时。 ​ 数据包的延时由四个部分组成： d_{nodal} = d_{prop}+d_{queue}+d_{trans}+d_{prop} 处理时延（Nodal Processing Delay，$d_{proc}$） ​ 路由器接收到分组对其进行处理的时间（比如差错检测），耗时很短，毫秒级。 排队时延（Queuing Delay，$d_{queue}$） ​ 分组在链路上等待传输的时间，取决于先期到达的正在排队等待向链路传输的分组数量。 传输时延（Transmission Delay，$d_{trans}$） ​ 将分组的比特流传输到链路的时间（比如进行编码转换成查分曼切斯特编码的时间）。 ​ 如分组长度 L ，传输速率 R bps，则其传输时延为： d_{trans}=L/R​ 所以传输时间取决于分组长度和传输速率。 传播时延（Propagation Delay，$$） ​ 信号在媒体上传播的时间。 ​ 如物理链路的长度 d，传播速度 s m/sec，则其传播时延为： d_{prop}=d/s 丢包（Packet Loss）​ 流量强度（traffic intensity）代表了路由器上排队的拥堵率。 traffic\\ intensity = (L\\times a)/R​ 其中，L —— 分组长度（bits）； ​ R —— 链路带宽（bps）； ​ a —— 平均分组到达速率 流量强度接近0时，几乎没有分组到达，排队延时很小； 流量强度0～1时，平均排队长度越来越长，排队延时越来越长； 流量强度接近1时，存在到达率超过传输时间间隔，拥堵。 ​ 路由器的排队容量是有限的，当分组到达一个已满的队列时，路由器将丢弃该分组，产生丢包。 吞吐量（Throughput）​ 从主机A到主机B传文件，B接收文件的速率为瞬时吞吐量（instantaneous throughput），单位bps；所有时间的平均速率为平均吞吐量（average throughput）。 ​ 串联链路吞吐量取决于瓶颈链路（bottleneck link）。 Throughput = min\\{R_1, R_2,...,R_N\\} 应用层（Application Layer）网络应用原理 可以在不同类型主机运行； 可以在不同终端间相互通讯； 在编写网络应用的过程中，不需要考虑网络核心设备，网络核心不会允许应用； 端系统上的应用可以快速开发，而且易于传播。 网络应用结构客户机-服务器体系结构（Client-server architecture）​ 例如：HTTP、IMAP、FTP 服务器： 永远在线； IP地址恒定； 服务器往往在数据中心，通过多台服务器进行扩展。 客户机： 可以和服务器进行通信； 可能间断性连接网络； 可能是动态的IP地址； 客户机之间不会直接通信； 点对点体系结构（Peer-peer architecture） 没有一个一直在线的服务器； 任意端系统之间直接进行通信； 每个点（peer）向其他的点请求服务，同时作为回报也会提供相应的服务； 优点：自扩展性（self-scalability）：新的点都会提供服务容量和负荷。 缺点：每个点都是间断性连接，而且IP地址会改变。 例子：P2P的文件分享。 进程通信（Processes Communicating）客户机和服务器进程​ 进程（Processe）：一台主机上运行的程序。 在同一台主机上，两个进程通过进程间通信（inter-process communication）来进行通信。进程间通信由操作系统定义； 不同主机之间，进程通信同过报文交换， 比如并行计算中的MP和MPI，MP（Multi Processing）只能用于同一台主机间的通信，MPI（Message Processing Interface）主要用于不同主机之间的通信，也适用于同一台主机。 ​ 客户机进程（client process）：发起通信的进程。 ​ 服务器进程（server process）：等待连接的进程。 P2P应用也存在客户机进程和服务器进程。 套接字（Sockets）​ 进程之间通过socket来接收/发送消息。 socket在进程通信中的作用相当于一个信封： 通信的信息需要装进socket 应用层下的各层作为基础设施，将信传到另一个进程 两个进程间的通讯会有两个socket 进程寻址（Addressing Processes）​ 如果两个主机之间的进程进行通信，发送端不仅要知道接收端的IP地址还需要知道进程相应的端口号。 IP地址：IPv4中32位IP，负责找到接收端主机。 端口号（port number）：每台主机都可能运行着多个进程，每个进程对应一个端口号。 比如，HTTP服务端口号80、邮件服务端口号25 应用层协议（Application-Layer Protocols）​ 网络应用的开发必须遵守网络协议。 应用层协议的分类公开网络协议 定义在RFC中 统一标准，易于相互操作 例如：HTTP、SMTP 专用网络协议 一些非公开的网络协议 例如：Skype 应用层协议内容应用层协议定义了 消息交换的类型：比如请求、响应 消息的语法：消息中有哪些字段以及这些字段如何定义 消息的语义：消息字段内容的含义 规则：进程什么时候、如何发送/接收消息 app对传输服务的需求 数据完整性（data integrity） ​ 一些app需要100%可靠的文件传输，比如文件传输；有一些运行一部分的丢失，比如语音。 时效性（timing） ​ 一些app要求较少的延时，比如对话直播。 吞吐率（throughput） ​ 吞吐率，即最小带宽，一些app存在一个吞吐率下限才能正常使用，比如视频音频等多媒体；有些app运行弹性的吞吐率，比如邮件传输，吞吐率小可以慢慢传过去。 网络传输协议服务​ 传输层提供为应用层提供的两种传输服务。 TCP​ 传输控制协议（TCP） 面向连接（connection-oriented）：需要客户端和服务器之间能够建立连接 可靠传输（reliable transport）：数据完整性高 流量控制（flow control）：发送方不能发送太多数据导致接收方过载 阻塞控制（congestion control）：不能有太多个主机同时发送导致网络过载 不提供的服务：时效性、最小带宽（吞吐率）、安全性 UDP​ UDP是一种不提供不必要服务的轻量传输协议。优点是速度快、灵活性好。 不需要建立连接 不可靠的数据传输 不提供的服务：基本都不提供，不提供包括可靠传输、流量控制、阻塞控制、时效性、最小带宽（吞吐率）、安全性 不同app选择的网络传输协议 Web和HTTP​ World Wide Web 中的网页由超链接（hyperlink）连接。 页面由很多对象（object）组成，对象存储在服务器中； 对象有多种类型，可以是HTML文件，JPEG图片，动态脚本等等； 网页以HTML文件为基础，包括了许多参考对象，每个对象都可以通过URL来寻址。例如一张图片的URL为www.someshcool.edu/someDept/pic.gif，其中www.someshcool.edu为主机名，/someDept/pic.gif为路径名。 HTTP概述​ 超文本传输协议（hypertext transfer protocol, HTTP） 网页的应用层协议 基于客户机-服务器体系结构 客户机：负责请求、接收和显示Web对象 服务器：Web服务器负责发送对象，响应客户机请求 HTTP的传输层使用TCP 客户机发起TCP连接（创建socket，端口号80） 服务器接收TCP连接 在浏览器和网页服务器之间进行HTTP信息的交换 TCP连接可以断开 HTTP是无状态的​ &emsp;&emsp;服务器不会保留之前客户机发的请求信息。​ &emsp;&emsp;协议要维持状态是很复杂的：保留之前的历史记录很消耗资源；如果客户机或着服务器有死机，它们的状态会不一致，还需要重新同步，这很麻烦。 HTTP消息类型：请求（request）与响应（response） HTTP连接类型非持久性连接（Non-persistent HTTP）非持久性HTTP步骤 TCP连接开启 通过这个TCP连接最多传输一个对象 TCP连接关闭 如果要加载多个对象时，需要多次非持久性HTTP连接。 非持久性HTTP响应时间 RTT：往返时间（Round Trip Time）,一个很小的数据包（处理文件的时间可忽略）从客户机传到服务器再传回来的时间。 HTTP响应时间（一个对象）： 1个RTT：建立TCP连接的时间 1个RTT：HTTP请求以及收到HTTP响应的前几个字符的时间 对象/文件传输的时间 对一个对象来说，非持久性HTTP响应时间为 Nonpersistent\\ HTTP\\ response\\ time = 2RTT + file\\ transmission\\ time 例题：如果一个网页包含1个HTML和10个对象，则非持久性HTTP响应需要多少时间？ 2RTT \\times (1+10) + total\\ file\\ transmission\\ time 非持久性HTTP的问题 每传输一个对象都需要耗费 $2RTT$ 每建立一个TCP连接都会对操作系统（OS）产生负荷 并行抓取：浏览器常常开多个并行的TCP连接去抓取对象 例题：一个网页包含1个HTML和10张图片，共有5个并行的TCP连接，则非持久性HTTP响应需要多少个RTT？ &emsp;&emsp;首先传输HTML需要 $2RTT$ 的时间，5个并行的TCP连接传输10个对象需要2个 $2RTT$ 的时间。 RTT\\ in\\ Response\\ Time = 2RTT + 2 \\times 2RTT = 6RTT 持久性连接（Persistent HTTP）持久性HTTP步骤 开启TCP连接 通过这一个TCP连接可以传多个对象 TCP连接关闭 持久性HTTP特点（HTTP1.1） 服务器在发送响应后保持连接开启状态 后续这个客户机\\服务器的HTTP消息都通过该开启的连接发送 两种发送对象方式：HTTP1.1采用流水的方式发送：一次性把对象全发了；另一种是客户机接收到一个对象后接着发下一个对象的请求 至少需要1个RTT发完所有对象 DNS​ &emsp;&emsp;域名系统（Domain Name System，DNS）通过分布式的数据库来实现IP地址和域名的映射。 层级结构的域名服务器提供分布式的数据库 应用层协议：主机和域名服务器通过通信来实现IP地址和域名的转换 DNS作为一个网络核心功能，为什么要放在应用层？&emsp;&emsp;与网络结构设计理念有关，网络中主机很多映射很复杂，希望将复杂度留在端系统中，而不是在网络核心。 DNS服务 IP地址和域名的转换 主机的别名 邮件服务的别名 负荷分配：有些Web可能有多个服务器，即会有多个IP地址对应一个域名，可调整IP地址的顺序以分配负荷。 DNS：分布式、层级的数据库 为什么要选用分布的DNS，而不采用集中式的DNS？单点可能失效：一个故障就gg了流量问题：所有客户机都访问一个域名服务器，会产生很大的流量远程的集中式数据库：客户机要访问可能要花费很多时间，RTT会很大，造成大时延 &emsp;&emsp;DNS采用三层结构 一个客户机得到www.amazon.com的IP地址的步骤： 客户机先查询根域名服务器，得到顶级域名服务器.com DNS server的地址； 客户机查询顶级域名服务器.com DNS server，得到权威域名服务器amazon.com DNS server的地址； 客户机查询权威域名服务器amazon.com DNS server，得到www.amazon.com的IP地址 根域名服务器（Root Name Server） 官方的服务器，是连接的最后的方法（如果知道下级域名服务器的地址就不需要再从头开始查询根域名服务器，不然会对根域名服务器产生很大的流量负荷） 对网络运行相当重要，离开根域名服务器网络无法正常工作 域名系统安全扩展（Domain Name System Security Extensions，DNSSEC） —— 对DNS提供给DNS客户端（解析器）的DNS数据来源进行认证，并验证不存在性和校验数据完整性验证。 ICANN（互联网名称与数字地址分配机构，Internet Corporation for Assigned Names and Numbers）—— 管理根域名服务器的组织 世界上现在有13个根域名服务器，分布在世界各地。 顶层域名服务器（Top-Level Domain Server, TLD） 各种类型的TLD，比如.com、.org、net、.edu等等，国家的TLD，比如.cn、.uk等等。 Network Solutions：管理.com、netTLD的组织 Educause：管理.edu的组织 权威域名服务器（Authoritative Domain Server） 组织自己的DNS服务器，用来提供组织内部的域名到IP地址的映射 由组织自己或者服务提供商来维护 本地域名服务器（Local DNS Name Server） 严格来说不属于层级结构 每个ISP都会有一个本地域名服务器，也叫做默认域名服务器（default name server） 当主机要进行DNS查询时，查询会被直接送到本地的DNS服务器。 作用： 缓存：可以缓存最近收到的域名到IP地址的映射（缓存有时效，会过期） 代理：可以作为代理，代替主机在层级结构中进行查询 DNS查询方法迭代查询（iterated query）&emsp;&emsp;被联系到的服务器会将后一个服务器的名字反馈回来，即“我不认识这个域名，但是你可以去问那台服务器(=ﾟωﾟ)ﾉ” &emsp;&emsp;下面的迭代查询过程，利用本地域名服务器作为代理迭代查询域名对于的IP地址。 递归查询（recursive query）&emsp;&emsp;把域名解析的负担交给了联系到的域名服务器，这种方法对于高级的负担增加，所以一般采用迭代查询而不采用递归查询。 DNS缓存和更新 一旦域名服务器学习到了一个映射，它就会缓存这个映射。缓存往往在本地域名服务器里，这样可以减轻根域名服务器的压力。 缓存有效时间TTL，过了有效时间该缓存就会被删除。 更新/通知机制：由IETF制定的 RFC2136 标准。&emsp;&emsp;如果中途域名主机改变IP地址，整个网络可能都不知道真正的IP地址，直到TTL到时，所以需要更新/通知机制。 DNS记录和消息DNS记录&emsp;&emsp;DNS的分布式数据库里存储了资源记录（resource record, RR） RR的格式：(name, value, type, ttl) type = A name：主机名 value：对应的IP地址 type = NS name：域（如foo.com） value：对应的权威域名服务器的主机名 type = CNAME name：别名 value：对应的规范主机名 比如 www.ibm.com 是 servereast.backup2.ibm.com 的别名，这与负荷的分配有关，可能有多个服务器。 type = MX name：邮件服务器别名 value：对应的规范主机名 DNS消息&emsp;&emsp;DNS有两种消息类型：查询（query）和回答（reply），两种消息格式相同。 向DNS数据库插入记录比如要创建一个networkutopia.com的网站 先在.com的TLD提供商 Network Solution 注册 networkutopia.com 提供信息：域名、权威域名服务器的IP地址 提供商会向.comTLD服务器插入 NS、A 的RR(networkutopia.com, dns1.networkutopia.com, NS)(dns1.networkutopia.com, 212.212.212.1, A) 在自己的权威域名服务器上进行配置 插入www.networkutopia.com的type A记录 如果是邮件服务，插入networkutopia.com的type MX记录 DNS查询工具&emsp;&emsp;在命令行用nslookup进行DNS查询。 nslookup直接查询&emsp;&emsp;查询一个域名的A记录，如果没指定dns-server，用系统默认的dns服务器。 1nslookup domain [dns-server] nslookup查询其他记录 1nslookup -qt&#x3D;type domain [dns-server] type可以是以下这些类型： type 类型 A 地址记录 AAAA 地址记录 AFSDB Andrew文件系统数据库服务器记录 ATMA ATM地址记录 CNAME 别名记录 HINFO 硬件配置记录，包括CPU、操作系统信息 ISDN 域名对应的ISDN号码 MB 存放指定邮箱的服务器 MG 邮件组记录 MINFO 邮件组和邮箱的信息记录 MR 改名的邮箱记录 MX 邮件服务器记录 NS 名字服务器记录 PTR 反向记录 RP 负责人记录 RT 路由穿透记录 SRV TCP服务器信息记录 TXT 域名对应的文本信息 X25 域名对应的X.25地址记录 P2P&emsp;&emsp;点对点体系结构（Peer-peer architecture） P2P概述 没有一个一直在线的服务器； 任意端系统之间直接进行通信； 每个点（peer）向其他的点请求服务，同时作为回报也会提供相应的服务； 优点：自扩展性（self-scalability）：新的点都会提供服务容量和负荷。 缺点：每个点都是间断性连接，而且IP地址会改变。 例子：P2P的文件分享。 文件分发：客户机-服务器结构 vs P2P&emsp;&emsp;从一个服务器分发大小为F的文件到N个节点需要多少时间？（每个节点上传和下载的速率都是有限的，网络中有足够的带宽） 如果选用客户机-服务器结构 服务器上传：需要上传这份文件 $N$ 次，上传速度为 $u_s$，则需要的上传时间为 $NF/u_s$ 客户机下载：每个客户机都需要下载文件，$d_{min}$ 是客户机最小下载速度，则客户机下载的最大时间为 $F/d{min}$ &emsp;&emsp;客户机-服务器结构的分发时间 D_{c\\_s} \\geq max\\{NF/u_s, F/d_{min}\\}&emsp;&emsp;此处的N导致耗费的时间随要下载的节点的数量线性增长，当要下载的节点数目大时，要耗费相当多的时间。 &emsp;&emsp;不需要先上传完再下载，参考第一章/网络核心/分组交换，以分组为单位发送，可以忽略上传到下载的时间。 如果选用P2P结构 服务器上传：服务器至少要上传1次文件，上传时间为 $F/u_s$ 客户机下载：每个客户机都要下载文件，客户机最大下载时间为$F/d_{min}$ 客户机上传：每个下载了文件的客户机都可以上传文件，此时总上传速率可以达到$u_s+\\sum\\limits^{n} u_i$ &emsp;&emsp;P2P结构的分发时间 D_{P2P} \\geq max\\{F/u_s, F/d_{min}, NF/(u_s+\\sum\\limits^{n} u_i)\\} 客户机-服务器结构和P2P分发时间对比 BitTorrent 文件分为大小为 256Kb的块（chunk） 每个节点负责上传和下载的文件块 追踪器（tracker）：追踪参加洪流的节点 洪流（torrent）：有一组节点相互交换文件块 新的节点想下载文件，先询问追踪器参加的节点，再从相近的节点处下载文件块 节点加入洪流： 本身没有文件块，但是随着时间的推移会从其他节点获取文件块 需要在追踪器进行登记，并且一般连接临近的节点 下载时，节点会上传文件块到其他节点 节点可以更改交换文件块的节点 节点随时会上线和下线 一旦节点有了完整的文件，它可以离开或者留在洪流中 请求文件块 在给定的时间，不同的节点拥有不同的文件块 一定周期，新的节点会问每个节点有哪些块 新节点会从其他节点处下载缺失的文件块最稀缺优先（rarest first）：如果有10个节点都有第1、2块，只有一个节点有第3块，则先下载第3块。 发送文件块 &emsp;&emsp;发送文件块遵守一报还一报原则（tit-for-tat） 节点会给目前给它发送文件块速率最高的四个节点发送文件块，其他节点就不发送了，每隔 10s 会选出新的top4 每隔 30s 会随机选择其他节点发送文件块，这样这个随机节点可能就会成为新的top4 tit-for-tat原则：上传速率快的节点相应地得到高下载速率的回报。 socket编程 &emsp;&emsp;目标：建立客户机/服务器的应用中的通信运用socket &emsp;&emsp;socket：相当于应用进程和点对点传输协议之间的一扇门 &emsp;&emsp;socket类型：对应TCP和UDP有两种socket UDP中的socket编程 UDP：客户机与服务器之间没有连接 发送数据前不需要握手 发送数据包附加IP地址+端口号 接收方从数据包中提取处IP地址+端口号 &emsp;&emsp;UDP提供的是一种不可靠的数据流传输，传输过程中可能会丢包，接收的时候顺序也可能被打乱。 UDP中的socket编程示例&emsp;&emsp;这里jupyter notebook中进行编程，安装好jupyter notebook后，在命令行执行 1jupyter notebook 即可启动jupyter notebook UDP服务器代码 UDPServer.ipynb123456789101112from socket import * #引入socket库serverPort = 12000 #服务器端口号serverSocket = socket(AF_INET, SOCK_DGRAM) #创建服务器套接字serverSocket.bind(('', serverPort)) #给套接字绑定端口号print('The server is ready to receive.')while True: #服务器要一直在线等待，所以给一个死循环 message, clientAddress = serverSocket.recvfrom(2048) #从服务器套接字中读取信息（发送的消息和客户机IP地址+端口号） modifiedMessage = message.decode().upper() #对消息进行处理（此处是改大写） serverSocket.sendto(modifiedMessage.encode(), clientAddress) #将处理后的消息发回给客户机 UDP客户机代码 UDPClient.ipynb12345678910111213from socket import * #引入socket库serverName = gethostname() #由于没得服务器，服务器主机用本机来当serverPort = 12000 #服务器端口号clientSocket = socket(AF_INET, SOCK_DGRAM) #创建客户机套接字message = input('Input lowercase sentence:') #得到输入字符串clientSocket.sendto(message.encode(),(serverName, serverPort)) #发送数据到相应主机名+端口号的服务器进程modifiedMessage, serverAddress = clientSocket.recvfrom(2048) #接收服务器发回的消息print(modifiedMessage.decode()) #显示接收的字符串clientSocket.close() #关闭客户机socket &emsp;&emsp;先运行UDPServer.ipynb，启动服务器运行。 &emsp;&emsp;先运行UDPClient.ipynb，进行客户机访问。 TCP中的socket编程 服务器的先行准备 服务器必须先运行 服务器需要创建socket来连接客户机 客户机连接服务器 客户机需要创建自己的socket，明确服务器进程的IP地址和端口号 客户机创建socket时，客户机和服务器之间需建立TCP连接 服务器接收客户机消息 服务器需创建一个新的socket，为了服务器进程能够和客户机进行通信 要运行服务器与多个客户机进行通信 用源的端口号来区分不同的客户机 &emsp;&emsp;TCP提供的是一种可靠的字节流（byte-stream）传输（pipe）。 TCP中的socket编程示例 TCP服务器代码 TCPServer.ipynb1234567891011121314151617from socket import * #引入socket库serverPort = 12000 #服务器端口号serverSocket = socket(AF_INET, SOCK_STREAM) #创建服务器套接字（前台）serverSocket.bind(('', serverPort)) #给套接字绑定端口号serverSocket.listen(1)print('The server is ready to receive.')while True: #服务器要一直在线等待，所以给一个死循环 connectionSocket, addr = serverSocket.accept() #前台套接字接收到请求后，创建一个新的套接字（窗口） sentence = connectionSocket.recv(1024).decode() #窗口套接字读取信息 capitalizedSentence = sentence.upper() #对消息进行处理（此处是改大写） connectionSocket.send(capitalizedSentence.encode()) #将处理后的信息发回给客户机 connectionSocket.close() #关闭窗口套接字，前台套接字保持开放 TCP客户机代码 TCPClient.ipynb1234567891011121314from socket import * #引入socket库serverName = gethostname() #由于没得服务器，服务器主机用本机来当serverPort = 12000 #服务器端口号clientSocket = socket(AF_INET, SOCK_STREAM) #创建客户机套接字(类型为字节流SOCK_STREAM)clientSocket.connect((serverName, serverPort)) #TCP连接sentence = input('Input lowercase sentence:') #得到输入字符串clientSocket.send(sentence.encode()) #发送数据到服务器modifiedSentence = clientSocket.recv(1024) #接收服务器发回的消息print('From server:', modifiedSentence.decode()) #显示接收的字符串clientSocket.close() #关闭客户机socket &emsp;&emsp;先运行TCPServer.ipynb，启动服务器运行。 &emsp;&emsp;先运行TCPClient.ipynb，进行客户机访问。 传输层（Transport Layer）传输层服务传输层概述 为不同主机之间的应用进程提供通信的桥梁 端对端：传输层协议在端系统间运行，不需要涉及网络核心 发送方把应用层接到的消息分成段（segment），再把这些段传输给网络层 接收方把接收到的段重新拼装成消息，传输给应用层 传输层的协议：TCP和UDP 传输层和网络层对比 网络层：主机之间的通信 传输层：进程之间的通信 传输层依赖于并能强化网络层服务。 传输层协议 TCP：可靠的，有序的传送 拥塞控制 流量控制 需要建立连接 UDP：不可靠的，无序的传送 提供尽力而为交付服务 二者均不提供的服务：延时保障、带宽保障 多路复用（Multiplexing）与多路分用（Demultiplexing） &emsp;&emsp;多路复用存在于发送方：发送方需要处理多个套接字，并且给套接字加上传输层的头部。 &emsp;&emsp;多路分用存在于接收方：利用头部信息，将接收到的报文段传输给正确的套接字。 多路分用多路分用工作流程 主机收到IP数据报（IP datagram） 每个数据报有源IP地址和目的IP地址 每个数据报携带一个传输层报文段（segment） 每个报文段有源和目的的端口号 主机利用IP地址和端口号来把报文段传入正确的套接字 无连接的多路分用（Connectionless demultiplexing） &emsp;&emsp;参考UDP的socket工作方式，如果数据报的目的IP地址和端口号相同，它们将被传到同一个socket当中。（即使数据报的源可能不同） 面向连接的多路分用（Connection-oriented demux） &emsp;&emsp;参考TCP的socket工作方式 标记TCP的socket需要4元组：源IP地址、源端口号、目的IP地址、目的端口号 多路分用：接收方要用到上面4个值来传入不同的socket 服务器的主机可能要同时支持多个TCP连接 web服务器有不同的socket对应每个连接的客户机，其中非持久性HTTP会给每个请求都建立新的socket。 UDPUDP概述 &emsp;&emsp;UDP（User Datagram Protocol，用户数据报协议），标准为RFC 768。 只有基本的功能 尽力而为的服务，UDP可能会丢包或者失序 不用连接：客户机和服务器不需要握手，每个UDP段都是独立处理的 UDP的优点 不需要进行连接，连接可能会造成时延 简单：不需要考虑连接的状态 相对小的头的大小 不需要拥塞控制，可以尽快地把UDP段发出去 UDP的应用 流媒体的app（运行一部分数据的丢失，但是对速度很敏感） DNS SNMP 通过UDP进行可靠的传输（UDP本身是不可靠的） 在应用层增加可靠性 app要有对应的错误恢复方法 UDP校验和（UDP checksum） &emsp;&emsp;位于UDP头部，负责检测传输的段有没有发生“错误”（比如位的翻转） 发送方： 把发送的段的内容包括头部分，当作一组16-bit的整数 校验和：报文段中的所有16-bit的和的取关于“1”的补码 发送方要将校验和放到UDP的校验和部分 接收方： 计算接收到的报文段的校验和 将接收方的校验和与发送方的校验和进行比较，不同则检测出错误，相同则没检测出错误 &emsp;&emsp;校验和相同只能说是“检验不出错误”，不能保障没有错误。比如传输中多个16bit字发生错误，但是可能恰巧相加校验和不变。 例题：有两个16-bit的字，1110011001100110 和 1101010101010101，求校验和。\\begin{split} &1110011001100110\\\\\\\\ +\\ &1101010101010101\\\\\\\\ ———————&—————————\\\\\\\\ wrap\\ around\\quad1&1011101110111011\\quad\\\\\\\\ sum\\quad&1011101110111100\\\\\\\\ checksum\\quad&0100010001000011 \\end{split} &emsp;&emsp;wraparound存在溢出，进位的部分回卷，加到最后一位。 可靠数据传输原理 &emsp;&emsp;可靠数据传输原理（Principles of reliable data transfer, rdt） 对应用层、传输层、链路层都很重要 &emsp;&emsp; 不可靠信道的特点决定了不可靠传输协议的复杂度 调用接口函数： 接口函数 参数 作用 rdt_send() data 调用数据传输协议的发送方，将要发送的数据交付给位于接收方的较高层 udt_send() packet rdt调用，通过不可靠信道，将packet传输到接收方 rdt_rcv() packet 在packet到达接收方信道时调用 deliver_data() data rdt调用，传输数据到高层 与不可靠信道之间的函数调用都是双向的，由于其不可靠性，需要进行确认的控制信号（ACK，NAK）。 rdt1.0：经可靠信道的可靠数据传输rdt1.0概述 下层信道完全可靠：rdt1.0中假设下层的信道是一个完全可靠的信道（理想情况） 没有bit的错误 没有分组（packet）丢失 发送方和接收方的有限状态机（FSM）（存在状态和操作） 发送方发送数据给下层信道 接收方接收下层信道传来的数据 rdt1.0有限状态机发送方&emsp;&emsp;发送方首先在“等待上级调用”的状态，rdt_send(data)上级调用rdt，从上级接收到data，make_pkt(data)将data装到packet里，再用udt_send(packet)将packet发送出去，完成后发送方再回到“等待上级调用”的状态。（发送方只有一个状态） 接收方&emsp;&emsp;接收方首先在“等待下级调用”的状态，rdt_rcv(packet)下级调用rdt，从下级接收到packet，用extract(packet, data)将packet重新恢复成data，提取出来的data再通过deliver_data(data)传送给上级。完成后接收方再回到“等待下级调用”的状态。 下层信道不可能完全可靠 =&gt; 引入rdt2.0 rdt2.0：经具有比特差错信道的数据传输&emsp;&emsp;引入差错检测、控制信号和重传机制，解决下层信道不可靠问题。 rdt2.0概述 packet在下层信道传输中会出现比特翻转：可以引入校验和（checksum）来检测比特错误。 错误恢复——如果检验到错误如何恢复？ ACKs（acknowledgements）：接收方告诉发送方收到的pkt是正确的 NAKs（negative acknowledgements）：接收方告诉发送方收到的pkt是错误的 发送方收到NAK则重传那个pkt rdt2.0引入的新机制 差错检测：checksum 接收方反馈：控制信号（control msg），即ACK和NAK 重传 rdt2.0无限状态机发送方&emsp;&emsp;rdt2.0的发送方有2个状态——等待上级调用、等待ACK或NAK。发送方最初处于“等待上级调用”的状态，rdt_send(data)上级调用rdt，从上级接收到data，sndpkt = make_pkt(data, checksum)将data装到packet里，再用udt_send(sndpkt)将packet发送出去。此时，发送方变为“等待ACK或NAK”的状态。rdt_rcv(rcvpkt)接收反馈，如果isNAK(rcvpkt)即接收到NAK，则重传udt_send(sndpkt)，并保持“等待ACK或NAK”的状态；如果isACK(rcvpkt)即接收到ACK，则回到“等待上级调用”的状态。 停等机制（stop and wait）&emsp;&emsp;发送方发送一个packet，然后等待接收方的响应。 接收方&emsp;&emsp;接收方还是只有一个状态——等待下级调用。接收方首先在“等待下级调用”的状态，rdt_rcv(rcvpkt)接收方接收packet，如果corrupt(rcvpkt)，即检测到错误，则udt_send(NAK)反馈NAK；如果notcorrupt(rcvpkt)，即未检测到错误，则extract(packet, data)将packet重新恢复成data，deliver_data(data)将data传送给上级，最后udt_send(ACK)反馈ACK。完成后接收方再回到“等待下级调用”的状态。 接收方可能判断ACK/NAK信号出错，导致发送分组重复 =&gt; 引入rdt2.1 rdt2.1：接收方判断ACK/NAK信号出错&emsp;&emsp;引入0/1序号和丢弃分组，解决接收方判断ACK/NAK信号出错，导致发送分组重复问题。但这也让发送方和接收方有限状态机的状态翻倍。 rdt2.1有限状态机发送方&emsp;&emsp;相较于rdt2.0，rdt2.1在发送的packet里包含了0/1序号（sequence number），所以发送方有4种状态——等待上级调用 0、等待ACK或NAK 0、等待上级调用 1、等待ACK或NAK 1。 接收方&emsp;&emsp;接收方有2种状态——等待下级调用 0、等待下级调用 1。只有在数据包ACK且收到的packet序号与目前状态等待的序号相同时，才能向上传输。 为什么接收方等待1状态接收到0的packet时，为什么要反馈ACK？&emsp;&emsp;为了让发送方的状态转移，从“等待ACK或NAK 0”到“等待上级调用 1”。 rdt2.2：不发送NAK的协议&emsp;&emsp;用重复的ACK替代NAK，解决信号冗余问题。 rdt2.2概述 只用ACK，不用NAK，实现和rdt2.1一样的功能。 在检测到错误时，不发送NAK，但是接收方要发送判断上一次序号的ACK（同时包括序号） 用重复的ACK代替NAK rdt2.2有限状态机发送方&emsp;&emsp;将rdt2.1中的isNAK(rcvpkt)判断本次反馈是NAK，替代成判断上次序号的反馈是ACK，比如rdt2.2在“等待ACK 0”时，如果isACK(rcvpkt, 1)，则相当于收到来rdt2.1中的isNAK(rcvpkt)。其余不变。 接收方&emsp;&emsp;接收方如果校验和检测出错，则发送上一次序号的ACK；在校验和检测正确时，发送ACK也需要带上本次的序号。 rdt3.0：信道存在错误和丢包rdt3.0概述&emsp;&emsp;发送端在一个合理的时间内，等待接收ACK。 当在等待时间内没有接收ACK时，重传 超过时间可能有两种情况：丢包或时延，如果发生时延可能会重复发生pkt，此时rdt2.1和2.2中的序号可以解决问题，同样的发生ACK得带上序号。 需要计时器 rdt3.0有限状态机&emsp;&emsp;发送方传输开始时，start_timer启动计时器。如果timeout传输超时，则重新启动计时器；如果在规定时间内接收到反馈，则stop_timer结束计时。 rdt3.0流程正常流程 丢packet 丢ACK 超时 rdt3.0性能&emsp;&emsp;rdt3.0性能很差 例题：一个 1Gbps的链路，15ms的传播时延，传输8000bit的packet，求发送方的使用效率。传输时延D_{tran} = \\frac LR = \\frac{8000\\ bits}{10^9\\ bits/sec} = 8 ms发送方使用效率U_{sender} = \\frac{L/R}{RTT+L/R} = \\frac{0.008}{30.008} = 0.00027&emsp;&emsp;可见rdt3.0的使用效率很低。 &emsp;&emsp;rdt3.0网络协议限制了物理资源的使用率。 流水线协议&emsp;&emsp;采用流水线的机制，不要等一个RTT发送回来再发下一个（即不再采用停等机制），来提高物理资源的使用率。 图 停等机制（Stop-and-wait） 图 流水线机制（Pipelined Operation） 回退N步（Go-back-N，GBN） 发送方可以有至多N个没有ACK的packet同时在流水线上 接收方只发送累计ACK 发送方给最早还没ACK的packet一个计时器，当这个计时器到时时，重传所有的未ACK的packet。 GBN发送方 packet头部有k bit的序号，则可以表示 $2^k$ 个序号。 “窗口”大小为N，这一段是允许的未ACK的packet ACK(n)累计确认：ACK在发送的时候要带上序号#n，即#n及之前的packet都收到了。接收方发送ACK n，则证明#n及之前的packet都收到了。否则接收方还是发送之前的ACK（重复）。 计时器只给最早的未ACK的packet保留 如果timeout（n），重传#n以及比#n更大的未ACK的packet GBN接收方 发送的ACK是顺序接收到的packet里面最大的序列号# 可能会产生重复的ACK 只需要记住期望的序列号（expextedseqnum） 乱序到达的packet 直接丢弃，不缓存（缓存会造成数据重复） 重新发送顺序最大序列号# GBN流程 例题：采用GBN协议，一个发送方发送了 #0到#5 的packet，但是只收到了 ACK0 和 ACK2。问发送方要重发哪些packet？&emsp;&emsp;重发#3、#4、#5 的 packet。&emsp;&emsp;虽然没有收到ACK1，但是接收方只有在#n及之前的packet都收到了的时候，才会发送ACKn，发送方接收到ACK n，则证明接收方#n及之前的packet都收到了。所以ACK1应该是在发送过程中丢包了，但是实际接收方已经收到了#1 packet。所以重发#3、#4、#5 的 packet。 选择重传（Selective Repeat，SR） 接收方分别确认所有正确收到的pkt 缓存pkt，最终有序传给上层 发送方重发没ACK的pkt 发送方给每个还没ACK的packet都维持一个计时器 发送方的window N个连续的序号 限制发送并且未ACK的pkt SR发送方 收到上层数据 如果window里还有可用序列，则继续发送 timeout(n) 重发pkt n，重启timer 如果ACK(n)在可接收范围内$[sendbase, sendbase+N-1]$ 将pkt n标记为接收完成 如果 n 是最小的未ACK的pkt，则将window滑动到下一个未ACK的pkt SR接收方 如果pkt n在接收范围内$[rcvbase, rcvbase+N-1]$ 发送ACK(n) 如果不是按序到达，则缓存pkt 如果是按序到达，则向上交付已有的按序的缓存，并将window滑动到下一个未收到的pkt 如果pkt n在$[rcvbase-N, rcvbase-1]$内 发送ACK(n) 其他情况忽略 SR流程 SR困境&emsp;&emsp;比如下面序列号有：#0, #1, #2, #3，window大小为3的情况。SR会无法分清a、b两种情况，导致在b中误判重发的第一轮的pkt0，被当作后一轮的pkt0填入。 TCPTCP概论 点对点（point-to-point）：一个发送方、一个接收方 可靠的、有序的字节流 没有消息的边界 流水线机制 窗口大小由拥塞和流量控制 全双工 同时双向数据流 MSS（maximum segment size）：最大报文段长度 面向连接 握手：交换控制信息，初始化发送方和接收方的状态 流量控制 TCP报文段结构 1、端口号：用来标识同一台计算机的不同的应用进程。 源端口：源端口和IP地址的作用是标识报文的返回地址。 目的端口：端口指明接收方计算机上的应用程序接口。 &emsp;&emsp;TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。 2、序号和确认号：是TCP可靠传输的关键部分。序号是本报文段发送的数据组的第一个字节的序号。在TCP传送的流中，每一个字节一个序号。e.g.一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为400。所以序号确保了TCP传输的有序性。确认号，即ACK，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。 3、数据偏移／首部长度：4bits。由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32/8 = 60，故报头最大长度为60字节。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。 4、保留：为将来定义新的用途保留，现在一般置0。 5、控制位：URG ACK PSH RST SYN FIN，共6个，每一个标志位表示一个控制功能。 URG：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。 ACK：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。 PSH：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。 RST：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。 SYN：同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。 FIN：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。 6、窗口：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。 7、校验和：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。 8、紧急指针：只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。 9、选项和填充：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。 10、数据部分： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。 TCP序号&emsp;&emsp;报文段（segment）的序号：字节流第一个字节的序号 例题：下面文件的前3个报文段的序号分别是？&emsp;&emsp;第一个报文段：0；第二个报文段：1000；第三个报文段：2000 TCP ACK TCP报文的ACK填写：期望从另一方收到的下一个字节序号 主机A接收到从主机B传来的字节#0～535，A下一个期望接到的字节#为536，所以主机A发送的报文段的ACK中填536。 累计ACK（cumulative ACK）:与GBN相似 主机A接收到从主机B传来的字节 #0～535 和 #900～1000，A下一个期望接到的字节#依旧为536，所以主机A下一个发送的报文段的ACK中填536。 TCP 序号和ACK传输 TCP计时如何设置TCP timeout值？ $time &gt; RTT$（但是RTT会改变） 不能太短：过早timeout造成不必要的重传 不能太长：对丢包反应太慢 如何EstimateRTT（估计RTT）？ SampleRTT（样本RTT）：计算发送segment到接收ACK的时间，忽略重传 SampleRTT多次测量取平均 则EstimateRTT为 EstimateRTT = (1-\\alpha )*EstimateRTT + \\alpha *SamleRTT 指数加权移动平均（不是线形的，存在迭代使原来的SamleRTT的系数越来越小，越靠后的越接近当前网络状态） EstimateRTT的变化通常比SamleRTT变化更加平滑 一般，$\\alpha = 0.125$ DevRTT（偏差RTT）为（一般$\\beta = 0.25$） DevRTT = (1-\\beta )*DevRTT + \\beta *|SampleRTT-EstimatedRTT|重传超时间隙（TimeoutInterval） TimeoutInterval = EstimatedRTT + 4*DevRTTTCP可靠数据传输 TCP的rdt服务是建立在IP的不可靠传输上的 流水机制 累计ACK 一个timer 重传触发情况 超时 重复的ACK TCP简化&emsp;&emsp;TCP简化版：无重复ACK、拥塞控制和流量控制。 TCP senderTCP sender 的3种事件 从上一层收到数据 分段，创建seq#（报文中字节流第一个字节的序号） 开始timer 只给最早一个未ACK的segment timer 用 TimeoutInterval 作为timeout时间 超时 重传segment 重启timer 收到ACK 如果收到未ACK的segment的ACK 更新被ACK的segment标记 从最近的一个未ACK的segment开新的timer 图 TCP sender简化版 TCP重传情况图 ACK丢包 图 提前timeout 图 累计ACK TCP receiver 事件 TCP接收方反应 具有所期望序号的按序报文段到达。所有在期望序号及以前的数据都已经被确认 延迟的ACK，对另一个按序报文段的到达最多等待500ms。如果下一个按序报文段在这个时间间隔内没有到达，则发送一个ACK 具有所期望序号的按序报文段到达。另一个按序报文段等待ACK传输 立即发送单个累计ACK，以确认两个按序报文段 比期望序号大的失序报文段到达。检测出间隔 立即发送冗余ACK，指示下一个期待字节的序号（其为间隔的低端的序号） 能部分或完全填充接收数据间隔的报文段到达 倘若该报文段起始于间隔的低端，则立即发送ACK TCP快速重传 timeout时间长，造成长时延 通过重复的ACK检测丢包 发送方会发送很多个segment 如果有segment丢失，则可能会收到很多个重复的ACK TCP快速重传机制： &emsp;&emsp;如果发送方收到对同一数据收到3个重复的ACK（实际收到4次该ACK），则认为此时未ACK的segment丢失，不需再等待timeout，重发未ACK的最小seq# 流量控制&emsp;&emsp;接收方要控制发送方，使发送方不会发送得太快导致接收方的缓存（buffer）溢出。 接收方告诉发送方free buffer大小，包含在TCP报文的rwnd（receive window中） RcvBuffer socket设定大小（一般，4096） 一些操作系统也可以自动调节RcvBuffer 图 接收方缓存 sender通过rwnd来限制unacked segment的数量 保障receive的buffer不会溢出 &emsp;&emsp;如果sender接收到$rwnd=0$，此时没有剩余buffer，再发送数据会造成receiver buffer溢出，但是有要防止锁住。&emsp;&emsp;所以sender向receiver发送一个1 byte data的报文，以更新rwnd。 连接管理TCP建立连接：3次握手建立连接之前，先握手 双方同意建立连接 同意连接的参数 &emsp;&emsp;为什么两次握手行不通？各种delay消息丢失导致重传消息乱序 图 TCP3次握手&emsp;&emsp; TCP关闭连接：4次挥手 client、server两边都可关闭连接 发送TCP segment的 FIN bit = 1 用ACK回应FIN（ACK可以和FIN一起发） 同时收到FIN也可以处理（双工） 图 TCP关闭连接 图 TCP双方状态循环 拥塞控制原理拥塞： 非正式定义：太多的源发送数据太多太快，导致网络无法处理 和流量控制不同（流量控制c-s一对一） 产生丢包、延时 网络前十的问题 场景一：2个Sender, 和1个无限buffer的Router 2个sender，2个receiver 1个router带无限buffer 输出链路的容量：R 没有重传（无限buffer不会丢包） 图 输入速率-输出速率 图 输入速率-时延 场景二：2个Sender, 和1个有限buffer的Router 一个router、有限buffer 重传timeout的packet $\\lambda _{in}$ —— 源数据 $\\lambda _{in}’$ —— 源数据+重传 \\lambda _{in}' \\geq \\lambda _{in} 正常理想情况下，\\lambda _{in}' \\geq \\lambda _{in} = \\lambda _{out} 情况一（理想）：sender只在router的buffer有空时才发送 情况二：知道丢包，当router的buffer满了，packet丢失。sender只有在知道丢包时才重传。 情况三：重复packet 在router的buffer满时，packet可以丢包 提前timeout，会导致发送两个相同的packet 拥塞代价 排队延时 丢包导致重传 提前timeout导致非必要的重传，pkt重复，降低吞吐量 当一个packet被丢弃，其上游提供给这个packet的传输容量都浪费了 TCP拥塞控制概述&emsp;&emsp;sender逐渐增加发送速率（window size），从而探查可用bandwidth，直到丢包 加性增（additive increase）：cwnd每次每个RTT增加 1 MSS 直到检测到丢包（MSS 最大报文段长度） 乘性减（multiplicative decrease）：如果发生丢包，cwnd减半 sender传输限制 LastByteSent - LastByteAcked \\leq cwnd cwnd是动态的随着网络拥塞程度变化的函数 结合之前的rwnd，实际的窗口大小为 $min{ rwnd, cwnd }$ TCP发送速率（TCP sending rate） &emsp;&emsp;发送cwnd bytes，等待1个RTT接收ACK，然后再发送后续的bytes。 rate \\approx \\frac{cwnd}{RTT}\\ bytes/secTCP慢启动（TCP slow start） 连接开始时，先指数级增长发送速率，直到出现丢包 初始，$cwnd = 1\\ MSS$ 每经过一个RTT，翻倍cwnd（实际上，每收到一个ACK，cwnd+1） 当出现丢包时， timeout情况 cwnd重新设为 1MSS 重新开始慢启动，直到到达一个threshold 3个重复的ACK情况（TCP RENO版本） 重复的ACK既然能收到，那么网络还是有一定的传输能力，不需要像timeout一样重开。 cwnd减半（乘性减） TCP Tahoe版本中，timeout和3个重复的ACK都将cwnd设为 1MSS 从 slow start 到 CA 的转换&emsp;&emsp;当cwnd达到上次timeout时的1/2（即sstresh）时，从指数级增长变成线形增长。 sstresh —— 出现丢包时，将sstresh设置为此时cwnd的1/2 图 TCP Tahoe/Reno下cwnd的变化图【注：中间有一次3次ACK的丢包】 TCP拥塞控制FSM TCP吞吐量 avg TCP throughput（TCP平均吞吐量）由window size 和 RTT 决定（忽略slow start，假设一直由data在发送） W：丢包时的 window size，avg window size 为 $3/4W$，则TCP平均吞吐量为 avg\\ TCP\\ throughput = \\frac34 \\frac{W}{RTT}\\ bytes/sec 高速TCP&emsp;&emsp;假设一条具有 1500byte 报文段和 100ms RTT 的TCP连接，用此连接以 10Gps 发送数据。此时平均拥塞窗口长度为 83.333 个报文段。TCP连接的吞吐量公式（单位 bytes/sec）： TCP\\ throughput = \\frac{1.22MSS}{RTT\\sqrt{L}}10Gps的吞吐量，报文段丢失概率为 $2\\times 10^{-10}$ TCP公平性目标：K条TCP连接，经过R bps的瓶颈，每条TCP连接分 R/Kbps，则公平。 &emsp;&emsp;以两条TCP连接为例，从A出发，经过加性增、乘性减，会逐渐趋向公平线。所以TCP可以实现公平性。 Explicit Congestion Notification（ECN）网络辅助的拥塞控制 ToS field（IP datagram头部的 2 bits）可以被网络路由标记，以显示拥塞 ToS field会被送到receiver的主机 receiver在发送给sender的ACK中嵌入ECE，来通知sender有拥塞 网络层（Network Layer）概述 在发送和接收的主机之间传送packet 路由器（router）要检验通过的IP数据报（IP datagram）的头部 网络层功能 路由（Routing）：决定packet从源到目的路径 转发（Forwarding）：将packet从route的输入端口到合适的输出端口 连接建立（Connection setup）：一些网络结构要求数据传输前先建立路由路径 网络层服务 确保交付（Guaranteed delivery） 具有时延上界的确保交付（Guaranteed delivery with bounded delay） 有序分组交付（In-order packet delivery） 确保最小带宽（Guaranteed minimal bandwidth） 安全性服务（Security） &emsp;&emsp;网络层提供尽力而为的服务（best-effort service）。 虚电路和数据报网络（Virtual circuit and datagram networks） 数据报网络是无连接的服务 虚电路是面向连接的服务 端到端的服务、运行在网络核心 虚电路（Virtual circuit，VC） 呼叫建立 -&gt; 数据传输 -&gt; 呼叫拆除 每个packet携带VC号 路径上的每个router会给每个经过的VC维护连接状态 链路、路由资源（带宽、缓存）都会分配到VC VC组成： 从源到目的的路径 VC号：路径上每个链路都有一个号码（可以变化） 转发表 路由维持连接状态的信息。 信令协议(signaling protocol) VC采用信令协议(signaling protocol) 用来建立、维护、拆除VC 用在ATM、frame-relay、X.25 VC在Internet中没有使用 数据报网络（Datagram networks） 无连接 路由没有端到端的连接状态 packet通过目的主机ID来路由，同一个源到目的的packet可能走不同的路径。 转发表存储地址范围对应的链路接口，比如 Destination Address Range Link Interface 11001000 00010111 00010000 00000000 ～ 11001000 00010111 00010111 11111111 0 11001000 00010111 00011000 00000000 ～ 11001000 00010111 00011000 11111111 1 11001000 00010111 00011001 00000000 ～ 11001000 00010111 00011111 11111111 2 Otherwise 3 最长前缀匹配 &emsp;&emsp;选择 Link Interface 遵循最长前缀匹配原则。 例题：下面转发表 目的地址11001000 00010111 00010110 10100001 和 11001000 00010111 00011000 10101010 分别对应的Link Interface为？ 11001000 00010111 00010110 10100001 -&gt; 0 11001000 00010111 00011000 10101010 -&gt; 1（与1和2都匹配，但是与1匹配更长） 虚电路和数据报网络选择Internet：网络核心简单，复杂度在网络边缘 计算机数据交换：弹性服务，没有严格时间要求 链路类型多：有不同特性，不能统一服务 “智能”端系统 ATM：复杂度在网络核心 电话演变而来 人之间的交流：严格的时间限制、可靠性、确定的服务保障 “笨拙”端系统 路由器工作原理路由器结构 输入端口（Input port） 交换结构（Switch fabric） 输出端口（Output port） 路由选择处理器（Routing processor） 上半部分为控制面板：软件、毫秒级 下半部分为数据面板：硬件、纳秒级 输入端口（Input port） 线路端接（line termination）：物理层功能，用来比特的接收 数据链路处理（协议，拆封）（data link processing (protocol, decapsulation)）：数据链路层功能，比如以太网 查找、转发、排队（lookup, forwarding, queueing） 分散交换：给出数据报目的地，然后根据转发表查找输出端口 目标：希望在“line speed”上完成输入端口的处理 排队：数据报到达速度大于转发速度 交换结构（Switch fabric）&emsp;&emsp;三种交换结构：共享内存、共享总线、交叉开关矩阵 共享内存（Switching via memory） 初代路由常采用共享内存 pkt在memory复制 速度被内存带宽限制，每个datagram都要经过2个bus Cisco Catalyst 8500 共享总线（Switching via a bus） datagram通过共享的bus从输入端口到输出端口 总线冲突（bus contention）：交换速度被总线带宽限制 Cisco 5600 交叉开关矩阵（Switching via an interconnection network） 客服总线带宽的限制 纵横式交换机是一种由2N条总线组成的互联网络，连接N个输入端口和N个输出端口 可并行转发多个分组，但如果同输入输出端口，还是必须等待前一个发送了再发下一个 Cisco 12000 输出端口（Output port） 排队（缓存管理）（Queueing(datagram buffer)） 缓存：当数据报到达快于传输速率，如果缓存不够会导致丢包 调度方法：从排队中选择数据报进行传输，例如按时间顺序、按优先级顺序 数据链路处理（协议，封装）（Data link processing(protocol, encapsulation)） 线路端接（Line termination） 排队输入端口排队 当fabric比input port慢时，发生排队 buffer满时，出现排队延时和丢包 队首阻塞（Head-of-the-Line blocking，HOL）：队首的datagram会阻塞排在它后面的datagram输入 输出端口排队 当switch到达比output line快，发生排队 buffer满时，出现排队延时和丢包 路由算法（Routing algorithms）概述路由协议 目标：从源到目的找到一条最好的路径 一般，最好路径是最小代价路径 但也可以有其他定义 路由 -&gt; 节点 物理链路 -&gt; 边 链路代价：可以是延时、花费或拥塞等级等等 路由图表示： G = (N,E) 路由器集合：$N = {u,v,w,x,y,z}$ 链路集合：$E = {(u,v),(u,x),(v,x),(v,w),(x,w),(x,y),(w,y),(w,z),(y,z)}$ 路径cost：$cost\\ of\\ path\\ (x1,x_2,x_3,…,x_p)=c(x_1,x_2)+c(x_2,x_3)+…+c(x{p-1},x_p)$ 路由算法：找到cost最小路径 路由算法分类 全局/分散信息 全局：知道所有路由信息 分散：只知道邻居路由的信息，需要进行迭代查询 静态/动态 静态：需要手动配置，路由变化慢 动态：路由变化快，周期更新 LS算法：路由选择算法（Link state alorithm）Dijkstra算法 基于全局信息的算法 计算从源到所有其他节点的最小cost 迭代：经过k次迭代可知到k个目的的路径cost 算法步骤如下：G={V,E} 初始时令 S={V0},T=V-S={其余顶点}，T中顶点对应的距离值若存在，d(V0,Vi)为弧上的权值若不存在，d(V0,Vi)为∞ 从T中选取一个与S中顶点有关联边且权值最小的顶点W，加入到S中 对其余T中顶点的距离值进行修改：若加进W作中间顶点，从V0到Vi的距离值缩短，则修改此距离值重复上述步骤2、3，直到S中包含峙所有顶点，即W=Vi为止 $c(x,y)$：x到y的cost，如果x，y不是邻居，则为$c(x,y) = \\infty $ $D(v)$：从源到目的v的路径的cost $p(v)$：从源到目的v的路径的前一个节点 $N’$：最小cost路径的节点集 算法复杂度 假如有n个节点， 一般的Dijkstra算法需要 $n(n+1)/2$，即$O(n^2)$ 通过算法优化，可将复杂度降为$O(n\\log n)$ &emsp;&emsp;Dijkstra算法存在振荡问题。 广播路由（Broadcast routing）&emsp;&emsp;通过广播路由得到路由的实时情况。完成广播通信的最直接方式是由发送节点向每个目的地分别发送分组的拷贝。 洪泛（Flooding）：从源发送pkt到所有其他的节点 &emsp;&emsp;无限制洪泛会引起广播风暴（Broadcast storm），导致广播路由耗光了所有的流量。 受控洪泛（Controlled flooding）：解决广播风暴问题 序号控制洪泛（Sequence-number-controlled flooding） &emsp;&emsp;源节点将其地址(或其他的唯一标识符)以及广播序号放人广播分组，再向它的所有邻居发送该分组。每个节点维护它已经收到的、复制的和转发的源地址和每个广播分组的序号列表。当一个节点接收到一个广播分组时，它首先检查该分组是否在该列表中。如果在，丢弃该分组;如果不在，复制该分组并向该节点的所有邻居转发。 反向路径广播(Reverse Path Broadcasting，RPB) RPB 的基本思想是当一台路由器接收到具有给定源地址的广播分组时， 仅当该分组到达的链路正好是位于它自己到其源的最短单播路径上，它才向其所有出链路 (除了它接收分组的那个)传输分组。否则，该路由器丢弃入分组。 生成树广播（Spanning-tree broadcast）：消除了冗余广播pkt，而且能够被任何节点用于开始广播分组 在生成树上广播pkt，这样就不再会有圈了 LS算法LS算法 = 广播路由 + Dijkstra算法 广播路由：每个节点都要广播链接状态pkt给每个其他节点，从而每个节点都获得相同完整的网络信息 Dijkstra算法：计算源到每个节点的最小cost路径 如果有link cost变化，则重新进行上述操作 DV算法：距离向量算法（Distance vector algorithm）&emsp;&emsp;DV算法为基于分散信息、动态的路由算法。 Bellman-Ford公式&emsp;&emsp;定义 $d_x(y)$ ：从x到y的最小cost路径的cost Bellman-Ford方程：$d_x(y)$进行分解 d_x(y) = min_v\\{c(x,v)+d_v(y)\\}例题：通过$d_v(z)$、$d_w(z)$、$d_x(z)$计算$d_u(z)$。 d_u(z) = min\\{c(u,v)+d_v(z), c(u,w)+d_w(z), c(u,x)+d_x(z)\\} = min(2+5,1+3,5+3) = 4 $D_x(y)$为估算的$d_x(y)$ 对于节点x 知道邻居节点v的 $c(x,v)$ 维持邻居的距离向量 $D_v = [D_v(y):y\\in N]$ DV算法 每个节点定期发送它的 DV estimate 给邻居 当一个节点x收到邻居发来的新的 DV estimate 时，它会根据 B-F公式 更新自己的 DV estimate 多次更新后，DV estimate 会收敛于真实的最小cost $d_x(y)$ 迭代、异步：每个本地迭代产生于： 本地链接cost改变 邻居发来新的 DV estimate 分布： 每个节点只会在它的DV改变的时候才会通知邻居 邻居如果改变再通知邻居 好事传得快，坏事传得慢 “好事”（cost变小）：更新完成快 “坏事”（cost变大）：更新完成慢，造成无限问题 如何解决无限问题？ &emsp;&emsp;如果要节点最小cost路由要绕路（即不是邻居），则标为$\\infty $ LS算法和DV算法对比 LS DV 信息复杂度（Message complexity） $O(nE)$（n个节点，E条链路） 只在邻居之间交换 收敛速度（Speed of convergence） $O(n^2)$，可优化到$O(n\\log n)$ 速度会变化 强健性（Robustness） 有一定强健性，每个节点都有自己的表 强健性低，节点依赖于邻居 层次路由（Hierarchical Routing）之前讨论的路由都是理想化的：所有路由器都相同，网络是“扁平”的。而实际，并不存在这样的理想路由。 大规模 无法存储所有目的的转发表 路由交换流量大，导致淹没链路 管理自治 因特网是网中网 每个网络管理都希望控制所在网络的路由 &emsp;&emsp;聚集路由成自治系统（autonomous system，AS） AS内的路由（intra_AS routing） 在一个AS间的路由 在一个AS的所有路由器运行同一个区域内协议 不同AS的路由器运行不同区域的协议 网管路由器：位于AS边缘，与其他AS的路由器有链接 AS间的路由（inter_AS routing） 在不同AS间的路由 网管参与区域间的路由 AS分类 Stub AS：末端AS，用于小企业 Multihomed AS：多出口AS，用于大企业，外部不能通过它传输 Transit AS：中转AS，网络提供商，用于传输 因特网中的路由选择&emsp;&emsp;内部网关协议（Interior Gateway Protocols，IGP）是AS内的路由。 常用的IGP有： RIP：路由信息协议，Routing Information Protocol OSPF：开放最短路径，Open Shortest Path First IGRP：Interior Gateway Routing Protocol RIP：路由信息协议（Routing Information Protocol） DV算法 cost：跳数 &emsp;&emsp;最大15跳，16跳视为$\\infty $。设置最大跳数以防止无穷计数问题，但这也限制了只能用于小网络，大网络很容易超最大跳数。 每30s通过发送通告的方式更新DV，通告最多路由到25个目的 如果超过180s每收到通告，则这个邻居/链路宣告死亡 通过该邻居的路由失效 发送新通告给邻居 如果邻居的转发表变化，它也会发送新的通告 链接失败的信息会快速迭代完成 采用毒性逆转防止循环 将16跳设置为$\\infty $ RIP运行在应用层（路由器实际可能存在应用层，只是不对用户开放） 通告用 UDP pkt 周期性发送 OSPF：开放最短路径（Open Shortest Path First）OSPF概述 对公众开放 使用LS算法 需要发送LS pkt 每个节点采用拓扑结构 路由采用 Dijkstra 算法 OSPF通告每个邻居路由器携带一个条目 通告通过洪泛散布到整个AS OSPF消息直接分装在IP数据报上 OSPF优点 安全：所有OSPF消息都要认证，防止恶意侵入 多条相同cost的路径：当到达某目的的多条路径具有相同的cost时，OSPF允许使用多条路径。即可以分流。 每条链路，给不同的数据类型不同的cost度量 对单播和多播（MOSPF）路由的支持：对单播进行扩展，以便提供给多播使用 在大域中用分层OSPF 分层OSPF 两层结构：局部区域（local area）和 主干（backbone） LS通告只在区域内 每个节点知道该区域的拓扑结构，对于其他区域只知道到那个区域的方向（最短路径） 区域边界路由器（area border router）：负责为流向该区域以外的分组提供路由选择。汇拢该区域的节点距离信息，通告给其他的区域边界路由器 主干路由器（backbone router）：在主干内运行OSPF路由 网关路由器（boundary router）：与其他AS连接 IGRP（Interior Gateway Routing Protocol） 最初是CISCO私有的，后来开放了，RIP的后继者 DV算法 cost：时延、带宽、可靠性、负荷等等 利用TCP来交换路由更新 利用扩散更新算法（Diffusing Update Algorithm,DUAL）来防止循环 BGP：边界网管协议（Border Gateway Protocol）BGP概述采用 Path Vector protocol 与DV协议相似 每个边界网关向邻居（对等方）广播到达目的地的整个路径（即 AS的序列） eBGP：外部BGP，跨越两个AS对话。从相邻的AS获取子网可达性信息。 iBGP：内部BGP，同一个AS中的两台路由器之间的BGP对话。将可达性信息传播到所有内部AS路由器。 BGP会话：两BGP路由器通过半永久的TCP连接来交换消息 将路径通告到不同的目标网络前缀（BGP是“路径向量”协议） 如果一个AS向另一个AS通告了某个路由器，则承诺了可以路由到该路由器 路径属性和BGP路由 通告前缀（advertised prefix）包括BGP属性 prefix + attributes = “route” 两个重要attributes AS-PATH：路径中的AS的列表 NEXT-HOP：以AS-PATH开头的路由器接口的IP地址 基于policy的路由 网关接收路由广告使用导入policy接受/拒绝路径（例如，从不通过AS Y路由） AS policy还确定是否向其他相邻AS通告路径 BGP消息 使用TCP交换BGP消息 BGP消息： OPEN：打开TCP连接，认证sender UPDATE：通告新路径（删除旧路径） KEEP ALIVE：在没有UPDATE的情况下，保持连接活跃；ACK OPEN请求 NOTIFICATION：报告以前的msg中的错误；也用于关闭连接 BGP路由选择&emsp;&emsp;路由器可能知道到达同一个前缀的多条路由。BGP以下优先级选择路由： 本地偏好值：由政策决定 最短 AS-PATH：通过的AS最少 最近 NEXT-HOP 路由器：最近的下一跳路由器 其他标准 假设：网关X 将其路径发送到 网关W W 可以选择/不选 X所提供的路径 根据cost，policy（eg.不通过竞争对手的AS进行路由），防止环路 的原因选择/不选 如果W选择X通告的路径 Path(W,Z) = W,Path(X,Z) X可以通过advertisement来控制传入流量： eg.不希望将流量路由到Z -&gt; 不通告任何路由到Z BGP路由策略 A,B,C是ISP（网络服务提供商） W,X,Y是客户 X是 Multihomed AS，连接了两个ISP，也可以称为 dual-homed，一般是大型公司。X可以不允许 B -&gt; X -&gt; C 这条路由，则X不通告B有路由到C A 通告 B 路径 AW B 通告 X 路径 BAW 是否 B 通告 C 路径 BAW ？ 不会，C不是B的客户，B希望强迫C走AW，B只想从客户发送/接收路由 Inra-/Inter-AS 的区别规模：分层可以节省表格大小，减小更新的流量。 Intra-AS Inter-AS Policy 一个管理员，不需要policy决策 管理员想要控制路由，需要有policy 性能 关注性能 比起性能更关注policy IP：Internet ProtocolIPv4数据报结构 版本（Version, 4bit）对于IPv4，字段的值是4。 首部长度（Header Length， IHL, 4bit）首部长度说明首部有多少32位字（4字节）。一般为5，相当于5*4=20字节。 服务类别（Type Of Service，8bit） 报文长度（Length, 16bit）IP首部+数据部分的总长度 标识（Identification, 16bit）用于在IP层对数据报进行分片的时候，标识数据包。 标志 （Flags, 3bit）这个3位字段用于控制和识别分片，它们是： 位0：保留，必须为0； 位1：禁止分片（Don’t Fragment，DF），当DF=0时才允许分片； 位2：更多分片（More Fragment，MF），MF=1代表后面还有分片，MF=0 代表已经是最后一个分片。如果DF标志被设置为1，但路由要求必须分片报文，此报文会被丢弃。这个标志可被用于发往没有能力组装分片的主机。当一个报文被分片，除了最后一片外的所有分片都设置MF为1。最后一个片段具有非零片段偏移字段，将其与未分片数据包区分开，未分片的偏移字段为0。 分片偏移 （Fragment Offset, 13bit）这个13位字段指明了每个分片相对于原始报文开头的偏移量，以8字节作单位。 存活时间（Time To Live，TTL, 8bit）本数据报的TTL. 协议 （Protocol, 8bit）1—-icmp, 2—-igmp, 6—-tcp, 17—-udp, 89—-ospf 首部检验和 （Header Checksum， 16bit）IP首部的校验和 源IP地址（Source IP, 32bit） 目的IP地址（Destination IP, 32bit） IPv4数据报分片 网络链路有MTU（最大传送单元）— 最大可传输的链路的帧 不同的链路类型有不同的MTU 如果IP数据报 &gt; MTU ，则分片，到目的地后再重组 IP头部字段用来标记 IP数据报分片示例 本来要发送 4000 byte 的数据报（head部分 + data部分） 链路的 MTU = 1500 bytes 需要将数据分为3片来发送 length：片长度，包括了 20 bytes IP首部部分，最大为MTU length为1500的数据报，实际包含 $1500-20=1480\\ bytes$ 的data部分 最后一片的length为 $(4000-20) - 1480\\times 2 + 20 = 1040$ fragflag：3 bits 第二个bit为 DF（Don’t Flag）：为0则该数据报分片，为1则不分片 第三个bit为 MF：为0则后面没有片了，为1则后面还有片 前两片为 1（001），表示该IP数据报分片，且后面还有片 最后一片为 0（000），表示该IP数据报分片，后面没片（即最后一片） offset：data部分偏移量，以 8 bytes 为单位，只计算data部分 第一片的offset为 0 第二片的offset为 $1480\\ bytes/8\\ bytes = 185$ IPv4编址概述 IP地址：32位、主机和路由器接口的ID 接口（interface）：主机/路由器 和 物理链接 之间的连接 路由器一般有多个接口 主机一般有1到2个接口 每个接口都有一个对应的IP地址 接口连接方式 通过路由器连接 有线以太网通过以太网交换机连接 无线网络通过WiFi基站连接 子网（Subnet）IP地址 网络部分 —— 高位 主机部分 —— 低位 子网 子网部分相同 可以不通过路由器到达彼此 &emsp;&emsp;把路由器去掉，剩下的每个区域都是一个子网。 &emsp;&emsp;上图中有6个子网。 分类编制（Classful Addressing） A类 网络部分前1位 —— 0 网络部分 8 bits，主机部分 24 bits IP地址范围：1.0.0.0 ～ 127.255.255.255 B类 网络部分前2位 —— 10 网络部分 16 bits，主机部分 16 bits IP地址范围：128.0.0.0 ～ 191.255.255.255 C类 网络部分前3位 —— 110 网络部分 24 bits，主机部分 8 bits IP地址范围：192.0.0.0 ～ 223.255.255.255 D类 前4位 —— 1110 用于多播地址 E类 前4位 —— 1111 被留作将来使用 子网掩码（subnet mask） IP地址采用点分十进制：例如 192.32.216.9 分类编制导致了地址资源的浪费 子网和子网掩码：可以减小地址资源的浪费 &emsp;&emsp;200.23.16.64/27中的27为 网络部分+子网部分 的位数 子网掩码 网络部分+子网部分 置1 主机部分 置0 子网的网络ID 网络部分+子网部分 不变 主机部分 置0 CIDR：无类的域间路由（Classless InterDomain Routing） IP分为两个部分 —— 子网部分 + 主机部分 子网部分可以是任意长度 地址格式：a.b.c.d / x，其中x是子网部分位数 网络部分称为前缀（prefix） 如何获取IP地址主机如何获取IP地址主机获取IP地址： 硬编码：自己设置静态的IP设置 DHCP：动态主机配置（Dynamic Host Configuration Protocol）&emsp;&emsp;当主机连接网络时，允许主机从网络服务器动态获取IP地址。 DHCP 即插即用 可以更新IP 地址重用：主机的IP只有在上线时才固定，下线即释放 支持移动用户 &emsp;&emsp;当一台主机加入网络时，从子网中的DHCP服务器获取IP地址。 网络如何获取IP地址&emsp;&emsp;从ISP处获取分配的IP地址。 ISP如何获取IP地址&emsp;&emsp;ISP从ICANN组织获取IP地址 ICANN：Internet Corporation for Assigned Names and Numbers 分配地址 管理DNS 分配域名、解决争议 NAT：网络地址转换（Network Address Translation） 从这个本地网络出去的报文都有着：相同的源IP+不同的端口号 对于外界网络来说，这个本地网络都是一个IP 本地网络有内部地址，改变该内部地址不需要通知外部网络 改变ISP不需要改变本地网络的内部地址 内部地址在外部不可见（保障安全性） 实现方式 发送出去的报文：（源IP(内部的IP)，端口号）—&gt; （NAT IP(NAT统一的IP)，新端口号） 外部发来的报文的目的地址填写：（NAT IP(NAT统一的IP)，新端口号） NAT转换表：记住（源IP(内部的IP)，端口号）&lt;—&gt; （NAT IP(NAT统一的IP)，新端口号）的转换对 收到的报文：根据NAT转换表，（NAT IP(NAT统一的IP)，新端口号）—&gt; （源IP(内部的IP)，端口号） 外部不知道内部的情况，所以外部不能发起通信 预留给内部的IP地址： 10.0.0.0~10.255.255.255（A类） 176.16.0.0~172.31.255.255（B类） 192.168.0.0~192.168.255.255（C类） 可以有16bit的主机地址位（10.0.0.0~10.255.255.255），一个NAT支持内部60000+的连接 NAT存在争议 路由器本来是在第3层，但NAT修改了端口号，而端口号包含在TCP/UDP的段结构里，即改了第4层的内容 违反了端到端 所以用IPv6来解决地址短缺 ICMP：因特网控制消息协议（Internet Control Message Protocol）ICMP 主机、路由器、网关来交流网络层信息 报错：到达不了主机、网络、端口、协议等等 用于探测：echo request/reply（使用ping） IP的一部分，但体系结构在IP之上：ICMP消息搭载在IP数据报上 ICMP消息：type，code，引发错误的IP数据报首部和前8个字节 Type Code description 描述 0 0 echo reply (ping) echo响应 (被程序ping使用） 3 0 dest. network unreachable 目标网络不可达 3 1 dest host unreachable 目标主机不可达 3 2 dest protocol unreachable 目标协议不可达 3 3 dest port unreachable 目标端口不可达 3 6 dest network unknown 未知的目标网络 3 7 dest host unknown 未知的目标主机 4 0 source quench (congestion control - not used) 源端关闭（拥塞控制） 8 0 echo request (ping) Echo请求 9 0 route advertisement 路由通告 10 0 router discovery 路由器的发现/选择/请求 11 0 TTL expired TTL 超时 12 0 bad IP header IP 报首部参数错误 ICMP是管控制的IP的“兄弟” ICMP被IP使用，同时作为网络层协议使用IP ping、traceroute、path MTU discovery 都使用到了ICMP ping：使用 ICMP Echo request/repley msgs path MTU discovery 发送一个大的IP数据报，该数据报的 don’t fragment 置 1（即不分片） 减小数据报大小，直至成功（成功标志：没有接收到返回的ICMP消息） Traceroute&emsp;&emsp;Traceroute程序：跟踪从一台主机到其他主机之间的路由，用ICMP报文实现。 源发送一系列 UDP报文段 到目的 第一个数据报 TTL=1，第二个数据报 TTL=2，以此类推 使用不常见的端口号 当第n个数据报到达第n台主机时 这个第n个数据报TTL刚好过期 路由器丢弃该数据报 路由器发送一个ICMP告警报文（type 11，code 0）给源 该ICMP告警报文包括第n台路由器名字及其IP 当该ICMP报文返回到源主机，源主机计算RTT（往返时延），得到第n台路由器名字及其IP 标准的Traceroute程序用相同的TTL发送3个一组的分组，输出对每个TTL提供3个结果 停止条件步骤 UDP数据报到达目的主机 目的主机返回 ICMP端口不可到达报文（type 3，code 3） 源主机接收到该ICMP报文，则停止 在Mac上可在app“系统信息”中的窗口-&gt;网络实用工具中使用Ping、Traceroute等工具。 IPv6 动机 初动机：解决32位IP地址空间分配完的问题 更快处理/转发的头部格式 头部支持QoS IPv6数据报格式 固定长度的头部：40 byte （IPv4头部长度不固定） 不允许分片 IPv6数据报结构 版本（Version, 4 bit）对于IPv6，字段的值是6（0110）。 流量类型（Traffic class，8 bit） 用来标识对应IPv6的通信流类别，类似于IPv4中的ToS。 流标签（Flow label，20 bit） 用来标记报文的数据流类型，以便在网络层区分不同的报文。 有效载荷长度（Payload length，16 bit） 给出了IPv6数据报中跟在定长的40 byte数据报头部后面的字节数量。 下一个头部（Next Header，8 bit） 该字段标识数据报中的内容（数据字段）需要交付给哪个协议（如TCP或UDP）。无扩展的头部，Next Header指向TCP/UDP；有扩展的头部，Next Header指向的下一个头部比如路由选择。与IPv4头部 协议（Protocol）字段相同。 跳段数限制（Hop limit，8 bit） 生存时间，相当于IPv4中的TTL。转发数据报的每台路由器讲对该字段内容 -1，如果跳转限制计数到0时，则丢弃该数据报 源IP地址（Source Address，128 bit） 目的IP地址（Destination Address，128 bit） 数据（Data） IPv6相较于IPv4的部分改变 去除Checksum：加快了转发速度 Options：依旧允许可选项，但是不放在头部，而是放在 Next Header 指出的位置上 ICMPv6：ICMP的IPv6版本 增加新的 type：比如“Packet Too Big” 包含多播组管理 IPv6地址 三种类型：单播（unicast）、多播（multicast）、任意播（anycast） 冒号划分的十六进制（128 bit） eg. 68E6:8C64:FFFF:FFFF:0:1180:960A:FFFF 0的压缩 用双冒号::表示一组0或多组连续的0，但只能出现一次。 FF05:0:0:0:0:0:0:B3 = FF05::B3 0:0:0:0:0:0:128.10.2.1 = ::128.10.2.1（IPv4和IPv6兼容的IP） 12AB:0:0:CD30:0:0:0:0 = 12AB::CD30:0:0:0:0 = 12AB:0:0:CD30::（如果出现两个多个0，随意压一个都行） 单播（Unicast address）单播的地址格式（一共 128 bit）： 全球路由前缀（Global routing prefix，48 bit） 前3位为001，分配给公司和组织。 子网ID（Subnet ID，16 bit） 如果是小公司，只需要1个子网的话，全设为0 接口ID（Interface ID，64 bit） 基于 EUI-64 IPv4到IPv6的迁移 现在的网络既有IPv4，也有IPv6。世界上的所有网从IPv4到IPv6需要很长的转换时间。 两种IPv4到IPv6的迁移 双栈（Dual Stack）：一些路由器可以兼容IPv4和IPv6 隧道（Tunneling）：当IPv6穿过IPv4的路由器上时，将IPv6作为载荷承载在IPv4上 双栈（Dual Stack） 早期的设计 一些路由器有双栈（IPv4 &amp; IPv6），可以翻译这两种格式 隧道（Tunneling）&emsp;&emsp;当IPv6穿过IPv4的路由器上时，将IPv6作为载荷承载在IPv4上。就是像一个连接两个IPv6路由器的IPv4隧道 链路层（Link Layer）概述保证帧流的透明传输 链路层服务： 成帧（Framing）、接入链路（link access） 将来自上级的数据报分装成帧，加上header、trailer 完成共享媒体的信道连接 物理地址，用来 indentify 源/目的，在帧头中 可靠交付（Reliable delivery） 可靠数据传输协议（rdt） 在可靠的传输情况下很少应用，一般应用在高错误概率的链路传输中 流量控制（Flow Control） 协调发送方和接收方 差错检测（Error Detection） 差错纠正（Error Correction） 成帧（Framing）&emsp;&emsp;主要考虑帧的界定，即如何将前一帧和后一帧分开。 字符计数法（Character count method）&emsp;&emsp;在每帧的前面添加 Counting header（本帧长度） 基于字符的首尾界定法（First and tail bound method based on character）&emsp;&emsp;设定两个ASCII——SOH、EOT，SOH为标注开始的字符，EOT为标注结尾的字符。 &emsp;&emsp;如果中间的数据部分也有SOH或EOT，则加入转义字符 EOT 标识。类似于C语言中的\\的作用。 基于bit的首尾界定法（First and tail bound method based on bit）&emsp;&emsp;与基于字符的首尾界定法的思路相似，但开始和结束的标志为01111110 &emsp;&emsp;为防止中间的数据部分也有01111110导致提前结束 发送方：每5个1后插入一个0 接收方：每5个1后删除一个0 物理层违逆码法（Pysical layer coding violation method）比如在曼切斯特编码中，如果 高低表示1 低高表示0 那么 低低/高高 就可以用来表示开始和结束 &emsp;&emsp;违逆码只能应用在物理层，因为违逆码无法储存。 差错检测（Error Detection）&emsp;&emsp;通过增加冗余位（EDC）来检测差错。 &emsp;&emsp;差错检测不是100%可靠的。 可能会漏掉一些错误，但是概率很小 更大的EDC检错能力更强 奇偶校验（Parity Checking） 单个奇偶校验位（Single Bit Parity） &emsp;&emsp;分为奇校验和偶校验，EDC长度为1 bit。 如发送一个长为$d$ bit 的信息时，加EDC一共$d+1$ bit。 偶校验中，则EDC需使这$d+1$ bit 中有偶数个1（即如果发送的信息有偶数个1，则EDC为0；奇数个1，则EDC为1） 奇校验中，则EDC需使这$d+1$ bit 中有奇数个1（即如果发送的信息有偶数个1，则EDC为1；奇数个1，则EDC为0） &emsp;&emsp;下图采用偶校验，信息D中共有9个1，所以偶校验位为1。 &emsp;&emsp;奇偶校验只能检测出奇数个错误的情况。但由于现在传输的准确率很高，就算出错，大概率也就出 1 bit 的错误，所以使用简单的奇偶校验也能检测出大部分错误。 二维奇偶校验（two-dimensional parity） &emsp;&emsp;将$D$中的$d$ bit 划分成$i$行、$j$列，计算每行和每列的奇偶校验值，产生$i+j+1$个奇偶比特，即ECD长度为$i+j+1$ bit。 &emsp;&emsp;二维奇偶校验不仅可以检测错误，还可以利用奇偶校验差错的行和列的索引找出错误的比特位，进行纠错。 CRC校验（Cyclic Redundancy Check）&emsp;&emsp;CRC（Cyclic Redundancy Check），循环冗余检测。 思路：发送信息$D$，设置一个生成多项式，利用冗余位$R$，将$D+R$凑成生成多项式的整数倍，在接收方如果无法整除，则出差错。 生成多项式$G$和CRC比特位数 &emsp;&emsp;设置一个$r+1$ bit 的生成多项式，先将生成多项式$G(x)$化为二进制数$G$，最高位必须为$1$。 &emsp;&emsp;比如下面，三次项和常数项系数为$1$，则二进制数$G$的第四位和第一位为$1$ G(x)=x^3+1\\ ,\\quad G=1001&emsp;&emsp;生成多项式$G$为$r+1$ bit，则CRC冗余位为$r$ bit。如此才能保证能把$D+R$凑成$G$的整数。 计算CRC冗余位$R$ &emsp;&emsp;增加$R$的目的是实现： D\\times 2^r \\oplus R = nG先将信息$D$乘以$2^r$，即左移$r$ bit，后面补0。再将移位后的$D\\times 2^r$除$G$，但是中间步骤不用减，而用异或。比如 1001-1101=0100&emsp;&emsp;信息$D$为101110，生成多项式$G(x)=x^3+1$。此时$r=3$，先在$D$后补$3$个0，得101110000，再除以$G=1001$ 得到的余数011则为CRC冗余位$R$。 &emsp;&emsp;发送方发送信息$D$和冗余位$R$的拼接，即101110011。 接收方检错 &emsp;&emsp;接收方收到发送方发来的101110011后，将其除以生成多项式$G$ 1001。如果整除则未检测到差错，否则检测到差错。 多路访问链路和协议（Multiple Access Links and Protocols）链路的两种类型： 点对点链路（point-to-point link） &emsp;&emsp;由链路一端的单个发送方和链路另一端的单个接收方组成。 广播链路（broadcast link） &emsp;&emsp;多个发送方和接收方，单一的、共享的信道。 &emsp;&emsp;多路访问协议（Multiple access protocol），规范结点在共享的广播信道上的传输行为。 多路访问协议分类： 信道划分协议（channel partitioning protocol） 静态 将信道平分给各节点 优点：公平、相互不干扰 缺点：闲置占有带宽 随机接入协议（random access protocol） 动态 独占信道 允许冲突，并能从冲突中恢复 轮流协议（taking-turns protocol） 上两种的结合 紧密协调共享访问以避免冲突 多路访问协议的目标：高效、公平、简单、分布式 信道划分协议（Channel Partitioning protocols）时分多路复用（TDMA）&emsp;&emsp;TDM将时间划分为时间帧（frame），并进一步划分每个时间帧为$N$个时隙（slot），链路中的每条连接专用一个时隙。 &emsp;&emsp;详见 时分多路复用（TDM）。 频分多路复用（FDMA）&emsp;&emsp;链路中的每条连接专用一个频段。 &emsp;&emsp;详见 时分多路复用（FDM） 。 码分多址（CDMA） &emsp;&emsp;详见 码分多路复用（Code division multiplexing，CDM）) 。 随机接入协议（Random Access protocols） 结点传输pkt时，占有信道全部带宽，结点间无优先级 存在多个传输结点 =&gt; 碰撞 随机接入协议明确了： 如何检测碰撞 如何从碰撞中恢复 常用的随机接入协议 ALOHA Slotted ALOHA CSMA 和 CSMA/CD 纯ALOHA（Pure ALOHA） 非时隙、简单、完全分散 最早的ALOHA，目前已经不再使用 帧长一定 =&gt; 帧传输时间一定 当一帧首次到达（从网络层传下来），结点立即将该帧完整传输进广播信道 如果发送碰撞，则该结点 有$p$的概率，将立即以重传该帧 有$1-p$的概率，等待一个帧传输时间，再以$p$的概率判断是否重传 &emsp;&emsp;假设一帧在$t_0$处开始传输，则在$[t_0-1,t_0+1]$，其他结点如有传输，发生碰撞，则易损时间区长度为$2\\tau$（$tau$为一帧的传输时间）。 &emsp;&emsp;一个结点发送成功，则需要本结点发送、其他结点在$[t_0-1,t_0]$和$[t_0,t_0+1]$不发送。一个给定结点成功传送的概率为 \\begin{split} P(success\\ by\\ given\\ node)=&P(node\\ transmits)\\times\\\\ & P(no\\ other\\ node\\ transmits\\ in\\ [t_0-1,t_0])\\times\\\\ & P(no\\ other\\ node\\ transmits\\ in\\ [t_0,t_0+1])\\\\ =&p\\times (1-p)^{N-1}\\times (1-p)^{N-1}\\\\ =&p\\times (1-p)^{2(N-1)} \\end{split}则有$N$个结点，任意一个结点成功传送的概率为 S=Np(1-p)^{2(N-1)}如此，求得纯ALOHA的最大效率为$1/(2e)\\approx 0.18$（改变$p$，使$S$最大化）。 时隙ALOHA（Slotted ALOHA） 时间被划分成长度相等的时隙（slot） 结点只在时隙起点开始传输帧 如果碰撞，在下一时隙的开始以$p$的概率重传，直至成功。 &emsp;&emsp;假设一帧在$t_0$处开始传输，则在本时隙中，其他结点如有传输，发生碰撞，则易损时间区长度为$\\tau$（$\\tau$为一帧的传输时间）。 &emsp;&emsp;一个给定结点成功传送的概率为 S=p(1-p)^{N-1}&emsp;&emsp;如果有$N$个活跃结点，任意一个结点成功传送的概率为 S=Np(1-p)^{N-1}如此，求得时隙ALOHA的最大效率为$1/e\\approx 0.37$（改变$p$，使$S$最大化）。即在有大量结点有帧要传输时，最多$37%$的时隙做有用的工作，信道传输速率不是$R$ bps，而是$0.37R$ bps。 &emsp;&emsp;时隙ALOHA的最大效率是纯ALOHA的两倍。 CSMA：载波侦听多路访问&emsp;&emsp;载波侦听多路访问（CSMA，Carrier Sense Multiple Access），一个结点在传输前先侦听信道。 如果侦听到信道空闲，则传输帧 如果侦听到信道正忙，则推迟传输。再传输方式分为坚持型和非坚持型： 坚持型CSMA（Persisitent CSMA）：一直坚持监听，直到信道空闲时，立即以概率$p$重试（可能导致不稳定）。其中1-坚持型CSMA的$p=1$，即立即重试。 非坚持型CSMA（Non-Persisitent CSMA）：不再监听，等待一个随机的时间之后再进行监听。 CSMA依旧会发生碰撞 &emsp;&emsp;只要共享信道，那么碰撞就是不可避免的，即使CSMA有侦听。 &emsp;&emsp;比如下图中，B结点在$t_0$时传输帧，但是帧的传输是需要一定时间的，这就导致在$t_1$时，D结点侦听判断信道空闲，传输帧。两信号发生碰撞。 &emsp;&emsp;如此，整个帧传输时间被浪费了。可以看出，广播信道的端到端信道传播时延（distance and propagation delay）（信号从一个结点到另一个结点的传播时间）在决定性能上起关键作用。 CSMA/CD：具有碰撞检测的载波侦听多路访问 碰撞要在短时间内检测出来（最好在一个争用期内） 一旦检测到碰撞立即停止传输，以减少信道的浪费 采样坚持型或非坚持型重传 碰撞检测 有线网络检测碰撞比较简单：如阈值法、过零法等等 无线网络检测碰撞比较困难 &emsp;&emsp;如下图，当B结点和D结点检测到碰撞时，立即停止继续发送。 争用期：以太网的端到端往返时间$2\\tau$ &emsp;&emsp;A结点给B结点发送帧流，最坏情况就是在即将发送到B结点时，发生碰撞，返回碰撞信息，最大用时即为$2\\tau$。 最短帧：最短帧长度为$2\\tau R$（$R$为信道速率） &emsp;&emsp;和上述同样的最坏情况中，从A结点发送帧，到碰撞信号返回到A结点花费$2\\tau$的时间，在此期间A结点不能停止帧的发送，所以最短帧的长度为$2\\tau R$。 &emsp;&emsp;如此可以最大利用网络效率，而且不会产生二义型。如果发送完了这个帧，没有发生碰撞，则发生成功。 CSMA/CD 效率 &emsp;&emsp;CSMA/CD 效率：当有大量的活跃结点，且每个结点有大量的帧要发送时，帧在信道中无碰撞地传输的那部分时间在长期运行时间中所占的份额。 efficiency = \\frac 1{1+t_{prop}/t_{trans}}其中，$t_{prop}$为两结点之间的最大传播时间； &emsp;&emsp;&emsp;$t_{trans}$为传输一个最大长度的帧的时间。 效率趋近1，则需 $t_{prop}$ -&gt; 0 或，$t_{trans}$ -&gt; $\\infty$ &emsp;&emsp;CSMA/CD 比 ALOHA 简单、便宜、分布式。 轮流协议（Taking-Turns protocol）轮询协议（Polling protocol） 有一个主结点 主结点以循环的方式轮询每个结点 主结点先向一个结点发送报文，告诉能够传输的帧的最多的数量，这个结点传输完帧后，主机点再发给下一个结点报文，循环轮询。 缺点： 主结点需先给结点发送报文，增加开销 轮询时延，不及时 如果主结点出故障，则整个网络无法工作 令牌传递协议（Token-Passing protocol） 令牌（token）在结点之间以某种固定次序进行交换 结点只有在拿到令牌时，才能发送帧 受控的，不会发生碰撞 缺点： 令牌开销 时延 令牌环会故障 局域网技术局域网模型&emsp;&emsp;局域网模型中，数据链路层分为LLC子层和MAC子层。 逻辑链路控制层（Logical Link Control，LLC）：为上层（网络层）提供连接环境 媒体接入层（Media Access Control，MAC）：为下层（物理层）提供媒体接入 局域网地址和ARPMAC 地址 可以叫MAC 地址、LAN地址、物理地址 用于从一个接口到另一个物理连接的接口（同一网络）获取数据报 MAC地址长度：$48$ bit / $6$ byte 与硬件有关，一个网卡（适配器）对应一个MAC地址 例如：1A-2F-BB-76-09-AD 与局域网相连的每个接口都有唯一的MAC地址 MAC地址由IEEE分配 IEEE给公司固定MAC地址的前$24$ bit，后$24$ bit由公司保证每个适配器MAC地址的唯一性 IP地址和MAC地址的关系：IP地址就像是一个邮件地址，解决在哪上网的问题；MAC地址像身份证，解决谁在上网的问题 IP地址层次结构，主机移动，主机的IP地址也改变 MAC地址扁平寻址结构，不会因为位置改变MAC地址 ARP：地址解析协议&emsp;&emsp;ARP（Address Resolution Protocol），地址解析协议 局域网中的每个IP结点（主机、路由器）都有ARP表 ARP表：局域网结点的IP地址和MAC地址的对应关系 每行的结构：&lt;IP address; MAC address; TTL&gt; TTL：存活时间，过TTL的时间要丢弃这一行数据 同一子网内的地址解析&emsp;&emsp;A想要发送数据报给B，但是B的MAC地址没有记录在A的ARP表中。 A发送一个广播帧——查询ARP分组，包含B的IP地址 目的MAC地址：FF-FF-FF-FF-FF-FF 所有结点都会收到该ARP查询分组 B接收到ARP分组，给A回复B的MAC地址 给A的MAC地址单播帧——响应APR分组 A在ARP表中缓存IP到MAC地址对，直至超时TTL &emsp;&emsp;ARP即插即用：ARP表自动建立，不需要系统管理员来配置 不同子网的地址解析&emsp;&emsp;不同子网的A和B通过路由器R发送数据报，A只知道B的IP地址，不知道B的MAC地址 A创建IP报文（IP地址在整个传输过程中不改变） 源IP地址：A的IP 目的IP地址：B的IP A创建数据帧，在IP报文的基础上，加上MAC地址 源MAC地址：A的MAC 目的MAC地址：路由器R左端的MAC（路由器R左端与A在一个子网中） 帧从A传到路由器R 路由器R接收帧，并从路由器R的数据链路层传到网络层，从数据帧拆成IP数据报 路由器R在IP报文的基础上，加上新的MAC地址段，传到数据链路层 源MAC地址：路由器R右端的MAC（路由器R右端与B在一个子网中） 目的MAC地址：B的MAC 帧从路由器R传到B，B接收到数据 以太网（Enternet）以太网物理拓扑 总线型 &emsp;&emsp;早期流行，所有的结点共用一条总线。 星型 &emsp;&emsp;以太网现在使用的拓扑结构，中间是交换机，所有结点和交换机的连接是唯一的，不会发生冲突。 以太网帧结构 前导码（Preamble，7 byte） 7 bytes 的方波10101010，用于“唤醒”接收适配器，并将它们的时钟与发送方的时钟同步。 帧开始符（Start of Frame Delimiter(SFD)，1 byte） 10101011，用来警告接收适配器，要开始了。 目的MAC地址（Destination address，6 byte） 目的适配器的MAC地址。 源MAC地址（Source address，6 byte） 源适配器的MAC地址。 类型（Type，2 byte） 上层的协议。比如，IP协议对应0X0800。 数据（Data，46~1500 byte） IP数据报。 最小长度——46 byte 由$2\\tau R$决定。IEEE 802.3中，$2\\tau$为$51.2\\mu s$，$R=10Mbps$，由此得到最小帧长度$64\\ bytes$。再减去$18\\ bytes$的其他部分，得到最小数据的长度$46\\ bytes$。 详见CSMA-C中的最短帧。 小于最小长度得补充到46 byte。 最大长度——1500 byte 超过最大长度得分片。 帧校验序列（FCS，4 byte） 错误检测机制，比如CRC。 以太网技术 无连接：不需要握手 不可靠：不需要发送ack或nack 以太网MAC协议：非时隙、1-坚持、二进制指数退避的CSMA/CD 二进制指数退避CSMA/CD算法1234567891011121314A: //A事件sense channel, if idle //如果侦听信道空闲then &#123; transmit and monitor the channel; //传输并监听信道（监听是否有其他站点在传输） if detect another transmission //如果监听到其他站点在传输 then &#123; abort and send jam signal; //停止并发送jam信号（将冲突信号发送给其他站点） update # collisions; //更新冲突次数（冲突次数+1） delay as required by exponential backoff algorithm; //调用二进制指数退避算法来延时 goto A //重新执行A事件 &#125; else &#123;done with the frame; set collisions to zero&#125; //如果在传输的过程中没监听到其他站点在传输，则完成帧的传输，并将冲突次数清零&#125;else &#123;wait until ongoing transmission is over and goto A&#125; //如果侦听信道在忙，则继续侦听，直至信道空闲，再发送（1-坚持）；如果是非坚持，则等待一个随机的时间之后再进行监听 Jam Signal：长$48\\ bits$，保证每个其他的发送方意识到冲突 二进制指数退避算法（Binary Exponential Backoff Algorithm）&emsp;&emsp;一旦检测到冲突，为降低再冲突的概率，需要等待一个随机时间，二进制指数退避算法即解决时延时间的问题。 &emsp;&emsp;时延的时间为端到端的往返时间$2\\tau$的整数倍，即$2\\tau \\times n$（$n$为整数）。$k$为冲突次数collisions。 初始的冲突次数$k=0$； 每冲突一次，则$k=k+1$； 如果$k&lt;10$，$n$从$[0, 2^k)$中随机选择一个整数（注意⚠️：右边为开区间），则延时$2\\tau \\times n$的时间； 如果$k\\geq 10$，则$n$从${0,1,2,3,…,1023}$中随机选择一个，延时$2\\tau \\times n$的时间。（$k$在$10$之后就不再增加时延的选择范围，防止延时过长） 802.3以太网标准不同的以太网标准有： 相同的MAC协议和帧格式 不同的速度：$2/ Mbps$、$10\\ Mbps$、$100\\ Mbps$等等 不同的物理层媒体：光纤、铜线 &emsp;&emsp;下图为$100\\ Mbps$以太网标准，其中100代表$100\\ Mbps，TX、T2、T4代表媒体为不同的铜线，FX、SX、BX代表媒体为不同的光纤。 交换机（Switch）集线器（Hub） 物理层设备：相当于工作在bit 层的传话筒，将接收到的bit从一个接口传到其他的所有接口 层级结构 每个连接的LAN称为LAN网段 集线器不会隔离冲突域 集线器的优点 简单便宜 如果一个集线器发生故障，则局域网的其他部分将继续运行 扩展节点对之间的最大距离（每个集线器100m） 集线器的缺点 未隔离冲突域，导致最大吞吐量没有增加（多层吞吐量与单段吞吐量相同） 单独的LAN限制对相同冲突域中的结点数以及允许的总地理覆盖范围进行了限制 无法连接不同的以太网类型（例如10BaseT和100baseT） 由于上述缺陷，如今大部分集线器已被交换机取代 以太网交换机概述 交换机，也可以叫网桥 链路层设备 存储、转发以太网帧 检查传入的帧的MAC地址，有选择地将帧转发到一个或多个传出链路，使用CSMA / CD访问段 收到的帧与发送的结点在同一网段，则丢弃该帧 收到的帧的目的MAC地址在转发表里，且与发送的结点不在同一网段，则向目的地址所对应端口转发该帧 收到的帧的目的MAC地址不在转发表里，则泛洪 透明：主机不知道交换机的存在 即插即用，自学习（不需要配置交换机） 主机有专用的、直接的到交换机的连接 交换机缓存pkt 每个输入链路都使用以太网协议，但是没有冲突 全双工 每个链路都是自己的冲突域 A至A’和B至B’可以同时传输而不会发生冲突 交换机自学习 每个交换机都有一张交换表作为转发表，交换表的每行数据为&lt;MAC address, interface, TTL&gt;，即MAC地址、通向该MAC地址的接口、存活时间。 交换机表初始为空 交换机每接收到一个帧，就记录一条数据（发送结点的数据） 过了TTL，则删掉该条数据 交换机转发与过滤123456789when frame received at switch: //交换机接收到帧 1. record incoming link, MAC address of sending host //在交换表中记录发送方的传入接口、MAC地址 2. index switch table using MAC destination address //在交换表中查找目的MAC地址 3. if entry found for destination //如果在交换表找到了该目的MAC地址 then &#123; if destination on segment from which frame arrived then drop frame //如果目的与发送方在同一网段，则丢弃该帧 else forward frame on interface indicated by entry //如果不在同一网段，则转发帧到相应接口 &#125; else flood //如果在交换表找到不到该目的MAC地址，则泛洪（转发到除发送方所在接口以外的所有接口） 交换机 vs 路由器 路由器 交换机 存储转发 有 有 所在层 网络层设备（检查网络层头部） 链路层设备（检查链路层头部） 转发表 使用路由算法，IP地址 使用泛洪，自学习，MAC地址 VLAN：虚拟局域网&emsp;&emsp;交换机以太网存在缺点：缺乏广播隔离，导致易产生广播风暴。 &emsp;&emsp;为解决上述问题，采用虚拟局域网VLAN。 &emsp;&emsp;VLAN：在单个LAN内，将支持VLAN功能的交换机配置为多个虚拟LAN。 基于端口的VLAN&emsp;&emsp;将单个LAN基于端口划分为多个VLAN。 流量隔离：帧只能在本VLAN内往返（VLAN相当于一个真实的局域网，将功能限制在链路层，只能传帧） VLAN之间的转发：通过路由完成（就像使用单独的交换机一样） 动态成员资格：端口可以在VLAN之间动态分配 跨多个交换机的VLAN 最早采用实体线相连，后采用中继端口。 中继端口（trunk port）：也可以叫共享端口，在多个物理交换机上定义的VLAN之间传送帧。 下图中，a为实体线相连，b为中继端口连。 802.1q：原802.1帧未带有VLAN标识，所以802.1q协议为中继端口之间转发的帧添加/删除了其他报头字段 增加了$4\\ byte$ 前$2\\ byte$为协议标识 后$2\\ byte$中，前$12\\ bit$为VLAN的ID，后$3\\ bit$为优先级 由于位数改变，CRC需重算","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://gy23333.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://gy23333.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"MATLAB学习手册","slug":"MATLAB学习手册","date":"2020-03-05T06:53:37.000Z","updated":"2024-11-11T03:57:58.119Z","comments":true,"path":"2020/03/05/MATLAB学习手册/","link":"","permalink":"https://gy23333.github.io/2020/03/05/MATLAB%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/","excerpt":"​ MATLAB是MATrix LABoratory（矩阵实验室）的缩写，是一款由美国The MathWorks公司出品的商业数学软件。MATLAB是一种用于算法开发、数据可视化、数据分析以及数值计算的高级技术计算语言和交互式环境。除了矩阵运算、绘制函数/数据图像等常用功能外，MATLAB还可以用来创建用户界面及与调用其它语言（包括C、C++、Java、Python和FORTRAN）编写的程序。下面是对MATLAB官方中文文档的学习总结。","text":"​ MATLAB是MATrix LABoratory（矩阵实验室）的缩写，是一款由美国The MathWorks公司出品的商业数学软件。MATLAB是一种用于算法开发、数据可视化、数据分析以及数值计算的高级技术计算语言和交互式环境。除了矩阵运算、绘制函数/数据图像等常用功能外，MATLAB还可以用来创建用户界面及与调用其它语言（包括C、C++、Java、Python和FORTRAN）编写的程序。下面是对MATLAB官方中文文档的学习总结。 入门矩阵和数组​ 所有 MATLAB 变量都是多维数组，与数据类型无关。矩阵是指通常用来进行线性代数运算的二维数组。 数组创建一般数组的创建 在每行中，用 , 或者 空格来分隔每个元素； 1a = [1 2 3 4] 用 ; 来分隔每行，形成矩阵； 1a = [1 2 3; 4 5 6; 7 8 9] 函数创建矩阵ones 函数 格式：ones(行数, 列数) 功能：创建由1构成的行数⨉列数的矩阵 1ones(2,3) zeros 函数 格式：zeros(行数, 列数) 功能：创建由0构成的行数⨉列数的矩阵 1zeros(2,3) 矩阵和数组运算​ MATLAB 允许使用单一的算术运算符或函数来处理矩阵中的所有值。 ​ 比如 sin(a) 即可将a矩阵中的所有值带入 sin函数。 命令 功能 a&#39; 矩阵转置 inv(a) 矩阵求逆 a*b 矩阵的乘法 a.*b 矩阵元素级乘法 矩阵串联 [a, a] 水平串联 [a; a] 垂直串联 数组索引注意：MATLAB中数组的开始下标为 1。 命令 功能 a(行下标, 列下标) 得到指定行和列下标的元素 a(下标) 用单一下标按顺序向下遍历每一列，得到单一元素 a(开始行下标:结束行下标, 列下标) 得到指定列，从开始行到结束行的元素数组 a(:, 列下标) 得到指定列的元素数组 工作变量​ 工作区包含在 MATLAB 中创建或从数据文件或其他程序导入的变量。 whos 可以查看工作区的内容。 退出 MATLAB 后，工作区变量不会保留。使用 save 命令保存数据以供将来使用 save myfile.mat 要清除工作区中的所有变量，请使用 clear 命令。 使用 load 将 MAT 文件中的数据还原到工作区。load myfile.mat 文本与字符 MATLAB中用 &quot;&quot; 定义字符； +连接字符或数字； 调用函数 格式：[输出变量1, 输出变量2...] = functionName(输入变量1, 输入变量2...) 将任何字符输入括在单引号中 clc 函数清空命令行窗口 二维图和三维图二维图​ 用 plot 函数创建二维线图。 123456x = 0:pi/100:2*pi; %自变量数组y = sin(x); %因变量函数plot(x,y) %显示x-y图像xlabel('x') %x轴标题ylabel('sin(x)') %y轴标题title('Plot of the Sine Function') %总标题 ​ 利用hold on一个窗口显示两个图。 123456789x = 0:pi/100:2*pi; y = sin(x); plot(x,y)hold on %保留住现窗口%显示第二个图形y2 = cos(x); plot(x,y2,':') legend('sin','cos')hold off %关闭窗口 三维图 使用 meshgrid 在此函数的域中创建一组 (x,y) 点 surf 创建曲面图 123mat[X,Y] = meshgrid(-2:.2:2); Z = X .* exp(-X.^2 - Y.^2);surf(X,Y,Z) %创建曲面 子图​ 使用 subplot 函数可以在同一窗口的不同子区域显示多个绘图。 格式：subplot(a, b, c) 功能：a⨉b网格中的第c个位置显示图形。 123456t = 0:pi/10:2*pi;[X,Y,Z] = cylinder(4*cos(t));subplot(2,2,1); mesh(X); title('X');subplot(2,2,2); mesh(Y); title('Y');subplot(2,2,3); mesh(Z); title('Z');subplot(2,2,4); mesh(X,Y,Z); title('X,Y,Z');","categories":[{"name":"MATLAB","slug":"MATLAB","permalink":"https://gy23333.github.io/categories/MATLAB/"}],"tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"https://gy23333.github.io/tags/MATLAB/"}]},{"title":"高斯滤波&均值滤波&中值滤波","slug":"高斯滤波-均值滤波-中值滤波","date":"2020-03-01T09:13:02.000Z","updated":"2024-11-11T03:57:58.118Z","comments":true,"path":"2020/03/01/高斯滤波-均值滤波-中值滤波/","link":"","permalink":"https://gy23333.github.io/2020/03/01/%E9%AB%98%E6%96%AF%E6%BB%A4%E6%B3%A2-%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2-%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2/","excerpt":"​ 图像滤波，即在尽量保留图像细节特征的条件下对噪声进行抑制，通过抑制高频段来减少噪音，同时会照成图像一定程度上的模糊，这也叫做平滑或者低通滤波器。","text":"​ 图像滤波，即在尽量保留图像细节特征的条件下对噪声进行抑制，通过抑制高频段来减少噪音，同时会照成图像一定程度上的模糊，这也叫做平滑或者低通滤波器。 滤波&emsp;&emsp;滤波本来应该是在傅立叶变换的频谱上对图像进行处理，但由于傅立叶的卷积特性 F[g*h]=F[g]F[h]滤波后的图像可以由原图像和滤波算子做卷积生成（频域的乘积 =&gt; 空域的卷积） g*h=F^{-1}[F[g]F[h]]高斯滤波​ 高斯滤波器是利用高斯核的一个2维的卷积算子（线性滤波器），对于抑制服从正态分布的噪声非常有效。 高斯分布一维高斯分布 &emsp;&emsp;其中，σ描述正态分布资料数据分布的离散程度，σ越大，数据分布越分散，σ越小，数据分布越集中。也称为是正态分布的形状参数，σ越大，曲线越扁平，反之，σ越小，曲线越瘦高。 二维高斯分布 高斯核&emsp;&emsp;高斯核主要有两个参数：高斯核的大小、离散程度σ 1h = fspecial('gaussian',hsize,sigma) 高斯核的大小：按高斯分布，理论上需要一个无限大的卷积核。但实际上，仅需要取均值周围3倍标准差内的值（高斯核单边大小为3σ），以外部分直接去掉即可。（没必要用很大的高斯核） 离散程度σ：σ越大，数据分布越分散，平滑程度越强，对高频的抑制程度更大。 &emsp;&emsp;高斯滤波再高斯滤波还是高斯滤波，两个σ的高斯滤波相当于一次$\\sqrt{2}\\sigma$。 Matlab实现Gauss123456789101112131415img = imread('Lenna.jpg');img = rgb2gray(img);sigma = 1;gausFilter = fspecial('gaussian', [5,5], sigma);gaus= imfilter(img, gausFilter, 'replicate');subplot(2,3,1),imshow(img,[]),title('原图');subplot(2,3,2),imshow(gausFilter,[]),title('高斯核');subplot(2,3,3),imshow(gaus,[]),title('高斯滤波后的图像');F1 = DFT(img);F2 = DFT(gausFilter);F3 = DFT(gaus);subplot(2,3,4),imshow(F1,[]),title('原图的频谱图');subplot(2,3,5),imshow(F2,[]),title('高斯核的频谱图');subplot(2,3,6),imshow(F3,[]),title('高斯滤波后的频谱图'); Gauss1234567function F = DFT(img)% 离散傅里叶变换频谱图img_Double = double(img);% 将灰度图归一化处理F = fft2(img_Double); % 二维快速傅里叶变换 F = fftshift(F); % FFT频谱平移F = log(1+abs(F)); % 频谱对数变换（由于幅度值范围很大，所以要取对数处理）end &emsp;&emsp;可以看出图像的高频部分受到了抑制，但并不是完全截断了高频。空域中的高斯到频域中依旧是高斯。 &emsp;&emsp; openCV实现（openCV提供的函数）cv :: GaussianBlur​ openCV自带的高斯滤波器：cv :: GaussianBlur 库文件：#include &lt;opencv2/imgproc.hpp&gt; 作用：该函数将源图像与指定的高斯内核进行卷积。 调用方法 void cv::GaussianBlur ( InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY = 0, int borderType = BORDER_DEFAULT ) 参量 src 输入图像；图像可以具有任意数量的通道，这些通道可以独立处理，但深度应为CV_8U，CV_16U，CV_16S，CV_32F或CV_64F。 dst 输出与src大小和类型相同的图像。 size 高斯核大小。ksize.width和ksize.height可以不同，但它们都必须为正数和奇数。或者，它们可以为零，然后根据sigma计算得出。 sigmaX X方向上的高斯核标准偏差。 sigmaY Y方向的高斯核标准差；如果sigmaY为零，则将其设置为等于sigmaX；如果两个sigmas为零，则分别从ksize.width和ksize.height计算得出（有关详细信息，请参见getGaussianKernel）；为了完全控制结果，而不管将来可能对所有这些语义进行的修改，建议指定所有ksize，sigmaX和sigmaY。 borderType 像素外推方法，请参见BorderTypes 代码12345678910111213141516171819202122#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/imgproc.hpp&gt;using namespace cv;int main() &#123; Mat src = imread(\"Lenna.jpg\", IMREAD_GRAYSCALE); //从文件中加载灰度图像 Mat dst; // 读取图片失败，则停止 if (src.empty()) &#123; printf(\"读取图像文件失败\"); system(\"pause\"); return 0; &#125; // 高斯滤波，高斯核大小为5*5 GaussianBlur(src, dst, Size(5,5), 0); imshow(\"dst\",dst); imwrite(\"gas_openCV.jpg\", dst); waitKey(); return 0;&#125; 结果 原图像和经高斯滤波后图像的傅立叶变换频谱 C++实现（函数自己编写）​ 如利用5*5的高斯核，对图像进行卷积。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;opencv2/opencv.hpp&gt;using namespace cv;/* 利用5*5的高斯核进行高斯滤波 img 输入原图像 dst 高斯滤波后的输出图像 */void Gaussian_Blur(Mat &amp;img, Mat &amp;dst)&#123; int Kernel[5][5] = &#123; &#123;1, 4, 7, 4, 1&#125;, &#123;4,16,26,16, 4&#125;, &#123;7,26,41,26, 7&#125;, &#123;4,16,26,16, 4&#125;, &#123;1, 4, 7, 4, 1&#125;, &#125;; //5*5的高斯核 // 与5*5的高斯核做卷积 for (int nrow = 2; nrow &lt; img.rows-2; nrow++) &#123; for (int ncol = 2; ncol &lt; img.cols-2; ncol++) &#123; int point = 0; for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt; 5; j++) &#123; point += Kernel[i][j] * img.ptr&lt;uchar&gt;(nrow+i-2)[ncol+j-2]; &#125; &#125; dst.ptr&lt;uchar&gt;(nrow)[ncol] = point/273; &#125; &#125;&#125;int main() &#123; Mat src = imread(\"Lenna.jpg\", IMREAD_GRAYSCALE); //从文件中加载灰度图像 Mat dst = src.clone(); // 读取图片失败，则停止 if (src.empty()) &#123; printf(\"读取图像文件失败\"); system(\"pause\"); return 0; &#125; // 高斯滤波，高斯核大小为5*5 GaussianBlur(src, dst, Size(5,5), 0); imshow(\"dst\",dst); imwrite(\"gas.jpg\", dst); waitKey(); return 0;&#125; 结果 ​ 该高斯滤波结果与openCV滤波结果基本一致。 均值滤波​ 均值滤波是空间域线性滤波器，其中所得到的图像中的每个像素具有的值等于其邻近的像素的输入图像中的平均值。它是低通（“模糊”）滤波器的一种形式。 openCV实现（openCV提供的函数）cv::blur​ openCV自带的均值滤波器：cv::blur 库文件：#include &lt;opencv2/imgproc.hpp&gt; 作用：使用归一化框滤波模糊图像。 调用方法 void cv::blur ( InputArray src, OutputArray dst, Size ksize, Point anchor = Point(-1,-1), int borderType = BORDER_DEFAULT ) 参数 src 输入图像；它可以具有任意数量的通道，这些通道可以独立处理，但深度应为CV_8U，CV_16U，CV_16S，CV_32F或CV_64F。 dst 输出与src大小和类型相同的图像。 大小 内核大小模糊。 锚 锚点 默认值Point（-1，-1）表示锚点位于内核中心。 borderType 用于推断图像外部像素的边框模式 代码12345678910111213141516171819202122#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/imgproc.hpp&gt;using namespace cv;int main() &#123; Mat src = imread(\"Lenna.jpg\", IMREAD_GRAYSCALE); //从文件中加载灰度图像 Mat dst; // 读取图片失败，则停止 if (src.empty()) &#123; printf(\"读取图像文件失败\"); system(\"pause\"); return 0; &#125; // 均值滤波，核大小为5*5 blur(src, dst, Size(5, 5)); imshow(\"dst\",dst); imwrite(\"box_openCV.jpg\", dst); waitKey(); return 0;&#125; 结果 原图像和经均值滤波后图像的傅立叶变换频谱 C++实现（函数自己编写）​ 利用5*5的均值滤波器 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;opencv2/opencv.hpp&gt;using namespace cv;/* 利用5*5的均值滤波 img 输入原图像 dst 均值滤波后的输出图像 */void Blur(Mat &amp;img, Mat &amp;dst)&#123; int Kernel[5][5] = &#123; &#123;1, 1, 1, 1, 1&#125;, &#123;1, 1, 1, 1, 1&#125;, &#123;1, 1, 1, 1, 1&#125;, &#123;1, 1, 1, 1, 1&#125;, &#123;1, 1, 1, 1, 1&#125;, &#125;; //5*5的核 // 与5*5的核做卷积 for (int nrow = 2; nrow &lt; img.rows-2; nrow++) &#123; for (int ncol = 2; ncol &lt; img.cols-2; ncol++) &#123; int point = 0; for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt; 5; j++) &#123; point += Kernel[i][j] * img.ptr&lt;uchar&gt;(nrow+i-2)[ncol+j-2]; &#125; &#125; dst.ptr&lt;uchar&gt;(nrow)[ncol] = point/25; &#125; &#125;&#125;int main() &#123; Mat src = imread(\"Lenna.jpg\", IMREAD_GRAYSCALE); //从文件中加载灰度图像 Mat dst = src.clone(); // 读取图片失败，则停止 if (src.empty()) &#123; printf(\"读取图像文件失败\"); system(\"pause\"); return 0; &#125; // 均值滤波，核大小为5*5 Blur(src, dst); imshow(\"dst\",dst); imwrite(\"box.jpg\", dst); waitKey(); return 0;&#125; 结果 中值滤波​ 中值滤波是一种非线性滤波器，利用采集领域的中值的方法，对噪声进行抑制。尤其对于椒盐噪声有用。 openCV实现（openCV提供的函数）cv::medianBlur​ openCV自带的均值滤波器：cv::medianBlur 库文件：#include &lt;opencv2/imgproc.hpp&gt; 作用：使用中值滤波模糊图像。 调用方法 void cv::medianBlur ( InputArray src, OutputArray dst, int ksize ) 参数 src 输入1、3或4通道图像; 当ksize为3或5时，图像深度应为CV_8U，CV_16U或CV_32F，对于较大的光圈，只能为CV_8U。 dst 与src具有相同大小和类型的目标数组。 大小 孔径线性尺寸；它必须是奇数且大于1，例如：3、5、7 … 代码12345678910111213141516171819202122#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/imgproc.hpp&gt;using namespace cv;int main() &#123; Mat src = imread(\"Lenna.jpg\", IMREAD_GRAYSCALE); //从文件中加载灰度图像 Mat dst; // 读取图片失败，则停止 if (src.empty()) &#123; printf(\"读取图像文件失败\"); system(\"pause\"); return 0; &#125; // 中值滤波，领域大小为5*5 medianBlur(src, dst, 5); imshow(\"dst\",dst); imwrite(\"median_openCV.jpg\", dst); waitKey(); return 0;&#125; 结果 C++实现（函数自己编写）代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;opencv2/opencv.hpp&gt;using namespace cv;/* 中值滤波 img 输入原图像 dst 中值滤波后的输出图像 ksize 领域大小 */void median_blur(Mat &amp;img, Mat &amp;dst, int ksize)&#123; for (int nrow = 2; nrow &lt; img.rows-2; nrow++) &#123; for (int ncol = 2; ncol &lt; img.cols-2; ncol++) &#123; vector&lt;int&gt; points; for (int i = 0; i &lt; ksize; i++) &#123; for (int j = 0; j &lt; ksize; j++) &#123; points.push_back(img.ptr&lt;uchar&gt;(nrow+i-2)[ncol+j-2]); &#125; &#125; for (int i = 0; i &lt; points.size()/2+1; i++) &#123; int minIndex = i; int j; for (j = i+1; j &lt; points.size(); j++) &#123; if (points[j] &lt; points[i]) &#123; minIndex = j; &#125; &#125; int temp = points[i]; points[i] = points[minIndex]; points[minIndex] = temp; &#125; dst.ptr&lt;uchar&gt;(nrow)[ncol] = points[points.size()/2]; &#125; &#125;&#125;int main() &#123; Mat src = imread(\"Lenna.jpg\", IMREAD_GRAYSCALE); //从文件中加载灰度图像 Mat dst = src.clone(); // 读取图片失败，则停止 if (src.empty()) &#123; printf(\"读取图像文件失败\"); system(\"pause\"); return 0; &#125; // 中值滤波，领域大小为5*5 median_blur(src, dst, 5); imshow(\"dst\",dst); imwrite(\"median.jpg\", dst); waitKey(); return 0;&#125; 结果 对比概述​ 从Lenna图无法看出上面三种滤波太大的区别，但可以明显看出在同样的领域大小下，高斯滤波的模糊化程度小于其余两种。 ​ 高斯滤波和均值滤波均是线性滤波，而中值滤波为非线性滤波。 ​ 这三种滤波适合处理的噪声不同，高斯滤波和均值滤波更适宜抑制高斯噪声，尤其是高斯滤波最适合高斯噪声，而中值滤波更适合抑制椒盐噪声。 高斯噪声的抑制程度对比​ 这是一张加入高斯噪声的图像。 ​ 下面分别该高斯噪声图像是用5*5的高斯滤波、均值滤波、中值滤波处理后的图像。 椒盐噪声的抑制程度对比​ 这是一张加入椒盐噪声的图像。 ​ 下面分别该椒盐噪声图像是用5*5的高斯滤波、均值滤波、中值滤波处理后的图像。","categories":[{"name":"Computer Vision","slug":"Computer-Vision","permalink":"https://gy23333.github.io/categories/Computer-Vision/"}],"tags":[{"name":"高斯滤波","slug":"高斯滤波","permalink":"https://gy23333.github.io/tags/%E9%AB%98%E6%96%AF%E6%BB%A4%E6%B3%A2/"},{"name":"均值滤波","slug":"均值滤波","permalink":"https://gy23333.github.io/tags/%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2/"},{"name":"中值滤波","slug":"中值滤波","permalink":"https://gy23333.github.io/tags/%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2/"}]},{"title":"Hexo搭建记录","slug":"Hexo搭建记录","date":"2020-02-25T08:13:22.000Z","updated":"2024-11-11T03:57:58.123Z","comments":true,"path":"2020/02/25/Hexo搭建记录/","link":"","permalink":"https://gy23333.github.io/2020/02/25/Hexo%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/","excerpt":"记录Hexo博客的搭建过程。包括Hexo的书写技巧与主题优化。","text":"记录Hexo博客的搭建过程。包括Hexo的书写技巧与主题优化。 Hexo书写技巧数学公式Hexo引入数学公式Hexo默认不支持数学公式，需要引入数学公式的响应环境。 更换Hexo的markdown渲染引擎 卸载原有的渲染器 hexo-renderer-marked，安装渲染器hexo-renderer-kramed 12npm uninstall hexo-renderer-markednpm install hexo-renderer-kramed 在next主题中开启mathJax开关 在 next/_config.yml 中将 mathjax 的 enable 打开。 /themes/next/_config.yml1234567# per_page为true，则需要每页自己添加`mathjax: true`；# per_page为false，则每页自动允许数学公式per_page: falseengine: mathjaxmathjax: enable: true mhchem: true 如此即可在每片文章中自动允许数学公式。 数学公式书写规则Hexo的markdown数学公式书写规则与Latex相同，具体规则见 Latex入门/数学公式 流程图Hexo引入flowchart流程图Hexo默认不支持markdown的流程图，需安装hexo-filter-flowchart插件。 安装hexo-filter-flowchart插件1npm install --save hexo-filter-flowchart 在主题配置文件下添加flowchart配置 /themes/next/_config.yml1234flowchart:# raphael: # optional, the source url of raphael.js# flowchart: # optional, the source url of flowchart.jsoptions: # options used for `drawSVG` 绘制流程图 范例：下列代码包在flow之间 1&lt;div id=\"flowchart-0\" class=\"flow-chart\"&gt;&lt;/div&gt; 流程图绘制规则流程图语法分为两个部分： 前半部分：定义流程图元素 后半部分：连接流程图元素 前半部分定义元素的语法 1tag&#x3D;&gt;type: content:&gt;url tag：元素标签，连接元素时用来代表元素。名称可以任意，一般为流程的英文缩写和数字的组合。 type：元素类型，一共有6种类型，分别为start、end、operation、subroutine、condition、inputoutput content：文本框中的内容，注意type:和content间一定要有空格 url：文本绑定的链接，点击可跳转 后半部分连接流程图元素 用-&gt;来连接两个元素 condition类型有yes和no两个分支，如cond(yes)和cond(no) 每个元素可以制定分支走向，默认向下，也可以用right指向右边，如sub1(right) 示例 1&lt;div id&#x3D;&quot;flowchart-2&quot; class&#x3D;&quot;flow-chart&quot;&gt;&lt;&#x2F;div&gt; Hexo引入Mermaid流程图 安装hexo-filter-mermaid-diagrams插件1npm install --save hexo-filter-mermaid-diagrams 在主题配置文件下添加mermaid配置 /themes/next/_config.yml12345# Mermaid tagmermaid: enable: true # Available themes: default | dark | forest | neutral theme: forest Mermaid官方文档 Mermaid在线编辑器 简单教程 代码块markdown的代码块写法有两种——```...``` 和{ % ... % }，这里主要使用```...``` 来实现功能。 格式写法一123&#96;&#96;&#96;[language] [title] [url] [link text]code snippet&#96;&#96;&#96; language: 语言名称，引导渲染引擎正确解析并高亮显示关键字 title: 代码块标题，将会显示在左上角 url: 链接地址，如果没有指定 link text 则会在右上角显示 link link text: 链接名称，指定 url 后有效，将会显示在右上角 url 必须为有效链接地址才会以链接的形式显示在右上角，否则将作为标题显示在左上角。以 url 为分界，左侧除了第一个单词会被解析为 language，其他所有单词都会被解析为 title，而右侧的所有单词都会被解析为 link text。 如果不想填写 title，可以在 language 和 url 之间添加至少三个空格。 示例 12345678&#96;&#96;&#96;C HelloWorld https:&#x2F;&#x2F;gy23333.github.io&#x2F;2020&#x2F;02&#x2F;25&#x2F;Hexo搭建记录&#x2F; 下载地址#include &lt;stdio.h&gt;int main()&#123; printf(&quot;hello world\\n&quot;); return 0;&#125;&#96;&#96;&#96; 效果 HelloWorld下载地址123456#include &lt;stdio.h&gt;int main()&#123; printf(\"hello world\\n\"); return 0;&#125; 写法二123&#123;% codeblock [title] [lang:language] [url] [link text] [additional options] %&#125;code snippet&#123;% endcodeblock %&#125; 设置语言 格式 123&#123;% codeblock [lang:language] %&#125;code snippet&#123;% endcodeblock %&#125; 示例 12345678&#123;% codeblock lang:C %&#125;#include &lt;stdio.h&gt;int main()&#123; printf(&quot;hello world\\n&quot;); return 0;&#125;&#123;% endcodeblock %&#125; 效果 123456#include &lt;stdio.h&gt;int main()&#123; printf(\"hello world\\n\"); return 0;&#125; 设置标题 格式 123&#123;% codeblock [title] %&#125;code snippet&#123;% endcodeblock %&#125; 示例 12345678&#123;% codeblock HelloWorld %&#125;#include &lt;stdio.h&gt;int main()&#123; printf(&quot;hello world\\n&quot;); return 0;&#125;&#123;% endcodeblock %&#125; 效果 HelloWorld123456#include &lt;stdio.h&gt;int main()&#123; printf(&quot;hello world\\n&quot;); return 0;&#125; 设置链接 格式 123&#123;% codeblock [url] [link text] %&#125;code snippet&#123;% endcodeblock %&#125; 示例 12345678&#123;% codeblock HelloWorld lang:C https:&#x2F;&#x2F;gy23333.github.io&#x2F;2020&#x2F;02&#x2F;25&#x2F;Hexo搭建记录&#x2F; 下载地址 %&#125;#include &lt;stdio.h&gt;int main()&#123; printf(&quot;hello world\\n&quot;); return 0;&#125;&#123;% endcodeblock %&#125; 效果 HelloWorld下载地址123456#include &lt;stdio.h&gt;int main()&#123; printf(\"hello world\\n\"); return 0;&#125; 是否显示行号 格式 123&#123;% codeblock [line_number:(true|false)] %&#125;code snippet&#123;% endcodeblock %&#125; line_number的默认值为true。 示例 12345678&#123;% codeblock lang:C line_number:false %&#125;#include &lt;stdio.h&gt;int main()&#123; printf(&quot;hello world\\n&quot;); return 0;&#125;&#123;% endcodeblock %&#125; 效果 #include &lt;stdio.h&gt;int main()&#123; printf(\"hello world\\n\"); return 0;&#125; 设置起始行号 格式 123&#123;% codeblock [first_line:number] %&#125;code snippet&#123;% endcodeblock %&#125; first_line的默认值为1。 示例 12345678&#123;% codeblock lang:C first_line:10 %&#125;#include &lt;stdio.h&gt;int main()&#123; printf(&quot;hello world\\n&quot;); return 0;&#125;&#123;% endcodeblock %&#125; 效果 101112131415#include &lt;stdio.h&gt;int main()&#123; printf(\"hello world\\n\"); return 0;&#125; 设置代码添加删除标记设置语言为 diff，可以在代码前添加 + 和 - 来使用如上所示的高亮增删行提示效果。 格式 123&#123;% codeblock lang:diff %&#125;code snippet&#123;% endcodeblock %&#125; 示例 123456789&#123;% codeblock lang:diff %&#125;#include &lt;stdio.h&gt;int main()&#123;- printf(&quot;delete\\n&quot;);+ printf(&quot;add\\n&quot;); return 0;&#125;&#123;% endcodeblock %&#125; 效果 12345678#include &lt;stdio.h&gt;int main()&#123;- printf(\"delete\\n\");+ printf(\"add\\n\"); return 0; &#125; Aplayer音乐播放器&emsp;&emsp;在blog中添加一个音乐播放页面 Aplayer官方中文文档 新建音乐页面 新建一个页面 1hexo new page music 在新生成的 /source/music/index.md 中 123title: 歌单date: 2020-02-25 19:50:11type: &quot;music&quot; 在主题的 _config.yml文件中，设置页面 123456menu:home: &#x2F; || homearchives: &#x2F;archives&#x2F; || archivecategories: &#x2F;categories&#x2F; || thtags: &#x2F;tags&#x2F; || tagsmusic: &#x2F;music&#x2F; || music 页面创建成功！ 使用hexo-tag-aplayer插件 安装hexo-tag-aplayer 1npm install --save hexo-tag-aplayer MeingJS支持 MetingJS 是基于Meting API 的 APlayer 衍生播放器，引入 MetingJS 后，播放器将支持对于 QQ音乐、网易云音乐、虾米、酷狗、百度等平台的音乐播放。 如果想在本插件中使用 MetingJS，请在 Hexo 配置文件 _config.yml 中设置： 12aplayer: meting: true 使用 MetingJS 播放器 12345&lt;!-- 简单示例 (id, server, type) --&gt;&#123;% meting \"60198\" \"netease\" \"playlist\" %&#125;&lt;!-- 进阶示例 --&gt;&#123;% meting \"60198\" \"netease\" \"playlist\" \"autoplay\" \"mutex:false\" \"listmaxheight:340px\" \"preload:none\" \"theme:#ad7a86\"%&#125; 有关选项列表如下: 选项 默认值 描述 id 必须值 歌曲 id / 播放列表 id / 相册 id / 搜索关键字 server 必须值 音乐平台: netease, tencent, kugou, xiami, baidu type 必须值 song（单首歌）, playlist（歌单）, album, search, artist fixed false 开启固定模式 mini false 开启迷你模式 loop all 列表循环模式：all, one,none order list 列表播放模式： list, random volume 0.7 播放器音量 lrctype 0 歌词格式类型 listfolded false 指定音乐播放列表是否折叠 storagename metingjs LocalStorage 中存储播放器设定的键名 autoplay true 自动播放，移动端浏览器暂时不支持此功能 mutex true 该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停 listmaxheight 340px 播放列表的最大长度 preload auto 音乐文件预载入模式，可选项： none, metadata, auto theme #ad7a86 播放器风格色彩设置 配置结束！ 手动建立歌单（不推荐）强迫症可手动将各平台的歌单整合在一起，这里提供一个下载各平台音乐的神器。 123456789101112131415161718192021222324252627&#123;% aplayerlist %&#125;&#123; \"narrow\": false, // （可选）播放器袖珍风格 \"autoplay\": true, // （可选) 自动播放，移动端浏览器暂时不支持此功能 \"mode\": \"random\", // （可选）曲目循环类型，有 'random'（随机播放）, 'single' (单曲播放), 'circulation' (循环播放), 'order' (列表播放)， 默认：'circulation' \"showlrc\": 3, // （可选）歌词显示配置项，可选项有：1,2,3 \"mutex\": true, // （可选）该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停 \"theme\": \"#e6d0b2\", // （可选）播放器风格色彩设置，默认：#b7daff \"preload\": \"metadata\", // （可选）音乐文件预载入模式，可选项： 'none' 'metadata' 'auto', 默认: 'auto' \"listmaxheight\": \"513px\", // (可选) 该播放列表的最大长度 \"music\": [ &#123; \"title\": \"CoCo\", \"author\": \"Jeff Williams\", \"url\": \"caffeine.mp3\", \"pic\": \"caffeine.jpeg\", \"lrc\": \"caffeine.txt\" &#125;, &#123; \"title\": \"アイロニ\", \"author\": \"鹿乃\", \"url\": \"irony.mp3\", \"pic\": \"irony.jpg\" &#125; ]&#125;&#123;% endaplayerlist %&#125; Hexo主题优化个性化回到顶部​ 猫耳FM同款回到顶部插件。 下载图片，将其添加到主题页面的 source\\images\\ 下； 在 /themes/next/source/css/_common/components/back-to-top.styl 中添加 12345678910111213141516171819202122//自定义回到顶部样式@media screen and (min-width: 900px) &#123; .back-to-top &#123; right: 60px; width: 70px; //图片素材宽度 height: 900px; //图片素材高度 top: -900px; bottom: unset; transition: all .5s ease-in-out; background: url(\"/images/scroll.png\"); position: fixed; //隐藏箭头图标 &gt; i &#123; display: none; &#125; &amp;.back-to-top-on &#123; bottom: unset; top: 100vh &lt; (900px + 200px) ? calc( 100vh - 900px - 200px ) : 0px; &#125;&#125;&#125; 效果图 鼠标点击效果​ 参考Yearito’s Blog有下面四种鼠标点击效果。在 themes\\next\\source\\js\\cursor\\ 中加入下列js文件 explosion.min.jslove.min.jsfireworks.jstext.js1\"use strict\";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=\"#F00\",a.radius=.1,a.alpha=.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)e.animatables[t].target.draw()&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)n.push(createParticule(e,t));anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:.1,duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:\"linear\",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:\"easeOutExpo\",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(\".fireworks\");if(canvasEl)&#123;var ctx=canvasEl.getContext(\"2d\"),numberOfParticules=30,pointerX=0,pointerY=0,tap=\"mousedown\",colors=[\"#FF1461\",\"#18FF92\",\"#5A87FF\",\"#FBF38C\"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+\"px\",canvasEl.style.height=window.innerHeight+\"px\",canvasEl.getContext(\"2d\").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;\"sidebar\"!==e.target.id&amp;&amp;\"toggle-sidebar\"!==e.target.id&amp;&amp;\"A\"!==e.target.nodeName&amp;&amp;\"IMG\"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(\"resize\",setCanvasSize,!1)&#125;1!function(e,t,a)&#123;function n()&#123;c(\".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;\"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=\"left:\"+d[e].x+\"px;top:\"+d[e].y+\"px;opacity:\"+d[e].alpha+\";transform:scale(\"+d[e].scale+\",\"+d[e].scale+\") rotate(45deg);background:\"+d[e].color+\";z-index:99999\");requestAnimationFrame(r)&#125;function o()&#123;var t=\"function\"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(\"div\");a.className=\"heart\",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(\"style\");a.type=\"text/css\";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(\"head\")[0].appendChild(a)&#125;function s()&#123;return\"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154class Circle &#123; constructor(&#123; origin, speed, color, angle, context &#125;) &#123; this.origin = origin this.position = &#123; ...this.origin &#125; this.color = color this.speed = speed this.angle = angle this.context = context this.renderCount = 0 &#125; draw() &#123; this.context.fillStyle = this.color this.context.beginPath() this.context.arc(this.position.x, this.position.y, 2, 0, Math.PI * 2) this.context.fill() &#125; move() &#123; this.position.x = (Math.sin(this.angle) * this.speed) + this.position.x this.position.y = (Math.cos(this.angle) * this.speed) + this.position.y + (this.renderCount * 0.3) this.renderCount++ &#125;&#125;class Boom &#123; constructor (&#123; origin, context, circleCount = 16, area &#125;) &#123; this.origin = origin this.context = context this.circleCount = circleCount this.area = area this.stop = false this.circles = [] &#125; randomArray(range) &#123; const length = range.length const randomIndex = Math.floor(length * Math.random()) return range[randomIndex] &#125; randomColor() &#123; const range = ['8', '9', 'A', 'B', 'C', 'D', 'E', 'F'] return '#' + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) &#125; randomRange(start, end) &#123; return (end - start) * Math.random() + start &#125; init() &#123; for(let i = 0; i &lt; this.circleCount; i++) &#123; const circle = new Circle(&#123; context: this.context, origin: this.origin, color: this.randomColor(), angle: this.randomRange(Math.PI - 1, Math.PI + 1), speed: this.randomRange(1, 6) &#125;) this.circles.push(circle) &#125; &#125; move() &#123; this.circles.forEach((circle, index) =&gt; &#123; if (circle.position.x &gt; this.area.width || circle.position.y &gt; this.area.height) &#123; return this.circles.splice(index, 1) &#125; circle.move() &#125;) if (this.circles.length == 0) &#123; this.stop = true &#125; &#125; draw() &#123; this.circles.forEach(circle =&gt; circle.draw()) &#125;&#125;class CursorSpecialEffects &#123; constructor() &#123; this.computerCanvas = document.createElement('canvas') this.renderCanvas = document.createElement('canvas') this.computerContext = this.computerCanvas.getContext('2d') this.renderContext = this.renderCanvas.getContext('2d') this.globalWidth = window.innerWidth this.globalHeight = window.innerHeight this.booms = [] this.running = false &#125; handleMouseDown(e) &#123; const boom = new Boom(&#123; origin: &#123; x: e.clientX, y: e.clientY &#125;, context: this.computerContext, area: &#123; width: this.globalWidth, height: this.globalHeight &#125; &#125;) boom.init() this.booms.push(boom) this.running || this.run() &#125; handlePageHide() &#123; this.booms = [] this.running = false &#125; init() &#123; const style = this.renderCanvas.style style.position = 'fixed' style.top = style.left = 0 style.zIndex = '999999999999999999999999999999999999999999' style.pointerEvents = 'none' style.width = this.renderCanvas.width = this.computerCanvas.width = this.globalWidth style.height = this.renderCanvas.height = this.computerCanvas.height = this.globalHeight document.body.append(this.renderCanvas) window.addEventListener('mousedown', this.handleMouseDown.bind(this)) window.addEventListener('pagehide', this.handlePageHide.bind(this)) &#125; run() &#123; this.running = true if (this.booms.length == 0) &#123; return this.running = false &#125; requestAnimationFrame(this.run.bind(this)) this.computerContext.clearRect(0, 0, this.globalWidth, this.globalHeight) this.renderContext.clearRect(0, 0, this.globalWidth, this.globalHeight) this.booms.forEach((boom, index) =&gt; &#123; if (boom.stop) &#123; return this.booms.splice(index, 1) &#125; boom.move() boom.draw() &#125;) this.renderContext.drawImage(this.computerCanvas, 0, 0, this.globalWidth, this.globalHeight) &#125;&#125;const cursorSpecialEffects = new CursorSpecialEffects()cursorSpecialEffects.init()123456789101112131415161718192021222324var a_idx = 0;jQuery(document).ready(function($) &#123; $(\"body\").click(function(e) &#123; var a = new Array(\"喜欢我\", \"不喜欢我\"); var $i = $(\"&lt;span/&gt;\").text(a[a_idx]); var x = e.pageX, y = e.pageY; $i.css(&#123; \"z-index\": 99999, \"top\": y - 28, \"left\": x - a[a_idx].length * 8, \"position\": \"absolute\", \"color\": \"#ff7a45\" &#125;); $(\"body\").append($i); $i.animate(&#123; \"top\": y - 180, \"opacity\": 0 &#125;, 1500, function() &#123; $i.remove(); &#125;); a_idx = (a_idx + 1) % a.length; &#125;);&#125;); ​ 在 themes\\next\\layout_custom\\custom.swig 中加入 123456789101112&#123;# 鼠标点击特效 #&#125;&#123;% if theme.cursor_effect == \"fireworks\" %&#125; &lt;script async src=\"/js/cursor/fireworks.js\"&gt;&lt;/script&gt;&#123;% elseif theme.cursor_effect == \"explosion\" %&#125; &lt;canvas class=\"fireworks\" style=\"position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;\" &gt;&lt;/canvas&gt; &lt;script src=\"//cdn.bootcss.com/animejs/2.2.0/anime.min.js\"&gt;&lt;/script&gt; &lt;script async src=\"/js/cursor/explosion.min.js\"&gt;&lt;/script&gt;&#123;% elseif theme.cursor_effect == \"love\" %&#125; &lt;script async src=\"/js/cursor/love.min.js\"&gt;&lt;/script&gt;&#123;% elseif theme.cursor_effect == \"text\" %&#125; &lt;script async src=\"/js/cursor/text.js\"&gt;&lt;/script&gt;&#123;% endif %&#125; ​ 如果 custom.swig 文件不存在，需要手动新建并在布局页面 themes\\next\\layout_layout.swig 中 body 末尾引入： 1&#123;% include '_custom/custom.swig' %&#125; ​ 在主题配置文件 themes\\next_config.yml 中添加： 12# mouse click effect: fireworks | explosion | love | textcursor_effect: fireworks ​ 则可通过配置主题配置文件来设置鼠标点击效果。 ​ 如explosion的效果 Hexo常见问题hexo d报错1fatal: Authentication failed for ‘https:&#x2F;&#x2F;github.com&#x2F;gy23333&#x2F;gy23333.github.io.git&#x2F;‘ Github开启二次验证后导致博客提交错误，解决方法参考GitHub二次验证带来的问题。 生成Personal access tokens令牌码，使用该码作为密码登录。 登录Github Setttings -&gt; Developer Settings -&gt; Personal access tokens -&gt; Generate new token 设定token的Expiration为no expiration（永久），全选scopes 生成token，复制记录 hexo d，输入Github用户名和密码（token） 参考 hexo官方文档 Yearito’s Blog|Hexo 搭建个人博客系列：写作技巧篇 数学公式 猪猪侠 | Hexo 下的语法高亮拓展修改 st=>start: Start|past:>http://www.google.com[blank] e=>end: End:>http://www.google.com op1=>operation: My Operation|past op2=>operation: Stuff|current sub1=>subroutine: My Subroutine|invalid cond=>condition: Yes or No?|approved:>http://www.google.com c2=>condition: Good idea|rejected io=>inputoutput: catch something...|request st->op1(right)->cond cond(yes, right)->c2 cond(no)->sub1(left)->op1 c2(yes)->io->e c2(no)->op2->e{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);st=>start: Start|past:>http://www.google.com[blank] e=>end: End:>http://www.google.com op1=>operation: My Operation|past op2=>operation: Stuff|current sub1=>subroutine: My Subroutine|invalid cond=>condition: Yes or No?|approved:>http://www.google.com c2=>condition: Good idea|rejected io=>inputoutput: catch something...|request st->op1(right)->cond cond(yes, right)->c2 cond(no)->sub1(left)->op1 c2(yes)->io->e c2(no)->op2->e{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-1-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-1-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-1\", options);st=>start: 开始 op1=>operation: 操作1 cond1=>condition: Yes or No? sub=>subroutine: 子程序 e=>end: 结束 st->op1->cond1 cond1(yes)->e cond1(no)->sub(right)->op1{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-2-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-2-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-2\", options);st=>start: 开始 op1=>operation: 操作1 cond1=>condition: Yes or No? sub=>subroutine: 子程序 e=>end: 结束 st->op1->cond1 cond1(yes)->e cond1(no)->sub(right)->op1{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-3-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-3-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-3\", options);","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://gy23333.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://gy23333.github.io/tags/Hexo/"},{"name":"blog","slug":"blog","permalink":"https://gy23333.github.io/tags/blog/"}]},{"title":"Latex入门","slug":"Latex入门","date":"2020-02-13T15:22:24.000Z","updated":"2024-11-11T03:57:58.118Z","comments":true,"path":"2020/02/13/Latex入门/","link":"","permalink":"https://gy23333.github.io/2020/02/13/Latex%E5%85%A5%E9%97%A8/","excerpt":"​ Latex是基于Tex的排版系统，可以方便的生成复杂公式，常常应用于论文的编写。本文介绍在Mac环境下利用Texpad编写Latex。","text":"​ Latex是基于Tex的排版系统，可以方便的生成复杂公式，常常应用于论文的编写。本文介绍在Mac环境下利用Texpad编写Latex。 在Mac环境下编写LatexMacTeX​ 在Mac环境下必需下载相应的 MacTeX ​ 下载完成后会得到下面四个app。 ​ 其中TeXShop是Latex的编辑器，但功能较为简单，建议使用Sublime+Skim 或 TeXpad Texpad​ 一款功能强大的Latex编辑器 Texpad for macOS Latex基本结构​ 每个tex文件都包含导言区和正文区，导言区用于设置全局设置，正文区用于编写显示的内容。 导言区文件类型1\\documentclass&#123;article&#125; %文件类型，会根据不同的文件类型有不同的排版，例如article, book, letter等等 标题区​ 包括title、author、date等等，在正文中调用 1\\maketitle ​ 此时，会显示标题区内容。 正文区正文​ 正文部分直接输入，但是要注意： 使用空行分段。单个换行不会引起分段，必须中间有空行，多个空行和一个空行效果一致。 段前不用空格。Latex会自动段前缩进，即使段前打了空格也会被省略。 汉字后的空格会被省略，但英文字母之间不会，多个空格和一个空格效果一致。 公式​ 在 $ $ 中插入公式——行内公式，公式处于行内； ​ 在 中插入公式——行间公式，公式前后自动换行，公式居中。 例子1234567891011121314151617181920212223% exemple.tex%--------------------导言区-------------------% 用于设置性质（全局设置），自定义一些命令\\documentclass&#123;article&#125; %文件类型，会根据不同的文件类型有不同的排版，例如article, book, letter等等%----------标题区------------\\title&#123;Tex Introduction&#125;\\author&#123;GuoYi&#125;\\date&#123;\\today&#125; %\\today会自动同步到今天%--------------------正文区-------------------% 一个tex有且只有一个document部分\\begin&#123;document&#125; \\maketitle %实际输出标题区 Hello world! % 正文中空行表换行 % $行内公式$ $$行间公式$$ Let $f(x)$ be defined by the formula $$f(x)=2sinx$$ which is a polynomial of degree 2. \\end&#123;document&#125; Latex使用中文CTEX文档（推荐）​ 在UTF-8编码情况下，使用CTEX文档。 123456\\documentclass[UTF8]&#123;ctexart&#125;\\title&#123;标题&#125;\\begin&#123;document&#125; \\maketitle 中文输入。&#123;\\kaishu 这里是楷体显示&#125;，&#123;\\songti 这里是宋体显示&#125;，&#123;\\heiti 这里是黑体显示&#125;，&#123;\\fangsong 这里是仿宋显示&#125;。\\end&#123;document&#125; 字体字体族​ 字体族共有3种：罗马字体族（Roman Family）、无衬线字体族（Sans Serif Family）、打字机字体族（Typewriter Family）。 ​ 正文一般默认使用罗马字体族，可用下面两种字体族命令规定字体族。 12345678910\\documentclass[UTF8]&#123;ctexart&#125;\\begin&#123;document&#125; %字体族设置（罗马字体族、无衬线字体族、打字机字体族） \\textrm&#123;Roman Family&#125; \\textsf&#123;Sans Serif Family&#125; \\texttt&#123;Typewriter Family&#125; \\rmfamily Roman Family \\sffamily Sans Serif Family \\ttfamily Typewriter Family &#123;\\rmfamily Roman Family&#125; &#123;\\sffamily Sans Serif Family&#125; &#123;\\ttfamily Typewriter Family&#125;\\end&#123;document&#125; 字体系列​ 字体系列共有2种：中等（medium）、加宽加粗（bold extended）。 ​ 正文默认使用中等字体系列。 12345678\\documentclass[UTF8]&#123;ctexart&#125;\\begin&#123;document&#125; %字体系列设置(粗细、宽度) \\textmd&#123;Medium Series&#125; \\textbf&#123;Boldface Series&#125; &#123;\\mdseries Medium Series&#125; &#123;\\bfseries Boldface Series&#125; \\end&#123;document&#125; 字体形状​ 字体形状共有4种：直立（Upright Shape）、意大利（Italic Shape）、倾斜（Slanted Shape）、小型大写（Small Caps Shape）。 ​ 正文默认使用直立字体形状。 12345678\\documentclass[UTF8]&#123;ctexart&#125;\\begin&#123;document&#125; %字体形状（直立、意大利、倾斜、小型大写） \\textup&#123;Upright Shape&#125; \\textit&#123;Italic Shape&#125; \\textsl&#123;Slanted Shape&#125; \\textsc&#123;Small Caps Shape&#125; &#123;\\upshape Upright Shape&#125; &#123;\\itshape Italic Shape&#125; &#123;\\slshape Slanted Shape&#125; &#123;\\scshape Small Caps Shape&#125;\\end&#123;document&#125; 中文字体​ 中文字体共有4种：宋体、黑体、仿宋、楷书。 ​ ctexart文体，正文中的中文默认为宋体。 123456\\documentclass[UTF8]&#123;ctexart&#125;\\begin&#123;document&#125; %中文字体（宋体、黑体、仿宋、楷书） &#123;\\songti 宋体&#125; \\quad &#123;\\heiti 黑体&#125; \\quad &#123;\\fangsong 仿宋&#125; \\quad &#123;\\kaishu 楷书&#125;\\end&#123;document&#125; %\\quad为tap ​ 中文字体同样包含粗体和斜体。 123456\\documentclass[UTF8]&#123;ctexart&#125;\\begin&#123;document&#125; %中文字体的粗体和斜体 中文字体的\\textbf&#123;粗体&#125;和\\textit&#123;斜体&#125;\\end&#123;document&#125; 字体大小英文字体大小​ 以\\normalsize的大小为基础，来设置字体大小。 ​ 正文字体默认为\\normalsize，\\normalsize字体大小默认为10pt。 12345678910111213141516\\documentclass[12pt]&#123;ctexart&#125; %[]中可设置normalsize字体大小\\begin&#123;document&#125; % 字体大小 &#123;\\tiny tiny&#125;\\\\ % \\\\为换行 &#123;\\scriptsize scriptsize&#125;\\\\ &#123;\\footnotesize footnotesize&#125;\\\\ &#123;\\small small&#125;\\\\ &#123;\\normalsize normalsize&#125;\\\\ &#123;\\large large&#125;\\\\ &#123;\\Large Large&#125;\\\\ &#123;\\LARGE LARGE&#125;\\\\ &#123;\\huge huge&#125;\\\\ &#123;\\Huge Huge&#125;\\\\ \\end&#123;document&#125; 中文字体大小​ 以五号字体的大小为基础，来设置字体大小。 ​ 正文字体默认为 五号字体。 123456789101112\\documentclass&#123;ctexart&#125;\\begin&#123;document&#125; % 中文字体大小 \\zihao&#123;2&#125; 二号中文字体 \\zihao&#123;-2&#125; 小二号中文字体 \\zihao&#123;5&#125; 五号中文字体 \\zihao&#123;-5&#125; 小五号中文字体\\end&#123;document&#125; 篇章结构提纲​ \\section可以在正文中构建小节，相当于一级标题，在section前加sub套娃形成二级、三级、四级等等标题。 12345678\\documentclass&#123;article&#125;\\begin&#123;document&#125; \\section&#123;section title&#125; %一级标题 \\subsection&#123;subsection title&#125; %二级标题 \\subsubsection&#123;subsubsection title&#125; %三级标题 \\section&#123;section title&#125; %三级标题\\end&#123;document&#125; 目录​ \\tableofcontents 可生成目录。 123456789\\documentclass&#123;article&#125;\\begin&#123;document&#125; \\tableofcontents %生成目录 \\section&#123;section title&#125; %一级标题 \\subsection&#123;subsection title&#125; %二级标题 \\section&#123;section title&#125; %三级标题\\end&#123;document&#125; 正文 使用空行分段。单个换行不会引起分段，必须中间有空行，多个空行和一个空行效果一致。 段前不用空格。Latex会自动段前缩进，即使段前打了空格也会被省略。 汉字后的空格会被省略，但英文字母之间不会，多个空格和一个空格效果一致。 \\ \\ 用来换行。换行不会新开一个段落。 \\par 分段。一般不使用。 12345678\\documentclass&#123;article&#125;\\begin&#123;document&#125; This is an article. This is an article. This is an article. %空行——新开一个段落 This is an article. This is an article. This is an article.\\\\Change the line. Change the line. Change the line. % \\\\——换行\\end&#123;document&#125; 特殊字符空白符号 英文字符之间多个空格当一个空格处理，中文字符之间的空格无效； 中文之间插入英文，在英文片段前后自动添加空格； 其他空格命令 命令 功能 \\quad 1em的空白（推荐） \\qquad 2em的空白 \\, 1/6em的空白 \\thinspace 1/6em的空白 \\enspace 0.5em的空白 \\ 空格（推荐） ～ 硬空格 \\kern 指定宽度 产生指定宽度的空白（宽度可为副值） \\hspace{指定宽度} 产生指定宽度的空白（宽度可为副值） \\hphantom{} 占位宽度的空格（空格长度等于{}内的字符应有的长度） \\hfill 产生一行的空格（前后分别在行首和行尾） 123456789101112131415161718192021222324252627282930313233343536\\documentclass&#123;article&#125;\\begin&#123;document&#125; % 1em的空白 a\\textbackslash quad b --------------- a\\quad b % 2em的空白 a\\textbackslash qquad b -------------- a\\qquad b % 1/6em的空白 a\\textbackslash,b --------------------- a\\,b % 1/6em的空白 a\\textbackslash thinspace b --------- a\\thinspace b % 0.5em的空白 a\\textbackslash enspace b ------------ a\\enspace b % 空格 a\\textbackslash b ----------------------- a\\ b % 硬空格 a\\~b ------------------------ a~b % 产生指定宽度的空白（宽度可为副值） a\\textbackslash kern 1em b ----------- a\\kern 1em b % 产生指定宽度的空白（宽度可为副值） a\\textbackslash hspace\\&#123;1em\\&#125;b ------ a\\hspace&#123;1em&#125; b % 占位宽度的空格（空格长度等于&#123;&#125;内的字符应有的长度） a\\textbackslash hphantom\\&#123;xyz\\&#125;b --- a\\hphantom&#123;xyz&#125;b % 产生一行的空格（前后分别在行首和行尾） a\\textbackslash hfill b ------------------ a\\hfill b\\end&#123;document&#125; 控制符​ 对于有特殊含义的符号，要想其正常显示，需在符号前加 \\ ，而 \\ 本身由于\\ \\表示换行，所以用 \\textbacklash 表示。 控制符 命令 \\ \\textbackslash # \\# $ \\$ {} \\{\\} 排版符号 排版符号 命令 § \\S ¶ \\P † \\dag ‡ \\ddag © \\copyright £ \\pounds 标志符号12345\\documentclass&#123;article&#125;\\begin&#123;document&#125; \\TeX \\quad \\LaTeX\\end&#123;document&#125; 引号 符号名称 符号 命令 左单引号 ‘ ` 右单引号 ’ ‘ 左双引号 “ `` 右双引号 ” ‘’ 插图基本​ 在LaTeX中，插图是由 graphics 或 graphicx 宏包所使用的 \\includegraphics 命令完成的。graphics 和 graphicx 功能差别不大，但 graphicx 使用更方便一些。 ​ 插图适用格式：EPS、PDF、PNG、JPEG、BMP ​ 搜索路径默认为tex文件所在文件夹，也可用\\graphicspath 对搜索路径进行修改。 12345678910\\documentclass&#123;article&#125;% 调用graphicx宏包，使用插图功能\\usepackage&#123;graphicx&#125;\\graphicspath&#123;&#123;\\figures&#125;&#125; %修改搜索路径\\begin&#123;document&#125; % 基于搜索路径插入图像 \\includegraphics&#123;Sx2ec.png&#125;\\end&#123;document&#125; 命令选项大小缩放​ width、height 和 scale 设置图形的宽度、高度或缩放比例。 1234567891011\\documentclass&#123;article&#125;% 调用graphicx宏包，使用插图功能\\usepackage&#123;graphicx&#125;\\begin&#123;document&#125; % 基于搜索路径插入图像 \\includegraphics[width=10em]&#123;figures/Sx2ec&#125; %宽度为10em \\includegraphics[height=5cm]&#123;figures/Sx2ec&#125; %高度为10cm \\includegraphics[scale=0.5]&#123;figures/Sx2ec&#125; %缩放0.5倍\\end&#123;document&#125; 旋转​ angle 选项可以让图形逆时针旋转一定的角度，旋转的中心可以用 origin 选项确定。origin的值可以用字符 l，r，c，t，b，B中的一个或者两个，分别表示左，右，中，上，下和基线，默认值为 lb。 12345678910\\documentclass&#123;article&#125;% 调用graphicx宏包，使用插图功能\\usepackage&#123;graphicx&#125;\\begin&#123;document&#125; % 基于搜索路径插入图像 \\includegraphics[angle=90]&#123;figures/Sx2ec&#125; %基于左下，逆时针旋转90度 \\includegraphics[angle=-45,origin=c]&#123;figures/Sx2ec&#125; %基于中心，顺时针旋转45度\\end&#123;document&#125; 表格​ LaTeX表格使用环境录入：在文本或数学模式下都可以使用 tabular 环境，在数学模式下还可以使用 array 环境。tabular 和 array 的一般格式基本相同。 基本​ 每行后用 \\\\ 表示换行，一行内的不同列之间用 &amp; 分开。 ​ 列格式说明，用 l、c、r 分别表示 左对齐、居中、右对齐。 123456789101112131415\\documentclass&#123;article&#125;\\begin&#123;document&#125; % \\begin&#123;tabular&#125;[(垂直对齐)]&#123;(列格式说明)&#125; % (表项)&amp;(表项)&amp;...&amp;(表项)\\\\ % .... % \\end&#123;tabular&#125; \\begin&#123;tabular&#125;&#123;lcr&#125; %三列 分别为：左对齐、居中、右对齐 l &amp; c &amp; r \\\\ %一行 left &amp; center &amp; right \\\\ %一行 \\end&#123;tabular&#125;\\end&#123;document&#125; 表格线​ 列表格线：在列格式说明中加 | ​ 行表格线：\\hline ​ 需要双线是重复 || 或 \\hline\\hline。 123456789101112131415161718\\documentclass&#123;article&#125;\\begin&#123;document&#125; % \\begin&#123;tabular&#125;[(垂直对齐)]&#123;(列格式说明)&#125; % (表项)&amp;(表项)&amp;...&amp;(表项)\\\\ % .... % \\end&#123;tabular&#125; \\begin&#123;tabular&#125;&#123;|l|c|r|&#125; %三列 分别为：左对齐、居中、右对齐 \\hline l &amp; c &amp; r \\\\ %一行 \\hline \\hline left &amp; center &amp; right \\\\ %一行 \\hline \\end&#123;tabular&#125;\\end&#123;document&#125; 垂直对齐​ 确定表格的基线位置。 t 按表格顶部对齐 b 按表格底部对齐 默认 垂直居中 123456789101112131415161718192021222324252627282930313233343536\\documentclass&#123;article&#125;\\begin&#123;document&#125; ---line1--- \\begin&#123;tabular&#125;&#123;|rr|&#125; %默认垂直居中 \\hline Input &amp; Output \\\\ \\hline $-2$ &amp; 4 \\\\ 0 &amp; 0 \\\\ 2 &amp; 4 \\\\ \\hline \\end&#123;tabular&#125; ---line2--- \\begin&#123;tabular&#125;[t]&#123;|rr|&#125; %按表格顶部对齐 \\hline Input &amp; Output \\\\ \\hline $-2$ &amp; 4 \\\\ 0 &amp; 0 \\\\ 2 &amp; 4 \\\\ \\hline \\end&#123;tabular&#125; ---line3--- \\begin&#123;tabular&#125;[b]&#123;|rr|&#125; %按表格底部对齐 \\hline Input &amp; Output \\\\ \\hline $-2$ &amp; 4 \\\\ 0 &amp; 0 \\\\ 2 &amp; 4 \\\\ \\hline \\end&#123;tabular&#125;\\end&#123;document&#125; 列格式说明 l 本列左对齐 c 本列居中 r 本列右对齐 p{(宽)} 本列具有固定宽度，且可以自动换行。 | 画一条竖线 @{(内容)} 添加任意内容，不占表项计数。 *{(计数)}{(列格式说明符)} 将给出的列格式说明符重复多次。 1234567891011\\documentclass&#123;article&#125;\\begin&#123;document&#125; \\begin&#123;tabular&#125;&#123;|c|*&#123;3&#125;&#123;r@&#123;.&#125;l|&#125;&#125; \\hline revenue &amp; 1234&amp;6 &amp; 2345&amp;23 &amp; 239&amp;0 \\\\ \\hline cost &amp; 231&amp;24 &amp; 123&amp;0 &amp; 329&amp;18 \\\\ \\hline \\end&#123;tabular&#125;\\end&#123;document&#125; 表格单元的合并与分割合并行合并​ \\multicolumn{(项数)}{(新列格式)}{(内容)} 可用于将一行中的几个不同的表项合并为一项。 12345678910111213\\documentclass&#123;article&#125;\\begin&#123;document&#125; \\begin&#123;tabular&#125;&#123;|r|r|&#125; \\hline \\multicolumn&#123;2&#125;&#123;|c|&#125;&#123;score&#125; \\\\ %居中合并两个单元格，内容为score \\hline Maths &amp; English \\\\ \\hline 80 &amp; 85 \\\\ \\hline \\end&#123;tabular&#125;\\end&#123;document&#125; 列合并\\cline（容易实现，但效果不佳）​ \\cline{(起始列号)-(终止列号)} 和 \\hline 一样可以画水平的表格线，但是 \\cline 可以规定表格线起始和终止的列号，即可相当于合并列单元。 1234567891011\\documentclass&#123;article&#125;\\begin&#123;document&#125; \\begin&#123;tabular&#125;&#123;|c|r|r|&#125; \\hline &amp; Maths &amp; English \\\\ \\cline&#123;2-3&#125; %只画2到3列 score &amp; 80 &amp; 85 \\\\ \\hline \\end&#123;tabular&#125;\\end&#123;document&#125; \\multirow （效果较好）​ \\multirow{(行数)}{(宽度)}{(内容)} 或 \\multirow{(行数)}*{(内容)} ​ 第一种形式可自动换行。 ​ 使用\\multirow得先引入宏包multirow。 1234567891011121314\\documentclass&#123;article&#125;% 使用\\multirow得先引入宏包multirow\\usepackage&#123;multirow&#125;\\begin&#123;document&#125; \\begin&#123;tabular&#125;&#123;|c|r|r|&#125; \\hline \\multirow&#123;2&#125;*&#123;score&#125; &amp; Maths &amp; English \\\\ \\cline&#123;2-3&#125; &amp; 80 &amp; 85 \\\\ \\hline \\end&#123;tabular&#125;\\end&#123;document&#125; 拆分​ \\diagbox 自动判断是把表头分成两部分还是三部分。 ​ 使用\\diagbox得先引入宏包diagbox。 12345678910111213141516\\documentclass&#123;article&#125;% 使用\\diagbox得先引入宏包diagbox\\usepackage&#123;diagbox&#125;\\begin&#123;document&#125; \\begin&#123;tabular&#125;&#123;|c|c|c|&#125; \\hline \\diagbox&#123;Letter&#125;&#123;Number&#125;&amp; 1 &amp; 2 \\\\ \\hline a &amp; 0.1 &amp; 0.3 \\\\ \\hline b &amp; 0.3 &amp; 0.8 \\\\ \\hline \\end&#123;tabular&#125;\\end&#123;document&#125; 浮动体​ 浮动体用于实现灵活分页，给图表添加标题，交叉应用。 ​ 图片使用 figure环境，表格使用 table环境。 格式（以figure为例）： 123\\begin&#123;figure&#125;[&lt;允许位置&gt;]&lt; 任意内容 &gt;\\end&#123;figure&#125; &lt;允许位置&gt;参数（默认tbp）： h —- 此处（here），代码所在的上下文位置 t —- 页顶（top），代码所在页面或之后的页面的顶部 b —- 页底（bottom），代码所在页面或之后的页面的底部 p —- 独立一页（page），浮动页面 123456789101112131415161718192021222324252627282930\\documentclass&#123;ctexart&#125;% 调用graphicx宏包，使用插图功能\\usepackage&#123;graphicx&#125;\\begin&#123;document&#125; 下面\\ref&#123;Latex&#125; 是\\LaTeX&#123;&#125;的标志。% \\ref为引用标签 \\begin&#123;figure&#125;[htbp] %htbp可以让图表随文字运动 \\centering %浮动体居中 \\includegraphics&#123;figures/Sx2ec&#125; \\caption&#123;\\LaTeX 的标志&#125; %标题 \\label&#123;Latex&#125; %标签（用于引用） \\end&#123;figure&#125; 引用下面\\ref&#123;InAndOut&#125; 中的数据。% \\ref为引用标签 \\begin&#123;table&#125;[htbp] %htbp可以让图表随文字运动 \\centering %浮动体居中 \\begin&#123;tabular&#125;&#123;|rr|&#125; \\hline Input &amp; Output \\\\ \\hline $-2$ &amp; 4 \\\\ 0 &amp; 0 \\\\ 2 &amp; 4 \\\\ \\hline \\end&#123;tabular&#125; \\caption&#123;输入输出数据&#125; %标题 \\label&#123;InAndOut&#125; %标签（用于引用） \\end&#123;table&#125;\\end&#123;document&#125; 数学公式​ LaTeX 将排版内内容分为文本模式和数学模式。文本模式适用于普通文本排版，数学模式用于数学公式排版。 基本行内公式​ 不需换行的公式。下面三种方法均可生成行内公式。 $ 美元符号​ 格式： 小括号​ 格式： \\(&lt;数学公式&gt;\\) math环境​ 格式： \\begin{math}&lt;数学公式&gt;\\end{math} ​ 使用math环境需引入 amsmath宏包。 1234567891011121314\\documentclass&#123;ctexart&#125;\\usepackage&#123;amsmath&#125;\\begin&#123;document&#125; % $ 美元符号 交换律是 $a+b=b+a$，如 $1+2=2+1=3$。 % 小括号 交换律是 \\(a+b=b+a\\)，如 \\(1+2=2+1=3\\)。 %math环境 交换律是 \\begin&#123;math&#125; a+b=b+a\\end&#123;math&#125;，如 \\begin&#123;math&#125; 1+2=2+1=3\\end&#123;math&#125;。\\end&#123;document&#125; 行间公式​ 行间公式换行不分段。下面三种方法均可生成行间公式。 $ 美元符号​ 格式： $$$&lt;数学公式&gt;$$$ 中括号​ 格式： \\[&lt;数学公式&gt;\\] displaymath环境​ 格式： \\begin{displaymath}&lt;数学公式&gt;\\end{displaymath} ​ 使用displaymath环境需引入 amsmath宏包。 1234567891011121314151617181920212223\\documentclass&#123;ctexart&#125;\\usepackage&#123;amsmath&#125;\\begin&#123;document&#125; % $ 美元符号 交换律是 $$a+b=b+a$$ 如 $$1+2=2+1=3$$ % 中括号 交换律是 \\[a+b=b+a\\] 如 \\[1+2=2+1=3\\] %displaymath环境 交换律是 \\begin&#123;displaymath&#125; a+b=b+a\\end&#123;displaymath&#125; 如 \\begin&#123;displaymath&#125; 1+2=2+1=3\\end&#123;displaymath&#125;\\end&#123;document&#125; 自动编号公式——equation环境​ equation环境可以对公式自动编号，此时添加 \\label 标签方便引用。 ​ 格式：\\begin{equation}&lt;数学公式&gt;\\end{equation} 12345678\\documentclass&#123;ctexart&#125;\\begin&#123;document&#125; 调用下面的公式\\ref&#123;eq:exchange&#125; \\begin&#123;equation&#125; a+b=b+a \\label&#123;eq:exchange&#125; \\end&#123;equation&#125;\\end&#123;document&#125; 数学结构上标与下标上标​ 用 ^{} 表示上标。 123456\\documentclass&#123;article&#125;\\begin&#123;document&#125; % 上标^&#123;&#125; $ f(x)=x^2 + x^&#123;20&#125; + 2x^&#123;4x^2+1&#125; $\\end&#123;document&#125; 下标​ 用 _{} 表示下标。 123456\\documentclass&#123;article&#125;\\begin&#123;document&#125; % 下标_&#123;&#125; $a_0,a_1,a_2,...,a_&#123;100&#125;$\\end&#123;document&#125; 其他上下标 符号 命令 ‘ ‘ ° ^\\circ 求和​ 格式： \\sum_{&lt;下限&gt;}^{&lt;上限&gt;} &lt;函数&gt; ​ 或（上面的格式上下限在右边，下面的\\limit格式上下限在正上下方 ） ​ \\sum\\limits_{&lt;下限&gt;}^{&lt;上限&gt;} &lt;函数&gt; 1234567\\documentclass&#123;ctexart&#125;\\begin&#123;document&#125; $ \\sum_&#123;i=0&#125;^&#123;n&#125; a_i $ %上下限在右边 \\quad $ \\sum\\limits_&#123;i=0&#125;^&#123;n&#125; a_i $ %上下限在正上下方\\end&#123;document&#125; 积分​ 格式: \\int_{&lt;下限&gt;}^{&lt;上限&gt;} &lt;函数&gt; d\\! &lt;变量&gt; ​ 多重积分用 \\iint \\iiint 12345\\documentclass&#123;ctexart&#125;\\begin&#123;document&#125; $ \\int_0^1 f(t) d\\! t $\\end&#123;document&#125; 分式​ 格式： \\frac &lt;分子&gt;&lt;分母&gt; 12345\\documentclass&#123;article&#125;\\begin&#123;document&#125; $ \\frac 12 + \\frac 1a = \\frac&#123;2+a&#125;&#123;2a&#125; $\\end&#123;document&#125; 根式​ 格式： \\sqrt[&lt;开方次数&gt;]{&lt;被开方数&gt;} 12345\\documentclass&#123;article&#125;\\begin&#123;document&#125; $ \\sqrt[n]&#123;\\frac&#123;x^2+\\sqrt&#123;2&#125;&#125;&#123;x+y&#125;&#125; $\\end&#123;document&#125; 矩阵​ amsmath宏包提供一下矩阵形式。 ​ 编写格式与表格相似。 123456789101112\\documentclass&#123;article&#125;% 使用矩阵，引入amsmath宏包\\usepackage&#123;amsmath&#125;\\begin&#123;document&#125; $ A = \\begin&#123;pmatrix&#125; a_&#123;11&#125; &amp; a_&#123;12&#125; &amp; a_&#123;13&#125; \\\\ 0 &amp; a_&#123;22&#125; &amp; a_&#123;23&#125; \\\\ 0 &amp; 0 &amp; a_&#123;33&#125; \\end&#123;pmatrix&#125; $\\end&#123;document&#125; 省略号 行省略号 \\dots 列省略号 \\vdots 斜省略号 \\ddots 123456789101112\\documentclass&#123;ctexart&#125;% 使用矩阵，引入amsmath宏包\\usepackage&#123;amsmath&#125;\\begin&#123;document&#125; $A = \\begin&#123;bmatrix&#125; a_&#123;11&#125; &amp; \\dots &amp; a_&#123;1n&#125; \\\\ &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; &amp; a_&#123;nn&#125; \\end&#123;bmatrix&#125;_&#123;n\\times n&#125;$\\end&#123;document&#125; 多列省略号 \\hdotsfor{&lt;列数&gt;} 123456789101112\\documentclass&#123;ctexart&#125;% 使用矩阵，引入amsmath宏包\\usepackage&#123;amsmath&#125;\\begin&#123;document&#125; $A = \\begin&#123;bmatrix&#125; a_&#123;11&#125; &amp; \\dots &amp; a_&#123;1n&#125; \\\\ \\hdotsfor&#123;3&#125; \\\\ %跨3列的省略号 0 &amp; &amp; a_&#123;nn&#125; \\end&#123;bmatrix&#125;_&#123;n\\times n&#125;$\\end&#123;document&#125; 符号与类型 符号 LaTeX $\\geq$ \\geq $\\leq$ \\leq $\\approx$ \\approx $\\pm$ \\pm $\\partial$ \\partial 符号 LaTeX $\\vec x$ \\vec x $\\hat x$ \\hat x $\\widehat x$ \\widehat x 希腊字母 数学普通符号 运算符 数学算子 多行公式​ equation环境中，换行命令\\\\无效，所以多行公式需要使用其他环境，使其可用\\\\换行。 ​ 使用多行公式的环境，均需引入 amsmath宏包。 gather环境​ gather环境中公式自带编号，如要阻止编号，需使用 \\notag 命令。 1234567891011\\documentclass&#123;article&#125;% 使用gather环境，引入amsmath宏包\\usepackage&#123;amsmath&#125;\\begin&#123;document&#125; \\begin&#123;gather&#125; a+b = b+a \\\\ %带编号 ab = ba \\notag %不带编号 \\end&#123;gather&#125;\\end&#123;document&#125; gather*环境​ 与gather环境不同的是，公式不带编号。 1234567891011\\documentclass&#123;article&#125;% 使用gather环境，引入amsmath宏包\\usepackage&#123;amsmath&#125;\\begin&#123;document&#125; \\begin&#123;gather*&#125; %不带编号 a+b = b+a \\\\ ab = ba \\end&#123;gather*&#125;\\end&#123;document&#125; align环境​ align环境允许公式按等号或其他关系符对齐，在关系符前加 &amp; 表示对齐。 1234567891011\\documentclass&#123;article&#125;% 使用gather环境，引入amsmath宏包\\usepackage&#123;amsmath&#125;\\begin&#123;document&#125; \\begin&#123;align&#125; %关于&amp;对齐，带编号 x &amp;= t + \\cos t + 1 \\\\ y &amp;= 2\\sin t \\end&#123;align&#125;\\end&#123;document&#125; align*环境​ 与align环境不同的是，但公式不带编号。 自定义命令\\newcommand 定义新的命令 格式：\\newcommand&lt;命令&gt;[&lt;参数个数&gt;][&lt;首参数默认值&gt;]{&lt;具体定义&gt;} 命令只能由字母组成，不能以 \\end 开头 参数可以从1到9，用 #1，#2，….，#9 表示 默认值为非必填项，只能设定 #1 的参数 1234567891011\\documentclass&#123;article&#125;% 设置新命令\\newcommand&#123;\\PRC&#125;&#123;People's Republic of China&#125;\\newcommand&#123;\\loves&#125;[2]&#123;#1 love #2&#125;\\begin&#123;document&#125; \\PRC \\loves&#123;I&#125;&#123;apple&#125;\\end&#123;document&#125; \\renewcommand 重新定义命令 格式：\\renewcommand&lt;命令&gt;[&lt;参数个数&gt;][&lt;首参数默认值&gt;]{&lt;具体定义&gt;} 只能定义已有命令 12345678\\documentclass&#123;ctexart&#125;% 重新定义已有命令\\renewcommand \\abstractname&#123;简介&#125;\\begin&#123;document&#125; \\abstractname\\end&#123;document&#125;","categories":[{"name":"Latex","slug":"Latex","permalink":"https://gy23333.github.io/categories/Latex/"}],"tags":[{"name":"入门","slug":"入门","permalink":"https://gy23333.github.io/tags/%E5%85%A5%E9%97%A8/"},{"name":"Latex","slug":"Latex","permalink":"https://gy23333.github.io/tags/Latex/"},{"name":"Mac","slug":"Mac","permalink":"https://gy23333.github.io/tags/Mac/"}]},{"title":"微信小程序（云开发）","slug":"微信小程序（云开发）","date":"2020-02-03T12:45:44.000Z","updated":"2024-11-11T03:57:58.123Z","comments":true,"path":"2020/02/03/微信小程序（云开发）/","link":"","permalink":"https://gy23333.github.io/2020/02/03/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BA%91%E5%BC%80%E5%8F%91%EF%BC%89/","excerpt":"​ 微信小程序+云开发的入门讲解。","text":"​ 微信小程序+云开发的入门讲解。 开始搭建云开发环境 新建一个文件夹 在微信开发者工具中新建一个小程序，注册AppID，选择云开发 点击云开发按钮，开通云开发 创建资源环境，并在miniprogram/app.js中配置环境 12345678910111213141516171819//app.jsApp(&#123; onLaunch: function () &#123; if (!wx.cloud) &#123; console.error('请使用 2.2.3 或以上的基础库以使用云能力') &#125; else &#123; wx.cloud.init(&#123; // env 参数说明： // env 参数决定接下来小程序发起的云开发调用（wx.cloud.xxx）会默认请求到哪个云环境的资源 // 此处请填入环境 ID, 环境 ID 可打开云控制台查看 // 如不填则使用默认环境（第一个创建的环境） env: 'test-6ga7apra89fe93e5', traceUser: true, &#125;) &#125; this.globalData = &#123;&#125; &#125;&#125;) 云开发环境搭建完成，后续可根据指引浏览小程序。 目录结构云开发小程序一经搭建，就提供一个基础框架。 1234567891011121314151617181920.├── README.md├── cloudfunctions &#x2F;&#x2F;云函数根目录│ ├── callback│ ├── echo│ ├── login│ └── openapi│├── miniprogram &#x2F;&#x2F;小程序根目录│ ├── components &#x2F;&#x2F;自定义组件目录│ ├── images &#x2F;&#x2F;图片目录│ ├── pages &#x2F;&#x2F;页面目录│ ├── style &#x2F;&#x2F;样式目录││ ├── app.js &#x2F;&#x2F;小程序逻辑│ ├── app.json &#x2F;&#x2F;小程序公共配置│ ├── app.wxss &#x2F;&#x2F;小程序公共样式表│ └── sitemap.json &#x2F;&#x2F;sitemap配置│ └── project.config.json 用户登录用户登录主要是要获取用户的userInfo和openid，流程如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Page(&#123; data: &#123; userInfo: &#123;&#125; &#125;, onLoad() &#123; // 获取本地缓存的userInfo this.setData(&#123; userInfo: wx.getStorageSync('userInfo') &#125;) &#125;, // 授权登录 // 1.getUserProfile获取userInfo // 2.获取userInfo成功，再通过云函数getOpenid获取openid，将openid添加进userInfo中 // 3.将userInfo加入本地缓存 login()&#123; // 1.获取userInfo wx.getUserProfile(&#123; desc: '用于完善用户资料', // 声明获取用户个人信息后的用途，后续会展示在弹窗中，请谨慎填写 success: res =&gt; &#123; this.setData(&#123; userInfo: res.userInfo &#125;) // 2.获取OpenID wx.cloud.callFunction(&#123; name: \"getOpenid\", success: res =&gt; &#123; this.data.userInfo.openid = res.result.openid // 3.加入本地缓存 wx.setStorageSync('userInfo', this.data.userInfo) &#125;, fail: res =&gt; &#123; this.setData(&#123; userInfo: &#123;&#125; &#125;) console.log(\"获取OpenID登录失败\") &#125; &#125;) &#125; &#125;) &#125;, // 登出 logout()&#123; // 清空用户信息缓存 wx.removeStorageSync('userInfo') this.setData(&#123; userInfo: null &#125;) &#125;&#125;) st=>start: start op1=>operation: 未登录状态 op2=>operation: 点击授权登录 cond1=>condition: 获取userInfo (getUserProfile函数) op3=>operation: 拒绝授权 (未获得userInfo) op4=>operation: 同意授权 (获得userInfo) cond2=>condition: 获取openid (getOpenid云函数) op5=>operation: openid获取失败 op6=>operation: 清空userInfo op7=>operation: openid获取成功 op8=>operation: 将userInfo和openid加入本地缓存 op9=>operation: 登录成功 e=>end: end st->op1->op2->cond1 cond1(no)->op3(right)->op1 cond1(yes)->op4->cond2 cond2(no)->op5->op6(right)->op1 cond2(yes)->op7->op8->op9->e{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://gy23333.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"入门","slug":"入门","permalink":"https://gy23333.github.io/tags/%E5%85%A5%E9%97%A8/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://gy23333.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"云开发","slug":"云开发","permalink":"https://gy23333.github.io/tags/%E4%BA%91%E5%BC%80%E5%8F%91/"}]},{"title":"数学形态学运算——腐蚀、膨胀、开运算、闭运算","slug":"数学形态学运算——腐蚀、膨胀、开运算、闭运算","date":"2020-01-20T15:02:14.000Z","updated":"2024-11-11T03:57:58.112Z","comments":true,"path":"2020/01/20/数学形态学运算——腐蚀、膨胀、开运算、闭运算/","link":"","permalink":"https://gy23333.github.io/2020/01/20/%E6%95%B0%E5%AD%A6%E5%BD%A2%E6%80%81%E5%AD%A6%E8%BF%90%E7%AE%97%E2%80%94%E2%80%94%E8%85%90%E8%9A%80%E3%80%81%E8%86%A8%E8%83%80%E3%80%81%E5%BC%80%E8%BF%90%E7%AE%97%E3%80%81%E9%97%AD%E8%BF%90%E7%AE%97/","excerpt":"​ 数学形态学中的二值形态学最基本的两种运算——腐蚀、膨胀。由这两个算子又可以衍生出开运算和闭运算。开运算为先腐蚀再膨胀，闭运算为先膨胀再腐蚀。","text":"​ 数学形态学中的二值形态学最基本的两种运算——腐蚀、膨胀。由这两个算子又可以衍生出开运算和闭运算。开运算为先腐蚀再膨胀，闭运算为先膨胀再腐蚀。 腐蚀算法描述​ 在目标图像中标出那些与结构元素相同的子图像的原点位置的像素。 ​ 把结构元素B看作一个卷积模版，每当结构元素平移到其原点位置与目标图像A中那些像素值为“1”的位置重合时，就判断被结构元素覆盖的子图像的其它像素的值是否都与结构元素相应位置的像素值相同；只有当其都相同时，就将结果图像中的那个与原点位置对应的像素位置的值置为1，否则置为0。 ​ ⚠️注意：当结构元素在目标图像上平移时，结构元素中的任何元素不能超出目标图像的范围。 例子原图像： 结构元素： 腐蚀运算后的结果图像： 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;using namespace cv;struct Kernel&#123; Mat B; int position[2]; //原点位置&#125;; //结构元素/** 生成十字型结构元素 size为结构元素的行列数，position为原点位置 返回生成的结构元素 */Kernel getCrossKernel(int* size, int* position)&#123; Kernel kernel; kernel.B = Mat::zeros(size[0], size[1], CV_8U); kernel.position[0] = position[0]; kernel.position[1] = position[1]; for (int nrow = 0; nrow &lt; size[0]; nrow++) &#123; kernel.B.ptr&lt;uchar&gt;(nrow)[kernel.position[0]] = 255; &#125; for (int ncol = 0; ncol &lt; size[1]; ncol++) &#123; kernel.B.ptr&lt;uchar&gt;(kernel.position[1])[ncol] = 255; &#125; return kernel;&#125;/** 腐蚀 img为原图像，dst为腐蚀后的图像，kernel为结构元素 */void getErosion(Mat img, Mat &amp;dst, Kernel kernel)&#123; dst = img.clone(); Mat B = kernel.B; int r_pos = kernel.position[0]; int c_pos = kernel.position[1]; // 遍历查重 for (int nrow = r_pos; nrow &lt; img.rows-r_pos; nrow++) &#123; for (int ncol = c_pos; ncol &lt; img.cols-c_pos; ncol++) &#123; bool bingo = true; if (img.ptr&lt;uchar&gt;(nrow)[ncol] == 255) &#123; for (int i = 0; i &lt; B.rows; i++) &#123; for (int j = 0; j &lt; B.cols; j++) &#123; if (B.ptr&lt;uchar&gt;(i)[j] == 255) &#123; if (img.ptr&lt;uchar&gt;(i+nrow-r_pos)[j+ncol-c_pos] != 255) &#123; bingo = false; break; &#125; &#125; &#125; &#125; &#125; if (!bingo) &#123; //不符合 dst.ptr&lt;uchar&gt;(nrow)[ncol] = 0; &#125; &#125; &#125;&#125;int main() &#123; Mat img1,erosion_dst; //图像一和其腐蚀结果 img1 = imread(\"img1.png\", IMREAD_GRAYSCALE); //获取原图的灰度图像 // 读取图片失败，则停止 if (img1.empty()) &#123; printf(\"读取图像文件失败\"); system(\"pause\"); return -1; &#125; // Otsu二值化 Mat img1_twoColor; threshold(img1, img1_twoColor, 0, 255, THRESH_OTSU); // 建立结构元素(中心为原点位置) int size[2] = &#123;5, 5&#125;; //结构元素的大小 int position[2] = &#123;2, 2&#125;; //原点位置 Kernel kernel = getCrossKernel(size, position); getErosion(img1_twoColor, erosion_dst, kernel); //腐蚀 imshow(\"img1\",img1_twoColor); imshow(\"erosion_dst\", erosion_dst); imwrite(\"erosion_dst.jpg\", erosion_dst); waitKey(); //等待键值输入 return 0;&#125; 结果原图像： 腐蚀后的图像（十字结构元素）： 膨胀算法描述​ 位于某个点的探针(结构元素)是否有探测到物件？ 过程： 求结构元素B关于原点的反射集合Bx； 每当结构元素Bx在目标图像A上平移后，结构元素Bx与其覆盖的子图像中至少有一个元素相交时，就将目标图像中与结构元素Bx的原点对应的那个位置的像素为1，否则置为0。 ⚠️注意： 当结构元素中原点位置的值是0时，仍把它看作是0；而不再把它看作是1。 当结构元素在目标图像上平移时，允许结构中的非原点像素超出目标图像范围。 例子 结构元素原点为1时， ​ 原图像： ​ 结构元素： ​ 结构元素的反射： ​ 膨胀运算后的结果图像： 结构元素原点为0时， ​ 原图像： ​ 结构元素： ​ 结构元素的反射： ​ 膨胀运算后的结果图像： ​ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;using namespace cv;struct Kernel&#123; Mat B; int position[2]; //原点位置&#125;; //结构元素/** 生成矩形结构元素 size为结构元素的大小，position为原点位置 返回生成的结构元素 */Kernel getRectKernel(int* size, int* position) &#123; Kernel kernel; kernel.B = Mat::ones(size[0], size[1], CV_8U); for (int nrow = 0; nrow &lt; kernel.B.rows; nrow++) &#123; for (int ncol = 0; ncol &lt; kernel.B.cols; ncol++) &#123; kernel.B.ptr&lt;uchar&gt;(nrow)[ncol] = 255; &#125; &#125; kernel.position[0] = position[0]; kernel.position[1] = position[1]; return kernel;&#125;/** 膨胀 img为原图像，dst为膨胀后的图像，kernel为结构元素 */void getDilation(Mat img, Mat &amp;dst, Kernel kernel) &#123; dst = img.clone(); Mat B = kernel.B; // 结构元素反射 Mat B_x = Mat::zeros(B.cols, B.rows, CV_8U); for (int nrow = 0; nrow &lt; B.rows; nrow++) &#123; for (int ncol = 0; ncol &lt; B.cols; ncol++) &#123; B_x.ptr&lt;uchar&gt;(ncol)[nrow] = B.ptr&lt;uchar&gt;(nrow)[ncol]; &#125; &#125; int r_pos = kernel.position[1]; int c_pos = kernel.position[0]; // 检验图像的每一个点 for (int nrow = 0; nrow &lt; img.rows; nrow++) &#123; for (int ncol = 0; ncol &lt; img.cols; ncol++) &#123; bool bingo = false; // 检测结构元素中是否有符合的1 for (int i = 0; i &lt; B_x.rows; i++) &#123; for (int j = 0; j &lt; B_x.cols; j++) &#123; // 图像中的位置（有可能越界） int row = nrow - r_pos + i; int col = ncol - c_pos + j; if (B_x.ptr&lt;uchar&gt;(i)[j] == 255) &#123; if (row &gt;= 0 &amp;&amp; row &lt; img.rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; img.cols) &#123; if (img.ptr&lt;uchar&gt;(row)[col] == 255) &#123; bingo = true; break; &#125; &#125; &#125; &#125; if (bingo) &#123; break; &#125; &#125; if (bingo) &#123; //如果符合，即存在重合的1，则置1 dst.ptr&lt;uchar&gt;(nrow)[ncol] = 255; &#125; else &#123; //如果没有符合的，则置0 dst.ptr&lt;uchar&gt;(nrow)[ncol] = 0; &#125; &#125; &#125;&#125;int main() &#123; Mat img2,dilation_dst; //图像二和其膨胀结果 img2 = imread(\"img2.png\", IMREAD_GRAYSCALE); //获取原图的灰度图像 // 读取图片失败，则停止 if (img2.empty()) &#123; printf(\"读取图像文件失败\"); system(\"pause\"); return -1; &#125; // Otsu二值化 Mat img2_twoColor; threshold(img2, img2_twoColor, 0, 255, THRESH_OTSU); // 矩形结构元素 int size[2] = &#123;7, 7&#125;; //结构元素的大小 int position[2] = &#123;0, 0&#125;; //原点位置 Kernel kernel = getRectKernel(size, position); getDilation(img2_twoColor, dilation_dst, kernel); //膨胀 imshow(\"img2\",img2_twoColor); imshow(\"dilation_dst\", dilation_dst); imwrite(\"dilation_dst.jpg\", dilation_dst); waitKey(); //等待键值输入 return 0;&#125; 结果原图像： 膨胀后的图像（矩形结构元素）： 开运算​ 开运算为先腐蚀再膨胀。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;using namespace cv;struct Kernel&#123; Mat B; int position[2]; //原点位置&#125;; //结构元素/** 生成矩形结构元素 size为结构元素的大小，position为原点位置 返回生成的结构元素 */Kernel getRectKernel(int* size, int* position) &#123; Kernel kernel; kernel.B = Mat::ones(size[0], size[1], CV_8U); for (int nrow = 0; nrow &lt; kernel.B.rows; nrow++) &#123; for (int ncol = 0; ncol &lt; kernel.B.cols; ncol++) &#123; kernel.B.ptr&lt;uchar&gt;(nrow)[ncol] = 255; &#125; &#125; kernel.position[0] = position[0]; kernel.position[1] = position[1]; return kernel;&#125;/** 腐蚀 img为原图像，dst为腐蚀后的图像，kernel为结构元素 */void getErosion(Mat img, Mat &amp;dst, Kernel kernel)&#123; dst = img.clone(); Mat B = kernel.B; int r_pos = kernel.position[0]; int c_pos = kernel.position[1]; // 遍历查重 for (int nrow = r_pos; nrow &lt; img.rows-r_pos; nrow++) &#123; for (int ncol = c_pos; ncol &lt; img.cols-c_pos; ncol++) &#123; bool bingo = true; if (img.ptr&lt;uchar&gt;(nrow)[ncol] == 255) &#123; for (int i = 0; i &lt; B.rows; i++) &#123; for (int j = 0; j &lt; B.cols; j++) &#123; if (B.ptr&lt;uchar&gt;(i)[j] == 255) &#123; if (img.ptr&lt;uchar&gt;(i+nrow-r_pos)[j+ncol-c_pos] != 255) &#123; bingo = false; break; &#125; &#125; &#125; &#125; &#125; if (!bingo) &#123; //不符合 dst.ptr&lt;uchar&gt;(nrow)[ncol] = 0; &#125; &#125; &#125;&#125;/** 膨胀 img为原图像，dst为膨胀后的图像，kernel为结构元素 */void getDilation(Mat img, Mat &amp;dst, Kernel kernel) &#123; dst = img.clone(); Mat B = kernel.B; // 结构元素反射 Mat B_x = Mat::zeros(B.cols, B.rows, CV_8U); for (int nrow = 0; nrow &lt; B.rows; nrow++) &#123; for (int ncol = 0; ncol &lt; B.cols; ncol++) &#123; B_x.ptr&lt;uchar&gt;(ncol)[nrow] = B.ptr&lt;uchar&gt;(nrow)[ncol]; &#125; &#125; int r_pos = kernel.position[1]; int c_pos = kernel.position[0]; // 检验图像的每一个点 for (int nrow = 0; nrow &lt; img.rows; nrow++) &#123; for (int ncol = 0; ncol &lt; img.cols; ncol++) &#123; bool bingo = false; // 检测结构元素中是否有符合的1 for (int i = 0; i &lt; B_x.rows; i++) &#123; for (int j = 0; j &lt; B_x.cols; j++) &#123; // 图像中的位置（有可能越界） int row = nrow - r_pos + i; int col = ncol - c_pos + j; if (B_x.ptr&lt;uchar&gt;(i)[j] == 255) &#123; if (row &gt;= 0 &amp;&amp; row &lt; img.rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; img.cols) &#123; if (img.ptr&lt;uchar&gt;(row)[col] == 255) &#123; bingo = true; break; &#125; &#125; &#125; &#125; if (bingo) &#123; break; &#125; &#125; if (bingo) &#123; //如果符合，即存在重合的1，则置1 dst.ptr&lt;uchar&gt;(nrow)[ncol] = 255; &#125; else &#123; //如果没有符合的，则置0 dst.ptr&lt;uchar&gt;(nrow)[ncol] = 0; &#125; &#125; &#125;&#125;int main() &#123; Mat img3, erosion_dst, opening_dst; //图像三和其开运算结果 img3 = imread(\"img3.png\", IMREAD_GRAYSCALE); //获取原图的灰度图像 // 读取图片失败，则停止 if (img3.empty()) &#123; printf(\"读取图像文件失败\"); system(\"pause\"); return -1; &#125; // Otsu二值化 Mat img3_twoColor; threshold(img3, img3_twoColor, 0, 255, THRESH_OTSU); // 矩形结构元素 int size[2] = &#123;4, 4&#125;; //结构元素的大小 int position[2] = &#123;0, 0&#125;; //原点位置 Kernel kernel = getRectKernel(size, position); getErosion(img3_twoColor, erosion_dst, kernel); //腐蚀 getDilation(erosion_dst, opening_dst, kernel); //膨胀 imshow(\"img3\",img3); imshow(\"erosion_dst\", erosion_dst); imshow(\"opening_dst\", opening_dst); imwrite(\"opening_dst.jpg\", opening_dst); waitKey(); //等待键值输入 return 0;&#125; 结果原图像： 开运算结果： 闭运算​ 闭运算为先膨胀再腐蚀。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;using namespace cv;struct Kernel&#123; Mat B; int position[2]; //原点位置&#125;; //结构元素/** 生成矩形结构元素 size为结构元素的大小，position为原点位置 返回生成的结构元素 */Kernel getRectKernel(int* size, int* position) &#123; Kernel kernel; kernel.B = Mat::ones(size[0], size[1], CV_8U); for (int nrow = 0; nrow &lt; kernel.B.rows; nrow++) &#123; for (int ncol = 0; ncol &lt; kernel.B.cols; ncol++) &#123; kernel.B.ptr&lt;uchar&gt;(nrow)[ncol] = 255; &#125; &#125; kernel.position[0] = position[0]; kernel.position[1] = position[1]; return kernel;&#125;/** 腐蚀 img为原图像，dst为腐蚀后的图像，kernel为结构元素 */void getErosion(Mat img, Mat &amp;dst, Kernel kernel)&#123; dst = img.clone(); Mat B = kernel.B; int r_pos = kernel.position[0]; int c_pos = kernel.position[1]; // 遍历查重 for (int nrow = r_pos; nrow &lt; img.rows-r_pos; nrow++) &#123; for (int ncol = c_pos; ncol &lt; img.cols-c_pos; ncol++) &#123; bool bingo = true; if (img.ptr&lt;uchar&gt;(nrow)[ncol] == 255) &#123; for (int i = 0; i &lt; B.rows; i++) &#123; for (int j = 0; j &lt; B.cols; j++) &#123; if (B.ptr&lt;uchar&gt;(i)[j] == 255) &#123; if (img.ptr&lt;uchar&gt;(i+nrow-r_pos)[j+ncol-c_pos] != 255) &#123; bingo = false; break; &#125; &#125; &#125; &#125; &#125; if (!bingo) &#123; //不符合 dst.ptr&lt;uchar&gt;(nrow)[ncol] = 0; &#125; &#125; &#125;&#125;/** 膨胀 img为原图像，dst为膨胀后的图像，kernel为结构元素 */void getDilation(Mat img, Mat &amp;dst, Kernel kernel) &#123; dst = img.clone(); Mat B = kernel.B; // 结构元素反射 Mat B_x = Mat::zeros(B.cols, B.rows, CV_8U); for (int nrow = 0; nrow &lt; B.rows; nrow++) &#123; for (int ncol = 0; ncol &lt; B.cols; ncol++) &#123; B_x.ptr&lt;uchar&gt;(ncol)[nrow] = B.ptr&lt;uchar&gt;(nrow)[ncol]; &#125; &#125; int r_pos = kernel.position[1]; int c_pos = kernel.position[0]; // 检验图像的每一个点 for (int nrow = 0; nrow &lt; img.rows; nrow++) &#123; for (int ncol = 0; ncol &lt; img.cols; ncol++) &#123; bool bingo = false; // 检测结构元素中是否有符合的1 for (int i = 0; i &lt; B_x.rows; i++) &#123; for (int j = 0; j &lt; B_x.cols; j++) &#123; // 图像中的位置（有可能越界） int row = nrow - r_pos + i; int col = ncol - c_pos + j; if (B_x.ptr&lt;uchar&gt;(i)[j] == 255) &#123; if (row &gt;= 0 &amp;&amp; row &lt; img.rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; img.cols) &#123; if (img.ptr&lt;uchar&gt;(row)[col] == 255) &#123; bingo = true; break; &#125; &#125; &#125; &#125; if (bingo) &#123; break; &#125; &#125; if (bingo) &#123; //如果符合，即存在重合的1，则置1 dst.ptr&lt;uchar&gt;(nrow)[ncol] = 255; &#125; else &#123; //如果没有符合的，则置0 dst.ptr&lt;uchar&gt;(nrow)[ncol] = 0; &#125; &#125; &#125;&#125;int main() &#123; Mat img4, dilation_dst, closing_dst; //图像四和其闭运算结果 img4 = imread(\"img4.png\", IMREAD_GRAYSCALE); //获取原图的灰度图像 // 读取图片失败，则停止 if (img4.empty()) &#123; printf(\"读取图像文件失败\"); system(\"pause\"); return -1; &#125; // Otsu二值化 Mat img4_twoColor; threshold(img4, img4_twoColor, 0, 255, THRESH_OTSU); // 矩形结构元素 int size[2] = &#123;4, 4&#125;; //结构元素的大小 int position[2] = &#123;0, 0&#125;; //原点位置 Kernel kernel = getRectKernel(size, position); getDilation(img4_twoColor, dilation_dst, kernel); //膨胀 getErosion(dilation_dst, closing_dst, kernel); //腐蚀 imshow(\"img4\",img4); imshow(\"dilation_dst\", dilation_dst); imshow(\"closing_dst\", closing_dst); imwrite(\"closing_dst.jpg\", closing_dst); waitKey(); //等待键值输入 return 0;&#125; 结果原图像： 闭运算结果：","categories":[{"name":"图像处理","slug":"图像处理","permalink":"https://gy23333.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://gy23333.github.io/tags/C/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://gy23333.github.io/tags/OpenCV/"},{"name":"图像处理","slug":"图像处理","permalink":"https://gy23333.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"数学形态学","slug":"数学形态学","permalink":"https://gy23333.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BD%A2%E6%80%81%E5%AD%A6/"}]},{"title":"基于区域的图像分割——区域分裂与合并","slug":"基于区域的图像分割——区域分裂与合并","date":"2020-01-19T09:39:31.000Z","updated":"2024-11-11T03:57:58.120Z","comments":true,"path":"2020/01/19/基于区域的图像分割——区域分裂与合并/","link":"","permalink":"https://gy23333.github.io/2020/01/19/%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E2%80%94%E2%80%94%E5%8C%BA%E5%9F%9F%E5%88%86%E8%A3%82%E4%B8%8E%E5%90%88%E5%B9%B6/","excerpt":"​ 分裂与合并是一种区域分割方式，将图像划分成不相交的区域，以某一检测准则从四叉树数据结构的任一层开始，对区域进行分裂或合并。并逐步改善区域划分的性能，直到最后将图像分成数量最小的均匀区域为止。","text":"​ 分裂与合并是一种区域分割方式，将图像划分成不相交的区域，以某一检测准则从四叉树数据结构的任一层开始，对区域进行分裂或合并。并逐步改善区域划分的性能，直到最后将图像分成数量最小的均匀区域为止。 算法步骤 定义用于同质性的标准； 将图像分成相等大小的区域； 计算每个区域的同质性； 如果区域同质，则将其与邻居合并； 重复该过程，直到所有区域均通过均一性测试。 同质性​ 可有多种同质性的定义方式，比如： 方差-灰度方差 当区域方差小于指定值时，则该区域符合同质性。 C++实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;iostream&gt;#include &lt;opencv2/opencv.hpp&gt;using namespace cv;using namespace std;struct Block&#123; int row; //起始行 int col; //起始列 int height; //高度 int width; //宽度&#125;; //区域/** 计算区域的灰度方差 img为原图像，blocks为区域集 */double variance(Mat img, vector&lt;Block&gt; blocks)&#123; // 求得区域方差 double ave_I = 0; //区域平均灰度值 int aero = 0; //区域集面积 for (int i = 0; i &lt; blocks.size(); i++) &#123; for (int nrow = blocks[i].row; nrow &lt; blocks[i].row+blocks[i].height; nrow++) &#123; for (int ncol = blocks[i].col; ncol &lt; blocks[i].col+blocks[i].width; ncol++) &#123; ave_I += img.ptr&lt;uchar&gt;(nrow)[ncol]; &#125; &#125; aero += blocks[i].height * blocks[i].width; &#125; ave_I /= double(aero); double v = 0; //区域灰度方差 for (int i = 0; i &lt; blocks.size(); i++) &#123; for (int nrow = blocks[i].row; nrow &lt; blocks[i].row+blocks[i].height; nrow++) &#123; for (int ncol = blocks[i].col; ncol &lt; blocks[i].col+blocks[i].width; ncol++) &#123; v += (img.ptr&lt;uchar&gt;(nrow)[ncol] - ave_I)*(img.ptr&lt;uchar&gt;(nrow)[ncol] - ave_I); &#125; &#125; &#125; v /= double(aero - 1); return v;&#125;/** 画线 */void drawLines(Mat &amp;img, vector&lt;vector&lt;Block&gt;&gt; homo_blocks)&#123; for (int i = 0; i &lt; homo_blocks.size(); i++) &#123; Mat linePic = Mat::zeros(img.size(), CV_8UC1); for (int j = 0; j &lt; homo_blocks[i].size(); j++) &#123; // 上下边缘 for (int ncol = homo_blocks[i][j].col; ncol &lt; homo_blocks[i][j].col+homo_blocks[i][j].width; ncol++) &#123; // 上边缘 int I = linePic.ptr&lt;uchar&gt;(homo_blocks[i][j].row)[ncol]; if (I == 0) &#123; //如果为黑，还未划线 linePic.ptr&lt;uchar&gt;(homo_blocks[i][j].row)[ncol] = 255; &#125; else if (I == 255) &#123; //已划线则去掉线 linePic.ptr&lt;uchar&gt;(homo_blocks[i][j].row)[ncol] = 0; &#125; // 下边缘 I = linePic.ptr&lt;uchar&gt;(homo_blocks[i][j].row+homo_blocks[i][j].height)[ncol]; if (I == 0) &#123; //如果为黑，还未划线 linePic.ptr&lt;uchar&gt;(homo_blocks[i][j].row+homo_blocks[i][j].height)[ncol] = 255; &#125; else if (I == 255) &#123; //已划线则去掉线 linePic.ptr&lt;uchar&gt;(homo_blocks[i][j].row+homo_blocks[i][j].height)[ncol] = 0; &#125; &#125; // 左右边缘 for (int nrow = homo_blocks[i][j].row; nrow &lt; homo_blocks[i][j].row+homo_blocks[i][j].height; nrow++) &#123; // 左边缘 int I = linePic.ptr&lt;uchar&gt;(nrow)[homo_blocks[i][j].col]; if (I == 0) &#123; //如果为黑，还未划线 linePic.ptr&lt;uchar&gt;(nrow)[homo_blocks[i][j].col] = 255; &#125; else if (I == 255) &#123; //已划线则去掉线 linePic.ptr&lt;uchar&gt;(nrow)[homo_blocks[i][j].col] = 0; &#125; // 右边缘 I = linePic.ptr&lt;uchar&gt;(nrow)[homo_blocks[i][j].col+homo_blocks[i][j].width]; if (I == 0) &#123; //如果为黑，还未划线 linePic.ptr&lt;uchar&gt;(nrow)[homo_blocks[i][j].col+homo_blocks[i][j].width] = 255; &#125; else if (I == 255) &#123; //已划线则去掉线 linePic.ptr&lt;uchar&gt;(nrow)[homo_blocks[i][j].col+homo_blocks[i][j].width] = 0; &#125; &#125; &#125; for (int nrow = 0; nrow &lt; img.rows; nrow++) &#123; for (int ncol = 0; ncol &lt; img.cols; ncol++) &#123; if (linePic.ptr&lt;uchar&gt;(nrow)[ncol] == 255) &#123; img.ptr&lt;uchar&gt;(nrow)[ncol] = 255; &#125; &#125; &#125; &#125;&#125;/** 区域分裂与合并 img为原图像，result为处理后的图像，threshold为方差阈值 */void splitMerge (Mat img, Mat &amp;result, double threshold)&#123; Block init_block = &#123; .row = 0, .col = 0, .height = img.rows, .width = img.cols &#125;; //初始区域 vector&lt;Block&gt; blocks; //不符合同质性区域集 vector&lt;vector&lt;Block&gt;&gt; homo_blocks; //符合同质性的区域集 blocks.push_back(init_block); //将初始区域压入不符合同质性区域集 // 分裂与合并的迭代 while (!blocks.empty()) &#123; // 取出一个不符合同质性的区域 Block current_block = blocks.back(); blocks.pop_back(); // 面积为8以上可分 if (current_block.height * current_block.width &gt;= 8) &#123; Block child_blocks[4] = &#123; &#123;.row = current_block.row, .col = current_block.col, .height = (current_block.height+1)/2, .width = (current_block.width+1)/2&#125;, &#123;.row = current_block.row, .col = current_block.col+(current_block.width+1)/2, .height = (current_block.height+1)/2, .width = current_block.width-(current_block.width+1)/2&#125;, &#123;.row = current_block.row+(current_block.height+1)/2, .col = current_block.col, .height = current_block.height-(current_block.height+1)/2, .width = (current_block.width+1)/2&#125;, &#123;.row = current_block.row+(current_block.height+1)/2, .col = current_block.col+(current_block.width+1)/2, .height = current_block.height-(current_block.height+1)/2, .width = current_block.width-(current_block.width+1)/2&#125; &#125;; //区域分裂成四块子区域 // 判断子区域是否具有同质性 for (int i = 0; i &lt; 4; i++) &#123; vector&lt;Block&gt; c_block = &#123;child_blocks[i]&#125;; if (variance(img, c_block) &lt;= threshold) &#123; //如果具有同质性（方差小于阈值），进行合并 // 如果符合同质性的区域集为空 if (homo_blocks.size() == 0) &#123; homo_blocks.push_back(c_block); //将该子区域压入符合同质性的区域集 &#125; else&#123; // 遍历符合同质性的区域集 int n; double min_v = 0; int min_n = 0; for (n = 0; n &lt; homo_blocks.size(); n++) &#123; vector&lt;Block&gt; bk = homo_blocks[n]; bk.push_back(child_blocks[i]); if (n == 0) &#123; min_v = variance(img, bk); &#125; else&#123; if (variance(img, bk) &lt; min_v) &#123; min_v = variance(img, bk); min_n = n; &#125; &#125; &#125; // 需合并，修改添加入区域 if (min_v &lt;= threshold) &#123; vector&lt;Block&gt; bk = homo_blocks[min_n]; bk.push_back(child_blocks[i]); homo_blocks[min_n] = bk; &#125; else &#123; //不需合并，直接加入该区域 homo_blocks.push_back(c_block); &#125; &#125; &#125;else&#123; //如果不具有同质性 blocks.push_back(child_blocks[i]); //压入不符合同质性区域集 &#125; &#125; &#125; &#125; drawLines(result, homo_blocks);&#125;int main() &#123; Mat img,result; img = imread(\"img.jpg\", IMREAD_GRAYSCALE); //获取原图的灰度图像 // 读取图片失败，则停止 if (img.empty()) &#123; printf(\"读取图像文件失败\"); system(\"pause\"); return -1; &#125; result = img.clone(); double threshold = 200; //方差阈值 splitMerge(img, result, threshold); //区域分裂与合并 // 图像显示 imshow(\"img\",img); imshow(\"result\",result); imwrite(\"result.jpg\", result); waitKey(); //等待键值输入 return 0;&#125; 结果原图像： ​ 该图片由HOerwin56在Pixabay上发布 处理后的图像：","categories":[{"name":"图像处理","slug":"图像处理","permalink":"https://gy23333.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://gy23333.github.io/tags/C/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://gy23333.github.io/tags/OpenCV/"},{"name":"图像处理","slug":"图像处理","permalink":"https://gy23333.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"区域分割","slug":"区域分割","permalink":"https://gy23333.github.io/tags/%E5%8C%BA%E5%9F%9F%E5%88%86%E5%89%B2/"},{"name":"区域分裂与合并","slug":"区域分裂与合并","permalink":"https://gy23333.github.io/tags/%E5%8C%BA%E5%9F%9F%E5%88%86%E8%A3%82%E4%B8%8E%E5%90%88%E5%B9%B6/"}]},{"title":"基于区域的图像分割——区域生长","slug":"基于区域的图像分割——区域生长","date":"2020-01-18T12:37:00.000Z","updated":"2024-11-11T03:57:58.125Z","comments":true,"path":"2020/01/18/基于区域的图像分割——区域生长/","link":"","permalink":"https://gy23333.github.io/2020/01/18/%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E2%80%94%E2%80%94%E5%8C%BA%E5%9F%9F%E7%94%9F%E9%95%BF/","excerpt":"​ 区域生长是一种基于区域的分割方式，从初始种子点出发，检查相邻像素点，判断是否需要加入该区域。","text":"​ 区域生长是一种基于区域的分割方式，从初始种子点出发，检查相邻像素点，判断是否需要加入该区域。 算法​ 令 f(x, y) 表示一个输入图像阵列；S(x, y) 表示一个种子阵列，阵列中种子点位置处为1，其他位置处为0；Q 表示在每个位置 (x, y) 处所用的属性。假设阵列 f 和 S 的尺寸相同。基于8连接的一个基本区域生长算法说明如下： 在 S(x, y) 中寻找所有连通分量，并把每个连通分量腐蚀成一个像素；把找到的所有这种像素标记为1，把 S 中的所有其他像素标记为0； 在坐标对 (x, y) 处形成图像 fQ：如果输入图像在该坐标处满足给定的属性 Q，则令 fQ(x, y) = 1，否则令 fQ(x, y) = 0； 令 g 是这样形成的图像：即把 fQ 中为8连通种子点的所有1值点，添加到 S 中的每个种子点； 用不同的区域标记标记出 g 中的每个连通分量。这就是由区域生长得到的分割图像。 例子 C++实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;opencv2/opencv.hpp&gt;#include &lt;iostream&gt;using namespace cv;using namespace std;/** 区域生长 img为原图像，result为经区域生长后的图像，seed为初始种子点，threshold为阈值 输入种子点超出范围返回false */bool regionGrowing(Mat img, Mat &amp;result, Point2i seed, int threshold)&#123; result = Mat::zeros(img.size(), CV_8UC1); //背景全部设置为黑// 输入种子点超出范围返回false if (seed.x &lt; 0 || seed.y &lt; 0 || seed.y &gt; img.rows-1 || seed.x &gt; img.cols-1) &#123; return false; &#125; vector&lt;Point2i&gt; seeds; //种子点集 seeds.push_back(seed); //压入初始种子点 result.ptr&lt;uchar&gt;(seed.y)[seed.x] = 255; //种子点设置为白 int growDirections[8][2] = &#123;&#123;-1,-1&#125;, &#123;0,-1&#125;, &#123;1,-1&#125;, &#123;-1,0&#125;, &#123;1,0&#125;, &#123;-1,1&#125;, &#123;0,1&#125;, &#123;1,1&#125;&#125;; //生长方向 // 开始生长 while (!seeds.empty()) &#123; // 取出一个种子点作为现在循环的初始种子点 Point2i seed_current = seeds.back(); seeds.pop_back(); // 遍历各生长方向的邻点 for (int i = 0; i &lt; 8; i++) &#123; Point2i neighborPoint = &#123;seed_current.x + growDirections[i][0], seed_current.y + growDirections[i][1]&#125;; //邻点 if (neighborPoint.x &lt; 0 || neighborPoint.y &lt; 0 || neighborPoint.x &gt; img.cols-1 || neighborPoint.y &gt; img.rows-1) &#123; //邻点超出范围 continue; &#125; if ((result.ptr&lt;uchar&gt;(neighborPoint.y)[neighborPoint.x] == 0) &amp;&amp; abs(img.ptr&lt;uchar&gt;(neighborPoint.y)[neighborPoint.x] - img.ptr&lt;uchar&gt;(seed.y)[seed.x]) &lt; threshold) &#123; // 设置为种子点 result.ptr&lt;uchar&gt;(neighborPoint.y)[neighborPoint.x] = 255; //设置为白色 seeds.push_back(neighborPoint); //压入种子集 &#125; &#125; &#125; return true;&#125;int main() &#123; Mat img, result; img = imread(\"mountains.jpg\", IMREAD_GRAYSCALE); //从文件中加载灰度图像// 读取图片失败，则停止 if (img.empty()) &#123; printf(\"读取图像文件失败\"); system(\"pause\"); return -1; &#125; // 输入初始种子点 cout &lt;&lt; \"Select a point as seed from [\" &lt;&lt; img.rows-1 &lt;&lt; \", \" &lt;&lt; img.cols-1 &lt;&lt; \"]\" &lt;&lt; endl; int seed_row, seed_col; cout &lt;&lt; \"row\"; cin &gt;&gt; seed_row; cout &lt;&lt; \"col\"; cin &gt;&gt; seed_col; Point2i seed; seed.x = seed_col; seed.y = seed_row; // 区域生长 int threshold = 50; regionGrowing(img, result, seed, threshold); //区域生长 // 图像显示 imshow(\"img\",img); imshow(\"result\",result); imwrite(\"result.jpg\", result); waitKey(); //等待键值输入 return 0;&#125; 结果原图像： 经区域生长后的图像（取原种子点为（0, 0））：","categories":[{"name":"图像处理","slug":"图像处理","permalink":"https://gy23333.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://gy23333.github.io/tags/C/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://gy23333.github.io/tags/OpenCV/"},{"name":"图像处理","slug":"图像处理","permalink":"https://gy23333.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"区域分割","slug":"区域分割","permalink":"https://gy23333.github.io/tags/%E5%8C%BA%E5%9F%9F%E5%88%86%E5%89%B2/"},{"name":"区域生长","slug":"区域生长","permalink":"https://gy23333.github.io/tags/%E5%8C%BA%E5%9F%9F%E7%94%9F%E9%95%BF/"}]},{"title":"大津二值化法","slug":"大津二值化法","date":"2020-01-17T17:05:12.000Z","updated":"2024-11-11T03:57:58.129Z","comments":true,"path":"2020/01/18/大津二值化法/","link":"","permalink":"https://gy23333.github.io/2020/01/18/%E5%A4%A7%E6%B4%A5%E4%BA%8C%E5%80%BC%E5%8C%96%E6%B3%95/","excerpt":"​ 大津法（Otsu算法，おおつ）用来自动对图像进行二值化，即将图像的两类分开。要计算将两类分开的最佳阈值，即要使两类的类内方差最小。由于两类平方距离恒定，所以类内方差最小即是求类间方差最大时的阈值为最佳阈值。","text":"​ 大津法（Otsu算法，おおつ）用来自动对图像进行二值化，即将图像的两类分开。要计算将两类分开的最佳阈值，即要使两类的类内方差最小。由于两类平方距离恒定，所以类内方差最小即是求类间方差最大时的阈值为最佳阈值。 算法 计算得原图的灰度直方图和概率直方图 ​ 设图像像素为 N，灰度范围为 [0, L-1]，对应灰度级 i 的像素为 ni，概率为： 遍历所有可能阈值 t ，找到类间方差最大是的两个对应的阈值（有一个最大则取一个，两个最大取平均） 类概率： 类均值： 类间方差： 最佳阈值= C++实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;opencv2/opencv.hpp&gt;using namespace cv;/** 获取灰度概率直方图 img为原图像，histogram为灰度概率直方图 */void getHistogram(Mat &amp;img, double *histogram)&#123; int H[256] = &#123;0&#125;; for (int nrow = 0; nrow &lt; img.rows; nrow++) &#123; for (int ncol = 0; ncol &lt; img.cols; ncol++) &#123; int h = img.ptr&lt;uchar&gt;(nrow)[ncol]; H[h] ++; &#125; &#125; int N = img.rows * img.cols; //总像素 for (int i = 0; i &lt;= 255; i++) &#123; histogram[i] = double(H[i]) / double(N); &#125;&#125;/** 大津法获取最佳阈值 histogram为灰度概率直方图，threshold为最佳阈值 */void Otsu(double *histogram, double &amp;threshold)&#123; double w1 = 0.0, w2 = 1.0; //类概率w1,w2 double u1, u2; //类均值u1,u2 double max = 0.0; //最大类间方差 double sum = 0.0; for (int i = 0; i &lt;= 255; i++) &#123; sum += i * histogram[i]; &#125; double sum1 = 0.0, sum2 = sum; double threshold1 = 0.0, threshold2 = 0.0; //有一个最大则取一个，两个最大取平均 // 遍历所有可能阈值 t ，找到类间方差最大是的两个对应的阈值 for (int t = 1; t &lt;= 255; t++) &#123; w1 += histogram[t]; w2 = 1 - w1; if (w1 == 0) &#123; //还没出现点时不会是阈值 continue; &#125;else if (w2 == 0)&#123; //后面没点时已获得最佳阈值 break; &#125; sum1 += t * histogram[t]; sum2 = sum - sum1; u1 = sum1 / w1; u2 = sum2 / w2; double v = w1 * w2 * (u1 - u2) * (u1 - u2); //类间方差 if (v &gt;= max) &#123; threshold1 = t; //大于等于，等于时，有两个最大 if (v &gt; max) &#123; threshold2 = t; //大于时，有唯一最大，threshold1、threshold2统一 &#125; max = v; //替换max &#125; &#125; threshold = (threshold1 + threshold2) / 2;&#125;/** 获得大津法二值化后的图像 img为原图像，result为大津法二值化后的图像，threshold为最佳阈值 */void getOtsuImg(Mat img, Mat &amp;result, double threshold)&#123; for (int nrow = 0; nrow &lt;= img.rows; nrow++) &#123; for (int ncol = 0; ncol &lt;= img.cols; ncol++) &#123; if (img.ptr&lt;uchar&gt;(nrow)[ncol] &lt;= threshold) &#123; result.ptr&lt;uchar&gt;(nrow)[ncol] = 0; &#125;else&#123; result.ptr&lt;uchar&gt;(nrow)[ncol] = 255; &#125; &#125; &#125;&#125;int main() &#123; Mat img,result; img = imread(\"Otsu.png\", IMREAD_GRAYSCALE); //获取原图的灰度图像 // 读取图片失败，则停止 if (img.empty()) &#123; printf(\"读取图像文件失败\"); system(\"pause\"); return -1; &#125; // 获取灰度概率直方图 double histogram[256] = &#123;0&#125;; //灰度概率直方图 getHistogram(img, histogram); //获取灰度概率直方图 // 获取最佳阈值 double threshold = 0; //最佳阈值 Otsu(histogram, threshold); //获取最佳阈值 // 获得大津法二值化后的图像 result = img.clone(); getOtsuImg(img, result, threshold); // 图像显示 imshow(\"img\", img); imshow(\"Otsu\", result); waitKey(); imwrite(\"result.jpg\", result); return 0;&#125; 结果原图像： 大津法二值化后得到的图像：","categories":[{"name":"图像处理","slug":"图像处理","permalink":"https://gy23333.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://gy23333.github.io/tags/C/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://gy23333.github.io/tags/OpenCV/"},{"name":"图像处理","slug":"图像处理","permalink":"https://gy23333.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"大津法","slug":"大津法","permalink":"https://gy23333.github.io/tags/%E5%A4%A7%E6%B4%A5%E6%B3%95/"}]},{"title":"Xcode上配置OpenCV和C++开发环境","slug":"Xcode上配置OpenCV和C-开发环境","date":"2020-01-15T16:01:55.000Z","updated":"2024-11-11T03:57:58.130Z","comments":true,"path":"2020/01/16/Xcode上配置OpenCV和C-开发环境/","link":"","permalink":"https://gy23333.github.io/2020/01/16/Xcode%E4%B8%8A%E9%85%8D%E7%BD%AEOpenCV%E5%92%8CC-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"​ 在下载完OpenCV和新建完C++工程后，需在Xcode的C++文件上配置OpenCV。","text":"​ 在下载完OpenCV和新建完C++工程后，需在Xcode的C++文件上配置OpenCV。 Xcode配置OpenCV步骤​ 首先先新建好C++工程。 设置库文件搜索路径(Header Search Paths)​ 找到OpenCV的header路径添加进Header Search Paths。 用SpotLight搜索到隐藏文件夹1&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;opencv&#x2F; 找到header的最终路径​ 这里我的最终路径是 1&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;opencv&#x2F;4.1.1_2&#x2F;include&#x2F;opencv4 将OpenCV的header路径添加进Header Search Paths​ 在该Xcode项目下，选择Building Settings -&gt; Header Search Paths，添加进入header的搜索路径。 1&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;opencv&#x2F;4.1.1_2&#x2F;include&#x2F;opencv4 设置库搜索路径（Library Search Paths）​ 在刚刚查询到的目录里面找到与include同级的lib文件夹 1&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;opencv&#x2F;4.1.1_2&#x2F;lib ​ 在该Xcode项目下，选择Building Settings -&gt; Library Search Paths，添加进入lib路径。 设置其他链接器标志（Other Linker Flags）​ 通过pkg-config获取opencv所有的Linker Flags，添加进Other Linker Flags。 在命令行中输入pkg-config命令，得到所有的Linker Flags1pkg-config --libs opencv4 将Linker Flags添加进Other Linker Flags​ 在该Xcode项目下，选择Building Settings -&gt; Other Linker Flags，添加Linker Flags。 ​ 此时，Xcode的OpenCV环境配置成功。 调用OpenCV库文件1#include &lt;opencv2/opencv.hpp&gt; 使用文件的相对路径​ 做图像免不了要使用图片文件，全部使用绝对路径不易转移，所以需在Xcode里设置文件的相对路径。 打开Edit Scheme​ 选择 Product -&gt; Scheme -&gt; Edit Scheme 添加相对路径​ 在 Run -&gt; Options 勾选 Use Custom Working Directory，并添加路径。 ​ 现在即可使用相对地址引入文件。 参考Setting up OpenCV and C++ development environment in Xcode for Computer Vision projects 注意科学上网！！","categories":[{"name":"图像处理","slug":"图像处理","permalink":"https://gy23333.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://gy23333.github.io/tags/C/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://gy23333.github.io/tags/OpenCV/"},{"name":"图像处理","slug":"图像处理","permalink":"https://gy23333.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"Xcode","slug":"Xcode","permalink":"https://gy23333.github.io/tags/Xcode/"},{"name":"环境配置","slug":"环境配置","permalink":"https://gy23333.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"直方图均衡化","slug":"直方图均衡化","date":"2020-01-15T15:55:04.000Z","updated":"2024-11-11T03:57:58.126Z","comments":true,"path":"2020/01/15/直方图均衡化/","link":"","permalink":"https://gy23333.github.io/2020/01/15/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/","excerpt":"​ 直方图均衡化是通过对原图像在像素个数多的灰度级进行展宽，对像素个数少的灰度级进行缩减，使原图像的灰度直方图修正为均匀分布的直方图。","text":"​ 直方图均衡化是通过对原图像在像素个数多的灰度级进行展宽，对像素个数少的灰度级进行缩减，使原图像的灰度直方图修正为均匀分布的直方图。 步骤由原图像得灰度直方图​ 计每一个像素值的点的个数。 例如：原图像 1 3 9 9 8 2 1 3 7 3 3 6 0 6 4 6 8 2 0 5 2 9 2 6 0 灰度直方图 灰度级 像素点个数H 0 3 1 2 2 4 3 4 4 1 5 1 6 4 7 1 8 2 9 3 由灰度直方图得灰度级像素百分比​ 灰度直方图中的像素点个数 / 总像素点个数 灰度级 灰度级像素百分比HR 0 0.12 1 0.08 2 0.16 3 0.16 4 0.04 5 0.04 6 0.16 7 0.04 8 0.08 9 0.12 计算各灰度级的累积分布 灰度级 累积分布HS 0 0.12 1 0.20 2 0.36 3 0.52 4 0.56 5 0.60 6 0.76 7 0.80 8 0.88 9 1.00 求出新图像的灰度值 ​ 即乘以灰度级个数后再四舍五入。 C++实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;opencv2/opencv.hpp&gt;using namespace std;using namespace cv;//直方图均衡化void histogram_equalization(Mat &amp;img, Mat &amp;result) &#123; int H[256] = &#123;0&#125;; for (int i = 0; i &lt;= 255; i++) &#123; H[i] = 0; // 灰度直方图 &#125;// 由原图像得灰度直方图 for (int nrow = 0; nrow &lt; img.rows; nrow++) &#123; for (int ncol = 0; ncol &lt; img.cols; ncol++) &#123; int h = img.ptr&lt;uchar&gt;(nrow)[ncol]; H[h] ++; &#125; &#125;// 由灰度直方图得灰度级像素百分比 int NR = img.rows * img.cols; // 总像素点个数 double HR[256] = &#123;0&#125;; for (int i = 0; i &lt;= 255; i++) &#123; HR[i] = 0.0; // 灰度直方图 &#125; for (int i = 0; i &lt;= 255; i++) &#123; HR[i] = double(H[i])/double(NR); // 灰度级像素百分比 &#125;// 计算各灰度级的累积分布，并求出新图像的灰度值 double HS[256] = &#123;0&#125;; for (int i = 0; i &lt;= 255; i++) &#123; HS[i] = 0.0; // 各灰度级的累积分布 &#125; for (int i = 1; i &lt;= 255; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; HS[i] += HR[j]; &#125; H[i] = round(HS[i] * 255); &#125;// 获得新图像 for (int nrow = 0; nrow &lt; img.rows; nrow++) &#123; for (int ncol = 0; ncol &lt; img.cols; ncol++) &#123; int h = img.ptr&lt;uchar&gt;(nrow)[ncol]; result.ptr&lt;uchar&gt;(nrow)[ncol] = H[h]; &#125; &#125;&#125;int main() &#123; Mat img = imread(\"Unequalized.jpg\", IMREAD_GRAYSCALE); Mat result = img.clone(); histogram_equalization(img, result); imshow(\"img\",img); imshow(\"Histogram Equalization\",result); imwrite(\"result.jpg\", result); waitKey(); return 0;&#125; 原图像： 经直方图均衡化后的图像：","categories":[{"name":"图像处理","slug":"图像处理","permalink":"https://gy23333.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://gy23333.github.io/tags/C/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://gy23333.github.io/tags/OpenCV/"},{"name":"图像处理","slug":"图像处理","permalink":"https://gy23333.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"直方图均衡化","slug":"直方图均衡化","permalink":"https://gy23333.github.io/tags/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/"}]},{"title":"C++学习手册","slug":"C-学习手册","date":"2020-01-09T18:36:52.000Z","updated":"2024-11-11T03:57:58.131Z","comments":true,"path":"2020/01/10/C-学习手册/","link":"","permalink":"https://gy23333.github.io/2020/01/10/C-%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/","excerpt":"​ C++学习手册，主要是在C的基础上写出一些C++不同于C的点，部分C语言相通部分就不再赘述。","text":"​ C++学习手册，主要是在C的基础上写出一些C++不同于C的点，部分C语言相通部分就不再赘述。 环境搭建使用 VS Code 搭建C++开发环境（MAC）参考视频 在VS Code上安装好相应插件：C/C++、CodeLLDB 新建工作目录，编写C++文件 在Debug中创建launch.json文件，选择LLDB 将&lt;your program&gt;替换为${fileBasenameNoExtension} 选择cpp文件，建立Build文件，Shift+Command+P切出面板，选择Tasks:Configure Task -&gt; C/C++ clang++ build active file 在”args”中添加C++标准&quot;-std=c++2a&quot; 在launch.json中的”configurations”中添加&quot;preLaunchTask&quot;: &quot;C/C++: clang++ build active file&quot;(与tasks.json中的label一致) Xcode引入iostream库失败提示 ‘iostream’ file not found的解决办法： 在Build Settings -&gt; Search paths -&gt;System Header Search Paths中添加路径 1&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Toolchains&#x2F;XcodeDefault.xctoolchain&#x2F;usr&#x2F;include&#x2F;c++&#x2F;v1&#x2F; 添加后，C++库引入成功。 从C到C++输入输出C++输入输出需使用iostream库 标准输出coutstd :: cout 是输出内容，&lt;&lt; 是输出运算符，std :: endl 结束改行，相当于一个”\\n” 1std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl; 1std::cout &lt;&lt; \"Hello, World!\\n\" ; 标准输入cinstd :: cin 是输入内容，&gt;&gt; 是输入运算符。 123456789#include &lt;iostream&gt;int main() &#123; int a = 0, b = 0; std::cout &lt;&lt; \"Input a and b.\" &lt;&lt; std::endl; std::cin &gt;&gt; a &gt;&gt; b; std::cout &lt;&lt; \"The sum of a and b is \" &lt;&lt; a+b &lt;&lt; std::endl; return 0;&#125; 使用标准库中的名字​ std::表示cout和cin是定义在名为std的命名空间中的，可以通过using namespace来进行命名空间的缩略。 1using namespace std; 控制流while语句​ while语句反复执行一段代码，直至条件判断为错误。 读取数量不定的输入数据​ 利用std::cin进行输入不定的输入。 123456789101112131415/** 不断输入数字求和，直至输入不是数字结束 */#include &lt;iostream&gt;using namespace std;int main() &#123; int sum = 0, value = 0; cout &lt;&lt; \"Input number.\" &lt;&lt; endl; while (cin &gt;&gt; value) &#123; //当输入不为数字时判断为false sum += value; cout &lt;&lt; \"Input number.\" &lt;&lt; endl; &#125; cout &lt;&lt; \"Sum is \" &lt;&lt; sum &lt;&lt; endl; return 0;&#125; ​ 已经定义了value为int型，所以在 cin&gt;&gt;value 输入不为int型时，则判断为false。 ​ 也可用文件结束符，输入Ctrl+D for语句​ for(初始化语句; 循环条件; 表达式) 遍历数组中的元素 ​ 一维数组 1234567891011#include &lt;iostream&gt;using namespace std;int main()&#123; int scores[10] = &#123;0&#125;; for (auto i : scores) &#123; //遍历数组scores中的元素 cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; 多维数组 1234567891011121314#include &lt;iostream&gt;using namespace std;int main()&#123; int ia[2][5] = &#123;0&#125;; for (auto &amp;row : ia) &#123; //遍历二维数组ia外层数组的每一个元素（这里相当于遍历每行） for (auto &amp;col : row) &#123; //遍历二维数组ia内层数组的每一个元素 cout &lt;&lt; col; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 函数重载同一作用域内，可以有同名函数，给函数多个定义，但形参必须不同，加以区分。 形参不同，指参数的类型、参数的个数和参数的顺序，至少有一个不同。 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;//三个形参不同的print函数void print(int data) &#123; cout &lt;&lt; data &lt;&lt; endl;&#125;void print(double data) &#123; cout &lt;&lt; data &lt;&lt; endl;&#125;void print(int a, int b) &#123; cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl;&#125;int main() &#123; print(2); print(2.5); print(1,2); return 0;&#125; C++基础变量和基本类型类​ 相当于把各种数据打包组成了一个集合来调用。 ​ 下面以建立和使用一个书籍销售单类Sales_data为例。 建立头文件​ 为保障各文件中的类的定义一致，类通常被定义在头文件中。这里我们建立一个名为Sales_data.h的头文件来转载Sales_data类的定义。 ​ 头文件一般最好进行预处理，添加头文件保护符： #define 把名字设定为预处理变量 #ifdef 当且仅当变量已定义时为真 #ifndef 当且仅当变量未被定义时为真 #endif 判断为真后，执行到#endif结束 123456789#ifndef Sales_data_h#define Sales_data_h#include &lt;string.h&gt;struct Sales_data&#123; std::string bookNo; // 书籍编号 unsigned units_sold = 0; // 销售数量 double revenue = 0.0; // 销售收入&#125;;#endif 使用类定义​ 调用该.h文件 1#include \"Sales_data.h\" ​ 定义类变量 1Sales_data data1; ​ 利用.来访问类中的对象 12345678910111213#include &lt;iostream&gt;#include \"Sales_data.h\"using namespace std;int main() &#123; Sales_data data1; double price = 0.0; // 书籍单价 cout &lt;&lt; \"Input book_No, sold_num and price.\" &lt;&lt; endl; cin &gt;&gt; data1.bookNo &gt;&gt; data1.units_sold &gt;&gt; price; data1.revenue = price * data1.units_sold; cout &lt;&lt; \"Book \" &lt;&lt; data1.bookNo &lt;&lt; \"'s revenue is \" &lt;&lt; data1.revenue &lt;&lt; endl; return 0;&#125; 迭代器​ 迭代器是一种检查容器内元素并遍历元素的数据类型。可以替代下标访问vector对象的元素。可以理解为指向容器内元素的指针。 使用迭代器​ begin 返回指向第一个元素的迭代器，end 返回指向容器尾元素的下一个位置的迭代器（实际上是不存在的）。当begin和end返回的为同一迭代器，则该容器为空。 ​ 不在意迭代器的类型，一般定义为auto。 迭代器运算符 功能 *iter 返回迭代器iter所指的元素的引用 Iter-&gt;mem 解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem ++iter 令iter指示容器中的下一个元素 —iter 令iter指示容器中的上一个元素 iter1 == iter2 / iter1 != iter2 判断两迭代器是否相等。如两迭代器指示的是同一个元素或者它们是同一个容器或者它们是同一个容器的尾后迭代器，则相等。 12345678910111213141516/** 将首单词的首字母大写 */#include &lt;iostream&gt;using namespace std;int main()&#123; string s = \"hello world.\"; if (s.begin() != s.end()) &#123; // s不为空 auto it = s.begin(); // 指向首单词的迭代器 *it = toupper(*it); // 将it迭代器所指的元素的引用首字母大写 cout &lt;&lt; s &lt;&lt; endl; &#125; return 0;&#125; 迭代器运算 代码 功能 iter + n / iter - n 加或减n个位置得到一个迭代器 iter += n / iter -= n 加或减n个位置得到一个迭代器赋给iter本身 iter1 - iter2 iter1与iter2之间的位置差 &gt; 、&gt;=、&lt;、&lt;= 比较位置 try语句块和异常处理throw表达式​ throw表达式，异常检测部分使用throw表达式来表示它遇到了无法处理的问题。 12345678910111213141516171819/** 检验输入是否是数字，不是则抛出异常 */#include &lt;iostream&gt;using namespace std;int main()&#123; int number = 0; cout &lt;&lt; \"Input a number.\" &lt;&lt; endl; char input; cin &gt;&gt; input; if (input &gt;= '0' &amp;&amp; input &lt;= '9') &#123; //输入为数字 number = input - '0'; &#125; else &#123; //输入不为数字 throw runtime_error(\"Input not number.\"); &#125; return 0;&#125; 当输入不为数字时，运行到throw语句时卡住，并输出异常信息。 try语句块​ try语句块，异常处理部分使用try语句块处理异常。try尝试一个代码块，如有异常通常会被catch捕捉处理。 12345try&#123; //测试的代码块&#125; catch(exception-declaration) &#123; //exception-declaration异常声明 //异常处理&#125; C++面向对象C++面向对象的三大特性：封装、继承、多态。 万事万物都是对象，具有相同属性的对象可以抽象成一个类。 类和对象类和对象的定义把类的所有成员（变量和函数）封装起来，并加以权限限制。 语法： 12345class 类名 &#123;访问权限: 成员变量 成员函数&#125;; 示例：设计一个圆类，求圆的周长 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const double PI = 3.14;//定义一个圆类class Circle&#123;public: //访问权限 //成员变量 double r; //半径 //成员函数 //计算周长 double calculate_circumference () &#123; return 2 * PI * r; &#125;&#125;;int main () &#123; Circle c1; //声明一个圆对象 c1.r = 10; cout &lt;&lt; \"周长为：\" &lt;&lt; c1.calculate_circumference() &lt;&lt; endl; return 0;&#125; 成员函数也可在类的外部，使用范围解析运算符::定义 12345678910111213class Circle&#123;public: double r; //成员函数声明 double calculate_circumference();&#125;;//成员函数定义double Circle::calculate_circumference () &#123; return 2 * PI * r;&#125; 访问权限类成员的访问限制共三种：public、private、protected 公共权限 public 类内、类外都可访问 保护权限 protected 类内可访问，派生类可访问，类外不可访问 私有权限 private 只允许类内访问 如果没有使用任何访问修饰符，默认为私有权限 访问权限 public protected private 类内 可访问 可访问 可访问 派生类 可访问 可访问 不可访问 类外 可访问 不可访问 不可访问 struct和class的区别：struct和class都可以表示类，但默认的权限不同。如果成员没有使用任何访问修饰符，struct默认为公共成员，class默认为私有成员。 类内访问 &amp; 类外访问 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;class Person&#123;public: //公共成员 //类内可访问，类外可访问 string name; string getPassword(); //读函数 void setPassword(string pass); //写函数protected: //保护成员 //类内可访问，类外不可访问 string address;private: //私有成员 //类内可访问，类外不可访问 string password;&#125;;string Person::getPassword () &#123; return password; //类内访问&#125;void Person::setPassword (string pass) &#123; password = pass; //类内访问&#125;int main () &#123; Person p1; //正确，类外可访问公共成员 p1.name = \"ZhangSan\"; cout &lt;&lt; p1.name &lt;&lt; endl; //错误，类外不可访问保护/私有成员 // p1.password = \"123456\"; p1.setPassword(\"123456\"); cout &lt;&lt; p1.getPassword() &lt;&lt; endl; return 0;&#125; 一般都把成员变量设置为private权限，然后在public中设置读写函数，以便控制读写权限。 构造函数/析构函数构造函数/析构函数是两个特殊的成员函数，分别在创建对象/销毁对象时被自动调用，用于完成对象初始化/清理工作。 即使不主动编辑构造函数/析构函数，编译器也会自动提供两个空函数作为构造函数/析构函数。 构造函数 创建对象时，自动调用一次，用于完成对象初始化 函数名与类名相同 类名() {} 可以有参数，不会有返回值，也不会返回void 析构函数 销毁对象时，自动调用一次，用于完成清理工作 函数名与类名相同，加个前缀~， ~类名() {} 不能有参数，不会有返回值，也不会返回void 语法框架 12345678910111213141516class 类名&#123;private: /* data */public: 类名(/* args */); //构造函数，可以有参数 ~类名(); //析构函数&#125;;类名::类名(/* args */)&#123;&#125;类名::~类名()&#123;&#125; 示例 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;class Line&#123;private: int length;public: Line(); //构造函数 ~Line(); //析构函数&#125;;Line::Line() &#123; cout &lt;&lt; \"调用构造函数\" &lt;&lt; endl;&#125;Line::~Line() &#123; cout &lt;&lt; \"调用析构函数\" &lt;&lt; endl;&#125;int main () &#123; Line line; //创建对象，自动调用构造函数 return 0; //销毁对象时，自动调用析构函数&#125; 构造函数的分类和调用方式无参构造 函数结构 123className() &#123; ...&#125; 调用方法（定义对象） 1className c; 定义无参构造的对象的错误写法className c();，不能加()，不然会与函数的声明弄混。 有参构造以int型参数为例 函数结构 123className(int x) &#123; ...&#125; 调用方法（定义对象） 1className c(10); //方法一：括号法 1className c = className(10); //方法二：显示法 1className c = 10; //方法三：隐式转换法 示例 12345Line::Line(int a, int b) &#123; A = a; B = b; ...&#125; 可以使用初始化列表来初始化字段，两种方法等效 1234Line::Line(int a, int b) : A(a), B(b)&#123; ...&#125; 拷贝构造拷贝构造函数，即复制一个对象，生成新对象。 函数结构 123className(const className &amp;obj) &#123; ...&#125; const防止被拷贝的数据obj被修改，且须用引用传递，而不能用值传递。 调用方法（定义对象） 1className c(obj); //方法一：括号法 1className c = className(obj); //方法二：显示法 1className c = obj; //方法三：隐式转换法 调用时机 使用一个对象，拷贝出一个新对象 12Line l1(10);Line l2(l1); //调用拷贝构造 值方式传递参数时，复制副本 123void func(Line l) &#123; //值传递，复制原对象l，调用拷贝构造 ...&#125; 值方式返回局部对象时，复制副本 1234void func( &#123; ... return l; //复制原对象l，返回副本，调用拷贝构造&#125; 无参/有参/拷贝构造示例 定义line类，分别用无参/有参构造函数，定义两个length相同的对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;using namespace std;class Line&#123;private: int length;public: Line(); //无参构造函数 Line(int len); //有参构造函数 Line(const Line &amp;obj); //拷贝构造函数 ~Line(); void setLength(int len); int getLength();&#125;;//无参构造函数Line::Line() &#123; cout &lt;&lt; \"无参构造函数调用\" &lt;&lt; endl;&#125;//有参构造函数Line::Line(int len) &#123; length = len; cout &lt;&lt; \"有参构造函数调用\" &lt;&lt; endl;&#125;//拷贝构造函数Line::Line(const Line &amp;obj) &#123; length = obj.length; cout &lt;&lt; \"拷贝构造函数调用\" &lt;&lt; endl;&#125;Line::~Line() &#123; cout &lt;&lt; \"析构函数调用\" &lt;&lt; endl;&#125;void Line::setLength(int len) &#123; length = len;&#125;int Line::getLength() &#123; return length;&#125;int main () &#123; Line l1; //无参构造 l1.setLength(10); Line l2(10); //有参构造 Line l3(l2); //拷贝构造 return 0;&#125; 构造函数的调用规则默认情况下，编译器会自动给一个类添加3个函数： 默认构造函数（无参，空函数） 默认析构函数（空函数） 默认拷贝构造函数（对属性进行值拷贝） 如用户自行定义了有参构造函数，编译器将不再提供默认无参构造函数，但依旧提供默认拷贝构造函数； 如用户自行定义了拷贝构造函数，编译器将不再提供其他构造函数。 对象参数的引用传递 传递对象参数时，最好用引用传递void func(className &amp;obj); 如为值传递，即void func(className obj);，调用该函数时，要复制生成新的对象，调用拷贝构造函数，结束时，还需要调用析构函数来做清理工作。时间效率低。 如为引用传递，即void func(className &amp;obj);，调用该函数时，直接用原对象，不需要生成新对象。 当不修改对象时，应当将参数声明为const引用。 拷贝构造函数的参数必须是引用，且最好用const引用className(const className &amp;obj); 如果使用值传递，即className(className obj);，则传值时会调用拷贝构造函数，会出现无穷递归调用拷贝构造函数的情况，所以拷贝构造函数的参数不能使用值传递。 深拷贝/浅拷贝浅拷贝，即简单的赋值拷贝，默认拷贝构造即是浅拷贝。 如定义一个类 123456789class Person &#123;private: int age;public: Person(int m_age) &#123; age = m_age; &#125;&#125;; 编译器会自动生成默认拷贝构造函数，即 123Person(const Person &amp;obj) &#123; age = obj.age;&#125; 调用拷贝构造函数，即可进行简单拷贝，也就是浅拷贝。 12Person p1(10);Person p2(p1); 浅拷贝可以处理一般的对象拷贝，所以不需要额外写拷贝构造函数，直接用默认的拷贝构造函数，即可进行浅拷贝。 但一旦类带有指针变量，用浅拷贝就会出现错误。 如下面的类中，带有指针变量 1234567891011121314151617181920class Person &#123;private: int age; int *height; //指针变量public: Person(int m_age, int m_height) &#123; age = m_age; height = new int(m_height); &#125; ~Person() &#123; //析构函数，释放堆区动态分配的空间 if (height != NULL) &#123; delete height; height = NULL; &#125; &#125;&#125;; 如果使用编译器的默认拷贝构造函数，进行浅拷贝 1234Person(const Person &amp;obj) &#123; age = obj.age; height = obj.height;&#125; 12Person p1(10);Person p2(p1); p2的height与p1的height完全相同，都是指向堆区同一地址的指针。 在析构函数释放空间时，先释放完p1的height，对p2析构时，height已经释放，无法重新释放，发生错误。 所以类带有指针变量，并有动态内存分配，则必须自行定义拷贝构造函数，进行深度拷贝。 深拷贝，即在堆区重新申请空间，内容相同，但是不同的地址。 12345678910111213141516171819202122232425class Person &#123;private: int age; int *height; //指针变量public: Person(int m_age, int m_height) &#123; age = m_age; height = new int(m_height); &#125; Person(const Person &amp;obj) &#123; age = obj.age; //深拷贝 height = new int(*obj.height); &#125; ~Person() &#123; //析构函数，释放堆区动态分配的空间 if (height != NULL) &#123; delete height; height = NULL; &#125; &#125;&#125;; this指针每一个对象都能通过this指针来访问自己的地址，this指针指向被调用成员函数的所属对象。 主要用途： 形参和成员变量同名时，用this指针加以区分 返回对象本身 12345678910class Person&#123;private: int age;public: Person(int age)&#123; this-&gt;age = age; &#125;&#125;; 静态成员在类成员前加上static，称为静态成员。当声明成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本，静态成员在类的所有对象中是共享的。 静态成员变量 该类的所有对象共享同一份数据 编译阶段分配内存 类内声明，类外初始化 访问静态成员，可以用p1.A或者Person::A 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;class Person&#123;public: static int A; //类内声明静态成员变量&#125;;int Person::A = 10; //类外初始化int main () &#123; Person p1; cout &lt;&lt; p1.A &lt;&lt; endl; //10 //所有对象共享同一份数据，所以修改p2的A，p1的A也会相应变化 Person p2; p2.A = 20; cout &lt;&lt; p1.A &lt;&lt; endl; //20 return 0;&#125; 静态成员函数 该类的所有对象共享同一个函数 静态成员函数只能访问静态成员 静态成员函数与普通成员函数的根本区别在于： 普通成员函数有this指针，可以访问类中的任意成员 静态成员函数没有this指针，只能访问静态成员（包括静态成员变量和静态成员函数） 静态成员函数的作用：方便调用 12345class Solution &#123;public: void func1(); static void func2();&#125;; 调用func1()时，需要先生成类对象，才能调用 12Solution s;s.func1(); 调用静态成员函数func2()时，可以直接调用 1Solution::func2(); const常函数和常对象如果不希望数据被修改，可以加上const关键字来修饰成员变量、成员函数、对象。 常函数 成员函数后加const 常函数内不能修改成员变量 如果成员变量前加mutable，则可在常函数内改变该变量 12345678910class Person &#123;public: void test() const &#123; //常函数 m_A = 100; //错误，常函数中普通成员变量无法修改 m_B = 100; //正确，mutable变量可在常函数中修改 &#125; int m_A; mutable int m_B; //加入mutable后，可在常函数中修改&#125;; 成员函数中调用m_A，实际是调用了this -&gt; m_A 成员函数的this指针，本质是指针常量，也就是指针本身是一个常量，地址不变，即Person * const this;，此时this一直指向对象本身 如果为常函数，const修饰的是this指针的指向，this指针的指向的值内容不变，即const Person * const this;，此时this指向对象的内容不能被修改 get类型的成员函数一般都采用常函数，只需获取，不需修改 常对象 对象前加const 不能修改一般的成员变量，但可以修改mutable的成员变量 常对象只能调用const常函数（不能调用普通函数，因为普通的成员函数可能会修改成员变量） 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Person &#123;public: Person(string name, int age); string get_name() const; //常函数 void set_age(int age); //普通成员函数 int m_a; mutable int m_b; private: string m_name; mutable int m_age; &#125;;Person::Person(string name, int age) : m_name(name), m_age(age) &#123;&#125;string Person::get_name() const&#123; return m_name;&#125;void Person::set_age(int age) &#123; m_age = age;&#125;int main() &#123; const Person p(\"Job\", 20); cout &lt;&lt; p.get_name() &lt;&lt; endl; //正确，常对象只能调用常函数 p.set_age(30); //错误，常对象无法调用普通成员函数 p.m_a = 100; //错误，常对象无法修改普通成员变量 p.m_b = 100; //正确，常对象能修改mutable成员变量&#125; 友元友元定义在类的外部，不属于类的成员，但有访问private和protected的权限，在类中用关键字friend声明函数/类，即可将其设定为友元。 友元函数将全局函数加上关键字friend，在类中声明为友元，即可使其能够访问private和protected的权限成员。 尽管在类中有声明，但友元函数并不是成员函数。 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;class Person&#123; //将全局函数设置为友元，允许其访问私有成员 friend void print_age(Person &amp;p);private: int m_age;public: void set_age(int age);&#125;;void Person::set_age(int age) &#123; m_age = age;&#125;//全局函数void print_age(Person &amp;p) &#123; cout &lt;&lt; p.m_age &lt;&lt; endl; //允许访问私有成员m_age&#125;int main () &#123; Person p; p.set_age(18); print_age(p); return 0;&#125; 友元类将类加上关键字friend，在类中声明为友元，即可使其能够访问private和protected的权限成员。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;class Person&#123; //将类设置为友元，允许其访问私有成员 friend class PersonFriend;private: int m_age;public: Person()&#123; m_age = 18; &#125;&#125;;class PersonFriend&#123;public: void visit(); PersonFriend();private: Person *p;&#125;;PersonFriend::PersonFriend()&#123; p = new Person;&#125;void PersonFriend::visit()&#123; cout &lt;&lt; p-&gt;m_age &lt;&lt; endl; //可以访问Person类对象的私有成员&#125;int main () &#123; Person p; PersonFriend pf; pf.visit(); return 0;&#125; 运算符重载同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。 函数重载和普通的函数重载一致，利用形参的不同加以区分。 运算符重载，则是重新定义运算符，以适应类的运算。 运算符重载是通过函数实现的，它本质上是函数重载。可以作为类的成员函数，还可以作为全局函数。 在运算符前加上关键词operator，作为声明时的函数名。 可重载的运算符 类型 运算符 双目算术运算符 + (加)，-(减)，*(乘)，/(除)，% (取模) 关系运算符 ==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于)，&lt;=(小于等于)，&gt;=(大于等于) 逻辑运算符 \\ \\ (逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非) 单目运算符 + (正)，-(负)，*(指针)，&amp;(取地址) 自增自减运算符 ++(自增)，—(自减) 位运算符 \\ (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移) 赋值运算符 =, +=, -=, *=, /= , % = , &amp;=, =, ^=, &lt;&lt;=, &gt;&gt;= 空间申请与释放 new, delete, new[ ] , delete[] 其他运算符 ()(函数调用)，-&gt;(成员访问)，,(逗号)，[](下标) 不可重载的运算符 .：成员访问运算符 .*, -&gt;*：成员指针访问运算符 ::：域运算符 sizeof：长度运算符 ?:：条件运算符 #： 预处理符号 负号-重载（一元） 作为类的成员函数 123456789101112131415161718192021class Complex &#123;public: Complex (int i, int j); //重载-，作为类的成员函数 Complex operator- ();private: int m_i; int m_j;&#125;;Complex :: Complex (int i, int j) &#123; m_i = i; m_j = j;&#125;//重载-Complex Complex :: operator- () &#123; m_i = -m_i; m_j = -m_j; return *this;&#125; 还可以作为全局函数 123456789101112131415161718192021class Complex &#123; //重载-，在全局范围内重载运算符，设置为友元函数 friend Complex operator- (Complex &amp;c);public: Complex (int i, int j);private: int m_i; int m_j;&#125;;Complex :: Complex (int i, int j) &#123; m_i = i; m_j = j;&#125;//重载-Complex operator- (Complex &amp;c) &#123; c.m_i = -c.m_i; c.m_j = -c.m_j; return Complex(c.m_i, c.m_j);&#125; 调用-c，即可将m_i、m_j取反 12Complex c(1,2);-c; 加号+重载123456789101112131415161718192021class Complex &#123;public: Complex (int i, int j); //重载+ Complex operator+ (const Complex &amp;b);private: int m_i; int m_j;&#125;;Complex :: Complex (int i, int j) &#123; m_i = i; m_j = j;&#125;//重载+Complex Complex :: operator+ (const Complex &amp;b) &#123; int i = this-&gt;m_i + b.m_i; int j = this-&gt;m_j + b.m_j; return Complex(i, j);&#125; 调用a+b，即可将m_i、m_j相加 12Complex a(1,2), b(2,3);Complex c = a + b; 关系运算符==重载1234567891011121314151617181920212223class Complex &#123;public: Complex (int i, int j); //重载== bool operator== (const Complex &amp;b) const;private: int m_i; int m_j;&#125;;Complex :: Complex (int i, int j) &#123; m_i = i; m_j = j;&#125;//重载==bool Complex :: operator== (const Complex &amp;b) const &#123; if (m_i == b.m_i &amp;&amp; m_j == b.m_j) &#123; return true; &#125; else &#123; return false; &#125;&#125; 继承类与类之间可以有继承关系，已有一个基类，可以用一个派生类来继承基类 语法：class 派生类 : 继承方式 基类 123456789//基类class Animal &#123;...&#125;;//派生类class Dog : public Animal &#123;...&#125;; Dog就是Animal的派生类，可以继承基类的成员。 派生类可以继承基类的所有成员，但只有public和protected成员能被访问到，private成员可以继承，但无法访问。 继承方式继承方式分为三种：公共继承public、保护继承protected、私有继承private 例如一个基类A 12345678class A &#123;public: int a;protected: int b;private: int c;&#125;; 派生类B按不同继承方式，成员会继承为不同的权限 公共继承public 原public、protected依旧以public、protected继承，不可访问private。 12345678class B : public A &#123;public: int a;protected: int b;不可访问: int c;&#125;; 保护继承protected 原public、protected以protected继承，不可访问private。 1234567class B : protected A &#123;protected: int a; int b;不可访问: int c;&#125;; 私有继承private 原public、protected以private继承，不可访问private。 1234567class B : private A &#123;private: int a; int b;不可访问: int c;&#125;; 多继承一个派生类继承了多个基类。 1234class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,…&#123;...&#125;; 例如， 123class Son : public Mother, public Father &#123;...&#125;; 构造和析构顺序构造顺序、析构顺序镜像相反，先构造的后析构，先析构的后构造。 继承关系中， 构造顺序：基类构造 -&gt; 派生类构造 析构顺序：派生类析构 -&gt; 基类析构 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;class Father &#123;public: Father() &#123; cout &lt;&lt; \"Father构造\" &lt;&lt; endl; &#125; ~Father() &#123; cout &lt;&lt; \"Father析构\" &lt;&lt; endl; &#125;&#125;;class Son : public Father &#123;public: Son() &#123; cout &lt;&lt; \"Son构造\" &lt;&lt; endl; &#125; ~Son() &#123; cout &lt;&lt; \"Son析构\" &lt;&lt; endl; &#125;&#125;;int main() &#123; Son s; return 0;&#125; 输出： Father构造Son构造Son析构Father析构 当其他类作为本类成员时， 构造顺序：成员类构造 -&gt; 本类构造 析构顺序：本类析构 -&gt; 成员类析构 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;class A &#123;public: A() &#123; cout &lt;&lt; \"A构造\" &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; \"A析构\" &lt;&lt; endl; &#125;&#125;;class B &#123;public: B() &#123; cout &lt;&lt; \"B构造\" &lt;&lt; endl; &#125; ~B() &#123; cout &lt;&lt; \"B析构\" &lt;&lt; endl; &#125; private: A a;&#125;;int main(void)&#123; B b; return 0;&#125; 输出： A构造B构造B析构A析构 同名成员处理如果派生类和基类中有相同成员重名，那么就会遮蔽从基类继承过来的成员，使用派生类成员。 如基类Father和派生类Son中都有成员变量m_A 123Son s;cout &lt;&lt; s.m_A; //默认调用的是派生类Son中的m_Acout &lt;&lt; s.Father::m_A; //加作用域可调用基类Father中的m_A 基类成员函数和派生类成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样。 123Son s;s.func(); //默认调用的是派生类Son中的func函数s.Father::func(100); //加作用域可调用基类Father中的func函数 派生类赋值给基类（向上转型）派生类赋值给基类，称为向上转型。相应地，将基类赋值给派生类，称为向下转型。 向上转型非常安全，可以由编译器自动完成；向下转型有风险，需要程序员手动干预。 派生类对象赋值给基类对象 1Father f = Son(); 派生类指针赋值给基类指针 1Father *f = new Son(); 派生类引用赋值给基类引用 12Son s;Father &amp;f = s; 赋值只包含成员变量，不包含成员函数。所以调用同名成员函数时，f依旧调用的是原本基类Father的成员函数。 多态多态，即函数多种形态，分为两类： 静态多态 函数重载、运算符重载 静态：编译阶段绑定函数地址 动态多态 派生类和虚函数实现运行时的多态 动态：运行阶段绑定函数地址 当基类和派生类中有相同成员函数时， 12345678910111213class Animal &#123;public: void speak() &#123; cout &lt;&lt; \"动物发声\" &lt;&lt; endl; &#125;&#125;;class Cat : public Animal &#123;public: void speak() &#123; cout &lt;&lt; \"喵喵喵\" &lt;&lt; endl; &#125;&#125;; 派生类调用，会遮蔽基类中的所有同名函数，直接调用派生类的函数，所以c.speak();输出了“喵喵喵”。 派生类赋值给基类后，只改变成员变量，不改变成员函数，基类调用，依旧调用的是原本基类的成员函数，所以a-&gt;speak();输出了“动物发声”。 12345Cat c;c.speak(); //喵喵喵，调用派生类函数 Animal *a = &amp;c;a-&gt;speak(); //动物发声，调用基类函数 虚函数如果希望a-&gt;speak();调用的是派生类函数的“喵喵喵”，则应将基类的speak()设置为虚函数，添加关键字virtual 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;class Animal &#123;public: //虚函数 virtual void speak() &#123; cout &lt;&lt; \"动物发声\" &lt;&lt; endl; &#125;&#125;;class Cat : public Animal &#123;public: void speak() &#123; cout &lt;&lt; \"喵喵喵\" &lt;&lt; endl; &#125;&#125;;int main() &#123; Cat c; c.speak(); //喵喵喵，调用派生类函数 Animal *a = &amp;c; a-&gt;speak(); //喵喵喵，调用派生类函数 return 0;&#125; 如不是虚函数，在编译时就会静态链接，将a-&gt;speak();早绑定到基类函数上。 如是虚函数，在运行时才会动态链接，如此，便可将a-&gt;speak();绑定到派生类函数上。 纯虚函数如果基类中的虚函数没有实际意义，可以定义为纯虚函数。 1virtual 返回值类型 函数名 (函数参数) = 0; 纯虚函数没有函数体，只有函数声明，在虚函数声明的结尾加上=0，表明此函数为纯虚函数。 12345class Animal &#123;public: //纯虚函数 virtual void speak() = 0;&#125;; 模版C++泛型编程，主要技术就是模版。使变量变成通用变量，如vector&lt;int&gt;的利用模版技术，可以输入不同的数据类型。 函数模版/类模版 定义 分为建立一个通用函数/类，返回值和形参的类型可以不具体制定，而用一个虚拟类型来表示。 函数模版例如swap函数，输入的两个参数都是模版，所有可以交换两个int，也可以交换两个string。 类模版例如vector&lt;int&gt;，其中的成员类型可变换。 语法 12template &lt;typename T&gt;函数/类声明或定义 template表明声明一个模版 typename可以换成class，效果相同 T为通用数据类型名，告诉编译器不要报错 函数模版例子 自行定义一个交换函数模版 123456template&lt;typename T&gt;void Swap(T &amp;a, T &amp;b) &#123; T temp = a; a = b; b = temp;&#125; 调用模版函数，可以自动类型推导 12int a = 10, b = 20;Swap(a, b); 也可以指定类型 12int a = 10, b = 20;Swap&lt;int&gt;(a, b); 类模版 定义一个模版类 12345678910template&lt;typename NameType, typename AgeType&gt;class Person &#123; NameType m_name; AgeType m_age;public: Person(NameType name, AgeType age) &#123; m_name = name; m_age = age; &#125;&#125;; 调用模版类 1Person&lt;string, int&gt; p(\"Job\", 10); STLSTL（Standard Template Library），即标准模板库。 STL由三大组件构成：容器、算法、迭代器。 容器：特定的数据结构，如 向量（vector）、双端队列（deque）、链表（list）、集合（set）、多重集合（multiset）、映射（map）和多重映射（multimap）等 算法：常用的各种算法，如 sort、find、copy、for_each等 迭代器：检查容器内元素并遍历元素的数据类型 vector（向量） 向量（vector）是一个封装了动态大小数组的顺序容器 函数方法 代码 功能 v.front() 返回第一个数据 v.back() 返回最后一个数据 v.pop_back() 删除最后一个数据 v.push_back(element) 在尾部加一个数据 v.size() 返回元素个数 v.clear() 清除所有元素 v.resize(n,v) 改变数组大小为n，n个空间数值赋为v，如果没有默认赋值为0 v.insert(it,x) 向任意迭代器it插入一个元素x v.erase(first,last) 删除[first,last)的所有元素 v.begin() 返回首元素的迭代器 v.end() 返回最后一个元素后一个位置的迭代器 v.empty() 判断是否为空，为空返回真，反之返回假 基本用法运用vector容器需要引用vector头文件 1#include &lt;vector&gt; vector初始化 方法 描述 vector v 默认初始化一个空vector vector v2(v1) v2中包含有v1所有元素的副本 vector v2 = v1 等价于 v2(v1) vector v(n, val) n个重复的元素val vector v(n) n个重复的默认 vector v {a, b, c….} 赋值 vector v = {a, b, c….} 等价于 v{a, b, c….} 二维vector初始化 12// 初始化10*5的二维vector，元素值都为1vector&lt;vector&lt;int&gt;&gt; v(10, vector&lt;int&gt;(5, 1)); 尾部插入元素 1v.push_back(x); 插入元素 1v.insert(v.begin() + 2, x); //在第3个位置插入x 删除元素 12v.erase(v.begin() + 2); //删除第3个位置的元素v.erase(v.begin() + i, v.begin() + j); //删除第[i, j)位置的元素 遍历vector集合 123456789//迭代器遍历访问for(vector&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)&#123; cout &lt;&lt; *it &lt;&lt; \" \";&#125;//另一种遍历访问方式for(auto i : s)&#123; cout &lt;&lt; i &lt;&lt; \" \";&#125; set（集合） set（集合）的每个元素只出现一次，且默认升序排列。 函数方法 代码 功能 s.begin() 返回set容器的第一个元素的地址（迭代器） s.end() 返回set容器的最后一个元素的下一个地址（迭代器） s.rbegin() 返回逆序迭代器，指向容器元素最后一个位置 s.rend() 返回逆序迭代器，指向容器第一个元素前面的位置 s.clear() 删除set容器中的所有的元素,返回unsigned int类型O(N) s.empty() 判断set容器是否为空 s.insert() 插入一个元素 s.size() 返回当前set容器中的元素个数O(1) erase(iterator) 删除定位器iterator指向的值 erase(first,second） 删除定位器first和second之间的值 erase(key_value) 删除键值key_value的值 s.find(元素) 查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器，即s.end() s.lower_bound(k) 返回大于等于k的第一个元素的迭代器 s.upper_bound(k) 返回大于k的第一个元素的迭代器 基本用法运用set容器需要引用set头文件 1#include &lt;set&gt; set构造函数 12set&lt;int&gt; s; //默认按键值升序set&lt;int, greater&lt;int&gt;&gt; p; //降序 遍历set集合 123456789//迭代器遍历访问for(set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)&#123; cout &lt;&lt; *it &lt;&lt; \" \";&#125;//另一种遍历访问方式for(auto i : s)&#123; cout &lt;&lt; i &lt;&lt; \" \";&#125; map（映射） map（映射）的每个元素都是一个pair，包含 &lt;键值，实值&gt;，map不允许两个元素有相同的键值，所有元素根据键值自动排序。 函数方法 代码 功能 mp.find(key) 返回键为key的映射的迭代器，当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回mp.end() mp.erase(it) 删除迭代器对应的键和值 mp.erase(key) 根据映射的键删除键和值 mp.erase(first,last) 删除左闭右开区间迭代器对应的键和值 mp.size() 返回映射的对数 mp.clear() 清空map中的所有元素 mp.insert() 插入元素，插入时要构造键值对 mp.empty() 如果map为空，返回true，否则返回false mp.begin() 返回指向map第一个元素的迭代器（地址） mp.end() 返回指向map尾部的迭代器（最后一个元素的下一个地址） mp.rbegin() 返回指向map最后一个元素的反向迭代器（地址） mp.rend() 返回指向map第一个元素前面(上一个）的反向迭代器（地址） mp.count(key) 查看元素是否存在，因为map中键是唯一的，所以存在返回1，不存在返回0 mp.lower_bound() 返回一个迭代器，指向键值&gt;= key的第一个元素 mp.upper_bound() 返回一个迭代器，指向键值&gt; key的第一个元素 基本用法运用map容器需要引用map头文件 1#include &lt;map&gt; map构造函数 1map&lt;string, int&gt; mp; //键值为string，实值为int 添加元素 方法一：通过数组的方式插入值 1mp[\"a\"] = 1; //mp[key]，如果不存在对应的key时，会自动创建一个键值对 方法二：通过pair的方式插入对象 1234567mp.insert(&#123;\"a\", 1&#125;); mp.insert(make_pair(\"a\", 1)); mp.insert(&#123;\"a\",1&#125;); mp.insert(pair&lt;string, int&gt; (\"a\", 1)); 访问元素 通过下标访问 1cout &lt;&lt; mp[\"a\"] &lt;&lt; endl; 通过find函数访问 12map&lt;string, int&gt;::iterator it = mp.find(\"a\");cout &lt;&lt; it-&gt;first &lt;&lt; \" \" &lt;&lt; it-&gt;second &lt;&lt; endl; 遍历元素 通过迭代器遍历 1234// 正向遍历（利用begin和end函数）for(auto it = mp.begin(); it != mp.end(); ++it)&#123; cout &lt;&lt; it-&gt;first &lt;&lt; \" \" &lt;&lt; it-&gt;second &lt;&lt; endl;&#125; 123456// 逆向遍历（利用rbegin和rend函数）auto it = mp.rbegin();while (it != mp.rend()) &#123; cout &lt;&lt; it-&gt;first &lt;&lt; \" \" &lt;&lt; it-&gt;second &lt;&lt; endl; it++;&#125; 范围for语句遍历 1234// 只能访问，无法改变容器中的值for(auto i : mp)&#123; cout &lt;&lt; i.first &lt;&lt; \" \" &lt;&lt; i.second &lt;&lt; endl;&#125; 1234// 如需改变值，则用引用for(auto &amp;i : mp)&#123; i.second *= 2;&#125; 通过迭代器遍历时，迭代器it可以理解为指向元素的指针，指针用-&gt;访问，即it-&gt;first，或用(*it).first，可改变容器中的值 范围for语句遍历时，i是一个pair对象，直接用.访问，即it.first。只访问时，用auto i : mp，当需要改变值时，用auto &amp;i : mp deque（双端队列） deque（双端队列）首尾都可以插入和删除的队列。 函数方法 代码 功能 push_back(x) 把x压入后端 push_front(x) 把x压入前端 back() 访问(不删除)后端元素 front() 访问(不删除)前端元素 pop_back() 删除后端元素 pop_front() 删除前端元素 erase(iterator it) 删除双端队列中的某一个元素 erase(iterator first,iterator last) 删除双端队列中（first,last）中的元素 empty() 判断deque是否空 size() 返回deque的元素数量 clear() 清空deque 基本用法运用deque容器需要引用deque头文件 1#include &lt;deque&gt; deque构造函数 1deque&lt;int&gt; d; stack（栈） stack（栈），先进后出的数据结构。 函数方法 代码 功能 s.push(x) 将x压入栈顶 s.top() 返回栈顶的元素 s.pop() 删除栈顶的元素 s.size() 返回栈中元素的个数 s.empty() 检查栈是否为空,若为空返回true,否则返回false 基本用法运用stack容器需要引用stack头文件 1#include &lt;stack&gt; stack构造函数 1stack&lt;int&gt; s; string（字符串）string是C++中的一个类，专门实现字符串的相关操作。数据类型为string，字符串结尾没有\\0字符。 与之相比，C语言字符串（C-string），用char数组实现，字符串结尾以\\0结尾。 基本用法1#include &lt;string&gt; 初始化 1234567891011string str1; //生成空字符串string str2(\"12345678\"); //结果为\"12345678\"string str3(\"12345678\", 1, 3); //结果为\"234\"，从1号开始，长度为3的字符串string str4(\"12345678\", 3); //结果为\"123\"，从0号开始，长度为3的字符串string str4(5, '2'); //结果为\"22222\"，5个'2'string str4(str2, 3); //结果为\"45678\"，从3号开始的字符串 读入 cin &gt;&gt; str 读入字符串，遇到空格或回车结束 getline(cin, str)，读入一行字符串，包括空格，遇到回车结束 注意：cin输入回车结束后，回车仍在输入流中，getline会获取前一个输入的换行符，所以需要在前面添加读取换行符的语句：getchar() 或 cin.get() 错误读取方式 123string str1, str2;cin &gt;&gt; str1;getline(cin, str2); //此处getline只能读到上一个cin的换行符 正确读取方式 1234string str1, str2;cin &gt;&gt; str1;getchar(); //或者cin.get()，用于接收上一个换行符getline(cin, str2); //此处getline只能读到上一个cin的换行符 获取长度 代码 含义 s.size()或s.length() 返回string对象的字符个数 s.max_size() 返回string对象最多包含的字符数，超出会抛出length_error异常 s.capacity() 重新分配内存之前，string对象能包含的最大字符数 插入 代码 含义 s.push_back(element) 在末尾插入一个字符element s.insert(iterator it,element) 在迭代器it处插入一个字符element s.append(str) 在s字符串结尾添加str字符串 1234string s = \"123456\";s.push_back('a'); //结果：123456a，在末尾插入一个字符'a's.insert(s.begin(), 'b'); //结果：b123456a，在开头插入一个字符'b's.append(\"cdef\"); //结果：b123456acdef，在末尾添加字符串“cdef” 删除 代码 含义 s.erase(iterator it) 删除字符串中it所指的字符 s.erase(iterator first, iterator last) 删除字符串中迭代器区间[first,last)上所有字符 s.erase(pos, len) 删除字符串中从索引位置pos开始的len个字符 s.clear() 删除字符串中所有字符 123456string s = \"123456789\";s.erase(s.begin()); //结果：23456789，删除开头的一个字符s.erase(s.end()-1); //结果：2345678，删除结尾的一个字符s.erase(s.begin()+2, s.end()-2); //结果：2378，删除[first,last)上所有字符，不删lasts.erase(1, 2); //结果：28，删除从1号位开始的2个字符s.clear(); //结果：空 字符替换 代码 含义 s.replace(pos,n,str) 把当前字符串从索引pos开始的n个字符替换为str s.replace(pos,n,n1,c) 把当前字符串从索引pos开始的n个字符替换为n1个字符c s.replace(iterator first,iterator last,str) 把当前字符串[first,last)区间替换为str 1234string s = \"123456789\";s.replace(0, 3, \"abcd\"); //结果：abcd456789，将从0号位开始的3个字符替换为\"abcd\"s.replace(6, 3, 2, 'e'); //结果：abcd45ee9，将从6号位开始的3个字符替换为2个'e's.replace(s.begin()+2, s.end()-2, \"fff\"); //结果：abfffe9，将ab‘cd45e’e9中间替换为\"fff\" 分割 代码 含义 s.substr(pos,n) 截取从pos索引开始的n个字符 12string s = \"123456789\";string sub = s.substr(2, 3); //结果：345，截取从2号位开始的3个字符 查找 代码 含义 s.find (str, pos) 在当前字符串的pos索引位置(默认为0)开始，查找子串str，返回找到的位置索引，-1表示查找不到子串 s.find (c, pos) 在当前字符串的pos索引位置(默认为0)开始，查找字符c，返回找到的位置索引，-1表示查找不到字符 s.rfind (str, pos) 在当前字符串的pos索引位置开始，反向查找子串s、str，返回找到的位置索引，-1表示查找不到子串 s.rfind (c,pos) 在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到字符 s.find_first_of (str, pos) 在当前字符串的pos索引位置(默认为0)开始，查找子串str的字符，返回找到的位置索引，-1表示查找不到字符 s.find_first_not_of (str,pos) 在当前字符串的pos索引位置(默认为0)开始，查找第一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到字符 s.find_last_of(str, pos) 在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，-1表示查找不到字符 s.find_last_not_of (str, pos) 在当前字符串的pos索引位置开始，查找最后一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到子串 12345678910111213141516171819string s = \"This is a string.\"; //从首位开始，查找字符的第一个出现的位置cout &lt;&lt; s.find('s') &lt;&lt; endl; //结果：3，Thi's' //从首位开始，查找字符串第一个出现的位置，返回首字符位置cout &lt;&lt; s.find(\"is\")&lt;&lt; endl; //结果：2，Th'i's //从4号位开始，查找字符串第一个出现的位置cout &lt;&lt; s.find(\"is\", 4)&lt;&lt; endl; //结果：5，'i's a //从尾部开始，反向查找字符，即正序的最后一个位置cout &lt;&lt; s.rfind('s') &lt;&lt; endl; //结果：10，'s'tring //从尾位开始，反向查找字符串，即正序的最后一个位置，返回首字符位置cout &lt;&lt; s.rfind(\"is\") &lt;&lt; endl; //结果：5，'i's a //从4号位开始，反向查找字符串cout &lt;&lt; s.rfind(\"is\", 4) &lt;&lt; endl; //结果：2，Th'i's 排序 123string s = \"349725618\";sort(s.begin(), s.end()); //结果：123456789，默认升序sort(s.begin(), s.end(), greater&lt;char&gt;()); //结果：987654321 内存分配C++ 内存分为以下几个部分： 栈区（stack） 存放函数的参数值、局部变量、返回值、返回地址等 由编译器自动分配和释放 堆区（heap） 存放动态分配的内存，如 new 、 malloc 分配的动态变量 STL（除 pair）也都是存放在堆区 堆区大小不固定，由程序手动分配和释放 全局区/静态区（static） 存放全局变量、静态变量 static 分为 data 段和 bss 段，已初始化的全局变量和静态变量存放在 data 段，未初始化或者初始化为0的全局变量和静态变量存放在 bss 段 程序启动时被分配，直到程序结束时自动释放 常量区 存放常量，不允许修改 程序启动时被分配，直到程序结束时自动释放 代码区 存放指令代码 程序启动时被分配，直到程序结束时自动释放 1234567891011int a1; //全局区的bss段int a2 = 0; //全局区的bss段int a3 = 1; //全局区的data段const int b = 1; //全局区的data段int func(int c) &#123; //栈区 int d1 = 1; //栈区 const int d2 = 1; //栈区 static int d3 = 1; //全局区的data段 return d1; //栈区&#125; 类型转换隐式转换隐式转换，即在类型不统一时，系统自动进行的类型转换 何时发生隐式转换？ 算术运算中，低类型转换为高类型 赋值表达式中，右边的表达式的值自动转化为左边变量的类型 函数传参时，将实参转化为形参的类型 函数返回时，将返回表达式转化为返回值的类型 算数转换算数转换是隐式转换的一种，会将低类型转换为高类型 显式转换常见问题记录作为函数参数的多维数组 详见《C和指针》P159 传数组参数，即是要传递指向数组第一个元素的指针。 以一维数组为例，vector即为指向数组第一个int元素的指针 123int vector[10];...func1(vector); 参数vector是指向int型的指针，所以函数定义可以是如下两种方法 12void func1(int *vector);void func1(int vector[]); 多维数组传参，同样是传指向第一个元素的指针，但有所不同的是，多维数组的每个元素本身也是另一个数组，编译器需要知道它的维度。 以二维数组为例，二维数组matrix[3][10]相当于是包含3个元素的一维数组，每个元素又是一个包含10个元素的一维数组，matrix的类型是指向包含10个整型元素的数组的指针。 123int matrix[3][10];...func2(matrix); 所以，函数的原型必须包含第二个维度10，编译器才知道什么时候开始换行，可以有如下两种定义方式： 12void func1(int (*matrix)[10]);void func1(int matrix[][10]); 关键就在于编译器必须知道第2个及以后各维的长度，才能对下标进行求值 典型的错误写法 错误写法一：未包含第二个维度长度，**matrix为指向整型指针的指针，而不是指向数组的指针 1void func2(int **matrix); 错误写法二：*matrix[10]为指针数组，即数组元素是指针；(*matrix)[10]为数组指针，即指向数组的指针 1void func2(int *matrix[10]); 类模板头文件的编写c++中模板的声明和定义不能分开 问题描述如和一般的类头文件一样，将模板类中函数声明写在类名.hpp中，函数定义写在类名.cpp中，类名.cpp、main.cpp调用.h文件，则会出现报错： 1error: Undefined Symbol 成员函数 问题分析模板类中的成员函数在调用时才创建。 C++编译时，就要确定每个对象的空间大小。 但是，模板类在未被使用前，无法确定大小，比如vector&lt;int&gt;和vector&lt;char&gt;，这两套用不同数据类型的模版，实际是两个不同的类。 所以，c++中模板的声明和定义不能分开。 解决方法 方法一：将模板类中的成员函数的声明和定义都写在.h文件里 Stack.hpp++1234567891011121314151617181920212223242526272829#ifndef Stack_hpp#define Stack_hpp//顺序栈template &lt;typename T&gt;class Stack &#123; T *data; //成员数组 int top; //栈顶指针，当前栈顶元素的位置 int size; //栈中元素的最大个数public: Stack(); ~Stack();&#125;;//栈初始化template &lt;typename T&gt;Stack&lt;T&gt;::Stack() : top(-1), size(10) &#123; data = new T[size];&#125;//销毁栈template &lt;typename T&gt;Stack&lt;T&gt;::~Stack() &#123; delete [] data; data = nullptr;&#125;#endif 在main.cpp调用Stack.hpp文件 方法二：main.cpp调用类名.cpp文件，类名.cpp文件调用类名.h文件 Stack.hpp++12345678910111213141516#ifndef Stack_hpp#define Stack_hpp//顺序栈template &lt;typename T&gt;class Stack &#123; T *data; //成员数组 int top; //栈顶指针，当前栈顶元素的位置 int size; //栈中元素的最大个数public: Stack(); ~Stack();&#125;;#endif Stack.hpp++1234567891011121314#include \"Stack.hpp\"//栈初始化template &lt;typename T&gt;Stack&lt;T&gt;::Stack() : top(-1), size(10) &#123; data = new T[size];&#125;//销毁栈template &lt;typename T&gt;Stack&lt;T&gt;::~Stack() &#123; delete [] data; data = nullptr;&#125; 在main.cpp调用Stack.cpp文件 常用函数sort()排序函数sort()函数类似于快速排序，时间复杂度为 $n*log2(n)$ 头文件 1#include&lt;algorithm&gt; 基本使用方法 1sort(begin, end, cmp); begin：待排序的数组的第一个元素的指针 end：待排序的数组的最后一个元素的下一个位置的指针 cmp：排序准则，不填则默认为从小到大排序，如想要从大到小排序，则填greater&lt;int&gt;()。如需自行定义排序准则，也可传入bool型函数，返回true则不换位置，返回false则前后调换位置 用例 数组排序123int num[5] = &#123;4, 3, 2, 1, 0&#125;;sort(num, num+5); //从小到大排序：0 1 2 3 4sort(num, num+5, greater&lt;int&gt;()); //从大到小排序：4 3 2 1 0 vector排序12vector&lt;int&gt; v = &#123;4, 3, 2, 1, 0&#125;;sort(v.begin(), v.end()); //从小到大排序：0 1 2 3 4 自定义排序准则123456789//个位数从大到小排序bool cmp (int x, int y) &#123; return x % 10 &gt; y % 10; //x个位大于y时，返回true&#125;int main () &#123; int num[5] = &#123;24, 1, 83, 12, 30&#125;; sort(num, num + 5, cmp); //个位数从大到小排序：24 83 12 1 30&#125; 参考 C++入门教程，C++基础教程","categories":[{"name":"C++","slug":"C","permalink":"https://gy23333.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://gy23333.github.io/tags/C/"},{"name":"入门","slug":"入门","permalink":"https://gy23333.github.io/tags/%E5%85%A5%E9%97%A8/"},{"name":"Xcode","slug":"Xcode","permalink":"https://gy23333.github.io/tags/Xcode/"}]},{"title":"matlab GUI入门","slug":"matlab-GUI入门","date":"2020-01-07T18:49:56.000Z","updated":"2024-11-11T03:57:58.128Z","comments":true,"path":"2020/01/08/matlab-GUI入门/","link":"","permalink":"https://gy23333.github.io/2020/01/08/matlab-GUI%E5%85%A5%E9%97%A8/","excerpt":"​ Matlab GUI为图形用户界面，可以理解为相当于做一个软件，将输入输出函数操作通过交互界面表现出来，下面简单讲述一些Matlab GUI入门知识。","text":"​ Matlab GUI为图形用户界面，可以理解为相当于做一个软件，将输入输出函数操作通过交互界面表现出来，下面简单讲述一些Matlab GUI入门知识。 创建新的GUI界面​ GUI系统包含两种文件，一种是.fig文件，用于设计页面，另一种是.m文件，用来存放控件操作。 创建.fig文件 打开Matlab，在命令行窗口中输入 1guide 回车，弹出GUIDE快速入门弹窗； 选中默认的 Blank GUI (Default) ，点击确定新建GUI，自动生成新的.fig页面文件； 完成GUI的.fig文件的新建。 创建.fig文件​ 保存.fig文件时，会自动生成相对应的.m的文件。 ​ 现在，一个GUI界面已经搭建完成，你可以在.fig文件里增加修改控件、设计页面，在.m文件里编写逻辑代码。 .fig的页面设计控件 ​ 左侧的控件栏里面直接可通过拖拽放入控件，下面简单介绍一下课设里几种常用的控件。 按钮 双击拖拽出来的按钮，可进入按钮的检查器，在检查器里设置按钮的属性。 ​ 检查器中比较重要的几个属性： | Tag | 控件的名称（不重名），.m通过Tag来唯一寻找该控件，建议将需调用的控件换成有意义的名字，方便调用。 || —————— | —————————————————————————————— || String | 控件里面的文字 || FontSize | 控件里面的文字的字体大小 || Visible | 控件初始是否可见 || Callback | 调用函数（如是按钮的话，则点击按钮就会调用该函数），双击中间的书写按钮matlab会自动跳转到相应的.m中的调用函数的位置，方便书写 | 可编辑文本可编辑文本，可通过交互界面来进行编辑，当然也可在检查器中String里直接设置其初始值，常用于参数输入。 静态文本静态文本，不可通过交互界面来进行编辑，可设置String初始文本，也可通过.m修改，用于描述文字和输出。 坐标区坐标区，用于画图（动画、坐标图等）。 面板面板，可将各控件组合成一个集合，方便移动，显示更清晰。 工具​ 介绍两个我觉得用得到的。 对齐对象 ​ 用于对齐控件，使页面整齐美观。 ​ 例如，随意拖入几个文本，选中全部，设置好横纵对齐分布格式，点击应用。 ​ 瞬间就整齐了。 运行​ 可方便地查看页面显示。 .m的文件编写查看修改控件属性​ 应用广泛，比如检测输入框输入的内容和输出到输出的静态文本框。 检测输入框输入的内容： 1x = str2num(get(handles.Tagname, 'string')); % 从Tag属性为Tagname的String属性中获取x的string格式，再转为num（即在Tagname中输入的x） 输出到输出的静态文本框： 1set(handles.Tagname, 'string', num2str(y)); % 将参数y先从num转为string，再设置到Tag属性为Tagname的String属性中（即在Tagname中显示y） 页面跳转123h = gcf; % 本页面（不需关闭本页面此句省略）pagename; % 打开名字为pagename的页面close(h); % 关闭本页面（不需关闭本页面此句省略） 页面之间传参​ 既然有跳转，那就免不了传参，最简单的方法就是设置全局变量（适用于小系统）。 ​ 在用到该全局变量的函数开头都声明该全局变量即可。 1global x 画图​ 例如绘制一个三角函数 y = sinx先在界面放置好axes控件，这里命名为axes1； 1234X = 0:0.01:pi; % 设置x的范围(起始值：采样间隔：终止值)Y = sin(X); % 设置x-y的对应函数axes(handles.axes1); % 选则坐标区（axes）axes1plot(X, Y, 'b'); % 绘制X-Y（X轴变量，Y轴变量，点的颜色）","categories":[{"name":"MATLAB","slug":"MATLAB","permalink":"https://gy23333.github.io/categories/MATLAB/"}],"tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"https://gy23333.github.io/tags/MATLAB/"},{"name":"GUI","slug":"GUI","permalink":"https://gy23333.github.io/tags/GUI/"}]},{"title":"Mac WiFi连接无法弹出验证页面问题解决办法","slug":"Mac-WiFi连接无法弹出验证页面问题解决办法","date":"2019-12-21T07:24:14.000Z","updated":"2024-11-11T03:57:58.113Z","comments":true,"path":"2019/12/21/Mac-WiFi连接无法弹出验证页面问题解决办法/","link":"","permalink":"https://gy23333.github.io/2019/12/21/Mac-WiFi%E8%BF%9E%E6%8E%A5%E6%97%A0%E6%B3%95%E5%BC%B9%E5%87%BA%E9%AA%8C%E8%AF%81%E9%A1%B5%E9%9D%A2%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"问题连接公共Wi-Fi时常有弹出的验证页面，Mac显示已连接上Wi-Fi，但未弹出验证页面，无法使用网络。","text":"问题连接公共Wi-Fi时常有弹出的验证页面，Mac显示已连接上Wi-Fi，但未弹出验证页面，无法使用网络。 解决方法 打开“设置 &gt; 网络 &gt; 高级 ”； 确定 “TCP/IP”的“配置IPv4”选中“使用DHCP”； “DNS”中的“DNS服务器”减去添加配置，恢复原始配置。","categories":[{"name":"踩坑记录","slug":"踩坑记录","permalink":"https://gy23333.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"DNS","slug":"DNS","permalink":"https://gy23333.github.io/tags/DNS/"},{"name":"Mac","slug":"Mac","permalink":"https://gy23333.github.io/tags/Mac/"},{"name":"Wi-Fi连接","slug":"Wi-Fi连接","permalink":"https://gy23333.github.io/tags/Wi-Fi%E8%BF%9E%E6%8E%A5/"}]},{"title":"hough变换","slug":"hough变换","date":"2019-12-20T11:06:56.000Z","updated":"2024-11-11T03:57:58.113Z","comments":true,"path":"2019/12/20/hough变换/","link":"","permalink":"https://gy23333.github.io/2019/12/20/hough%E5%8F%98%E6%8D%A2/","excerpt":"​ hough变换主要用于找线，当然也可以扩展为找圆或者其他形状。","text":"​ hough变换主要用于找线，当然也可以扩展为找圆或者其他形状。 算法在Canny算法提取出边缘的基础上， 将原图像空间转到参数空间； 在参数空间 (u,v) 内建立两维数组 A( u,v ) ; 在开始时将数组置零； 对图像空间的每一个待检测点 (xi, yi) ，令 u 取遍所有可能的取值，并计算对应的v； ​ v = - xi * u + yi 对计算得到的 (u,v) ，对 A(u,v) 中相应单元进行累加: ​ A(u, v) = A(u, v) + 1 根据 A(u,v)的值，确定有多少点是共线的， 同时可以知道线条的参数(u,v)。 ​ y = u x + v C++实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215#include &lt;opencv2/opencv.hpp&gt;#include &lt;math.h&gt;#define _USE_MATH_DEFINES#define NUM_LINES 8#define MIN_LINEPOINTS 30using namespace cv;using namespace std;/** Hough变换(找到最长的NUM_LINES条直线) img为输入的二值边缘图像，lines为Hough变换提取出的直线 */int houghTrans_max(Mat img, vector&lt;Vec2f&gt; &amp;lines) &#123; int numangle = 360; int numr = int(sqrt(pow(img.rows, 2) + pow(img.cols, 2))); int numpoint[numangle][numr]; int numline = 0; // numpoint置0 for (int i = 0; i &lt; numangle; i++) &#123; for (int j = 0 ; j &lt; numr; j++) &#123; numpoint[i][j] = 0; &#125; &#125; // 循环遍历每个点，如果为边缘点则进行处理（遍历每个角度ang，算出相应的r） for (int j = 0; j &lt; img.rows; j++) &#123; for (int i = 0; i &lt; img.cols; i++) &#123; // 只取边缘点 if (img.ptr&lt;uchar&gt;(j)[i] == 255) &#123; // 遍历每个角度ang，算出相应的r for (int n = 0; n &lt; numangle/2; n++) &#123; double ang = double(n*M_PI/180); int r = int(i*cos(ang) + j*sin(ang)); if(r &lt; 0)&#123; int n1 = n+180; int r1 = -r; numpoint[n1][r1] ++; &#125; else &#123; numpoint[n][r] ++; //记录该角度半径下的点数 &#125; &#125; &#125; &#125; &#125; int minmax = 0; int maxNum[NUM_LINES]; for (int i = 0; i &lt; NUM_LINES; i++) &#123; maxNum[i] = 0; &#125; float lines_f[NUM_LINES][2]; // 遍历角度半径 for (int i = 0; i &lt; numangle; i++) &#123; for (int j = 0 ; j &lt; numr; j++) &#123; // 如该角度、半径下点数大于门限10，且进行非极大值抑制，则记录线 if (numpoint[i][j] &gt; MIN_LINEPOINTS &amp;&amp; (numpoint[i][j] &gt; minmax || numline &lt; NUM_LINES)) &#123; // 未满四条线时 if (numline &lt; NUM_LINES) &#123; maxNum[numline] = numpoint[i][j]; lines_f[numline][0] = float(j); lines_f[numline][1] = float(i*M_PI/180); minmax = maxNum[0]; for (int m = 0; m &lt; numline+1; m++) &#123; if (maxNum[m] &lt; minmax) &#123; minmax = maxNum[m]; &#125; &#125; &#125; // 满四条线时 else &#123; for (int m = 0; m &lt; NUM_LINES; m++) &#123; if (maxNum[m] == minmax) &#123; lines_f[m][0] = float(j); lines_f[m][1] = float(i*M_PI/180); maxNum[m] = numpoint[i][j]; break; &#125; &#125; minmax = maxNum[0]; for (int m = 0; m &lt; NUM_LINES; m++) &#123; if (maxNum[m] &lt; minmax) &#123; minmax = maxNum[m]; &#125; &#125; &#125; numline++; &#125; &#125; &#125; if (numline &gt; NUM_LINES) &#123; numline = NUM_LINES; &#125; int n = 0; for (int i = 0; i &lt; numline; i++) &#123; Vec2f l; l[0] = lines_f[i][0]; l[1] = lines_f[i][1]; lines.push_back(l); n++; &#125; return numline;&#125;/** Hough变换 img为输入的二值边缘图像，lines为Hough变换提取出的直线，threshold是共线的点数的阈值 */int houghTrans(Mat img, vector&lt;Vec2f&gt; &amp;lines, int threshold) &#123; int numangle = 360; int numr = int(sqrt(pow(img.rows, 2) + pow(img.cols, 2))); int numpoint[numangle][numr]; int numline = 0; // numpoint置0 for (int i = 0; i &lt; numangle; i++) &#123; for (int j = 0 ; j &lt; numr; j++) &#123; numpoint[i][j] = 0; &#125; &#125; // 循环遍历每个点，如果为边缘点则进行处理（遍历每个角度ang，算出相应的r） for (int j = 0; j &lt; img.rows; j++) &#123; for (int i = 0; i &lt; img.cols; i++) &#123; // 只取边缘点 if (img.ptr&lt;uchar&gt;(j)[i] == 255) &#123; // 遍历每个角度ang，算出相应的r for (int n = 0; n &lt; numangle/2; n++) &#123; double ang = double(n*M_PI/180); int r = int(i*cos(ang) + j*sin(ang)); if(r &lt; 0)&#123; int n1 = n+180; int r1 = -r; numpoint[n1][r1] ++; &#125; else &#123; numpoint[n][r] ++; //记录该角度半径下的点数 &#125; &#125; &#125; &#125; &#125; // 遍历角度半径 for (int i = 0; i &lt; numangle; i++) &#123; for (int j = 0 ; j &lt; numr; j++) &#123; // 如该角度、半径下点数大于门限，且进行非极大值抑制，则记录线 if (numpoint[i][j] &gt; threshold) &#123; Vec2f l; l[0] = float(j); l[1] = float(i*M_PI/180); lines.push_back(l); numline ++; &#125; &#125; &#125; return numline;&#125;/** 在图像上画线 img为输入图像，result为画完线的输出图像，lines为需要画的线 */void drawLines(Mat &amp;img, Mat &amp;result, vector&lt;Vec2f&gt; &amp;lines)&#123; cvtColor(img, result, COLOR_GRAY2BGR); //将IMREAD_GRAYSCALE转化为COLOR_GRAY2BGR格式，以便显示线 for( size_t i = 0; i &lt; lines.size(); i++ ) &#123; float rho = lines[i][0], theta = lines[i][1]; Point pt1, pt2; double a = cos(theta), b = sin(theta); if (rho/b &lt; 0) &#123; pt1.y = 0; pt1.x = cvRound(rho/a); &#125; else &#123; pt1.x = 0; pt1.y = cvRound(rho/b); &#125; if ((-(a/b)*float(img.cols-1)+rho/b) &gt;= img.rows) &#123; pt2.y = img.rows-1; pt2.x = cvRound(-(b/a)*float(img.rows-1) + rho/a); &#125; else &#123; pt2.x = img.cols-1; pt2.y = cvRound(-(a/b)*float(img.cols-1) + rho/b); &#125; line( result, pt1, pt2, Scalar(0,0,255), 1, LINE_AA); &#125;&#125;int main() &#123; Mat img, edge, result; img = imread(\"road.jpg\", IMREAD_GRAYSCALE); //从文件中加载灰度图像 // 读取图片失败，则停止 if (img.empty()) &#123; printf(\"读取图像文件失败\"); system(\"pause\"); return -1; &#125; Canny(img, edge, 100, 400); // canny变换 vector&lt;Vec2f&gt; lines;// int numline = houghTrans_max(edge, lines); // Hough变换(找到最长的NUM_LINES条直线)// HoughLines(edge, lines, 1, CV_PI/180, 150, 0, 0 ); // OpenCV的hough变换 houghTrans(edge, lines, 400); drawLines(img, result, lines);// 画线 // 图像显示 imshow(\"img\", img); imshow(\"canny\",edge);// 图像显示 imshow(\"hough\", result); waitKey(); imwrite(\"result.jpg\", result); return 0;&#125; 结果原图像： hough变化后的图像（找到直线用红线标出）：","categories":[{"name":"图像处理","slug":"图像处理","permalink":"https://gy23333.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://gy23333.github.io/tags/C/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://gy23333.github.io/tags/OpenCV/"},{"name":"图像处理","slug":"图像处理","permalink":"https://gy23333.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"hough","slug":"hough","permalink":"https://gy23333.github.io/tags/hough/"}]},{"title":"汇编学习笔记","slug":"汇编学习笔记","date":"2019-12-20T07:56:45.000Z","updated":"2024-11-11T03:57:58.116Z","comments":true,"path":"2019/12/20/汇编学习笔记/","link":"","permalink":"https://gy23333.github.io/2019/12/20/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"汇编学习","text":"汇编学习 如何在Mac上运行汇编程序安装nasm在命令行中安装nasm 1brew install nasm Mac中虽自带nasm，但版本太老，需重新安装。 新建asm文件下面名为 HelloWorld.asm 文件运行可输出hello world! 1234567891011121314151617181920msg: db &quot;hello world!&quot;, 0x0alen: equ $-msg SECTION .textglobal _main kernel: syscall ret _main: mov rax,0x2000004 mov rdi,1 mov rsi,msg mov rdx,len call kernel mov rax,0x2000001 mov rdi,0 call kernel 在命令行中运行 根据HelloWorld.asm生成相应的输出文件HelloWorld.o -o outfile write output to an outfile -f format select an output format（指定编译环境） 1nasm -f macho64 -o HelloWorld.o HelloWorld.asm 生成输出文件HelloWorld（格式：Unix可执行文件） 1ld HelloWorld.o -o HelloWorld -macosx_version_min 10.13 -lSystem -no_pie 运行HelloWorld文件 1.&#x2F;HelloWorld 运行成功 此时可看到文件夹中有三种文件（.asm、.o、Unix可执行文件）","categories":[{"name":"汇编","slug":"汇编","permalink":"https://gy23333.github.io/categories/%E6%B1%87%E7%BC%96/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://gy23333.github.io/tags/Mac/"},{"name":"汇编","slug":"汇编","permalink":"https://gy23333.github.io/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"某不科学的C课设入门（华科自动化C课设）","slug":"某不科学的C课设入门","date":"2019-12-17T04:10:28.000Z","updated":"2024-11-11T03:57:58.126Z","comments":true,"path":"2019/12/17/某不科学的C课设入门/","link":"","permalink":"https://gy23333.github.io/2019/12/17/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84C%E8%AF%BE%E8%AE%BE%E5%85%A5%E9%97%A8/","excerpt":"一些关于华科自动化C课设的经验总结，之前在课设群里发过pdf版的，现整理到博客上，如有问题可在下面进行评论。","text":"一些关于华科自动化C课设的经验总结，之前在课设群里发过pdf版的，现整理到博客上，如有问题可在下面进行评论。 入门建议预备知识C课设的大部分需要的知识都已经在自动化大一下学期的C语言课程上学习过了，这里主要就谈一些需要自学的知识，建议大家在暑假期间学习一下。 建立打开工程 跑一跑学长学姐的代码，看看大致是一个怎样的内容。学会如何在bc上建立一个工程。（详细过程请参考《Borland C++建立工程菜鸟教程》） 选择画图的模式，学习基本的画图方法 两种模式可供选择——VGA和SVGA | | 优点 | 缺点 || ———— | —————————————————————————————— | —————————————————————————————— || VGA | 具有众多的画图函数（例如画圆、画方框等），画图显示速度快（基本一跳转画图就完成） | 分辨率低，可选择的颜色少，不能贴图 || SVGA | 分辨率高，可选颜色多，可贴图 | 需要基于画点自己写画图函数，画图显示慢（页面显示时可以明显地看出画图的过程） | 建议：不要求较为复杂的页面的课题选择VGA模式，因为画图比较方便而且显示效果比较好；如果需要画较为复杂的页面和图形，或者必须得贴图的课题选择SVGA模式。 提醒：贴图须谨慎，非必要不贴图。每年的情况可能不同，打听一下今年的贴图的要求。 VGA画图函数可以参考《C高级实用程序设计（王士元）》中的章节。 鼠标的使用 重点是找到一个好用的鼠标，然后学会如何使用。（当然如果愿意自己写一个也是可以的，这样会理解的更透彻一些） 注意：不要用系统鼠标！！！ 系统鼠标是DOS下面自带的一个鼠标，在我们的电脑的bc跑的时候可以很好地显示，但是在验收用XP系统跑的时候，系统鼠标是无法显示出来的。 如何区分是否是系统鼠标？ 看有没有画鼠标的图形，如果该鼠标文件里面没有任何画图的过程直接调出鼠标的形状即为系统鼠标。 汉字显示 与鼠标相同，只要找一个汉字库加入工程，然后学会使用就行。 有些用Notepad++编写的同学会发现汉字乱码的情况，这是因为在编写的最初没有设置为简体汉字，Notepad++默认编码为UTF-8编码，在每次编写c文件前需要手动设为中文简体。 文件操作 需要自学文件的读取和写入的操作。由于不连网，所以课设中信息一般都是储存在文件中， 这时候的文件相当于课设系统的数据库。文件建议以二进制形式存储，这样读写的速度会更快。 其他建议 组内配合。C课设毕竟是个合作项目，很多人一开始忽视了搭档之间配合的重要性，最后一个人完成了大部分的工作，其实这样不仅会让你身心俱疲，而且也可能无法取得更高的分数（老师并不知道真正工作分配量，而且就算知道，不能和搭档较好的合作这个问题也会成为你的一个扣分项）。不建议组三人队，三人队对于课设来说人太多了些，但是已经组好了三人队也没关系，把功能多做一些，分摊到每个人的工作量不能小于二人队。 多找老师。找老师主要是两个方面：一是和老师讨论一下项目的总体规划（最好找出这道题的老师），不要让你的项目功能和老师想的偏差太大，可能的话多给几个老师看一下你的程序。二是找老师帮助debug，如果有bug一直都该不好，尽早找老师或者学长学姐问，不要拖。 仿照市面上已有的电脑版软件设计。课设最好的效果就是让人看起来像一个真实的软件。 尽早开始做。C课设至少要一到两个月的工作量，一般中期验收在10月中旬，终期验收在11月初或者中旬，所以建议最晚在9月中旬要开始工作，当然越早开始肯定是越好的啦。 验收前一周一定要去科技楼的电脑上跑一下程序，科技楼有一种银白色的主机是最后验收时跑的主机，（判断是否是最后验收时跑的方式的方法：工程在XP系统上直接运行，不需要打开BC），这种跑法可能会和你在自己电脑上或者科技楼非XP系统的电脑上跑得有很大的不同，所以一定要提前至少一周的时间去科技楼跑一下你的程序。最后有闲余的时间的话可以把程序里的warning全部消掉一下。 中期和终期报告尽量多写一些。中期验收会看报告页数，页数不够的会被打回去重写。 每个函数的行数不要过多。不要把一个页面所有的代码都堆在一个函数里，这样很可能让你带上重复代码来凑代码量的嫌疑，把带有功能的代码块提出成函数，这样也方便重复调用。 多功能性和稳定性。不一定要追求十分复杂的算法，重要的是扩展功能，特别是较为简单的题就得放开思路，使你的系统功能更加的丰富。 跑往届代码《Borland C++建立工程菜鸟教程》中很详细地讲述了如何建立工程的问题，所以这里就只是简述一下怎么打开已有的工程（这里就用我们组的工程进行演示，文件夹名为stock）。 第一步：把代码放到BC的DISK_C文件夹下。 第二步：打开BC，在 File &gt; Change Directory 里找到相应文件。 第三步：在 Project &gt; Open Project File 中找到 .prj 文件，打开。 第四步：设置Directories 在Options &gt; Directories中的第一行是头文件的地址，除了BC自带的头文件库外，还得添加自己程序的头文件所在地址。 第五步：上述几步都设置好了后就可以编译了 ​ Compile &gt; Build all 编译没有error，就可以跑了（Run &gt; Run） 之后就自己去玩啦。。。。。 如何搭建项目框架接下来我会演示我们组当时建立整个项目的框架，如何建工程《Borland C++建立工程菜鸟教程》中有讲，这里不在赘述。 Notepad++的使用建议使用第三方编译器来打代码（如Notepad++） Notepad++可在官网直接免费下载 用Notepad++新建一个文件后，一定要记得进行两个设置，一个是汉字（前面提过），一个是C语言。 项目框架的搭建事例项目test 将放在文件夹中一起提供给大家。 文件夹中需要编写的只有.c 和 .h文件，其余为自动生成和库。 主函数的编写主函数 main.c 主要由初始化部分和页面跳转部分组成。 1234567891011121314151617181920212223242526272829303132333435363738394041#include \"common.h\"#include \"main.h\"void main(void)&#123; /***********各种初始化*****************/ /*设定初始页面 调试的时候可以改变page的初始设定，直接跳转到需要调试的页面 */ int page = 0; //VGA画图的初始化 int graphdriver = VGA; int graphmode = VGAHI; initgraph(&amp;graphdriver, &amp;graphmode, \"BGI\"); //鼠标的初始化 mouseinit(); /* *********页面跳转循环*********** 每一个页面对应一个page值， 在各个页面的程序中，每一次有需要跳转页面的时候，就改变page值，且回到主程序 在主程序的循环中，通过page值的改变，跳转到相应页面 */ while(1) &#123; switch(page) &#123; case 0://页面1（初始页面） page = p1(); break; case 1://页面2 page = p2(); break; case 2://退出程序 closegraph();//关闭画图 exit(0);//退出程序 &#125; &#125;&#125; 页面跳转依赖while循环和switch case的结合，之后新开页面直接增加case就可以。 页面函数的编写页面函数主要是页面绘制和鼠标或者其他控制功能和页面跳转的两个部分。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include \"common.h\"#include \"page1.h\"//因为需要返回page值，所以页面的函数需是int型int p1(void)&#123; int page = 0; //防止鼠标在跳转页面时留痕 clrmous(MouseX,MouseY); delay(100); page1_screen(); /*循环，不停地监测异动，当异动导致page值改变，跳转页面*/ while(page == 0) &#123; //获取鼠标的位置和状态 mou_pos(&amp;MouseX,&amp;MouseY,&amp;press); //点击跳转页面框，跳转到页面2界面 if(mouse_press(180, 170, 180+280, 170+60) == 1) &#123; page = 1;//返回1到主函数的页面跳转循环 &#125; //点击退出程序框 else if(mouse_press(180, 170+60+40, 180+280, 170+60+40+60) == 1) &#123; page = 2;//返回2到主函数的页面跳转循环 &#125; &#125; return page;&#125;//绘制页面1界面void page1_screen(void)&#123; cleardevice();//把以前的页面清屏 setbkcolor(BLACK);//背景色设置 setfillstyle(SOLID_FILL, BLUE);//设定蓝色框 bar(180, 170, 180+280, 170+60);//跳转页面 setfillstyle(SOLID_FILL, RED);//设定红色框 bar(180, 170+60+40, 180+280, 170+60+40+60);//退出程序&#125; 页面1有两个框，点击蓝框跳转到页面2，点击红框退出程序。 页面2与页面1编写结构相同，只有一个红色的退出框。 123456789101112131415161718192021222324252627282930313233343536373839#include \"common.h\"#include \"page2.h\"////因为需要返回page值，所以页面的函数需是int型int p2(void)&#123; int page = 0; //防止鼠标在跳转页面时留痕 clrmous(MouseX,MouseY); delay(100); page2_screen(); /*循环，不停地监测异动，当异动导致page值改变，跳转页面*/ while(page == 0) &#123; //获取鼠标的位置和状态 mou_pos(&amp;MouseX,&amp;MouseY,&amp;press); //点击退出程序框 if(mouse_press(180, 200, 180+280, 200+60) == 1) &#123; page = 2; &#125; &#125; return page;//返回2到主函数的页面跳转循环&#125;//绘制页面2界面void page2_screen(void)&#123; cleardevice();//把以前的页面清屏 setbkcolor(BLACK);//背景色设置 setfillstyle(SOLID_FILL, RED);//设定红色框 bar(180, 200, 180+280, 200+60);//退出程序&#125; 头文件的编写头文件的编写有多种形式，这里写的只是我们当时用的那种，其他编写形式也是可以的。 从上面的.c文件中可以看出，我们的每一个.c都调用了两个头文件。 一个是同样的common.h，一个是与其文件名相同的 .h文件。 test的common.h如下图所示： 1234567891011#ifndef _COMMON_H_#define _COMMON_H_#include&lt;graphics.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;bios.h&gt;#include&lt;dos.h&gt;#include\"mouse.h\"#endif 我们用common.h装了所有需要用到的库文件和鼠标头文件，每次有新调用的库文件就加进去，这样每个.c文件都只要调用common.h，不需要再重新写调用的库文件。 另一种是与文件名相同的 .h文件，以main.h为例。 123456789#ifndef _MAIN_H_#define _MAIN_H_#include \"page1.h\"#include \"page2.h\"void main(void);#endif 与文件名相同的 .h文件包含两个部分，第一部分是其调用的位于其他文件的函数的头文件，如main中调用了p1()和p2()分别位于page1.h和page2.h；第二部分是该.c文件中所有的函数。 这样我们就搭建了一个有两个页面的简单工程。 最后祝学弟学妹们“0 warning, 0 error.”，之后的路就要靠学弟学妹们自己去探索，老妈子学姐就不再废话啦。","categories":[{"name":"C","slug":"C","permalink":"https://gy23333.github.io/categories/C/"}],"tags":[{"name":"入门","slug":"入门","permalink":"https://gy23333.github.io/tags/%E5%85%A5%E9%97%A8/"},{"name":"华科自动化","slug":"华科自动化","permalink":"https://gy23333.github.io/tags/%E5%8D%8E%E7%A7%91%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"C语言课程设计","slug":"C语言课程设计","permalink":"https://gy23333.github.io/tags/C%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"},{"name":"BorlandC","slug":"BorlandC","permalink":"https://gy23333.github.io/tags/BorlandC/"}]},{"title":"Mac使用Matlab卡顿严重且闪退的解决办法","slug":"Mac使用Matlab卡顿严重且闪退的解决办法","date":"2019-12-16T13:39:02.000Z","updated":"2024-11-11T03:57:58.127Z","comments":true,"path":"2019/12/16/Mac使用Matlab卡顿严重且闪退的解决办法/","link":"","permalink":"https://gy23333.github.io/2019/12/16/Mac%E4%BD%BF%E7%94%A8Matlab%E5%8D%A1%E9%A1%BF%E4%B8%A5%E9%87%8D%E4%B8%94%E9%97%AA%E9%80%80%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"问题安装Matlab后发现使用时十分卡顿且易闪退。","text":"问题安装Matlab后发现使用时十分卡顿且易闪退。 解决方法关闭 “MathWorks源代码管理集成”。 1、打开 “主页 &gt; 环境 &gt; 预设”； 2、打开 “常规 &gt; 原代码管理”，选择 “无”。 问题解决。","categories":[{"name":"踩坑记录","slug":"踩坑记录","permalink":"https://gy23333.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://gy23333.github.io/tags/Mac/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://gy23333.github.io/tags/MATLAB/"}]},{"title":"Canny边缘检测算法（C++实现）","slug":"Canny边缘检测算法（C++实现）","date":"2019-12-16T12:50:50.000Z","updated":"2024-11-11T03:57:58.122Z","comments":true,"path":"2019/12/16/Canny边缘检测算法（C++实现）/","link":"","permalink":"https://gy23333.github.io/2019/12/16/Canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%EF%BC%88C++%E5%AE%9E%E7%8E%B0%EF%BC%89/","excerpt":"步骤 用高斯滤波器平滑图像； 用一阶偏导有限差分计算梯度幅值和方向； 对梯度幅值应用非极大值抑制； 用双阈值算法检测和连接边缘。","text":"步骤 用高斯滤波器平滑图像； 用一阶偏导有限差分计算梯度幅值和方向； 对梯度幅值应用非极大值抑制； 用双阈值算法检测和连接边缘。 openCV在C++中的应用首先，在mac的Xcode上安装配置openCV库，参考一下链接（科学上网访问）https://medium.com/@jaskaranvirdi/setting-up-opencv-and-c-development-environment-in-xcode-b6027728003 1using namespace cv; // 使用命名空间cv 如此可以减少输入，例如 cv :: Mat 就可省略为 Mat MatMat的优点是不再需要手动分配其内存，并在不需要它时立即发布它。在执行此操作仍然是可能的情况下，大多数OpenCV功能将自动分配其输出数据。 Mat作为一个类，包含 矩阵头（包含矩阵的大小，用于存储的方法，存储在哪个地址的信息等等） 指向包含像素值（取决于所选存储方法的任何维度） 从文件中加载图像： 1Mat img = imread(filename); 如果需要加载灰度图： 1Mat img = imread(filename, IMREAD_GRAYSCALE); 显示图像： 12namedWindow(\"图片\"); //打开名为“图片”的窗口imshow(\"图片\", img); //显示图像 openCV加载图像显示 123456789101112using namespace cv; // 使用命名空间cvint main()&#123; Mat img = imread(\"building.jpg\", IMREAD_GRAYSCALE); //从文件中加载灰度图像 //显示图像 namedWindow(\"原图\"); imshow(\"原图\", img); waitKey(); //等待键值输入 return 0;&#125; 如何访问图像每一个像素点利用指针访问，调用 Mat::ptr(i) 来获取第i行的首地址，通过循环进行访问。 123456// 按行遍历所有点(单通道)for (int j = 0; j &lt; nr; j++) &#123; for (int i = 0; i &lt; nc; i++) &#123; //每个点为 img.ptr&lt;uchar&gt;(j)[i] &#125;&#125; 用高斯滤波器平滑图像高斯滤波器（openCV）openCV自带的高斯滤波器：cv :: GaussianBlur void cv::GaussianBlur ( InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY = 0, int borderType = BORDER_DEFAULT ) include 使用高斯滤镜模糊图像。 该函数将源图像与指定的高斯内核进行卷积。支持就地过滤。 参量 src 输入图像；图像可以具有任意数量的通道，这些通道可以独立处理，但深度应为CV_8U，CV_16U，CV_16S，CV_32F或CV_64F。 dst 输出与src大小和类型相同的图像。 size 高斯核大小。ksize.width和ksize.height可以不同，但它们都必须为正数和奇数。或者，它们可以为零，然后根据sigma计算得出。 sigmaX X方向上的高斯核标准偏差。 sigmaY Y方向的高斯核标准差；如果sigmaY为零，则将其设置为等于sigmaX；如果两个sigmas为零，则分别从ksize.width和ksize.height计算得出（有关详细信息，请参见getGaussianKernel）；为了完全控制结果，而不管将来可能对所有这些语义进行的修改，建议指定所有ksize，sigmaX和sigmaY。 borderType 像素外推方法，请参见BorderTypes 高斯滤波器的C++实现 对图像使用一维高斯卷积模版，在一个方向上进行滤波（例如水平方向）； 转置图像； 对转置后的图像使用同一个高斯卷积模版，在同样的方向上进行滤波； 将图像转置回原来的位置，得到二维高斯滤波的图像。 一维高斯卷积模版可以由二项式展开的系数来模拟，如3*3模版: 1/4 * [1 2 1] 123456789101112131415161718192021222324252627282930313233343536373839404142/** 高斯滤波器，利用3*3的高斯模版进行高斯卷积 img 输入原图像 dst 高斯滤波后的输出图像*/void gaussianFilter(Mat &amp;img, Mat &amp;dst) &#123; // 对水平方向进行滤波 Mat dst1 = img.clone(); gaussianConvolution(img, dst1); //图像矩阵转置 Mat dst2; transpose(dst1, dst2); // 对垂直方向进行滤波 Mat dst3 = dst2.clone(); gaussianConvolution(dst2, dst3); // 再次转置 transpose(dst3, dst);&#125;/** 一维高斯卷积，对每行进行高斯卷积 img 输入原图像 dst 一维高斯卷积后的输出图像 */void gaussianConvolution(Mat &amp;img, Mat &amp;dst) &#123; int nr = img.rows; int nc = img.cols; int templates[3] = &#123;1, 2, 1&#125;; // 按行遍历除每行边缘点的所有点 for (int j = 0; j &lt; nr; j++) &#123; uchar* data= img.ptr&lt;uchar&gt;(j); //提取该行地址 for (int i = 1; i &lt; nc-1; i++) &#123; int sum = 0; for (int n = 0; n &lt; 3; n++) &#123; sum += data[i-1+n] * templates[n]; //相称累加 &#125; sum /= 4; dst.ptr&lt;uchar&gt;(j)[i] = sum; &#125; &#125;&#125; 高斯滤波前后的图像： 高斯滤波 用一阶偏导有限差分计算梯度幅值和方向用一阶偏导有限差分计算偏导数的两个阵列P与Q 再由P和Q算出梯度幅值和方向角 12345678910111213141516171819/** 用一阶偏导有限差分计算梯度幅值和方向 img 输入原图像 gradXY 输出的梯度幅值 theta 输出的梯度方向 */void getGrandient (Mat &amp;img, Mat &amp;gradXY, Mat &amp;theta) &#123; gradXY = Mat::zeros(img.size(), CV_8U); theta = Mat::zeros(img.size(), CV_8U); for (int i = 0; i &lt; img.rows-1; i++) &#123; for (int j = 0; j &lt; img.cols-1; j++) &#123; double p = (img.ptr&lt;uchar&gt;(j)[i+1] - img.ptr&lt;uchar&gt;(j)[i] + img.ptr&lt;uchar&gt;(j+1)[i+1] - img.ptr&lt;uchar&gt;(j+1)[i])/2; double q = (img.ptr&lt;uchar&gt;(j+1)[i] - img.ptr&lt;uchar&gt;(j)[i] + img.ptr&lt;uchar&gt;(j+1)[i+1] - img.ptr&lt;uchar&gt;(j)[i+1])/2; gradXY.ptr&lt;uchar&gt;(j)[i] = sqrt(p*p + q*q); //计算梯度 theta.ptr&lt;uchar&gt;(j)[i] = atan(q/p); &#125; &#125;&#125; 此时输入输出图像为： 二维梯度算法 可以看出，二维计算梯度只区分出了部分边界，边界损失过大，于是采用三维算法计算梯度((y,x)为a11)。 a00 a01 a02 a10 a11 a12 a20 a21 a22 1234567891011121314151617181920212223double gradX = double(a02 + 2 * a12 + a22 - a00 - 2 * a10 - a20);double gradY = double(a00 + 2 * a01 + a02 - a20 - 2 * a21 - a22);/** 用一阶偏导有限差分计算梯度幅值和方向 img 输入原图像 gradXY 输出的梯度幅值 theta 输出的梯度方向 */void getGrandient (Mat &amp;img, Mat &amp;gradXY, Mat &amp;theta) &#123; gradXY = Mat::zeros(img.size(), CV_8U); theta = Mat::zeros(img.size(), CV_8U); for (int j = 1; j &lt; img.rows-1; j++) &#123; for (int i = 1; i &lt; img.cols-1; i++) &#123; double gradY = double(img.ptr&lt;uchar&gt;(j-1)[i-1] + 2 * img.ptr&lt;uchar&gt;(j-1)[i] + img.ptr&lt;uchar&gt;(j-1)[i+1] - img.ptr&lt;uchar&gt;(j+1)[i-1] - 2 * img.ptr&lt;uchar&gt;(j+1)[i] - img.ptr&lt;uchar&gt;(j+1)[i+1]); double gradX = double(img.ptr&lt;uchar&gt;(j-1)[i+1] + 2 * img.ptr&lt;uchar&gt;(j)[i+1] + img.ptr&lt;uchar&gt;(j+1)[i+1] - img.ptr&lt;uchar&gt;(j-1)[i-1] - 2 * img.ptr&lt;uchar&gt;(j)[i-1] - img.ptr&lt;uchar&gt;(j+1)[i-1]); gradXY.ptr&lt;uchar&gt;(j)[i] = sqrt(gradX*gradX + gradY*gradY); //计算梯度 theta.ptr&lt;uchar&gt;(j)[i] = atan(gradY/gradX); //计算梯度方向 &#125; &#125;&#125; 三维梯度算法的输入输出图像： 三维梯度算法 对梯度幅值应用非极大值抑制仅仅得到全局梯度并不足以确定边缘，保留局部梯度最大的点，而抑制非极大点。将梯度角的变化范围减小到圆周的四个扇区之一； 四个扇区的标号为0到3，对应3*3领域的四种可能组合方向； 每一个点上领域的中心像素M与沿着梯度线的两个像素比较； 如果M梯度值不比沿梯度线的两个相邻像素梯度值大，则令M=0。 由 atan() 得到的角度在 范围内，将此范围均分为四个等份。 123456789101112131415161718192021222324252627282930313233343536373839/** 局部非极大值抑制 gradXY 输入的梯度幅值 theta 输入的梯度方向 dst 输出的经局部非极大值抑制后的图像 */void nonLocalMaxValue (Mat &amp;gradXY, Mat &amp;theta, Mat &amp;dst) &#123; dst = gradXY.clone(); for (int j = 1; j &lt; gradXY.rows-1; j++) &#123; for (int i = 1; i &lt; gradXY.cols-1; i++) &#123; double t = double(theta.ptr&lt;uchar&gt;(j)[i]); double g = double(dst.ptr&lt;uchar&gt;(j)[i]); if (g == 0.0) &#123; continue; &#125; double g0, g1; if ((t &gt;= -(3*M_PI/8)) &amp;&amp; (t &lt; -(M_PI/8))) &#123; g0 = double(dst.ptr&lt;uchar&gt;(j-1)[i-1]); g1 = double(dst.ptr&lt;uchar&gt;(j+1)[i+1]); &#125; else if ((t &gt;= -(M_PI/8)) &amp;&amp; (t &lt; M_PI/8)) &#123; g0 = double(dst.ptr&lt;uchar&gt;(j)[i-1]); g1 = double(dst.ptr&lt;uchar&gt;(j)[i+1]); &#125; else if ((t &gt;= M_PI/8) &amp;&amp; (t &lt; 3*M_PI/8)) &#123; g0 = double(dst.ptr&lt;uchar&gt;(j-1)[i+1]); g1 = double(dst.ptr&lt;uchar&gt;(j+1)[i-1]); &#125; else &#123; g0 = double(dst.ptr&lt;uchar&gt;(j-1)[i]); g1 = double(dst.ptr&lt;uchar&gt;(j+1)[i]); &#125; if (g &lt;= g0 || g &lt;= g1) &#123; dst.ptr&lt;uchar&gt;(j)[i] = 0.0; &#125; &#125; &#125;&#125; 输入的经梯度计算后的图像和输出的局部非极大值抑制后的图像： 局部非极大值抑制 用双阈值算法检测和连接边缘1、Canny算法采用双阈值，高阈值一般是低阈值的两倍，遍历所有像素点： X &lt; 低阈值 ，像素点置0，被抑制掉； 低阈值 &lt; X &lt;高阈值，像素点为弱边缘点，像素点值先不变； X &gt; 高阈值，像素点为强边缘点，置255。 2、弱边缘点补充连接强边缘点： 如果弱边缘点的8邻点域存在强边缘点，则将此点置255，用以连接强边缘点；如果不存在强边缘点，则这是一个孤立的弱边缘点，此点置0。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** 用双阈值算法检测和连接边缘 low 输入的低阈值 high 输入的高阈值 img 输入的原图像 dst 输出的用双阈值算法检测和连接边缘后的图像 */void doubleThreshold (double low, double high, Mat &amp;img, Mat &amp;dst) &#123; dst = img.clone(); // 区分出弱边缘点和强边缘点 for (int j = 0; j &lt; img.rows-1; j++) &#123; for (int i = 0; i &lt; img.cols-1; i++) &#123; double x = double(dst.ptr&lt;uchar&gt;(j)[i]); // 像素点为强边缘点，置255 if (x &gt; high) &#123; dst.ptr&lt;uchar&gt;(j)[i] = 255; &#125; // 像素点置0，被抑制掉 else if (x &lt; low) &#123; dst.ptr&lt;uchar&gt;(j)[i] = 0; &#125; &#125; &#125; // 弱边缘点补充连接强边缘点 doubleThresholdLink(dst);&#125;/** 弱边缘点补充连接强边缘点 img 弱边缘点补充连接强边缘点的输入和输出图像 */void doubleThresholdLink (Mat &amp;img) &#123; // 循环找到强边缘点，把其领域内的弱边缘点变为强边缘点 for (int j = 1; j &lt; img.rows-2; j++) &#123; for (int i = 1; i &lt; img.cols-2; i++) &#123; // 如果该点是强边缘点 if (img.ptr&lt;uchar&gt;(j)[i] == 255) &#123; // 遍历该强边缘点领域 for (int m = -1; m &lt; 1; m++) &#123; for (int n = -1; n &lt; 1; n++) &#123; // 该点为弱边缘点（不是强边缘点，也不是被抑制的0点） if (img.ptr&lt;uchar&gt;(j+m)[i+n] != 0 &amp;&amp; img.ptr&lt;uchar&gt;(j+m)[i+n] != 255) &#123; img.ptr&lt;uchar&gt;(j+m)[i+n] = 255; //该弱边缘点补充为强边缘点 &#125; &#125; &#125; &#125; &#125; &#125; for (int j = 0; j &lt; img.rows-1; j++) &#123; for (int i = 0; i &lt; img.cols-1; i++) &#123; // 如果该点依旧是弱边缘点，及此点是孤立边缘点 if (img.ptr&lt;uchar&gt;(j)[i] != 255 &amp;&amp; img.ptr&lt;uchar&gt;(j)[i] != 255) &#123; img.ptr&lt;uchar&gt;(j)[i] = 0; //该孤立弱边缘点抑制 &#125; &#125; &#125;&#125; 双阈值算法前后的输入输出图像 ： 双阈值算法 Canny边缘检测代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include &lt;opencv2/opencv.hpp&gt;#include &lt;math.h&gt; #define _USE_MATH_DEFINES using namespace cv;// 使用命名空间cv /** 将两个图像拼接，以便在同一个窗口显示 dst 输出的拼接后的图像 src1 拼接的第一幅图 src2 拼接的第二幅图 */void mergeImg(Mat &amp; dst,Mat &amp;src1,Mat &amp;src2) &#123; int rows = src1.rows; int cols = src1.cols+5+src2.cols; CV_Assert(src1.type () == src2.type ()); dst.create (rows,cols,src1.type ()); src1.copyTo (dst(Rect(0,0,src1.cols,src1.rows))); src2.copyTo (dst(Rect(src1.cols+5,0,src2.cols,src2.rows)));&#125; /** 一维高斯卷积，对每行进行高斯卷积 img 输入原图像 dst 一维高斯卷积后的输出图像 */void gaussianConvolution(Mat &amp;img, Mat &amp;dst) &#123; int nr = img.rows; int nc = img.cols; int templates[3] = &#123;1, 2, 1&#125;; // 按行遍历除每行边缘点的所有点 for (int j = 0; j &lt; nr; j++) &#123; uchar* data= img.ptr&lt;uchar&gt;(j); //提取该行地址 for (int i = 1; i &lt; nc-1; i++) &#123; int sum = 0; for (int n = 0; n &lt; 3; n++) &#123; sum += data[i-1+n] * templates[n]; //相称累加 &#125; sum /= 4; dst.ptr&lt;uchar&gt;(j)[i] = sum; &#125; &#125;&#125; /** 高斯滤波器，利用3*3的高斯模版进行高斯卷积 img 输入原图像 dst 高斯滤波后的输出图像*/void gaussianFilter(Mat &amp;img, Mat &amp;dst) &#123; // 对水平方向进行滤波 Mat dst1 = img.clone(); gaussianConvolution(img, dst1); //图像矩阵转置 Mat dst2; transpose(dst1, dst2); // 对垂直方向进行滤波 Mat dst3 = dst2.clone(); gaussianConvolution(dst2, dst3); // 再次转置 transpose(dst3, dst);&#125; /** 用一阶偏导有限差分计算梯度幅值和方向 img 输入原图像 gradXY 输出的梯度幅值 theta 输出的梯度方向 */void getGrandient (Mat &amp;img, Mat &amp;gradXY, Mat &amp;theta) &#123; gradXY = Mat::zeros(img.size(), CV_8U); theta = Mat::zeros(img.size(), CV_8U); for (int j = 1; j &lt; img.rows-1; j++) &#123; for (int i = 1; i &lt; img.cols-1; i++) &#123; double gradY = double(img.ptr&lt;uchar&gt;(j-1)[i-1] + 2 * img.ptr&lt;uchar&gt;(j-1)[i] + img.ptr&lt;uchar&gt;(j-1)[i+1] - img.ptr&lt;uchar&gt;(j+1)[i-1] - 2 * img.ptr&lt;uchar&gt;(j+1)[i] - img.ptr&lt;uchar&gt;(j+1)[i+1]); double gradX = double(img.ptr&lt;uchar&gt;(j-1)[i+1] + 2 * img.ptr&lt;uchar&gt;(j)[i+1] + img.ptr&lt;uchar&gt;(j+1)[i+1] - img.ptr&lt;uchar&gt;(j-1)[i-1] - 2 * img.ptr&lt;uchar&gt;(j)[i-1] - img.ptr&lt;uchar&gt;(j+1)[i-1]); gradXY.ptr&lt;uchar&gt;(j)[i] = sqrt(gradX*gradX + gradY*gradY); //计算梯度 theta.ptr&lt;uchar&gt;(j)[i] = atan(gradY/gradX); //计算梯度方向 &#125; &#125;&#125; /** 局部非极大值抑制 gradXY 输入的梯度幅值 theta 输入的梯度方向 dst 输出的经局部非极大值抑制后的图像 */void nonLocalMaxValue (Mat &amp;gradXY, Mat &amp;theta, Mat &amp;dst) &#123; dst = gradXY.clone(); for (int j = 1; j &lt; gradXY.rows-1; j++) &#123; for (int i = 1; i &lt; gradXY.cols-1; i++) &#123; double t = double(theta.ptr&lt;uchar&gt;(j)[i]); double g = double(dst.ptr&lt;uchar&gt;(j)[i]); if (g == 0.0) &#123; continue; &#125; double g0, g1; if ((t &gt;= -(3*M_PI/8)) &amp;&amp; (t &lt; -(M_PI/8))) &#123; g0 = double(dst.ptr&lt;uchar&gt;(j-1)[i-1]); g1 = double(dst.ptr&lt;uchar&gt;(j+1)[i+1]); &#125; else if ((t &gt;= -(M_PI/8)) &amp;&amp; (t &lt; M_PI/8)) &#123; g0 = double(dst.ptr&lt;uchar&gt;(j)[i-1]); g1 = double(dst.ptr&lt;uchar&gt;(j)[i+1]); &#125; else if ((t &gt;= M_PI/8) &amp;&amp; (t &lt; 3*M_PI/8)) &#123; g0 = double(dst.ptr&lt;uchar&gt;(j-1)[i+1]); g1 = double(dst.ptr&lt;uchar&gt;(j+1)[i-1]); &#125; else &#123; g0 = double(dst.ptr&lt;uchar&gt;(j-1)[i]); g1 = double(dst.ptr&lt;uchar&gt;(j+1)[i]); &#125; if (g &lt;= g0 || g &lt;= g1) &#123; dst.ptr&lt;uchar&gt;(j)[i] = 0.0; &#125; &#125; &#125;&#125; /** 弱边缘点补充连接强边缘点 img 弱边缘点补充连接强边缘点的输入和输出图像 */void doubleThresholdLink (Mat &amp;img) &#123; // 循环找到强边缘点，把其领域内的弱边缘点变为强边缘点 for (int j = 1; j &lt; img.rows-2; j++) &#123; for (int i = 1; i &lt; img.cols-2; i++) &#123; // 如果该点是强边缘点 if (img.ptr&lt;uchar&gt;(j)[i] == 255) &#123; // 遍历该强边缘点领域 for (int m = -1; m &lt; 1; m++) &#123; for (int n = -1; n &lt; 1; n++) &#123; // 该点为弱边缘点（不是强边缘点，也不是被抑制的0点） if (img.ptr&lt;uchar&gt;(j+m)[i+n] != 0 &amp;&amp; img.ptr&lt;uchar&gt;(j+m)[i+n] != 255) &#123; img.ptr&lt;uchar&gt;(j+m)[i+n] = 255; //该弱边缘点补充为强边缘点 &#125; &#125; &#125; &#125; &#125; &#125; for (int j = 0; j &lt; img.rows-1; j++) &#123; for (int i = 0; i &lt; img.cols-1; i++) &#123; // 如果该点依旧是弱边缘点，及此点是孤立边缘点 if (img.ptr&lt;uchar&gt;(j)[i] != 255 &amp;&amp; img.ptr&lt;uchar&gt;(j)[i] != 255) &#123; img.ptr&lt;uchar&gt;(j)[i] = 0; //该孤立弱边缘点抑制 &#125; &#125; &#125;&#125; /** 用双阈值算法检测和连接边缘 low 输入的低阈值 high 输入的高阈值 img 输入的原图像 dst 输出的用双阈值算法检测和连接边缘后的图像 */void doubleThreshold (double low, double high, Mat &amp;img, Mat &amp;dst) &#123; dst = img.clone(); // 区分出弱边缘点和强边缘点 for (int j = 0; j &lt; img.rows-1; j++) &#123; for (int i = 0; i &lt; img.cols-1; i++) &#123; double x = double(dst.ptr&lt;uchar&gt;(j)[i]); // 像素点为强边缘点，置255 if (x &gt; high) &#123; dst.ptr&lt;uchar&gt;(j)[i] = 255; &#125; // 像素点置0，被抑制掉 else if (x &lt; low) &#123; dst.ptr&lt;uchar&gt;(j)[i] = 0; &#125; &#125; &#125; // 弱边缘点补充连接强边缘点 doubleThresholdLink(dst);&#125; int main () &#123; Mat img = imread(\"woman.jpg\", IMREAD_GRAYSCALE); //从文件中加载灰度图像 // 读取图片失败，则停止 if (img.empty()) &#123; printf(\"读取图像文件失败\"); system(\"pause\"); return 0; &#125; // 高斯滤波 Mat gauss_img; gaussianFilter(img, gauss_img); //高斯滤波器 // 用一阶偏导有限差分计算梯度幅值和方向 Mat gradXY, theta; getGrandient(gauss_img, gradXY, theta); // 局部非极大值抑制 Mat local_img; nonLocalMaxValue(gradXY, theta, local_img); // 用双阈值算法检测和连接边缘 Mat dst; doubleThreshold(40, 80, local_img, dst); // 图像显示 Mat outImg; mergeImg (outImg,img,dst); //图像拼接 namedWindow(\"img\"); imshow(\"img\",outImg);// 图像显示 imwrite(\"canny算法.jpg\", outImg); waitKey(); //等待键值输入 return 0;&#125; Canny边缘检测的前后图像 Canny边缘检测算法 参考资源： 【1】Setting up OpenCV and C++ development environment in Xcode for Computer Vision projects 【2】OpenCV Tutorials 【3】OpenCV教程","categories":[{"name":"图像处理","slug":"图像处理","permalink":"https://gy23333.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[{"name":"Canny","slug":"Canny","permalink":"https://gy23333.github.io/tags/Canny/"},{"name":"C++","slug":"C","permalink":"https://gy23333.github.io/tags/C/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://gy23333.github.io/tags/OpenCV/"},{"name":"图像处理","slug":"图像处理","permalink":"https://gy23333.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}]},{"title":"命令行执行hexo d后，出现错误ERROR Deployer not found: git","slug":"命令行执行hexo-d后，出现错误ERROR-Deployer-not-found-git","date":"2019-12-16T11:50:26.000Z","updated":"2024-11-11T03:57:58.109Z","comments":true,"path":"2019/12/16/命令行执行hexo-d后，出现错误ERROR-Deployer-not-found-git/","link":"","permalink":"https://gy23333.github.io/2019/12/16/%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%A7%E8%A1%8Chexo-d%E5%90%8E%EF%BC%8C%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AFERROR-Deployer-not-found-git/","excerpt":"问题命令行执行hexo d后，出现错误ERROR Deployer not found: git","text":"问题命令行执行hexo d后，出现错误ERROR Deployer not found: git 解决办法命令行在hexo的根目录位置执行 npm install --save hexo-deployer-git","categories":[{"name":"踩坑记录","slug":"踩坑记录","permalink":"https://gy23333.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://gy23333.github.io/tags/hexo/"},{"name":"error","slug":"error","permalink":"https://gy23333.github.io/tags/error/"}]},{"title":"Mac权限无法修改问题解决办法","slug":"Mac权限无法修改问题解决办法","date":"2019-12-16T08:33:33.000Z","updated":"2024-11-11T03:57:58.108Z","comments":true,"path":"2019/12/16/Mac权限无法修改问题解决办法/","link":"","permalink":"https://gy23333.github.io/2019/12/16/Mac%E6%9D%83%E9%99%90%E6%97%A0%E6%B3%95%E4%BF%AE%E6%94%B9%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"Mac里文件夹必须以管理员身份才可写入，staff只有读的权限，且在文件夹简介中修改显示弹窗“无权限修改”。 苹果官方解决办法","text":"Mac里文件夹必须以管理员身份才可写入，staff只有读的权限，且在文件夹简介中修改显示弹窗“无权限修改”。 苹果官方解决办法 解决办法下面以文件夹post为例， 此时staff为只读权限，需修改为读和写权限 在共享与权限设置中点击“应用到包含的项目”先在“共享与权限”右下角的地方解锁，再在设置中选中“应用到包含的项目”，等待进度条结束即可。 命令行操作打开命令行，在根目录下输入 1diskutil resetUserPermissions &#x2F; &#96;id -u&#96; 重启命令行运行结束后重启电脑。 修改权限重启后再次打开该文件夹的“简介”，发现权限可修改了，权限修改完成。","categories":[{"name":"踩坑记录","slug":"踩坑记录","permalink":"https://gy23333.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://gy23333.github.io/tags/Mac/"},{"name":"权限","slug":"权限","permalink":"https://gy23333.github.io/tags/%E6%9D%83%E9%99%90/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://gy23333.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Golang","slug":"Golang","permalink":"https://gy23333.github.io/categories/Golang/"},{"name":"Linux","slug":"Linux","permalink":"https://gy23333.github.io/categories/Linux/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://gy23333.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Docker","slug":"Docker","permalink":"https://gy23333.github.io/categories/Docker/"},{"name":"环境配置","slug":"环境配置","permalink":"https://gy23333.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"英语","slug":"英语","permalink":"https://gy23333.github.io/categories/%E8%8B%B1%E8%AF%AD/"},{"name":"人工智能","slug":"人工智能","permalink":"https://gy23333.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"Computer Vision","slug":"Computer-Vision","permalink":"https://gy23333.github.io/categories/Computer-Vision/"},{"name":"图像处理","slug":"图像处理","permalink":"https://gy23333.github.io/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://gy23333.github.io/categories/MATLAB/"},{"name":"Hexo","slug":"Hexo","permalink":"https://gy23333.github.io/categories/Hexo/"},{"name":"Latex","slug":"Latex","permalink":"https://gy23333.github.io/categories/Latex/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://gy23333.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"C++","slug":"C","permalink":"https://gy23333.github.io/categories/C/"},{"name":"踩坑记录","slug":"踩坑记录","permalink":"https://gy23333.github.io/categories/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"name":"汇编","slug":"汇编","permalink":"https://gy23333.github.io/categories/%E6%B1%87%E7%BC%96/"},{"name":"C","slug":"C","permalink":"https://gy23333.github.io/categories/C/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://gy23333.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"堆","slug":"堆","permalink":"https://gy23333.github.io/tags/%E5%A0%86/"},{"name":"Golang","slug":"Golang","permalink":"https://gy23333.github.io/tags/Golang/"},{"name":"logrotate","slug":"logrotate","permalink":"https://gy23333.github.io/tags/logrotate/"},{"name":"FRRouting","slug":"FRRouting","permalink":"https://gy23333.github.io/tags/FRRouting/"},{"name":"BIRD","slug":"BIRD","permalink":"https://gy23333.github.io/tags/BIRD/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://gy23333.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Linux","slug":"Linux","permalink":"https://gy23333.github.io/tags/Linux/"},{"name":"Load Balancing","slug":"Load-Balancing","permalink":"https://gy23333.github.io/tags/Load-Balancing/"},{"name":"路由协议","slug":"路由协议","permalink":"https://gy23333.github.io/tags/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/"},{"name":"BGP","slug":"BGP","permalink":"https://gy23333.github.io/tags/BGP/"},{"name":"systemd","slug":"systemd","permalink":"https://gy23333.github.io/tags/systemd/"},{"name":"Docker","slug":"Docker","permalink":"https://gy23333.github.io/tags/Docker/"},{"name":"OSPF","slug":"OSPF","permalink":"https://gy23333.github.io/tags/OSPF/"},{"name":"学习路线","slug":"学习路线","permalink":"https://gy23333.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"name":"DPDK","slug":"DPDK","permalink":"https://gy23333.github.io/tags/DPDK/"},{"name":"TRex","slug":"TRex","permalink":"https://gy23333.github.io/tags/TRex/"},{"name":"gRPC","slug":"gRPC","permalink":"https://gy23333.github.io/tags/gRPC/"},{"name":"git","slug":"git","permalink":"https://gy23333.github.io/tags/git/"},{"name":"python","slug":"python","permalink":"https://gy23333.github.io/tags/python/"},{"name":"GDB","slug":"GDB","permalink":"https://gy23333.github.io/tags/GDB/"},{"name":"DNS","slug":"DNS","permalink":"https://gy23333.github.io/tags/DNS/"},{"name":"BIND","slug":"BIND","permalink":"https://gy23333.github.io/tags/BIND/"},{"name":"语言基本语法","slug":"语言基本语法","permalink":"https://gy23333.github.io/tags/%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://gy23333.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"栈","slug":"栈","permalink":"https://gy23333.github.io/tags/%E6%A0%88/"},{"name":"环境配置","slug":"环境配置","permalink":"https://gy23333.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"VSCode","slug":"VSCode","permalink":"https://gy23333.github.io/tags/VSCode/"},{"name":"C/C++","slug":"C-C","permalink":"https://gy23333.github.io/tags/C-C/"},{"name":"表达式求值","slug":"表达式求值","permalink":"https://gy23333.github.io/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"},{"name":"深度优先搜索（DFS）","slug":"深度优先搜索（DFS）","permalink":"https://gy23333.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88DFS%EF%BC%89/"},{"name":"图","slug":"图","permalink":"https://gy23333.github.io/tags/%E5%9B%BE/"},{"name":"动态规划","slug":"动态规划","permalink":"https://gy23333.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Makefile","slug":"Makefile","permalink":"https://gy23333.github.io/tags/Makefile/"},{"name":"Coach-Shane","slug":"Coach-Shane","permalink":"https://gy23333.github.io/tags/Coach-Shane/"},{"name":"HTML","slug":"HTML","permalink":"https://gy23333.github.io/tags/HTML/"},{"name":"人工智能","slug":"人工智能","permalink":"https://gy23333.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"有序搜索","slug":"有序搜索","permalink":"https://gy23333.github.io/tags/%E6%9C%89%E5%BA%8F%E6%90%9C%E7%B4%A2/"},{"name":"八数码问题","slug":"八数码问题","permalink":"https://gy23333.github.io/tags/%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/"},{"name":"问题归约","slug":"问题归约","permalink":"https://gy23333.github.io/tags/%E9%97%AE%E9%A2%98%E5%BD%92%E7%BA%A6/"},{"name":"梵塔问题","slug":"梵塔问题","permalink":"https://gy23333.github.io/tags/%E6%A2%B5%E5%A1%94%E9%97%AE%E9%A2%98/"},{"name":"SURF算子","slug":"SURF算子","permalink":"https://gy23333.github.io/tags/SURF%E7%AE%97%E5%AD%90/"},{"name":"特征描述","slug":"特征描述","permalink":"https://gy23333.github.io/tags/%E7%89%B9%E5%BE%81%E6%8F%8F%E8%BF%B0/"},{"name":"SIFT算子","slug":"SIFT算子","permalink":"https://gy23333.github.io/tags/SIFT%E7%AE%97%E5%AD%90/"},{"name":"傅立叶变换","slug":"傅立叶变换","permalink":"https://gy23333.github.io/tags/%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/"},{"name":"高斯金字塔","slug":"高斯金字塔","permalink":"https://gy23333.github.io/tags/%E9%AB%98%E6%96%AF%E9%87%91%E5%AD%97%E5%A1%94/"},{"name":"拉普拉斯金字塔","slug":"拉普拉斯金字塔","permalink":"https://gy23333.github.io/tags/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E9%87%91%E5%AD%97%E5%A1%94/"},{"name":"小波金字塔","slug":"小波金字塔","permalink":"https://gy23333.github.io/tags/%E5%B0%8F%E6%B3%A2%E9%87%91%E5%AD%97%E5%A1%94/"},{"name":"C++","slug":"C","permalink":"https://gy23333.github.io/tags/C/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://gy23333.github.io/tags/OpenCV/"},{"name":"Xcode","slug":"Xcode","permalink":"https://gy23333.github.io/tags/Xcode/"},{"name":"Mac","slug":"Mac","permalink":"https://gy23333.github.io/tags/Mac/"},{"name":"摄像头权限","slug":"摄像头权限","permalink":"https://gy23333.github.io/tags/%E6%91%84%E5%83%8F%E5%A4%B4%E6%9D%83%E9%99%90/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://gy23333.github.io/tags/MATLAB/"},{"name":"高斯滤波","slug":"高斯滤波","permalink":"https://gy23333.github.io/tags/%E9%AB%98%E6%96%AF%E6%BB%A4%E6%B3%A2/"},{"name":"均值滤波","slug":"均值滤波","permalink":"https://gy23333.github.io/tags/%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2/"},{"name":"中值滤波","slug":"中值滤波","permalink":"https://gy23333.github.io/tags/%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2/"},{"name":"Hexo","slug":"Hexo","permalink":"https://gy23333.github.io/tags/Hexo/"},{"name":"blog","slug":"blog","permalink":"https://gy23333.github.io/tags/blog/"},{"name":"入门","slug":"入门","permalink":"https://gy23333.github.io/tags/%E5%85%A5%E9%97%A8/"},{"name":"Latex","slug":"Latex","permalink":"https://gy23333.github.io/tags/Latex/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://gy23333.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"云开发","slug":"云开发","permalink":"https://gy23333.github.io/tags/%E4%BA%91%E5%BC%80%E5%8F%91/"},{"name":"图像处理","slug":"图像处理","permalink":"https://gy23333.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"数学形态学","slug":"数学形态学","permalink":"https://gy23333.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BD%A2%E6%80%81%E5%AD%A6/"},{"name":"区域分割","slug":"区域分割","permalink":"https://gy23333.github.io/tags/%E5%8C%BA%E5%9F%9F%E5%88%86%E5%89%B2/"},{"name":"区域分裂与合并","slug":"区域分裂与合并","permalink":"https://gy23333.github.io/tags/%E5%8C%BA%E5%9F%9F%E5%88%86%E8%A3%82%E4%B8%8E%E5%90%88%E5%B9%B6/"},{"name":"区域生长","slug":"区域生长","permalink":"https://gy23333.github.io/tags/%E5%8C%BA%E5%9F%9F%E7%94%9F%E9%95%BF/"},{"name":"大津法","slug":"大津法","permalink":"https://gy23333.github.io/tags/%E5%A4%A7%E6%B4%A5%E6%B3%95/"},{"name":"直方图均衡化","slug":"直方图均衡化","permalink":"https://gy23333.github.io/tags/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/"},{"name":"GUI","slug":"GUI","permalink":"https://gy23333.github.io/tags/GUI/"},{"name":"Wi-Fi连接","slug":"Wi-Fi连接","permalink":"https://gy23333.github.io/tags/Wi-Fi%E8%BF%9E%E6%8E%A5/"},{"name":"hough","slug":"hough","permalink":"https://gy23333.github.io/tags/hough/"},{"name":"汇编","slug":"汇编","permalink":"https://gy23333.github.io/tags/%E6%B1%87%E7%BC%96/"},{"name":"华科自动化","slug":"华科自动化","permalink":"https://gy23333.github.io/tags/%E5%8D%8E%E7%A7%91%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"C语言课程设计","slug":"C语言课程设计","permalink":"https://gy23333.github.io/tags/C%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"},{"name":"BorlandC","slug":"BorlandC","permalink":"https://gy23333.github.io/tags/BorlandC/"},{"name":"Canny","slug":"Canny","permalink":"https://gy23333.github.io/tags/Canny/"},{"name":"hexo","slug":"hexo","permalink":"https://gy23333.github.io/tags/hexo/"},{"name":"error","slug":"error","permalink":"https://gy23333.github.io/tags/error/"},{"name":"权限","slug":"权限","permalink":"https://gy23333.github.io/tags/%E6%9D%83%E9%99%90/"}]}