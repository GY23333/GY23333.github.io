<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BGP 路由协议</title>
    <url>/2024/10/23/BGP-%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>BGP 路由协议</p>
<a id="more"></a>
<h1 id="BGP-路由选择策略"><a href="#BGP-路由选择策略" class="headerlink" title="BGP 路由选择策略"></a>BGP 路由选择策略</h1><p>对于同一个目的地址，路由器会收到多个路径，BGP 对这些路径进行选择分类，决定最终的路由选择</p>
<ul>
<li>Available：可用路径<ul>
<li>所有合法的可用路径</li>
</ul>
</li>
<li>Best：最佳路径<ul>
<li>通过 BGP 最佳路由选择策略，选出来的唯一一个路由，作为最佳路由</li>
</ul>
</li>
<li>Select：选择路径<ul>
<li>在 BGP 最佳路由选择策略中，前 8 步都与 Best Path 属性相同的路径</li>
<li>这些 Select Path 将会加入路由表，实现 BGP 负载均衡</li>
</ul>
</li>
</ul>
<h2 id="BGP-最佳路由选择策略"><a href="#BGP-最佳路由选择策略" class="headerlink" title="BGP 最佳路由选择策略"></a>BGP 最佳路由选择策略</h2><p>当路由器收到到同一个目的地址的多个 Available Path，BGP 最佳路由选择策略从中选出一条 Best Path。</p>
<p>以下是 BGP 最佳路径选择策略，按比较顺序排列：</p>
<ol>
<li><strong>优选权重（Weight）最高的路径</strong></li>
<li><strong>优选本地优先级（Local Preference）最高的路径</strong></li>
<li><strong>优选起本地生成的路径</strong><ul>
<li>本地内部生成的路由优先级高于从外部学到的路由</li>
<li>本地生成的路由，即通过<code>network</code>命令或<code>aggregate</code>命令手动注入的路由</li>
</ul>
</li>
<li><strong>优选 AS Path 长度最短的路径</strong><ul>
<li>AS Path：一个路由经过的自治系统（AS）序列</li>
<li>优先级比较 AS Path 长度，而非 AS Path 本身<ul>
<li>路径 1 的 AS Path：<code>65005 65004 65003</code></li>
<li>路径 2 的 AS Path：<code>65006 65003</code></li>
<li>只比较两者的长度，路径 1 长度为 3，路径 2 长度为 2，优选路径 2</li>
</ul>
</li>
</ul>
</li>
<li><strong>优选 Origin Type 优先级最高的路径</strong><ul>
<li>Origin Type 用于表示路由来源类型，共有三种：<ul>
<li>IGP：内部网关协议，Internal Gateway Protocol</li>
<li>EGP：外部网关协议，Exterior Gateway Protocol</li>
<li>Incomplete：不确定来源</li>
</ul>
</li>
<li>优先级 IGP &gt; EGP &gt; Incomplete</li>
</ul>
</li>
<li><strong>优选 MED 最小的路径</strong><ul>
<li>MED，Multi-Exit Discriminator，多出口鉴别，只在两个 AS 之间交换，不会传到第三个 AS</li>
<li>两个 AS 之间可能有多条链路连接，MED 用于决定选择那条链路</li>
<li>MED 默认值：0</li>
</ul>
</li>
<li><strong>优选邻居路由器类型为 eBGP 先于 iBGP</strong><ul>
<li>eBGP，external BGP，外部 BGP，不同 AS 之间的 BGP</li>
<li>iBGP，internal BGP，内部 BGP，相同 AS 内部的 BGP</li>
<li>优选 eBGP 路由器，即优选跨 AZ 路径，到达这一步比较的路由，如同时有 eBGP 和 iBGP 路径，iBGP 路径是经过了内部转发再到 eBGP 路由器的绕行路径，所以优选直接到 eBGP 路由器的路径</li>
</ul>
</li>
<li><strong>优选到 BGP next hop 的 IGP 度量值最小的路径</strong><ul>
<li>IGP metric，内部路由度量值，在第七步中选择 iBGP 才需要比较步骤，否则跳过</li>
<li>IGP 越小，则去该下一跳的开销越小</li>
<li><strong>到该步如存在多个路径条件都相同，则 BGP 负载均衡</strong></li>
</ul>
</li>
<li><strong>优选来自 Route ID 最小的路由器的路径</strong></li>
<li><strong>优选 Cluster List 最短的路径</strong></li>
<li><strong>优选来自 IP 地址最小的 Neighbor 的路径</strong></li>
</ol>
<h2 id="BGP-负载均衡"><a href="#BGP-负载均衡" class="headerlink" title="BGP 负载均衡"></a>BGP 负载均衡</h2><p>BGP Multipath 允许给一个目的地址加载多个 BGP 路径到 IP 路由表，这些路由实现 BGP 负载均衡。这不影响上步中的 Best Path 的选择，依旧从多个路径中选择一条路径作为 Best Path。在此基础之上，可以选取多个路径作为 Select Path，一同加入路由表，实现多路径负载均衡。</p>
<ul>
<li>Select Path 在路由选择策略中的前 8 步必须与 Best Path 完全相同，即有相同的 Weight、Local Preference、AS Path length、Origin Type、MED、eBGP/iBGP、IGP Metric</li>
<li>Best Path 必然包含在 Select Path 中</li>
<li><code>maximum-paths</code> 设置 BGP 最多允许的 Select Path 数量，如果设置为 1，则 Select Path 只能有一个，也就是 Best Path</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/13753-25.html" target="_blank" rel="noopener">Select BGP Best Path Algorithm</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>路由协议</tag>
        <tag>BGP</tag>
      </tags>
  </entry>
  <entry>
    <title>Daily English Dictation</title>
    <url>/2021/01/06/Daily-English-Dictation/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>关于B站Coach Shane老师的<a href="https://www.bilibili.com/video/BV1U7411a7xG" target="_blank" rel="noopener">每日英语听写 Daily English Dictation 1-400</a>的学习记录。</p>
<a id="more"></a>
<h1 id="D1"><a href="#D1" class="headerlink" title="D1"></a>D1</h1><iframe src="//player.bilibili.com/player.html?aid=84745697&bvid=BV1U7411a7xG&cid=144914957&page=2" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<ul>
<li>Mother Teresa, who received a Nobel Peace Price for her work on behalf of the poor, dies in Calcutta, India — She was 87 years old.</li>
<li>dies 用一般现在时表过去发生的事，给人身临其境的感觉。</li>
</ul>
<h1 id="D2"><a href="#D2" class="headerlink" title="D2"></a>D2</h1><iframe src="//player.bilibili.com/player.html?aid=84745697&bvid=BV1U7411a7xG&cid=144915110&page=3" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<ul>
<li><p>Jerry, wha<u>t t</u>ime  do you have (de yuh ave) ?</p>
<p>I have (a<u>ve) f</u>ive o’clock.</p>
</li>
<li><p>wha<u>t t</u>ime 两相同音，保留第二个，即 wha time</p>
</li>
<li><p>7 Hs：he, her, him, his, have, has, had</p>
<p>连读时，去掉h发音，即 have(ave)</p>
</li>
</ul>
<h1 id="D3"><a href="#D3" class="headerlink" title="D3"></a>D3</h1><iframe src="//player.bilibili.com/player.html?aid=84745697&bvid=BV1U7411a7xG&cid=144915235&page=4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<ul>
<li><p>The<u>re ar</u>e three things I have(ave) learned Never to(t’) discuss with people, religion, politics and the Great Pumpkin!</p>
</li>
<li><p>Never 重度第一音，表示决心</p>
</li>
<li><p>to的7种发音：to, tah, tuh, t’, dah, duh, d’</p>
<p>其中较为常用的是：t’, d’</p>
</li>
</ul>
<h1 id="D4"><a href="#D4" class="headerlink" title="D4"></a>D4</h1><iframe src="//player.bilibili.com/player.html?aid=84745697&bvid=BV1U7411a7xG&cid=144915301&page=5" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<ul>
<li><p>Don’t ever (Don-ever) let(le) somebody tell you you can’t(can) do something(sump’n).</p>
</li>
<li><p>强音：S, N, L</p>
<p>弱音：d, t, th</p>
<p>当强音遇到了弱音，弱音省略，即 Don’t(Don)</p>
</li>
<li><p>can’t同样因为强弱音原则变成can，但是重音与表肯定的can又区别。表否定的can’t读作短促的can</p>
</li>
<li><p>something(sump’n)</p>
</li>
</ul>
<h1 id="D5"><a href="#D5" class="headerlink" title="D5"></a>D5</h1><iframe src="//player.bilibili.com/player.html?aid=84745697&bvid=BV1U7411a7xG&cid=144915349&page=6" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<ul>
<li><p>I have come here to(d’) chew bubblegum and(an) kick ass… and(an) I’m(ah<u>m) a</u>l<u>l ou</u>t of (<u>ou</u>tta) bubblegum!</p>
</li>
<li><p>to的7种发音：to, tah, tuh, t’, dah, duh, d’</p>
<p>其中较为常用的是：t’, d’</p>
</li>
<li><p>and(an) 强弱音原则</p>
</li>
<li><p>I’m(ahm)</p>
</li>
<li><p>out of (outta)</p>
</li>
</ul>
<h1 id="D6"><a href="#D6" class="headerlink" title="D6"></a>D6</h1><iframe src="//player.bilibili.com/player.html?aid=84745697&bvid=BV1U7411a7xG&cid=144915414&page=7" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<ul>
<li>The secre<u>t o</u>f li<u>fe i</u>s just(juss) to(t’) li<u>ve e</u>very moment.</li>
</ul>
<h1 id="D7"><a href="#D7" class="headerlink" title="D7"></a>D7</h1><iframe src="//player.bilibili.com/player.html?aid=84745697&bvid=BV1U7411a7xG&cid=144915414&page=8" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<ul>
<li>Anothe<u>r r</u>ogue trader has cos<u>t a</u> bank billions.</li>
</ul>
<h1 id="D8"><a href="#D8" class="headerlink" title="D8"></a>D8</h1><iframe src="//player.bilibili.com/player.html?aid=84745697&bvid=BV1U7411a7xG&cid=144915414&page=9" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<ul>
<li>German, Rolf Buchholz, is the (ize) man wi<u>th th</u>e most(mos) piercings, he’s got 453!</li>
<li>is the (ize) 强弱音原则</li>
<li>wi<u>th th</u>e 相似音留后一个</li>
<li>453 -&gt; four hu-nerd fivety three</li>
</ul>
<h1 id="D9"><a href="#D9" class="headerlink" title="D9"></a>D9</h1><iframe src="//player.bilibili.com/player.html?aid=84745697&bvid=BV1U7411a7xG&cid=144915414&page=10" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<ul>
<li>A satelli<u>te th</u>at was carri<u>ed to</u>(t’) space aboar<u>d th</u>e shuttle Discovery twenty(twen<u>y) y</u>ear<u>s a</u>ge, i<u>s a</u>bou<u>t t</u>o(t’) fall to(d’) Earth, but noboby know<u>s wh</u>ere the debris(d’-bree) will hit.</li>
</ul>
<h1 id="D10"><a href="#D10" class="headerlink" title="D10"></a>D10</h1><iframe src="//player.bilibili.com/player.html?aid=84745697&bvid=BV1U7411a7xG&cid=144915414&page=11" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<ul>
<li>It’<u>s a</u> (I’sa) lofty, probably impossible goal.</li>
</ul>
<h1 id="D11"><a href="#D11" class="headerlink" title="D11*"></a>D11*</h1><iframe src="//player.bilibili.com/player.html?aid=84745697&bvid=BV1U7411a7xG&cid=144915414&page=12" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<ul>
<li>New York swep<u>t th</u>e Tampa Bay Rays by identical 4-2 scores in a day-night doubleheader Wednesday.</li>
<li>Doubleheader 一天连赛两场</li>
<li>以同样的4比2的比分连赢两场</li>
</ul>
<h1 id="D12"><a href="#D12" class="headerlink" title="D12*"></a>D12*</h1><iframe src="//player.bilibili.com/player.html?aid=84745697&bvid=BV1U7411a7xG&cid=144915414&page=13" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<ul>
<li>Jim Henson, creator of(o’) the Muppets - from Kermit the Frog to Sesame Street, is born in Greenville , MS.</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>Coach-Shane</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS与Bind</title>
    <url>/2023/03/19/DNS%E4%B8%8EBind/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>基于《DNS与Bind》的学习</p>
<a id="more"></a>
<h1 id="DNS基础"><a href="#DNS基础" class="headerlink" title="DNS基础"></a>DNS基础</h1><p>TCP/IP网络依赖IP地址进行设备间通信，但是数字形式的IP地址难以记忆，所以使用域名（如www.google.com）解析成IP地址，以便访问该网络设备。</p>
<p>本机上的<code>/etc/hosts</code>中存放了部分域名到IP地址的映射，可以手工维护，分散式管理映射。</p>
<p>如在mac中的Finder中按下<code>Shift</code>+<code>command</code>+<code>G</code>，输入<code>/etc/hosts</code>，即可找到本机的名称解析配置文件。</p>
<p>但<code>hosts</code>文件不可能存下所有的（域名，IP地址）映射，于是便引入了DNS。</p>
<p>域名系统（Domain Name System，DNS）通过分布式的数据库来实现IP地址和域名的映射。</p>
<p>DNS基于C/S架构，服务端端口号UDP53、TCP53。</p>
<h2 id="DNS域名结构"><a href="#DNS域名结构" class="headerlink" title="DNS域名结构"></a>DNS域名结构</h2><p>DNS采用分布式的数据库，是一个逆向的树形结构。</p>
<p>DNS树每个节点代表一个域</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/Network_DNS_Server.png" alt="DNS域名空间"></p>
<ul>
<li><p>根域名服务器</p>
<p>  最高层的域就是根域root，全球共13台根域名服务器，根域即是一个点 <code>.</code> ，通常都省略不写。</p>
</li>
<li><p>顶级域名服务器</p>
<p>  又称一级域名，常见的有”.com”、”.org”、”.net”、”.cn”等。</p>
</li>
</ul>
<p>剩下的域为二级、三级、四级域，最多可达127级域名。</p>
<blockquote>
<p>FQDN 全称域名 = 主机名 + 域名</p>
<p>以 <code>www.baidu.com</code> 和 <code>tieba.baidu.com</code> 为例<br><code>baidu.com</code> 为域名，<code>www</code> 和 <code>tieba</code> 都是 <code>baidu.com</code> 下的主机，一个域下可以定义多台主机，只需配置好主机名和对应主机的IP地址即可。</p>
<p><code>www.baidu.com</code>本该有一个根域名的 <code>.</code>，即 <code>www.baidu.com.</code>，但根域名的 <code>.</code> 一般省略不写。</p>
</blockquote>
<h2 id="DNS查询方法"><a href="#DNS查询方法" class="headerlink" title="DNS查询方法"></a>DNS查询方法</h2><h3 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h3><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_iterated-query.png" alt=""></p>
<h3 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h3><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_recursive-query.png" alt=""></p>
<h3 id="缓存和更新"><a href="#缓存和更新" class="headerlink" title="缓存和更新"></a>缓存和更新</h3><h3 id="域名解析顺序"><a href="#域名解析顺序" class="headerlink" title="域名解析顺序"></a>域名解析顺序</h3><ul>
<li>查找 /etc/hosts</li>
<li></li>
</ul>
<h1 id="DNS软件BIND"><a href="#DNS软件BIND" class="headerlink" title="DNS软件BIND"></a>DNS软件BIND</h1><p>BIND是一款提供DNS服务的软件，Centos安装BIND作为DNS服务器，程序名称为named</p>
<p>BIND相关程序包有4个：</p>
<ul>
<li><code>bind</code>：服务器</li>
<li><code>bind-libs</code>：相关库</li>
<li><code>bind-utils</code>：客户端工具</li>
<li><code>bind-chroot</code>：安全包</li>
</ul>
<h2 id="Bind安装"><a href="#Bind安装" class="headerlink" title="Bind安装"></a>Bind安装</h2><p>在Centos上使用<code>yum</code>安装的bind</p>
<ul>
<li><p>切换到root用户，以获取权限</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su root</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>yum</code>安装Bind</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install bind</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装完bind后，相关程序包存在依赖性，也会一起安装，可以用<code>rpm</code>查看是否顺带安装了相关程序包</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qi bind-libs</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qi bind-utils</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qi bind-chroot</span><br></pre></td></tr></table></figure>
<p>  如缺少<code>bind-libs</code>、<code>bind-utils</code>，建议单独安装</p>
</li>
</ul>
<h2 id="BIND包相关文件"><a href="#BIND包相关文件" class="headerlink" title="BIND包相关文件"></a>BIND包相关文件</h2><p>查询BIND包相关文件列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ql bind</span><br></pre></td></tr></table></figure>
<p>里面的常用文件介绍：</p>
<ul>
<li>BIND主程序：<code>/usr/sbin/named</code></li>
<li>主配置文件：<code>/etc/named.conf</code></li>
<li>数据库目录：<code>/var/named</code></li>
</ul>
<h1 id="启动DNS服务"><a href="#启动DNS服务" class="headerlink" title="启动DNS服务"></a>启动DNS服务</h1><p>启动named程序，本机即可充当DNS服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start named</span><br></pre></td></tr></table></figure>
<h1 id="查看DNS服务器"><a href="#查看DNS服务器" class="headerlink" title="查看DNS服务器"></a>查看DNS服务器</h1><h2 id="方法一：可视化页面中查看DNS"><a href="#方法一：可视化页面中查看DNS" class="headerlink" title="方法一：可视化页面中查看DNS"></a>方法一：可视化页面中查看DNS</h2><p>右上角 <code>Wired Settings</code> -&gt; <code>Wired</code>的设置 -&gt; DNS</p>
<h2 id="方法二：查看DNS客户机配置文件（-etc-resolv-conf）"><a href="#方法二：查看DNS客户机配置文件（-etc-resolv-conf）" class="headerlink" title="方法二：查看DNS客户机配置文件（/etc/resolv.conf）"></a>方法二：查看DNS客户机配置文件（/etc/resolv.conf）</h2><p><code>/etc/resolv.conf</code>是DNS客户机配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;resolv.conf</span><br></pre></td></tr></table></figure>
<p>查看该文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Generated by NetworkManager</span><br><span class="line">search localdomain</span><br><span class="line">nameserver 192.168.45.2</span><br></pre></td></tr></table></figure>
<p>查看<code>nameserver</code>项，可以看出使用的DNS服务器的IP地址为<code>192.168.45.2</code></p>
<h2 id="方法三：查看网卡配置文件（-etc-sysconfig-network-scripts-ifcfg-ens33）"><a href="#方法三：查看网卡配置文件（-etc-sysconfig-network-scripts-ifcfg-ens33）" class="headerlink" title="方法三：查看网卡配置文件（/etc/sysconfig/network-scripts/ifcfg-ens33）"></a>方法三：查看网卡配置文件（/etc/sysconfig/network-scripts/ifcfg-ens33）</h2><p>每种Linux系统的网卡配置文件路径不同，详见 相关文件配置 -&gt; 网卡配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33</span><br></pre></td></tr></table></figure>
<p>查看<code>DNS</code>配置选项</p>
<h1 id="设置DNS服务器"><a href="#设置DNS服务器" class="headerlink" title="设置DNS服务器"></a>设置DNS服务器</h1><h2 id="CentOS配置网卡为静态IP"><a href="#CentOS配置网卡为静态IP" class="headerlink" title="CentOS配置网卡为静态IP"></a>CentOS配置网卡为静态IP</h2><p>DHCP协议会自动动态配置IP和DNS服务器，为了方便学习DNS，建议改为静态IP模式学习。</p>
<p>如本身就是静态IP，请跳过此步。</p>
<h3 id="查看是静态IP还是动态IP"><a href="#查看是静态IP还是动态IP" class="headerlink" title="查看是静态IP还是动态IP"></a>查看是静态IP还是动态IP</h3><p>可以在网卡配置文件中查看采用的是DHCP协议还是静态IP</p>
<p>查看网卡配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33</span><br></pre></td></tr></table></figure>
<p>显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TYPE&#x3D;&quot;Ethernet&quot;</span><br><span class="line">PROXY_METHOD&#x3D;&quot;none&quot;</span><br><span class="line">BROWSER_ONLY&#x3D;&quot;no&quot;</span><br><span class="line">BOOTPROTO&#x3D;&quot;dhcp&quot;</span><br><span class="line">DEFROUTE&#x3D;&quot;yes&quot;</span><br><span class="line">IPV4_FAILURE_FATAL&#x3D;&quot;no&quot;</span><br><span class="line">IPV6INIT&#x3D;&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF&#x3D;&quot;yes&quot;</span><br><span class="line">IPV6_DEFROUTE&#x3D;&quot;yes&quot;</span><br><span class="line">IPV6_FAILURE_FATAL&#x3D;&quot;no&quot;</span><br><span class="line">IPV6_ADDR_GEN_MODE&#x3D;&quot;stable-privacy&quot;</span><br><span class="line">NAME&#x3D;&quot;ens33&quot;</span><br><span class="line">UUID&#x3D;&quot;0a5c00b5-f7bc-49cf-9a58-11ca6df07fe2&quot;</span><br><span class="line">DEVICE&#x3D;&quot;ens33&quot;</span><br><span class="line">ONBOOT&#x3D;&quot;yes&quot;</span><br></pre></td></tr></table></figure>
<p>查看<code>BOOTPROTO</code>选项，如果是<code>dhcp</code>，则采用DHCP协议；如是<code>static</code>，则采用静态IP</p>
<h3 id="配置网卡为静态IP"><a href="#配置网卡为静态IP" class="headerlink" title="配置网卡为静态IP"></a>配置网卡为静态IP</h3><ul>
<li><p>打开网卡配置文件</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOTPROTO&#x3D;static</span><br><span class="line">ONBOOT&#x3D;yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>增加配置</p>
<p>  查看网络配置，手动填入</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IPADDR&#x3D;192.168.45.130</span><br><span class="line">NETMASK&#x3D;255.255.255.0</span><br><span class="line">GATEWAY&#x3D;192.168.45.2</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启网卡</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmcli connection reload</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmcli connection up ens33</span><br></pre></td></tr></table></figure>
<p>  或者</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>此时，网卡配置文件内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TYPE&#x3D;Ethernet</span><br><span class="line">PROXY_METHOD&#x3D;none</span><br><span class="line">BROWSER_ONLY&#x3D;no</span><br><span class="line">BOOTPROTO&#x3D;static</span><br><span class="line">DEFROUTE&#x3D;yes</span><br><span class="line">IPV4_FAILURE_FATAL&#x3D;no</span><br><span class="line">IPV6INIT&#x3D;yes</span><br><span class="line">IPV6_AUTOCONF&#x3D;yes</span><br><span class="line">IPV6_DEFROUTE&#x3D;yes</span><br><span class="line">IPV6_FAILURE_FATAL&#x3D;no</span><br><span class="line">IPV6_ADDR_GEN_MODE&#x3D;stable-privacy</span><br><span class="line">NAME&#x3D;ens33</span><br><span class="line">UUID&#x3D;0a5c00b5-f7bc-49cf-9a58-11ca6df07fe2</span><br><span class="line">DEVICE&#x3D;ens33</span><br><span class="line">ONBOOT&#x3D;yes</span><br><span class="line">IPADDR&#x3D;192.168.45.130</span><br><span class="line">NETMASK&#x3D;255.255.255.0</span><br><span class="line">GATEWAY&#x3D;192.168.45.2</span><br></pre></td></tr></table></figure>
<p>没有配置DNS服务器，查看DNS服务器，也都是为空</p>
<p>此时，尝试ping一下域名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ping baidu.com</span><br></pre></td></tr></table></figure>
<p>没有DNS服务器，域名解析失败</p>
<h2 id="设置DNS服务器-1"><a href="#设置DNS服务器-1" class="headerlink" title="设置DNS服务器"></a>设置DNS服务器</h2><ul>
<li><p>编辑网卡配置文件，修改DNS服务器，如尝试加入本机IP作为DNS服务器</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33</span><br></pre></td></tr></table></figure>
<p>  加入一行DNS配置，<code>127.0.0.1</code>是送回地址，指本机。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DNS1&#x3D;127.0.0.1</span><br></pre></td></tr></table></figure>
<p>  如有多个DNS服务器，则DNS1、DNS2依次类推</p>
</li>
<li><p>重启该网卡</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmcli connection reload</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmcli connection up ens33</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新查看DNS服务器</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;resolv.conf</span><br></pre></td></tr></table></figure>
<p>  显示</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nameserver 127.0.0.1</span><br></pre></td></tr></table></figure>
<p>  可以看到<code>127.0.0.1</code>添加进了DNS服务器中，此时本机既是DNS服务器，又是DNS的客户端</p>
</li>
<li><p>启动BIND的DNS服务</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start named</span><br></pre></td></tr></table></figure>
</li>
<li><p>ping一下域名</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ping baidu.com</span><br></pre></td></tr></table></figure>
<p>  ping成功，本机作为DNS服务器完成了baidu.com的域名解析</p>
</li>
</ul>
<h1 id="多IP配置"><a href="#多IP配置" class="headerlink" title="多IP配置"></a>多IP配置</h1><p>一台虚拟机可以配置多个静态IP，即多网卡。</p>
<p>上面的DNS配置只利用了单网卡<code>ens33</code>，同时作为DNS服务器和客户机。</p>
<p>可以配置多个IP地址，分别作为DNS服务器和客户机。</p>
<h2 id="多IP配置-1"><a href="#多IP配置-1" class="headerlink" title="多IP配置"></a>多IP配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="主DNS配置"><a href="#主DNS配置" class="headerlink" title="主DNS配置"></a>主DNS配置</h1><h1 id="相关文件配置"><a href="#相关文件配置" class="headerlink" title="相关文件配置"></a>相关文件配置</h1><h2 id="DNS客户机配置文件-etc-resolv-conf"><a href="#DNS客户机配置文件-etc-resolv-conf" class="headerlink" title="DNS客户机配置文件 /etc/resolv.conf"></a>DNS客户机配置文件 /etc/resolv.conf</h2><p><code>/etc/resolv.conf</code>是DNS客户机配置文件，用于设置DNS服务器的IP地址及DNS域名，供域名解析器（resolver）使用。</p>
<p>每一行以一个关键字开头，后接一个或多个由空格隔开的参数。</p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>关键字有四个：（<code>nameserver</code>是必填项，其余的关键字都是可选）</p>
<ul>
<li><code>nameserver</code> <ul>
<li>表明DNS服务器的IP地址</li>
<li>可以有多行，按顺序查询，如果前面的IP无响应，则查询下一个IP</li>
</ul>
</li>
<li><code>domain</code><ul>
<li>声明主机的域名</li>
<li>很多程序用到它，如邮件系统；当为没有域名的主机进行DNS查询时，也要用到。如果没有域名，主机名将被使用，删除所有在第一个点( .)前面的内容</li>
</ul>
</li>
<li><code>search</code><ul>
<li>它的多个参数指明域名查询顺序。当要查询没有域名的主机，主机将在由search声明的域中分别查找</li>
<li>如要域名 <code>www</code> 解析，但 <code>www</code> 无法解析，如配置中有 <code>search baidu.com</code> ，则在<code>www</code>后加上 <code>.</code> + <code>baidu.com</code> ，对 <code>www.baidu.com</code>重新进行解析</li>
<li><code>domain</code>和<code>search</code>不能共存；如果同时存在，后面出现的将会被使用</li>
</ul>
</li>
<li><code>sortlist</code><ul>
<li>允许将得到域名结果进行特定的排序。它的参数为网络/掩码对，允许任意的排列顺序</li>
</ul>
</li>
</ul>
<h3 id="域名解析顺序-1"><a href="#域名解析顺序-1" class="headerlink" title="域名解析顺序"></a>域名解析顺序</h3><ol>
<li>查找 <code>etc/hosts</code></li>
<li>根据 <code>nameserver</code> 指定的DNS服务器解析域名</li>
<li>如果所有的 <code>nameserver</code> 都找不到域名，则进行<code>search</code>补全，重新走1～2步</li>
</ol>
<h3 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h3><p>查看<code>/etc/resolv.conf</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;resolv.conf</span><br></pre></td></tr></table></figure>
<p>如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Generated by NetworkManager</span><br><span class="line">search localdomain</span><br><span class="line">nameserver 192.168.45.2</span><br></pre></td></tr></table></figure>
<h2 id="网卡配置文件-etc-sysconfig-network-scripts-ifcfg-ens33"><a href="#网卡配置文件-etc-sysconfig-network-scripts-ifcfg-ens33" class="headerlink" title="网卡配置文件 /etc/sysconfig/network-scripts/ifcfg-ens33"></a>网卡配置文件 /etc/sysconfig/network-scripts/ifcfg-ens33</h2><p>Centos可在<code>/etc/sysconfig/network-scripts</code>目录下查找网卡配置文件，Linux传统网卡设备命名是<code>eth0</code>、<code>eth1</code>这样的，而Centos提供了不同的命名规则，比如<code>ens33</code>（Ubuntu的网卡配置文件有所不同）</p>
<p>查看网卡配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TYPE&#x3D;Ethernet   #网卡类型：为以太网</span><br><span class="line">PROXY_METHOD&#x3D;none   # 代理方式：关闭状态</span><br><span class="line">BROWSER_ONLY&#x3D;no  # 只是浏览器：否</span><br><span class="line">BOOTPROTO&#x3D;dhcp  # 网卡的引导协议：DHCP[中文名称: 动态主机配置协议]</span><br><span class="line">DEFROUTE&#x3D;yes     # 默认路由：是</span><br><span class="line">IPV4_FAILURE_FATAL&#x3D;no   # 是不开启IPV4致命错误检测：否</span><br><span class="line">IPV6INIT&#x3D;yes     # IPV6是否自动初始化: 是</span><br><span class="line">IPV6_AUTOCONF&#x3D;yes   # IPV6是否自动配置：是</span><br><span class="line">IPV6_DEFROUTE&#x3D;yes    # IPV6是否可以为默认路由：是</span><br><span class="line">IPV6_FAILURE_FATAL&#x3D;no    # 是不开启IPV6致命错误检测：否</span><br><span class="line">IPV6_ADDR_GEN_MODE&#x3D;stable-privacy    # IPV6地址生成模型：stable-privacy</span><br><span class="line">NAME&#x3D;ens33   # 网卡物理设备名称</span><br><span class="line">UUID&#x3D;0a5c00b5-f7bc-49cf-9a58-11ca6df07fe2    # 通用唯一识别码, 每一个网卡都会有, 不能重复, 否两台linux只有一台网卡可用</span><br><span class="line">DEVICE&#x3D;ens33     # 网卡设备名称, 必须和 &#96;NAME&#96; 值一样</span><br><span class="line">ONBOOT&#x3D;yes   # 是否开机启动，要想网卡开机就启动或通过 &#96;systemctl restart network&#96;控制网卡,必须设置为 &#96;yes&#96;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.bilibili.com/video/BV1JW4y1J7cw?p=1&amp;vd_source=f5f8e6e01c0d525ef6934da8b95c76ce" target="_blank" rel="noopener">Linux DNS服务Bind最全教程</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>BIND</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习手册</title>
    <url>/2020/01/10/C-%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>​    C++学习手册，主要是在C的基础上写出一些C++不同于C的点，部分C语言相通部分就不再赘述。</p>
<a id="more"></a>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="使用-VS-Code-搭建C-开发环境（MAC）"><a href="#使用-VS-Code-搭建C-开发环境（MAC）" class="headerlink" title="使用 VS Code 搭建C++开发环境（MAC）"></a>使用 VS Code 搭建C++开发环境（MAC）</h2><p><a href="https://www.bilibili.com/video/BV1sW411v7VZ?p=2" target="_blank" rel="noopener">参考视频</a></p>
<ol>
<li>在VS Code上安装好相应插件：C/C++、CodeLLDB</li>
<li>新建工作目录，编写C++文件</li>
<li>在Debug中创建launch.json文件，选择LLDB</li>
<li>将<code>&lt;your program&gt;</code>替换为<code>${fileBasenameNoExtension}</code></li>
<li>选择cpp文件，建立Build文件，Shift+Command+P切出面板，选择Tasks:Configure Task -&gt; C/C++ clang++ build active file</li>
<li>在”args”中添加C++标准<code>&quot;-std=c++2a&quot;</code></li>
<li>在launch.json中的”configurations”中添加<code>&quot;preLaunchTask&quot;: &quot;C/C++: clang++ build active file&quot;</code>(与tasks.json中的label一致)</li>
</ol>
<h2 id="Xcode引入iostream库失败"><a href="#Xcode引入iostream库失败" class="headerlink" title="Xcode引入iostream库失败"></a>Xcode引入iostream库失败</h2><p>提示 ‘iostream’ file not found的解决办法：</p>
<p>在Build Settings -&gt; Search paths -&gt;System Header Search Paths中添加路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Toolchains&#x2F;XcodeDefault.xctoolchain&#x2F;usr&#x2F;include&#x2F;c++&#x2F;v1&#x2F;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/01/10/DT7fHNvbGzyVXIM.png" alt=""></p>
<p>添加后，C++库引入成功。</p>
<h1 id="从C到C"><a href="#从C到C" class="headerlink" title="从C到C++"></a>从C到C++</h1><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>C++输入输出需使用iostream库</p>
<h3 id="标准输出cout"><a href="#标准输出cout" class="headerlink" title="标准输出cout"></a>标准输出cout</h3><p>std :: cout 是输出内容，&lt;&lt; 是输出运算符，std :: endl 结束改行，相当于一个”\n”</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, World!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, World!\n"</span> ;</span><br></pre></td></tr></table></figure>
<h3 id="标准输入cin"><a href="#标准输入cin" class="headerlink" title="标准输入cin"></a>标准输入cin</h3><p>std :: cin 是输入内容，&gt;&gt; 是输入运算符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Input a and b."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of a and b is "</span> &lt;&lt; a+b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用标准库中的名字"><a href="#使用标准库中的名字" class="headerlink" title="使用标准库中的名字"></a>使用标准库中的名字</h3><p>​     std::表示cout和cin是定义在名为std的<strong>命名空间</strong>中的，可以通过<strong>using namespace</strong>来进行命名空间的缩略。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><p>​    while语句反复执行一段代码，直至条件判断为错误。</p>
<h4 id="读取数量不定的输入数据"><a href="#读取数量不定的输入数据" class="headerlink" title="读取数量不定的输入数据"></a>读取数量不定的输入数据</h4><p>​    利用std::cin进行输入不定的输入。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    不断输入数字求和，直至输入不是数字结束</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, value = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Input number."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; value) &#123; <span class="comment">//当输入不为数字时判断为false</span></span><br><span class="line">        sum += value;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Input number."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sum is "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    已经定义了value为int型，所以在 cin&gt;&gt;value 输入不为int型时，则判断为false。</p>
<p>​    也可用文件结束符，输入Ctrl+D</p>
<h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><p>​    for(初始化语句; 循环条件; 表达式)</p>
<h4 id="遍历数组中的元素"><a href="#遍历数组中的元素" class="headerlink" title="遍历数组中的元素"></a>遍历数组中的元素</h4><ol>
<li><p>​    一维数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> scores[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : scores) &#123; <span class="comment">//遍历数组scores中的元素</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多维数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ia[<span class="number">2</span>][<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;row : ia) &#123; <span class="comment">//遍历二维数组ia外层数组的每一个元素（这里相当于遍历每行）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;col : row) &#123; <span class="comment">//遍历二维数组ia内层数组的每一个元素</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; col;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>同一作用域内，可以有同名函数，给函数多个定义，但形参必须不同，加以区分。</p>
<p>形参不同，指参数的类型、参数的个数和参数的顺序，至少有一个不同。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三个形参不同的print函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2.5</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h1><h1 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a>变量和基本类型</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>​    相当于把各种数据打包组成了一个集合来调用。</p>
<p>​    下面以建立和使用一个书籍销售单类Sales_data为例。</p>
<h3 id="建立头文件"><a href="#建立头文件" class="headerlink" title="建立头文件"></a>建立头文件</h3><p>​    为保障各文件中的类的定义一致，类通常被定义在头文件中。这里我们建立一个名为Sales_data.h的头文件来转载Sales_data类的定义。</p>
<p>​    头文件一般最好进行预处理，添加头文件保护符：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>#define</th>
<th style="text-align:left">把名字设定为预处理变量</th>
</tr>
</thead>
<tbody>
<tr>
<td>#ifdef</td>
<td style="text-align:left">当且仅当变量已定义时为真</td>
</tr>
<tr>
<td>#ifndef</td>
<td style="text-align:left">当且仅当变量未被定义时为真</td>
</tr>
<tr>
<td>#endif</td>
<td style="text-align:left">判断为真后，执行到#endif结束</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> Sales_data_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Sales_data_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo; <span class="comment">// 书籍编号</span></span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>; <span class="comment">// 销售数量</span></span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>; <span class="comment">// 销售收入</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="使用类定义"><a href="#使用类定义" class="headerlink" title="使用类定义"></a>使用类定义</h3><p>​    调用该.h文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Sales_data.h"</span></span></span><br></pre></td></tr></table></figure>
<p>​    定义类变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sales_data data1;</span><br></pre></td></tr></table></figure>
<p>​    利用.来访问类中的对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Sales_data.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Sales_data data1;</span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">0.0</span>; <span class="comment">// 书籍单价</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Input book_No, sold_num and price."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; data1.bookNo &gt;&gt; data1.units_sold &gt;&gt; price;</span><br><span class="line">    data1.revenue = price * data1.units_sold;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Book "</span> &lt;&lt; data1.bookNo &lt;&lt; <span class="string">"'s revenue is "</span> &lt;&lt; data1.revenue &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>​    迭代器是一种检查容器内元素并遍历元素的数据类型。可以替代下标访问vector对象的元素。可以理解为指向容器内元素的指针。</p>
<h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><p>​    begin 返回指向第一个元素的迭代器，end 返回指向容器尾元素的下一个位置的迭代器（实际上是不存在的）。当begin和end返回的为同一迭代器，则该容器为空。</p>
<p>​    不在意迭代器的类型，一般定义为auto。</p>
<h4 id="迭代器运算符"><a href="#迭代器运算符" class="headerlink" title="迭代器运算符"></a>迭代器运算符</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>*iter</td>
<td>返回迭代器iter所指的元素的引用</td>
</tr>
<tr>
<td>Iter-&gt;mem</td>
<td>解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem</td>
</tr>
<tr>
<td>++iter</td>
<td>令iter指示容器中的下一个元素</td>
</tr>
<tr>
<td>—iter</td>
<td>令iter指示容器中的上一个元素</td>
</tr>
<tr>
<td>iter1 == iter2 / iter1 != iter2</td>
<td>判断两迭代器是否相等。如两迭代器指示的是同一个元素或者它们是同一个容器或者它们是同一个容器的尾后迭代器，则相等。</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    将首单词的首字母大写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"hello world."</span>;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">begin</span>() != s.<span class="built_in">end</span>()) &#123; <span class="comment">// s不为空</span></span><br><span class="line">        <span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); <span class="comment">// 指向首单词的迭代器</span></span><br><span class="line">        *it = <span class="built_in">toupper</span>(*it); <span class="comment">// 将it迭代器所指的元素的引用首字母大写</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代器运算"><a href="#迭代器运算" class="headerlink" title="迭代器运算"></a>迭代器运算</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>iter + n / iter - n</td>
<td>加或减n个位置得到一个迭代器</td>
</tr>
<tr>
<td>iter += n / iter -= n</td>
<td>加或减n个位置得到一个迭代器赋给iter本身</td>
</tr>
<tr>
<td>iter1 - iter2</td>
<td>iter1与iter2之间的位置差</td>
</tr>
<tr>
<td>&gt; 、&gt;=、&lt;、&lt;=</td>
<td>比较位置</td>
</tr>
</tbody>
</table>
</div>
<h2 id="try语句块和异常处理"><a href="#try语句块和异常处理" class="headerlink" title="try语句块和异常处理"></a>try语句块和异常处理</h2><h3 id="throw表达式"><a href="#throw表达式" class="headerlink" title="throw表达式"></a>throw表达式</h3><p>​    throw表达式，异常检测部分使用throw表达式来<strong>表示</strong>它遇到了无法处理的问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    检验输入是否是数字，不是则抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Input a number."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">char</span> input;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; input;</span><br><span class="line">    <span class="keyword">if</span> (input &gt;= <span class="string">'0'</span> &amp;&amp; input &lt;= <span class="string">'9'</span>) &#123; <span class="comment">//输入为数字</span></span><br><span class="line">        number = input - <span class="string">'0'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//输入不为数字</span></span><br><span class="line">        <span class="keyword">throw</span> runtime_error(<span class="string">"Input not number."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当输入不为数字时，运行到throw语句时卡住，并输出异常信息。</p>
<p><img src="https://i.loli.net/2020/01/15/Sl2ne7PQgsriDfO.png" style="zoom:50%;" /></p>
<p><img src="https://i.loli.net/2020/01/15/opaRJDAg7B2nd54.png" style="zoom: 50%;" /></p>
<h3 id="try语句块"><a href="#try语句块" class="headerlink" title="try语句块"></a>try语句块</h3><p>​    try语句块，异常处理部分使用try语句块<strong>处理</strong>异常。try尝试一个代码块，如有异常通常会被catch捕捉处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="comment">//测试的代码块</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(exception-declaration) &#123; <span class="comment">//exception-declaration异常声明</span></span><br><span class="line">	<span class="comment">//异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-面向对象"><a href="#C-面向对象" class="headerlink" title="C++面向对象"></a>C++面向对象</h1><p>C++面向对象的三大特性：封装、继承、多态。</p>
<p>万事万物都是对象，具有相同属性的对象可以抽象成一个类。</p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="类和对象的定义"><a href="#类和对象的定义" class="headerlink" title="类和对象的定义"></a>类和对象的定义</h3><p>把类的所有成员（变量和函数）封装起来，并加以权限限制。</p>
<ul>
<li>语法：  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名 &#123;</span></span><br><span class="line">访问权限:</span><br><span class="line">    成员变量</span><br><span class="line">    成员函数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>示例：设计一个圆类，求圆的周长</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个圆类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//访问权限</span></span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">double</span> r; <span class="comment">//半径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员函数</span></span><br><span class="line">    <span class="comment">//计算周长</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calculate_circumference</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * PI * r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Circle c1; <span class="comment">//声明一个圆对象</span></span><br><span class="line">    c1.r = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"周长为："</span> &lt;&lt; c1.calculate_circumference() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>成员函数也可在类的外部，使用范围解析运算符<code>::</code>定义</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员函数声明</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calculate_circumference</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Circle::calculate_circumference</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * PI * r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>类成员的访问限制共三种：<code>public</code>、<code>private</code>、<code>protected</code></p>
<ul>
<li>公共权限 <code>public</code><ul>
<li>类内、类外都可访问</li>
</ul>
</li>
<li>保护权限 <code>protected</code><ul>
<li>类内可访问，派生类可访问，类外不可访问</li>
</ul>
</li>
<li>私有权限 <code>private</code><ul>
<li>只允许类内访问</li>
<li>如果没有使用任何访问修饰符，默认为私有权限</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>访问权限</th>
<th>public</th>
<th>protected</th>
<th style="text-align:left">private</th>
</tr>
</thead>
<tbody>
<tr>
<td>类内</td>
<td>可访问</td>
<td>可访问</td>
<td style="text-align:left">可访问</td>
</tr>
<tr>
<td>派生类</td>
<td>可访问</td>
<td>可访问</td>
<td style="text-align:left">不可访问</td>
</tr>
<tr>
<td>类外</td>
<td>可访问</td>
<td>不可访问</td>
<td style="text-align:left">不可访问</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><code>struct</code>和<code>class</code>的区别：<br><code>struct</code>和<code>class</code>都可以表示类，但默认的权限不同。<br>如果成员没有使用任何访问修饰符，<code>struct</code>默认为公共成员，<code>class</code>默认为私有成员。</p>
</blockquote>
<p><strong>类内访问 &amp; 类外访问</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//公共成员</span></span><br><span class="line">    <span class="comment">//类内可访问，类外可访问</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getPassword</span><span class="params">()</span></span>; <span class="comment">//读函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(<span class="built_in">string</span> pass)</span></span>; <span class="comment">//写函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//保护成员</span></span><br><span class="line">    <span class="comment">//类内可访问，类外不可访问</span></span><br><span class="line">    <span class="built_in">string</span> address;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//私有成员</span></span><br><span class="line">    <span class="comment">//类内可访问，类外不可访问</span></span><br><span class="line">    <span class="built_in">string</span> password;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Person::getPassword</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> password; <span class="comment">//类内访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person::setPassword</span> <span class="params">(<span class="built_in">string</span> pass)</span> </span>&#123;</span><br><span class="line">    password = pass; <span class="comment">//类内访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正确，类外可访问公共成员</span></span><br><span class="line">    p1.name = <span class="string">"ZhangSan"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p1.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误，类外不可访问保护/私有成员</span></span><br><span class="line">    <span class="comment">// p1.password = "123456";</span></span><br><span class="line"></span><br><span class="line">    p1.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p1.getPassword() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一般都把成员变量设置为<code>private</code>权限，然后在<code>public</code>中设置读写函数，以便控制读写权限。</p>
</blockquote>
<h3 id="构造函数-析构函数"><a href="#构造函数-析构函数" class="headerlink" title="构造函数/析构函数"></a>构造函数/析构函数</h3><p>构造函数/析构函数是两个特殊的成员函数，分别在创建对象/销毁对象时被自动调用，用于完成对象初始化/清理工作。</p>
<p>即使不主动编辑构造函数/析构函数，编译器也会自动提供两个空函数作为构造函数/析构函数。</p>
<ul>
<li>构造函数<ul>
<li>创建对象时，自动调用一次，用于完成对象初始化</li>
<li>函数名与类名相同 <code>类名() {}</code></li>
<li>可以有参数，不会有返回值，也不会返回<code>void</code></li>
</ul>
</li>
<li><p>析构函数</p>
<ul>
<li>销毁对象时，自动调用一次，用于完成清理工作</li>
<li>函数名与类名相同，加个前缀<code>~</code>， <code>~类名() {}</code></li>
<li>不能有参数，不会有返回值，也不会返回<code>void</code></li>
</ul>
</li>
<li><p>语法框架</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    类名(<span class="comment">/* args */</span>); <span class="comment">//构造函数，可以有参数</span></span><br><span class="line">    ~类名(); <span class="comment">//析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">类名::类名(<span class="comment">/* args */</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">类名::~类名()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Line(); <span class="comment">//构造函数</span></span><br><span class="line">    ~Line(); <span class="comment">//析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Line::Line() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Line::~Line() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用析构函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Line <span class="built_in">line</span>; <span class="comment">//创建对象，自动调用构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//销毁对象时，自动调用析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="构造函数的分类和调用方式"><a href="#构造函数的分类和调用方式" class="headerlink" title="构造函数的分类和调用方式"></a>构造函数的分类和调用方式</h3><h4 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h4><ul>
<li><p>函数结构</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">className() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用方法（定义对象）</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">className c;</span><br></pre></td></tr></table></figure>
<p>  定义无参构造的对象的错误写法<code>className c();</code>，不能加<code>()</code>，不然会与函数的声明弄混。</p>
</li>
</ul>
<h4 id="有参构造"><a href="#有参构造" class="headerlink" title="有参构造"></a>有参构造</h4><p>以<code>int</code>型参数为例</p>
<ul>
<li><p>函数结构</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">className(<span class="keyword">int</span> x) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用方法（定义对象）</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">className <span class="title">c</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//方法一：括号法</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">className c = className(<span class="number">10</span>); <span class="comment">//方法二：显示法</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">className c = <span class="number">10</span>; <span class="comment">//方法三：隐式转换法</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>示例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Line::Line(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">    A = a;</span><br><span class="line">    B = b;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用初始化列表来初始化字段，两种方法等效</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Line::Line(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : A(a), B(b)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h4><p>拷贝构造函数，即复制一个对象，生成新对象。</p>
<ul>
<li><p>函数结构</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">className(<span class="keyword">const</span> className &amp;obj) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <code>const</code>防止被拷贝的数据obj被修改，且须用引用传递，而不能用值传递。</p>
</li>
<li><p>调用方法（定义对象）</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">className <span class="title">c</span><span class="params">(obj)</span></span>; <span class="comment">//方法一：括号法</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">className c = className(obj); <span class="comment">//方法二：显示法</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">className c = obj; <span class="comment">//方法三：隐式转换法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用时机</p>
<ul>
<li><p>使用一个对象，拷贝出一个新对象</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Line <span class="title">l1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Line <span class="title">l2</span><span class="params">(l1)</span></span>; <span class="comment">//调用拷贝构造</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>值方式传递参数时，复制副本</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Line l)</span> </span>&#123; <span class="comment">//值传递，复制原对象l，调用拷贝构造</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>值方式返回局部对象时，复制副本</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">( &#123; </span></span></span><br><span class="line"><span class="function"><span class="params">    ...</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">return</span> l; <span class="comment">//复制原对象l，返回副本，调用拷贝构造</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>无参/有参/拷贝构造示例</strong></p>
<p>定义<code>line</code>类，分别用无参/有参构造函数，定义两个<code>length</code>相同的对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Line(); <span class="comment">//无参构造函数</span></span><br><span class="line">    Line(<span class="keyword">int</span> len); <span class="comment">//有参构造函数</span></span><br><span class="line">    Line(<span class="keyword">const</span> Line &amp;obj); <span class="comment">//拷贝构造函数</span></span><br><span class="line">    ~Line();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">int</span> len)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无参构造函数</span></span><br><span class="line">Line::Line() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"无参构造函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line">Line::Line(<span class="keyword">int</span> len) &#123;</span><br><span class="line">    length = len;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"有参构造函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line">Line::Line(<span class="keyword">const</span> Line &amp;obj) &#123;</span><br><span class="line">    length = obj.length;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"拷贝构造函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Line::~Line() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"析构函数调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Line::setLength</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    length = len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Line::getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Line l1; <span class="comment">//无参构造</span></span><br><span class="line">    l1.setLength(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">Line <span class="title">l2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//有参构造</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Line <span class="title">l3</span><span class="params">(l2)</span></span>; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造函数的调用规则"><a href="#构造函数的调用规则" class="headerlink" title="构造函数的调用规则"></a>构造函数的调用规则</h4><p>默认情况下，编译器会自动给一个类添加3个函数：</p>
<ul>
<li>默认构造函数（无参，空函数）</li>
<li>默认析构函数（空函数）</li>
<li>默认拷贝构造函数（对属性进行值拷贝）</li>
</ul>
<p>如用户自行定义了有参构造函数，编译器将不再提供默认无参构造函数，但依旧提供默认拷贝构造函数；</p>
<p>如用户自行定义了拷贝构造函数，编译器将不再提供其他构造函数。</p>
<h3 id="对象参数的引用传递"><a href="#对象参数的引用传递" class="headerlink" title="对象参数的引用传递"></a>对象参数的引用传递</h3><ul>
<li><p>传递对象参数时，最好用引用传递<code>void func(className &amp;obj);</code></p>
<p>  如为值传递，即<code>void func(className obj);</code>，调用该函数时，要复制生成新的对象，调用拷贝构造函数，结束时，还需要调用析构函数来做清理工作。时间效率低。</p>
<p>  如为引用传递，即<code>void func(className &amp;obj);</code>，调用该函数时，直接用原对象，不需要生成新对象。</p>
<p>  当不修改对象时，应当将参数声明为const引用。</p>
</li>
<li><p>拷贝构造函数的参数必须是引用，且最好用const引用<code>className(const className &amp;obj);</code></p>
<p>  如果使用值传递，即<code>className(className obj);</code>，则传值时会调用拷贝构造函数，会出现无穷递归调用拷贝构造函数的情况，所以拷贝构造函数的参数不能使用值传递。</p>
</li>
</ul>
<h3 id="深拷贝-浅拷贝"><a href="#深拷贝-浅拷贝" class="headerlink" title="深拷贝/浅拷贝"></a>深拷贝/浅拷贝</h3><p>浅拷贝，即简单的赋值拷贝，默认拷贝构造即是浅拷贝。</p>
<p>如定义一个类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> m_age) &#123;</span><br><span class="line">        age = m_age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>编译器会自动生成默认拷贝构造函数，即</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Person(<span class="keyword">const</span> Person &amp;obj) &#123;</span><br><span class="line">    age = obj.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用拷贝构造函数，即可进行简单拷贝，也就是浅拷贝。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br></pre></td></tr></table></figure>
<p>浅拷贝可以处理一般的对象拷贝，所以不需要额外写拷贝构造函数，直接用默认的拷贝构造函数，即可进行浅拷贝。</p>
<p>但一旦类带有指针变量，用浅拷贝就会出现错误。</p>
<p>如下面的类中，带有指针变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">height</span>; <span class="comment">//指针变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> m_age, <span class="keyword">int</span> m_height) &#123;</span><br><span class="line">        age = m_age;</span><br><span class="line">        <span class="built_in">height</span> = <span class="keyword">new</span> <span class="keyword">int</span>(m_height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        <span class="comment">//析构函数，释放堆区动态分配的空间</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">height</span> != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">height</span>;</span><br><span class="line">            <span class="built_in">height</span> = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果使用编译器的默认拷贝构造函数，进行浅拷贝</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Person(<span class="keyword">const</span> Person &amp;obj) &#123;</span><br><span class="line">    age = obj.age;</span><br><span class="line">    <span class="built_in">height</span> = obj.<span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>p2</code>的<code>height</code>与<code>p1</code>的<code>height</code>完全相同，都是指向堆区同一地址的指针。</p>
<p>在析构函数释放空间时，先释放完<code>p1</code>的<code>height</code>，对<code>p2</code>析构时，<code>height</code>已经释放，无法重新释放，发生错误。</p>
<p>所以类带有指针变量，并有动态内存分配，则必须自行定义拷贝构造函数，进行深度拷贝。</p>
<p>深拷贝，即在堆区重新申请空间，内容相同，但是不同的地址。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">height</span>; <span class="comment">//指针变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> m_age, <span class="keyword">int</span> m_height) &#123;</span><br><span class="line">        age = m_age;</span><br><span class="line">        <span class="built_in">height</span> = <span class="keyword">new</span> <span class="keyword">int</span>(m_height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(<span class="keyword">const</span> Person &amp;obj) &#123;</span><br><span class="line">        age = obj.age;</span><br><span class="line">        <span class="comment">//深拷贝</span></span><br><span class="line">        <span class="built_in">height</span> = <span class="keyword">new</span> <span class="keyword">int</span>(*obj.<span class="built_in">height</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Person() &#123;</span><br><span class="line">        <span class="comment">//析构函数，释放堆区动态分配的空间</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">height</span> != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">height</span>;</span><br><span class="line">            <span class="built_in">height</span> = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>每一个对象都能通过<code>this</code>指针来访问自己的地址，<code>this</code>指针指向被调用成员函数的所属对象。</p>
<p>主要用途：</p>
<ul>
<li>形参和成员变量同名时，用<code>this</code>指针加以区分</li>
<li>返回对象本身</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>在类成员前加上<code>static</code>，称为静态成员。当声明成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本，静态成员在类的所有对象中是共享的。</p>
<h4 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h4><ul>
<li>该类的所有对象共享同一份数据</li>
<li>编译阶段分配内存</li>
<li>类内声明，类外初始化</li>
<li>访问静态成员，可以用<code>p1.A</code>或者<code>Person::A</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> A; <span class="comment">//类内声明静态成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Person::A = <span class="number">10</span>; <span class="comment">//类外初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p1.A &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有对象共享同一份数据，所以修改p2的A，p1的A也会相应变化</span></span><br><span class="line">    Person p2;</span><br><span class="line">    p2.A = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p1.A &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h4><ul>
<li><p>该类的所有对象共享同一个函数</p>
</li>
<li><p>静态成员函数只能访问静态成员</p>
</li>
<li><p>静态成员函数与普通成员函数的根本区别在于：</p>
<ul>
<li>普通成员函数有<code>this</code>指针，可以访问类中的任意成员</li>
<li>静态成员函数没有<code>this</code>指针，只能访问静态成员（包括静态成员变量和静态成员函数）</li>
</ul>
</li>
</ul>
<p>静态成员函数的作用：方便调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用<code>func1()</code>时，需要先生成类对象，才能调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Solution s;</span><br><span class="line">s.func1();</span><br></pre></td></tr></table></figure>
<p>调用静态成员函数<code>func2()</code>时，可以直接调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Solution::func2();</span><br></pre></td></tr></table></figure>
<h3 id="const常函数和常对象"><a href="#const常函数和常对象" class="headerlink" title="const常函数和常对象"></a>const常函数和常对象</h3><p>如果不希望数据被修改，可以加上<code>const</code>关键字来修饰成员变量、成员函数、对象。</p>
<h4 id="常函数"><a href="#常函数" class="headerlink" title="常函数"></a>常函数</h4><ul>
<li>成员函数后加<code>const</code></li>
<li>常函数内不能修改成员变量</li>
<li>如果成员变量前加<code>mutable</code>，则可在常函数内改变该变量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">//常函数</span></span><br><span class="line">        m_A = <span class="number">100</span>; <span class="comment">//错误，常函数中普通成员变量无法修改</span></span><br><span class="line">        m_B = <span class="number">100</span>; <span class="comment">//正确，mutable变量可在常函数中修改</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> m_B; <span class="comment">//加入mutable后，可在常函数中修改</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>成员函数中调用<code>m_A</code>，实际是调用了<code>this -&gt; m_A</code></p>
<p>成员函数的<code>this</code>指针，本质是指针常量，也就是指针本身是一个常量，地址不变，即<code>Person * const this;</code>，此时<code>this</code>一直指向对象本身</p>
<p>如果为常函数，<code>const</code>修饰的是<code>this</code>指针的指向，<code>this</code>指针的指向的值内容不变，即<code>const Person * const this;</code>，此时<code>this</code>指向对象的内容不能被修改</p>
<p><code>get</code>类型的成员函数一般都采用常函数，只需获取，不需修改</p>
</blockquote>
<h4 id="常对象"><a href="#常对象" class="headerlink" title="常对象"></a>常对象</h4><ul>
<li>对象前加<code>const</code></li>
<li>不能修改一般的成员变量，但可以修改<code>mutable</code>的成员变量</li>
<li>常对象只能调用<code>const</code>常函数（不能调用普通函数，因为普通的成员函数可能会修改成员变量）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">get_name</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">//常函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_age</span><span class="params">(<span class="keyword">int</span> age)</span></span>; <span class="comment">//普通成员函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> m_b;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_name;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> m_age; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person::Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) : m_name(name), m_age(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Person::get_name</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person::set_age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    m_age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Person <span class="title">p</span><span class="params">(<span class="string">"Job"</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p.get_name() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//正确，常对象只能调用常函数</span></span><br><span class="line">    p.set_age(<span class="number">30</span>); <span class="comment">//错误，常对象无法调用普通成员函数</span></span><br><span class="line">    </span><br><span class="line">    p.m_a = <span class="number">100</span>; <span class="comment">//错误，常对象无法修改普通成员变量</span></span><br><span class="line">    p.m_b = <span class="number">100</span>; <span class="comment">//正确，常对象能修改mutable成员变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>友元定义在类的外部，不属于类的成员，但有访问<code>private</code>和<code>protected</code>的权限，在类中用关键字<code>friend</code>声明函数/类，即可将其设定为友元。</p>
<h4 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h4><p>将全局函数加上关键字<code>friend</code>，在类中声明为友元，即可使其能够访问<code>private</code>和<code>protected</code>的权限成员。</p>
<p>尽管在类中有声明，但友元函数并不是成员函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//将全局函数设置为友元，允许其访问私有成员</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">print_age</span><span class="params">(Person &amp;p)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_age</span><span class="params">(<span class="keyword">int</span> age)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person::set_age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    m_age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_age</span><span class="params">(Person &amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p.m_age &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//允许访问私有成员m_age</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    p.set_age(<span class="number">18</span>);</span><br><span class="line">    print_age(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h4><p>将类加上关键字<code>friend</code>，在类中声明为友元，即可使其能够访问<code>private</code>和<code>protected</code>的权限成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="comment">//将类设置为友元，允许其访问私有成员</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonFriend</span>;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person()&#123;</span><br><span class="line">        m_age = <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonFriend</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line">    PersonFriend();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Person *p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PersonFriend::PersonFriend()&#123;</span><br><span class="line">    p = <span class="keyword">new</span> Person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PersonFriend::visit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p-&gt;m_age &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//可以访问Person类对象的私有成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    PersonFriend pf;</span><br><span class="line">    pf.visit();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。</p>
<p>函数重载和普通的函数重载一致，利用形参的不同加以区分。</p>
<p>运算符重载，则是重新定义运算符，以适应类的运算。</p>
<p>运算符重载是通过函数实现的，它本质上是函数重载。可以作为类的成员函数，还可以作为全局函数。</p>
<p>在运算符前加上关键词<code>operator</code>，作为声明时的函数名。</p>
<ul>
<li>可重载的运算符</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td>双目算术运算符</td>
<td>+ (加)，-(减)，*(乘)，/(除)，% (取模)</td>
</tr>
<tr>
<td>关系运算符</td>
<td>==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于)，&lt;=(小于等于)，&gt;=(大于等于)</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>\</td>
<td>\</td>
<td>(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)</td>
</tr>
<tr>
<td>单目运算符</td>
<td>+ (正)，-(负)，*(指针)，&amp;(取地址)</td>
</tr>
<tr>
<td>自增自减运算符</td>
<td>++(自增)，—(自减)</td>
</tr>
<tr>
<td>位运算符</td>
<td>\</td>
<td>(按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>=, +=, -=, *=, /= , % = , &amp;=,</td>
<td>=, ^=, &lt;&lt;=, &gt;&gt;=</td>
</tr>
<tr>
<td>空间申请与释放</td>
<td>new, delete, new[ ] , delete[]</td>
</tr>
<tr>
<td>其他运算符</td>
<td>()(函数调用)，-&gt;(成员访问)，,(逗号)，[](下标)</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>不可重载的运算符<ul>
<li><code>.</code>：成员访问运算符</li>
<li><code>.*</code>, <code>-&gt;*</code>：成员指针访问运算符</li>
<li><code>::</code>：域运算符</li>
<li><code>sizeof</code>：长度运算符</li>
<li><code>?:</code>：条件运算符</li>
<li><code>#</code>： 预处理符号</li>
</ul>
</li>
</ul>
<h3 id="负号-重载（一元）"><a href="#负号-重载（一元）" class="headerlink" title="负号-重载（一元）"></a>负号<code>-</code>重载（一元）</h3><ul>
<li>作为类的成员函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex (<span class="keyword">int</span> i, <span class="keyword">int</span> j);</span><br><span class="line">    <span class="comment">//重载-，作为类的成员函数</span></span><br><span class="line">    Complex <span class="keyword">operator</span>- ();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_i;</span><br><span class="line">    <span class="keyword">int</span> m_j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex :: Complex (<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">    m_i = i;</span><br><span class="line">    m_j = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载-</span></span><br><span class="line">Complex Complex :: <span class="keyword">operator</span>- () &#123;</span><br><span class="line">    m_i = -m_i;</span><br><span class="line">    m_j = -m_j;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>还可以作为全局函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">    <span class="comment">//重载-，在全局范围内重载运算符，设置为友元函数</span></span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>- (Complex &amp;c);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex (<span class="keyword">int</span> i, <span class="keyword">int</span> j);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_i;</span><br><span class="line">    <span class="keyword">int</span> m_j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex :: Complex (<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">    m_i = i;</span><br><span class="line">    m_j = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载-</span></span><br><span class="line">Complex <span class="keyword">operator</span>- (Complex &amp;c) &#123;</span><br><span class="line">    c.m_i = -c.m_i;</span><br><span class="line">    c.m_j = -c.m_j;</span><br><span class="line">    <span class="keyword">return</span> Complex(c.m_i, c.m_j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>-c</code>，即可将<code>m_i</code>、<code>m_j</code>取反</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">-c;</span><br></pre></td></tr></table></figure>
<h3 id="加号-重载"><a href="#加号-重载" class="headerlink" title="加号+重载"></a>加号<code>+</code>重载</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex (<span class="keyword">int</span> i, <span class="keyword">int</span> j);</span><br><span class="line">    <span class="comment">//重载+</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex &amp;b);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_i;</span><br><span class="line">    <span class="keyword">int</span> m_j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex :: Complex (<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">    m_i = i;</span><br><span class="line">    m_j = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载+</span></span><br><span class="line">Complex Complex :: <span class="keyword">operator</span>+ (<span class="keyword">const</span> Complex &amp;b) &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="keyword">this</span>-&gt;m_i + b.m_i;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="keyword">this</span>-&gt;m_j + b.m_j;</span><br><span class="line">    <span class="keyword">return</span> Complex(i, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>a+b</code>，即可将<code>m_i</code>、<code>m_j</code>相加</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Complex a(1,2), b(2,3);</span><br><span class="line">Complex c = a + b;</span><br></pre></td></tr></table></figure>
<h3 id="关系运算符-重载"><a href="#关系运算符-重载" class="headerlink" title="关系运算符==重载"></a>关系运算符<code>==</code>重载</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex (<span class="keyword">int</span> i, <span class="keyword">int</span> j);</span><br><span class="line">    <span class="comment">//重载==</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>== (<span class="keyword">const</span> Complex &amp;b) <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_i;</span><br><span class="line">    <span class="keyword">int</span> m_j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex :: Complex (<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">    m_i = i;</span><br><span class="line">    m_j = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载==</span></span><br><span class="line"><span class="keyword">bool</span> Complex :: <span class="keyword">operator</span>== (<span class="keyword">const</span> Complex &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (m_i == b.m_i &amp;&amp; m_j == b.m_j) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>类与类之间可以有继承关系，已有一个基类，可以用一个派生类来继承基类</p>
<ul>
<li>语法：<code>class 派生类 : 继承方式 基类</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Dog</code>就是<code>Animal</code>的派生类，可以继承基类的成员。</p>
<p>派生类可以继承基类的所有成员，但只有<code>public</code>和<code>protected</code>成员能被访问到，<code>private</code>成员可以继承，但无法访问。</p>
<h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>继承方式分为三种：公共继承<code>public</code>、保护继承<code>protected</code>、私有继承<code>private</code></p>
<p>例如一个基类<code>A</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类<code>B</code>按不同继承方式，成员会继承为不同的权限</p>
<ul>
<li><p>公共继承<code>public</code></p>
<p>  原<code>public</code>、<code>protected</code>依旧以<code>public</code>、<code>protected</code>继承，不可访问<code>private</code>。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">不可访问:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>保护继承<code>protected</code></p>
<p>  原<code>public</code>、<code>protected</code>以<code>protected</code>继承，不可访问<code>private</code>。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">protected</span> A &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">不可访问:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>私有继承<code>private</code></p>
<p>  原<code>public</code>、<code>protected</code>以<code>private</code>继承，不可访问<code>private</code>。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">private</span> A &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">不可访问:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>一个派生类继承了多个基类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;派生类名&gt;:</span>&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例如，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Mother, <span class="keyword">public</span> Father &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="构造和析构顺序"><a href="#构造和析构顺序" class="headerlink" title="构造和析构顺序"></a>构造和析构顺序</h3><p>构造顺序、析构顺序镜像相反，先构造的后析构，先析构的后构造。</p>
<ul>
<li><p>继承关系中，</p>
<p>  构造顺序：基类构造 -&gt; 派生类构造</p>
<p>  析构顺序：派生类析构 -&gt; 基类析构</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Father() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Father构造"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Father() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Father析构"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Son() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Son构造"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Son() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Son析构"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  输出：</p>
<blockquote>
<p>Father构造<br>Son构造<br>Son析构<br>Father析构</p>
</blockquote>
</li>
<li><p>当其他类作为本类成员时，</p>
<p>  构造顺序：成员类构造 -&gt; 本类构造</p>
<p>  析构顺序：本类析构 -&gt; 成员类析构</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A构造"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A析构"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B构造"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~B() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B析构"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  输出：</p>
<blockquote>
<p>A构造<br>B构造<br>B析构<br>A析构</p>
</blockquote>
</li>
</ul>
<h3 id="同名成员处理"><a href="#同名成员处理" class="headerlink" title="同名成员处理"></a>同名成员处理</h3><p>如果派生类和基类中有相同成员重名，那么就会遮蔽从基类继承过来的成员，使用派生类成员。</p>
<p>如基类<code>Father</code>和派生类<code>Son</code>中都有成员变量<code>m_A</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Son s;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.m_A; <span class="comment">//默认调用的是派生类Son中的m_A</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.Father::m_A; <span class="comment">//加作用域可调用基类Father中的m_A</span></span><br></pre></td></tr></table></figure>
<p>基类成员函数和派生类成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Son s;</span><br><span class="line">s.func(); <span class="comment">//默认调用的是派生类Son中的func函数</span></span><br><span class="line">s.Father::func(<span class="number">100</span>); <span class="comment">//加作用域可调用基类Father中的func函数</span></span><br></pre></td></tr></table></figure>
<h3 id="派生类赋值给基类（向上转型）"><a href="#派生类赋值给基类（向上转型）" class="headerlink" title="派生类赋值给基类（向上转型）"></a>派生类赋值给基类（向上转型）</h3><p>派生类赋值给基类，称为向上转型。相应地，将基类赋值给派生类，称为向下转型。</p>
<p>向上转型非常安全，可以由编译器自动完成；向下转型有风险，需要程序员手动干预。</p>
<ul>
<li><p>派生类对象赋值给基类对象</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Father f = Son();</span><br></pre></td></tr></table></figure>
</li>
<li><p>派生类指针赋值给基类指针</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Father *f = <span class="keyword">new</span> Son();</span><br></pre></td></tr></table></figure>
</li>
<li><p>派生类引用赋值给基类引用</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Son s;</span><br><span class="line">Father &amp;f = s;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>赋值只包含成员变量，不包含成员函数。所以调用同名成员函数时，<code>f</code>依旧调用的是原本基类<code>Father</code>的成员函数。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态，即函数多种形态，分为两类：</p>
<ul>
<li>静态多态<ul>
<li>函数重载、运算符重载</li>
<li>静态：编译阶段绑定函数地址</li>
</ul>
</li>
<li>动态多态<ul>
<li>派生类和虚函数实现运行时的多态</li>
<li>动态：运行阶段绑定函数地址</li>
</ul>
</li>
</ul>
<p>当基类和派生类中有相同成员函数时，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"动物发声"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"喵喵喵"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类调用，会遮蔽基类中的所有同名函数，直接调用派生类的函数，所以<code>c.speak();</code>输出了“喵喵喵”。</p>
<p>派生类赋值给基类后，只改变成员变量，不改变成员函数，基类调用，依旧调用的是原本基类的成员函数，所以<code>a-&gt;speak();</code>输出了“动物发声”。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Cat c;</span><br><span class="line">c.speak(); <span class="comment">//喵喵喵，调用派生类函数</span></span><br><span class="line">    </span><br><span class="line">Animal *a = &amp;c;</span><br><span class="line">a-&gt;speak(); <span class="comment">//动物发声，调用基类函数</span></span><br></pre></td></tr></table></figure>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>如果希望<code>a-&gt;speak();</code>调用的是派生类函数的“喵喵喵”，则应将基类的<code>speak()</code>设置为<strong>虚函数</strong>，添加关键字<code>virtual</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"动物发声"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"喵喵喵"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cat c;</span><br><span class="line">    c.speak(); <span class="comment">//喵喵喵，调用派生类函数</span></span><br><span class="line">    </span><br><span class="line">    Animal *a = &amp;c;</span><br><span class="line">    a-&gt;speak(); <span class="comment">//喵喵喵，调用派生类函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如不是虚函数，在编译时就会静态链接，将<code>a-&gt;speak();</code>早绑定到基类函数上。</p>
<p>如是虚函数，在运行时才会动态链接，如此，便可将<code>a-&gt;speak();</code>绑定到派生类函数上。</p>
</blockquote>
<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>如果基类中的虚函数没有实际意义，可以定义为纯虚函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">virtual</span> 返回值类型 函数名 (函数参数) = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>纯虚函数没有函数体，只有函数声明，在虚函数声明的结尾加上<code>=0</code>，表明此函数为纯虚函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h1><p>C++泛型编程，主要技术就是模版。使变量变成通用变量，如<code>vector&lt;int&gt;</code>的利用模版技术，可以输入不同的数据类型。</p>
<h2 id="函数模版-类模版"><a href="#函数模版-类模版" class="headerlink" title="函数模版/类模版"></a>函数模版/类模版</h2><ul>
<li><p>定义</p>
<p>  分为建立一个通用函数/类，返回值和形参的类型可以不具体制定，而用一个虚拟类型来表示。<br>  函数模版例如<code>swap</code>函数，输入的两个参数都是模版，所有可以交换两个<code>int</code>，也可以交换两个<code>string</code>。<br>  类模版例如<code>vector&lt;int&gt;</code>，其中的成员类型可变换。</p>
</li>
<li><p>语法</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数/类声明或定义</span><br></pre></td></tr></table></figure>
<ul>
<li>template表明声明一个模版</li>
<li>typename可以换成class，效果相同</li>
<li>T为通用数据类型名，告诉编译器不要报错</li>
</ul>
</li>
<li><p>函数模版例子</p>
<p>  自行定义一个交换函数模版</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  调用模版函数，可以自动类型推导</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">Swap(a, b);</span><br></pre></td></tr></table></figure>
<p>  也可以指定类型</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">Swap&lt;<span class="keyword">int</span>&gt;(a, b);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>类模版</p>
<p>定义一个模版类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> NameType, <span class="keyword">typename</span> AgeType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    NameType m_name;</span><br><span class="line">    AgeType m_age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(NameType name, AgeType age) &#123;</span><br><span class="line">        m_name = name;</span><br><span class="line">        m_age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用模版类</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Person&lt;string, int&gt; p("Job", 10);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><p>STL（Standard Template Library），即标准模板库。</p>
<p>STL由三大组件构成：容器、算法、迭代器。</p>
<ul>
<li><p><strong>容器</strong>：特定的数据结构，如 向量（vector）、双端队列（deque）、链表（list）、集合（set）、多重集合（multiset）、映射（map）和多重映射（multimap）等</p>
</li>
<li><p><strong>算法</strong>：常用的各种算法，如 sort、find、copy、for_each等</p>
</li>
<li><p><strong>迭代器</strong>：检查容器内元素并遍历元素的数据类型</p>
</li>
</ul>
<h2 id="vector（向量）"><a href="#vector（向量）" class="headerlink" title="vector（向量）"></a>vector（向量）</h2><blockquote>
<p>向量（vector）是一个封装了动态大小数组的顺序容器</p>
</blockquote>
<h3 id="函数方法"><a href="#函数方法" class="headerlink" title="函数方法"></a>函数方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>v.front()</td>
<td>返回第一个数据</td>
</tr>
<tr>
<td>v.back()</td>
<td>返回最后一个数据</td>
</tr>
<tr>
<td>v.pop_back()</td>
<td>删除最后一个数据</td>
</tr>
<tr>
<td>v.push_back(element)</td>
<td>在尾部加一个数据</td>
</tr>
<tr>
<td>v.size()</td>
<td>返回元素个数</td>
</tr>
<tr>
<td>v.clear()</td>
<td>清除所有元素</td>
</tr>
<tr>
<td>v.resize(n,v)</td>
<td>改变数组大小为n，n个空间数值赋为v，如果没有默认赋值为0</td>
</tr>
<tr>
<td>v.insert(it,x)</td>
<td>向任意迭代器it插入一个元素x</td>
</tr>
<tr>
<td>v.erase(first,last)</td>
<td>删除[first,last)的所有元素</td>
</tr>
<tr>
<td>v.begin()</td>
<td>返回首元素的迭代器</td>
</tr>
<tr>
<td>v.end()</td>
<td>返回最后一个元素后一个位置的迭代器</td>
</tr>
<tr>
<td>v.empty()</td>
<td>判断是否为空，为空返回真，反之返回假       </td>
</tr>
</tbody>
</table>
</div>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>运用vector容器需要引用vector头文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>vector初始化</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>vector<T> v</td>
<td>默认初始化一个空vector</td>
</tr>
<tr>
<td>vector<T> v2(v1)</td>
<td>v2中包含有v1所有元素的副本</td>
</tr>
<tr>
<td>vector<T> v2 = v1</td>
<td>等价于 v2(v1)</td>
</tr>
<tr>
<td>vector<T> v(n, val)</td>
<td>n个重复的元素val</td>
</tr>
<tr>
<td>vector<T> v(n)</td>
<td>n个重复的默认</td>
</tr>
<tr>
<td>vector<T> v {a, b, c….}</td>
<td>赋值</td>
</tr>
<tr>
<td>vector<T> v = {a, b, c….}</td>
<td>等价于 v{a, b, c….}</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>二维vector初始化</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化10*5的二维vector，元素值都为1</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>, <span class="number">1</span>))</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>尾部插入元素</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">v.push_back(x);</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入元素</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">v.insert(v.<span class="built_in">begin</span>() + <span class="number">2</span>, x); <span class="comment">//在第3个位置插入x</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除元素</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">v.erase(v.<span class="built_in">begin</span>() + <span class="number">2</span>); <span class="comment">//删除第3个位置的元素</span></span><br><span class="line">v.erase(v.<span class="built_in">begin</span>() + i, v.<span class="built_in">begin</span>() + j); <span class="comment">//删除第[i, j)位置的元素</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历vector集合</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代器遍历访问</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种遍历访问方式</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : s)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="set（集合）"><a href="#set（集合）" class="headerlink" title="set（集合）"></a>set（集合）</h2><blockquote>
<p>set（集合）的每个元素只出现一次，且默认升序排列。</p>
</blockquote>
<h3 id="函数方法-1"><a href="#函数方法-1" class="headerlink" title="函数方法"></a>函数方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.begin()</td>
<td>返回set容器的第一个元素的地址（迭代器）</td>
</tr>
<tr>
<td>s.end()</td>
<td>返回set容器的最后一个元素的下一个地址（迭代器）</td>
</tr>
<tr>
<td>s.rbegin()</td>
<td>返回逆序迭代器，指向容器元素最后一个位置</td>
</tr>
<tr>
<td>s.rend()</td>
<td>返回逆序迭代器，指向容器第一个元素前面的位置</td>
</tr>
<tr>
<td>s.clear()</td>
<td>删除set容器中的所有的元素,返回unsigned int类型O(N)</td>
</tr>
<tr>
<td>s.empty()</td>
<td>判断set容器是否为空</td>
</tr>
<tr>
<td>s.insert()</td>
<td>插入一个元素</td>
</tr>
<tr>
<td>s.size()</td>
<td>返回当前set容器中的元素个数O(1)</td>
</tr>
<tr>
<td>erase(iterator)</td>
<td>删除定位器iterator指向的值</td>
</tr>
<tr>
<td>erase(first,second）</td>
<td>删除定位器first和second之间的值</td>
</tr>
<tr>
<td>erase(key_value)</td>
<td>删除键值key_value的值</td>
</tr>
<tr>
<td>s.find(元素)</td>
<td>查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器，即s.end()</td>
</tr>
<tr>
<td>s.lower_bound(k)</td>
<td>返回大于等于k的第一个元素的迭代器</td>
</tr>
<tr>
<td>s.upper_bound(k)</td>
<td>返回大于k的第一个元素的迭代器</td>
</tr>
</tbody>
</table>
</div>
<h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>运用set容器需要引用set头文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>set构造函数</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s; <span class="comment">//默认按键值升序</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt;&gt; p; <span class="comment">//降序</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历set集合</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代器遍历访问</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种遍历访问方式</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : s)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="map（映射）"><a href="#map（映射）" class="headerlink" title="map（映射）"></a>map（映射）</h2><blockquote>
<p>map（映射）的每个元素都是一个pair，包含 &lt;键值，实值&gt;，map不允许两个元素有相同的键值，所有元素根据键值自动排序。</p>
</blockquote>
<h3 id="函数方法-2"><a href="#函数方法-2" class="headerlink" title="函数方法"></a>函数方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>mp.find(key)</td>
<td>返回键为key的映射的迭代器，当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回mp.end()</td>
</tr>
<tr>
<td>mp.erase(it)</td>
<td>删除迭代器对应的键和值</td>
</tr>
<tr>
<td>mp.erase(key)</td>
<td>根据映射的键删除键和值</td>
</tr>
<tr>
<td>mp.erase(first,last)</td>
<td>删除左闭右开区间迭代器对应的键和值</td>
</tr>
<tr>
<td>mp.size()</td>
<td>返回映射的对数</td>
</tr>
<tr>
<td>mp.clear()</td>
<td>清空map中的所有元素</td>
</tr>
<tr>
<td>mp.insert()</td>
<td>插入元素，插入时要构造键值对</td>
</tr>
<tr>
<td>mp.empty()</td>
<td>如果map为空，返回true，否则返回false</td>
</tr>
<tr>
<td>mp.begin()</td>
<td>返回指向map第一个元素的迭代器（地址）</td>
</tr>
<tr>
<td>mp.end()</td>
<td>返回指向map尾部的迭代器（最后一个元素的下一个地址）</td>
</tr>
<tr>
<td>mp.rbegin()</td>
<td>返回指向map最后一个元素的反向迭代器（地址）</td>
</tr>
<tr>
<td>mp.rend()</td>
<td>返回指向map第一个元素前面(上一个）的反向迭代器（地址）</td>
</tr>
<tr>
<td>mp.count(key)</td>
<td>查看元素是否存在，因为map中键是唯一的，所以存在返回1，不存在返回0</td>
</tr>
<tr>
<td>mp.lower_bound()</td>
<td>返回一个迭代器，指向键值&gt;= key的第一个元素</td>
</tr>
<tr>
<td>mp.upper_bound()</td>
<td>返回一个迭代器，指向键值&gt; key的第一个元素</td>
</tr>
</tbody>
</table>
</div>
<h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><p>运用map容器需要引用map头文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>map构造函数</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mp; <span class="comment">//键值为string，实值为int</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加元素</p>
<ul>
<li><p>方法一：通过数组的方式插入值</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mp[<span class="string">"a"</span>] = <span class="number">1</span>; <span class="comment">//mp[key]，如果不存在对应的key时，会自动创建一个键值对</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二：通过pair的方式插入对象</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mp.insert(&#123;<span class="string">"a"</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    </span><br><span class="line">mp.insert(make_pair(<span class="string">"a"</span>, <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">mp.insert(&#123;<span class="string">"a"</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    </span><br><span class="line">mp.insert(pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; (<span class="string">"a"</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>访问元素</p>
<ul>
<li><p>通过下标访问</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; mp[<span class="string">"a"</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过find函数访问</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it = mp.<span class="built_in">find</span>(<span class="string">"a"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>遍历元素</p>
<ul>
<li><p>通过迭代器遍历</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正向遍历（利用begin和end函数）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 逆向遍历（利用rbegin和rend函数）</span></span><br><span class="line"><span class="keyword">auto</span> it = mp.rbegin();</span><br><span class="line"><span class="keyword">while</span> (it != mp.rend()) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    it++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>范围for语句遍历</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只能访问，无法改变容器中的值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : mp)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i.first &lt;&lt; <span class="string">" "</span> &lt;&lt; i.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如需改变值，则用引用</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : mp)&#123;</span><br><span class="line">    i.second *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过迭代器遍历时，迭代器<code>it</code>可以理解为指向元素的指针，指针用<code>-&gt;</code>访问，即<code>it-&gt;first</code>，或用<code>(*it).first</code>，可改变容器中的值</p>
<p>范围for语句遍历时，<code>i</code>是一个pair对象，直接用<code>.</code>访问，即<code>it.first</code>。只访问时，用<code>auto i : mp</code>，当需要改变值时，用<code>auto &amp;i : mp</code></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="deque（双端队列）"><a href="#deque（双端队列）" class="headerlink" title="deque（双端队列）"></a>deque（双端队列）</h2><blockquote>
<p>deque（双端队列）首尾都可以插入和删除的队列。</p>
</blockquote>
<h3 id="函数方法-3"><a href="#函数方法-3" class="headerlink" title="函数方法"></a>函数方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>push_back(x)</td>
<td>把x压入后端</td>
</tr>
<tr>
<td>push_front(x)</td>
<td>把x压入前端</td>
</tr>
<tr>
<td>back()</td>
<td>访问(不删除)后端元素</td>
</tr>
<tr>
<td>front()</td>
<td>访问(不删除)前端元素</td>
</tr>
<tr>
<td>pop_back()</td>
<td>删除后端元素</td>
</tr>
<tr>
<td>pop_front()</td>
<td>删除前端元素</td>
</tr>
<tr>
<td>erase(iterator it)</td>
<td>删除双端队列中的某一个元素</td>
</tr>
<tr>
<td>erase(iterator first,iterator last)</td>
<td>删除双端队列中（first,last）中的元素</td>
</tr>
<tr>
<td>empty()</td>
<td>判断deque是否空</td>
</tr>
<tr>
<td>size()</td>
<td>返回deque的元素数量</td>
</tr>
<tr>
<td>clear()</td>
<td>清空deque</td>
</tr>
</tbody>
</table>
</div>
<h3 id="基本用法-3"><a href="#基本用法-3" class="headerlink" title="基本用法"></a>基本用法</h3><p>运用deque容器需要引用deque头文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>deque构造函数</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="stack（栈）"><a href="#stack（栈）" class="headerlink" title="stack（栈）"></a>stack（栈）</h2><blockquote>
<p>stack（栈），先进后出的数据结构。</p>
</blockquote>
<h3 id="函数方法-4"><a href="#函数方法-4" class="headerlink" title="函数方法"></a>函数方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.push(x)</td>
<td>将x压入栈顶</td>
</tr>
<tr>
<td>s.top()</td>
<td>返回栈顶的元素</td>
</tr>
<tr>
<td>s.pop()</td>
<td>删除栈顶的元素</td>
</tr>
<tr>
<td>s.size()</td>
<td>返回栈中元素的个数</td>
</tr>
<tr>
<td>s.empty()</td>
<td>检查栈是否为空,若为空返回true,否则返回false</td>
</tr>
</tbody>
</table>
</div>
<h3 id="基本用法-4"><a href="#基本用法-4" class="headerlink" title="基本用法"></a>基本用法</h3><p>运用stack容器需要引用stack头文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>stack构造函数</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="string（字符串）"><a href="#string（字符串）" class="headerlink" title="string（字符串）"></a>string（字符串）</h2><p>string是C++中的一个类，专门实现字符串的相关操作。数据类型为string，字符串结尾没有<code>\0</code>字符。</p>
<p>与之相比，C语言字符串（C-string），用char数组实现，字符串结尾以<code>\0</code>结尾。</p>
<h3 id="基本用法-5"><a href="#基本用法-5" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>初始化</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str1; <span class="comment">//生成空字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str2</span><span class="params">(<span class="string">"12345678"</span>)</span></span>; <span class="comment">//结果为"12345678"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str3</span><span class="params">(<span class="string">"12345678"</span>, <span class="number">1</span>, <span class="number">3</span>)</span></span>; <span class="comment">//结果为"234"，从1号开始，长度为3的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str4</span><span class="params">(<span class="string">"12345678"</span>, <span class="number">3</span>)</span></span>; <span class="comment">//结果为"123"，从0号开始，长度为3的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str4</span><span class="params">(<span class="number">5</span>, <span class="string">'2'</span>)</span></span>; <span class="comment">//结果为"22222"，5个'2'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str4</span><span class="params">(str2, <span class="number">3</span>)</span></span>; <span class="comment">//结果为"45678"，从3号开始的字符串</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>读入</p>
<ul>
<li><p><code>cin &gt;&gt; str</code> 读入字符串，遇到空格或回车结束</p>
</li>
<li><p><code>getline(cin, str)</code>，读入一行字符串，包括空格，遇到回车结束</p>
</li>
<li><p>注意：<code>cin</code>输入回车结束后，回车仍在输入流中，<code>getline</code>会获取前一个输入的换行符，所以需要在前面添加读取换行符的语句：<code>getchar()</code> 或 <code>cin.get()</code></p>
<p>  错误读取方式</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str1, str2;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str1;</span><br><span class="line">getline(<span class="built_in">cin</span>, str2); <span class="comment">//此处getline只能读到上一个cin的换行符</span></span><br></pre></td></tr></table></figure>
<p>  正确读取方式</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str1, str2;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str1;</span><br><span class="line">getchar(); <span class="comment">//或者cin.get()，用于接收上一个换行符</span></span><br><span class="line">getline(<span class="built_in">cin</span>, str2); <span class="comment">//此处getline只能读到上一个cin的换行符</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>获取长度</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.size()或s.length()</td>
<td>返回string对象的字符个数</td>
</tr>
<tr>
<td>s.max_size()</td>
<td>返回string对象最多包含的字符数，超出会抛出length_error异常</td>
</tr>
<tr>
<td>s.capacity()</td>
<td>重新分配内存之前，string对象能包含的最大字符数</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>插入</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.push_back(element)</td>
<td>在末尾插入一个字符element</td>
</tr>
<tr>
<td>s.insert(iterator it,element)</td>
<td>在迭代器it处插入一个字符element</td>
</tr>
<tr>
<td>s.append(str)</td>
<td>在s字符串结尾添加str字符串</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"123456"</span>;</span><br><span class="line">s.push_back(<span class="string">'a'</span>); <span class="comment">//结果：123456a，在末尾插入一个字符'a'</span></span><br><span class="line">s.insert(s.<span class="built_in">begin</span>(), <span class="string">'b'</span>); <span class="comment">//结果：b123456a，在开头插入一个字符'b'</span></span><br><span class="line">s.append(<span class="string">"cdef"</span>); <span class="comment">//结果：b123456acdef，在末尾添加字符串“cdef”</span></span><br></pre></td></tr></table></figure>
<ul>
<li>删除</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.erase(iterator it)</td>
<td>删除字符串中it所指的字符</td>
</tr>
<tr>
<td>s.erase(iterator first, iterator last)</td>
<td>删除字符串中迭代器区间[first,last)上所有字符</td>
</tr>
<tr>
<td>s.erase(pos, len)</td>
<td>删除字符串中从索引位置pos开始的len个字符</td>
</tr>
<tr>
<td>s.clear()</td>
<td>删除字符串中所有字符</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"123456789"</span>;</span><br><span class="line">s.erase(s.<span class="built_in">begin</span>()); <span class="comment">//结果：23456789，删除开头的一个字符</span></span><br><span class="line">s.erase(s.<span class="built_in">end</span>()<span class="number">-1</span>); <span class="comment">//结果：2345678，删除结尾的一个字符</span></span><br><span class="line">s.erase(s.<span class="built_in">begin</span>()+<span class="number">2</span>, s.<span class="built_in">end</span>()<span class="number">-2</span>); <span class="comment">//结果：2378，删除[first,last)上所有字符，不删last</span></span><br><span class="line">s.erase(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//结果：28，删除从1号位开始的2个字符</span></span><br><span class="line">s.<span class="built_in">clear</span>(); <span class="comment">//结果：空</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字符替换</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.replace(pos,n,str)</td>
<td>把当前字符串从索引pos开始的n个字符替换为str</td>
</tr>
<tr>
<td>s.replace(pos,n,n1,c)</td>
<td>把当前字符串从索引pos开始的n个字符替换为n1个字符c</td>
</tr>
<tr>
<td>s.replace(iterator first,iterator last,str)</td>
<td>把当前字符串[first,last)区间替换为str</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"123456789"</span>;</span><br><span class="line">s.replace(<span class="number">0</span>, <span class="number">3</span>, <span class="string">"abcd"</span>); <span class="comment">//结果：abcd456789，将从0号位开始的3个字符替换为"abcd"</span></span><br><span class="line">s.replace(<span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">'e'</span>); <span class="comment">//结果：abcd45ee9，将从6号位开始的3个字符替换为2个'e'</span></span><br><span class="line">s.replace(s.<span class="built_in">begin</span>()+<span class="number">2</span>, s.<span class="built_in">end</span>()<span class="number">-2</span>, <span class="string">"fff"</span>); <span class="comment">//结果：abfffe9，将ab‘cd45e’e9中间替换为"fff"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>分割</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.substr(pos,n)</td>
<td>截取从pos索引开始的n个字符</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"123456789"</span>;</span><br><span class="line"><span class="built_in">string</span> sub = s.substr(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">//结果：345，截取从2号位开始的3个字符</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查找</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.find (str, pos)</td>
<td>在当前字符串的pos索引位置(默认为0)开始，查找子串str，返回找到的位置索引，-1表示查找不到子串</td>
</tr>
<tr>
<td>s.find (c, pos)</td>
<td>在当前字符串的pos索引位置(默认为0)开始，查找字符c，返回找到的位置索引，-1表示查找不到字符</td>
</tr>
<tr>
<td>s.rfind (str, pos)</td>
<td>在当前字符串的pos索引位置开始，反向查找子串s、str，返回找到的位置索引，-1表示查找不到子串</td>
</tr>
<tr>
<td>s.rfind (c,pos)</td>
<td>在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到字符</td>
</tr>
<tr>
<td>s.find_first_of (str, pos)</td>
<td>在当前字符串的pos索引位置(默认为0)开始，查找子串str的字符，返回找到的位置索引，-1表示查找不到字符</td>
</tr>
<tr>
<td>s.find_first_not_of (str,pos)</td>
<td>在当前字符串的pos索引位置(默认为0)开始，查找第一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</td>
</tr>
<tr>
<td>s.find_last_of(str, pos)</td>
<td>在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</td>
</tr>
<tr>
<td>s.find_last_not_of (str, pos)</td>
<td>在当前字符串的pos索引位置开始，查找最后一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到子串</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"This is a string."</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//从首位开始，查找字符的第一个出现的位置</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.<span class="built_in">find</span>(<span class="string">'s'</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//结果：3，Thi's'</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//从首位开始，查找字符串第一个出现的位置，返回首字符位置</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.<span class="built_in">find</span>(<span class="string">"is"</span>)&lt;&lt; <span class="built_in">endl</span>; <span class="comment">//结果：2，Th'i's</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//从4号位开始，查找字符串第一个出现的位置</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.<span class="built_in">find</span>(<span class="string">"is"</span>, <span class="number">4</span>)&lt;&lt; <span class="built_in">endl</span>; <span class="comment">//结果：5，'i's a</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//从尾部开始，反向查找字符，即正序的最后一个位置</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.rfind(<span class="string">'s'</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//结果：10，'s'tring</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//从尾位开始，反向查找字符串，即正序的最后一个位置，返回首字符位置</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.rfind(<span class="string">"is"</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//结果：5，'i's a</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//从4号位开始，反向查找字符串</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.rfind(<span class="string">"is"</span>, <span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//结果：2，Th'i's</span></span><br></pre></td></tr></table></figure>
<ul>
<li>排序</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"349725618"</span>;</span><br><span class="line">sort(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>()); <span class="comment">//结果：123456789，默认升序</span></span><br><span class="line">sort(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), greater&lt;<span class="keyword">char</span>&gt;()); <span class="comment">//结果：987654321</span></span><br></pre></td></tr></table></figure>
<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><p>C++ 内存分为以下几个部分：</p>
<ul>
<li><p>栈区（stack）</p>
<ul>
<li>存放函数的参数值、局部变量、返回值、返回地址等</li>
<li>由编译器自动分配和释放</li>
</ul>
</li>
<li><p>堆区（heap）</p>
<ul>
<li>存放动态分配的内存，如 <code>new</code> 、 <code>malloc</code> 分配的动态变量</li>
<li>STL（除 <code>pair</code>）也都是存放在堆区</li>
<li>堆区大小不固定，由程序手动分配和释放</li>
</ul>
</li>
<li><p>全局区/静态区（static）</p>
<ul>
<li>存放全局变量、静态变量 <code>static</code></li>
<li>分为 <code>data</code> 段和 <code>bss</code> 段，已初始化的全局变量和静态变量存放在 <code>data</code> 段，未初始化或者初始化为0的全局变量和静态变量存放在 <code>bss</code> 段</li>
<li>程序启动时被分配，直到程序结束时自动释放</li>
</ul>
</li>
<li><p>常量区</p>
<ul>
<li>存放常量，不允许修改</li>
<li>程序启动时被分配，直到程序结束时自动释放</li>
</ul>
</li>
<li><p>代码区</p>
<ul>
<li>存放指令代码</li>
<li>程序启动时被分配，直到程序结束时自动释放</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a1; <span class="comment">//全局区的bss段</span></span><br><span class="line"><span class="keyword">int</span> a2 = <span class="number">0</span>; <span class="comment">//全局区的bss段</span></span><br><span class="line"><span class="keyword">int</span> a3 = <span class="number">1</span>; <span class="comment">//全局区的data段</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">1</span>; <span class="comment">//全局区的data段</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="comment">//栈区</span></span><br><span class="line">    <span class="keyword">int</span> d1 = <span class="number">1</span>; <span class="comment">//栈区</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> d2 = <span class="number">1</span>; <span class="comment">//栈区</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> d3 = <span class="number">1</span>; <span class="comment">//全局区的data段</span></span><br><span class="line">    <span class="keyword">return</span> d1; <span class="comment">//栈区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>隐式转换，即在类型不统一时，系统自动进行的类型转换</p>
<p>何时发生隐式转换？</p>
<ul>
<li>算术运算中，低类型转换为高类型</li>
<li>赋值表达式中，右边的表达式的值自动转化为左边变量的类型</li>
<li>函数传参时，将实参转化为形参的类型</li>
<li>函数返回时，将返回表达式转化为返回值的类型</li>
</ul>
<h3 id="算数转换"><a href="#算数转换" class="headerlink" title="算数转换"></a>算数转换</h3><p>算数转换是隐式转换的一种，会将低类型转换为高类型</p>
<h2 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h2><h1 id="常见问题记录"><a href="#常见问题记录" class="headerlink" title="常见问题记录"></a>常见问题记录</h1><h2 id="作为函数参数的多维数组"><a href="#作为函数参数的多维数组" class="headerlink" title="作为函数参数的多维数组"></a>作为函数参数的多维数组</h2><blockquote>
<p>详见《C和指针》P159</p>
</blockquote>
<p>传数组参数，即是要传递指向数组第一个元素的指针。</p>
<p>以一维数组为例，<code>vector</code>即为指向数组第一个<code>int</code>元素的指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">vector</span>[<span class="number">10</span>];</span><br><span class="line">...</span><br><span class="line">func1(<span class="built_in">vector</span>);</span><br></pre></td></tr></table></figure>
<p>参数<code>vector</code>是指向<code>int</code>型的指针，所以函数定义可以是如下两种方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">vector</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> <span class="built_in">vector</span>[])</span></span>;</span><br></pre></td></tr></table></figure>
<p>多维数组传参，同样是传指向第一个元素的指针，但有所不同的是，多维数组的每个元素本身也是另一个数组，编译器需要知道它的维度。</p>
<p>以二维数组为例，二维数组<code>matrix[3][10]</code>相当于是包含3个元素的一维数组，每个元素又是一个包含10个元素的一维数组，<code>matrix</code>的类型是指向包含10个整型元素的数组的指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> matrix[<span class="number">3</span>][<span class="number">10</span>];</span><br><span class="line">...</span><br><span class="line">func2(matrix);</span><br></pre></td></tr></table></figure>
<p>所以，函数的原型必须包含第二个维度10，编译器才知道什么时候开始换行，可以有如下两种定义方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> (*matrix)[<span class="number">10</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> matrix[][<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>关键就在于编译器必须知道第2个及以后各维的长度，才能对下标进行求值</strong></p>
<hr>
<p>典型的错误写法</p>
<ul>
<li><p>错误写法一：未包含第二个维度长度，<code>**matrix</code>为指向整型指针的指针，而不是指向数组的指针</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> **matrix)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>错误写法二：<code>*matrix[10]</code>为指针数组，即数组元素是指针；<code>(*matrix)[10]</code>为数组指针，即指向数组的指针</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> *matrix[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="类模板头文件的编写"><a href="#类模板头文件的编写" class="headerlink" title="类模板头文件的编写"></a>类模板头文件的编写</h2><p>c++中模板的声明和定义不能分开</p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>如和一般的类头文件一样，将模板类中函数声明写在<code>类名.hpp</code>中，函数定义写在<code>类名.cpp</code>中，<code>类名.cpp</code>、<code>main.cpp</code>调用<code>.h</code>文件，则会出现报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: Undefined Symbol 成员函数</span><br></pre></td></tr></table></figure>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>模板类中的成员函数在调用时才创建。</p>
<blockquote>
<p>C++编译时，就要确定每个对象的空间大小。</p>
<p>但是，模板类在未被使用前，无法确定大小，比如<code>vector&lt;int&gt;</code>和<code>vector&lt;char&gt;</code>，这两套用不同数据类型的模版，实际是两个不同的类。</p>
</blockquote>
<p>所以，c++中模板的声明和定义不能分开。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li><p>方法一：将模板类中的成员函数的声明和定义都写在<code>.h</code>文件里</p>
  <figure class="highlight c"><figcaption><span>Stack.hpp++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> Stack_hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Stack_hpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    T *data; <span class="comment">//成员数组</span></span><br><span class="line">    <span class="keyword">int</span> top; <span class="comment">//栈顶指针，当前栈顶元素的位置</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>; <span class="comment">//栈中元素的最大个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stack();</span><br><span class="line">    ~Stack();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Stack&lt;T&gt;::Stack() : top(<span class="number">-1</span>), <span class="built_in">size</span>(<span class="number">10</span>) &#123;</span><br><span class="line">    data = <span class="keyword">new</span> T[<span class="built_in">size</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁栈</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Stack&lt;T&gt;::~Stack() &#123;</span><br><span class="line">    <span class="keyword">delete</span> [] data;</span><br><span class="line">    data = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>  在<code>main.cpp</code>调用<code>Stack.hpp</code>文件</p>
</li>
<li><p>方法二：<code>main.cpp</code>调用<code>类名.cpp</code>文件，<code>类名.cpp</code>文件调用<code>类名.h</code>文件</p>
  <figure class="highlight c"><figcaption><span>Stack.hpp++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> Stack_hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Stack_hpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    T *data; <span class="comment">//成员数组</span></span><br><span class="line">    <span class="keyword">int</span> top; <span class="comment">//栈顶指针，当前栈顶元素的位置</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>; <span class="comment">//栈中元素的最大个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stack();</span><br><span class="line">    ~Stack();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
  <figure class="highlight c"><figcaption><span>Stack.hpp++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Stack.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Stack&lt;T&gt;::Stack() : top(<span class="number">-1</span>), <span class="built_in">size</span>(<span class="number">10</span>) &#123;</span><br><span class="line">    data = <span class="keyword">new</span> T[<span class="built_in">size</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁栈</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Stack&lt;T&gt;::~Stack() &#123;</span><br><span class="line">    <span class="keyword">delete</span> [] data;</span><br><span class="line">    data = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在<code>main.cpp</code>调用<code>Stack.cpp</code>文件</p>
</li>
</ul>
<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h2 id="sort-排序函数"><a href="#sort-排序函数" class="headerlink" title="sort()排序函数"></a>sort()排序函数</h2><p>sort()函数类似于快速排序，时间复杂度为 $n*log2(n)$</p>
<ul>
<li>头文件  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li>基本使用方法  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(<span class="built_in">begin</span>, <span class="built_in">end</span>, cmp);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>begin</code>：待排序的数组的第一个元素的指针</li>
<li><code>end</code>：待排序的数组的最后一个元素的下一个位置的指针</li>
<li><code>cmp</code>：排序准则，不填则默认为从小到大排序，如想要从大到小排序，则填<code>greater&lt;int&gt;()</code>。如需自行定义排序准则，也可传入bool型函数，返回<code>true</code>则不换位置，返回<code>false</code>则前后调换位置</li>
</ul>
</li>
<li>用例<ul>
<li>数组排序<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num[<span class="number">5</span>] = &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">sort(num, num+<span class="number">5</span>); <span class="comment">//从小到大排序：0 1 2 3 4</span></span><br><span class="line">sort(num, num+<span class="number">5</span>, greater&lt;<span class="keyword">int</span>&gt;()); <span class="comment">//从大到小排序：4 3 2 1 0</span></span><br></pre></td></tr></table></figure></li>
<li>vector排序<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); <span class="comment">//从小到大排序：0 1 2 3 4</span></span><br></pre></td></tr></table></figure></li>
<li>自定义排序准则<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//个位数从大到小排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">10</span> &gt; y % <span class="number">10</span>; <span class="comment">//x个位大于y时，返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">5</span>] = &#123;<span class="number">24</span>, <span class="number">1</span>, <span class="number">83</span>, <span class="number">12</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    sort(num, num + <span class="number">5</span>, cmp); <span class="comment">//个位数从大到小排序：24 83 12 1 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://c.biancheng.net/cplus/" target="_blank" rel="noopener">C++入门教程，C++基础教程</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>入门</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title>DPDK</title>
    <url>/2024/01/15/DPDK/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>DPDK 学习</p>
<a id="more"></a>
<h1 id="DPDK-概述"><a href="#DPDK-概述" class="headerlink" title="DPDK 概述"></a>DPDK 概述</h1><h2 id="包处理"><a href="#包处理" class="headerlink" title="包处理"></a>包处理</h2><p>基于系统是网络终端还是中间件，包处理会有不同的范围。一般来说，包含了包的接收和传输、包头的解析、包的修改以及转发，这些步骤发生在多个协义层。</p>
<ul>
<li>对于网络终端，包会发给本地应用进行更多的处理，如包的加解密、隧道覆盖，这些都可能是包处理、会话建立及结束的一部分。</li>
<li>对于中间件，包会被转发给网络中的下一跳。一般这种系统需要处理大量的进出数据包，功能包括包查询、访问控制、QoS 等等。</li>
</ul>
<h2 id="传统包处理"><a href="#传统包处理" class="headerlink" title="传统包处理"></a>传统包处理</h2><p>在 DPDK 前，Linux 一般的网卡包处理过程如下：</p>
<ol>
<li>包的数据帧抵达网卡</li>
<li>网卡把包的帧以 DMA（Direct Memory Access）的方式写到内存</li>
<li>网卡硬中断通知 CPU 有包到达</li>
<li>CPU 响应硬中断，简单处理后，发出软中断，尽量快速释放 CPU 资源</li>
<li>ksoftirqd 内核线程检测到软中断后，调用网卡驱动注册的 poll 函数开始轮询收包</li>
<li>帧从 RingBuffer 摘下，收到的包交给 Linux 内核的各个协议栈处理</li>
<li>如果最终收包的应用在用户态，包中的信息会从内核态拷贝到用户态</li>
<li>如果最终收包的应用在内核态，包中的信息直接在内核态被处理</li>
</ol>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/1687344-20201204090611124-2143444161.png" alt="Linux收包过程"></p>
<p>在上述包处理过程中，Linux 采用了 NAPI 和 Netmap两个机制来加快包处理过程</p>
<ul>
<li>NAPI 即轮询收包，一次处理多个数据包，处理结束后，再回到中断状态</li>
<li>Netmap 则是数据包通过共享池的方式，减少包从内核态到用户态的复制</li>
</ul>
<p>但这依旧不够，如何使包处理性能更强？待解决的问题如下：</p>
<ul>
<li>Linux 包处理过程需要在内核态和用户态之间转换，任务切换、cache 替换等都会带来不小的开销</li>
<li>随着 CPU 核数越来越多，早期为了适应 CPU 核数较少的分时调度机制限制了处理性能</li>
</ul>
<p>由上述问题，期望的包处理框架应具有如下能力：</p>
<ul>
<li>一个软件方式可以在 x86 CPU 进行包处理</li>
<li>自定义包处理</li>
<li>能使用多核架构，具有高性能</li>
<li>将一般的 Linux 系统调教为包处理环境</li>
</ul>
<h2 id="DPDK-特性"><a href="#DPDK-特性" class="headerlink" title="DPDK 特性"></a>DPDK 特性</h2><p>DPDK 就是回应上述期待的包处理技术，DPDK 拥有下面这些特性：</p>
<ul>
<li>轮询<ul>
<li>为网卡的收发包分配独立的核，不需要与其他任务共享核，因此该类核可以无限循环地检查是否有包到达以及是否需要发送包</li>
<li>该方法减少了中断服务导致的上下文切换等开销</li>
</ul>
</li>
<li>用户态驱动<ul>
<li>在大多数期间下，包最后都会被发到用户态，但 Linux 网卡驱动在内核态</li>
<li>用户态驱动可以避免包从内核态到用户态不必要的内存拷贝，并避免系统调用开销</li>
<li>用户驱动更加灵活，可自定义，不受限于内核现有的数据格式与行为定义</li>
</ul>
</li>
<li>CPU 亲和<ul>
<li>DPDK 虽然工作在用户态，但线程调度依旧依赖内核<ul>
<li>线程在不同的核间切换，由于缓存未命中和缓存写回，会导致性能的下降</li>
<li>同一核内不同任务切换，每次切换都需要保存当前状态寄存器到堆栈中，并恢复切换后的进程的状态信息，带来了额外的开销</li>
</ul>
</li>
<li>CPU 亲和，即将进程或线程绑定到一个或多个特定的 CPU，进一步可独占该核，而不会迁移到其他核</li>
<li>如此，独占固定的核运行 DPDK，既避免了核之间的切换，提高了缓存命中率，又使得该核不用频繁的进行任务切换，减少了任务切换的开销</li>
</ul>
</li>
<li>低访存开销<ul>
<li>包处理大量的 I/O 需要频繁地访存，需要降低访存带来的开销</li>
<li>如采用大页技术降低 TLB miss</li>
</ul>
</li>
<li>软件调优<ul>
<li>一系列调优方式，如 cache line 对齐、cache line 共享等等</li>
</ul>
</li>
</ul>
<h2 id="DPDK-框架"><a href="#DPDK-框架" class="headerlink" title="DPDK 框架"></a>DPDK 框架</h2><p>下面是 DPDK 的基本模块，作为开发包处理系统的基础层，可以用软件模拟大部分的网络功能。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20240908210138213.png" alt="DPDK 框架"></p>
<p>在最底部的内核态有三个模块 ：KNI、IGB_UIO、VFIO，其中</p>
<ul>
<li><strong>KNI</strong>，Kernel Network Interface，内核网络接口，提供 DPDK 和内核交换报文的解决方案。<ul>
<li>KNI 模拟了一个虚拟网卡，提供 DPDK 与 Linux 内核之间通讯，允许报文被用户态接收后转发到 Linux 内核协议栈。</li>
</ul>
</li>
<li><strong>IGB_UIO</strong>，通过 UIO 技术，在初始化过程中将网卡硬件寄存器映射到用户态。<ul>
<li>UIO 技术是一种用户态 I/O 框架，支持将用户态驱动的很少一部分运行在内核空间，大部分则运行在用户空间</li>
<li>IGB_UIO 则是 UIO 的，形态上是一种网卡驱动，网卡绑定 IGB_UIO 驱动后，相当于隔离了内核的网卡驱动，同时 IGB_UIO 还能够完成网卡中断内核态的初始化，并将中断信号映射到用户态</li>
</ul>
</li>
<li><strong>VFIO</strong>，可以安全地把设备 I/O、中断、DMA 等暴露到用户空间，从而可以在用户空间完成设备驱动的架构</li>
</ul>
<p>在上层的用户态，DPDK由很多库组成，主要包括：核心部件库（Core Libs）、平台相关模块（platform）、网卡轮询模式驱动模块（PMD-natives &amp; virtual）、QoS 库、报文转发分类算法（classify 算法）等几大类。</p>
<ul>
<li><strong>核心部件库（Core Libs）</strong>：提供环境抽象层（EAL）、大页内存、缓存池、定时器以及无锁环等基础组件</li>
<li><strong>PMD 库</strong>：提供所有用户态驱动，以便通过轮询和线程绑定得到高网络吞吐量。支持各种本地或者虚拟网卡</li>
<li><strong>Classify 库</strong>：支持精确匹配（exact match）、最长后缀匹配（LPM，longest prefix match）、通配符匹配（ACL，access control list）和 cuckoo hash 算法，这些算法用来包处理中的查表操作</li>
<li><strong>加速器 API</strong>：支持包安全（CryptoDev）、数据压缩（CompressionDev）和用于内核间通信的事件建模器（EventDev）</li>
<li><strong>QoS 库</strong>：提供网络服务质量相关组件，如限速（Meter）和调度（Sched）</li>
<li><strong>平台相关模块</strong>：<ul>
<li>POWER：能耗管理，运行时调整 CPU 时钟频率，可以根据分组接收频率动态调整 CPU 频率，或进入 CPU 的不同休眠状态</li>
<li>KNI：通过 kni.ko 模块将数据报文从用户态传递到内核态协议栈，以便用户进程使用传统的 Socket 接口对相关报文进行处理</li>
<li>Packet Framework 和 DISTRIB 为搭建更复杂的多核流水线处理模型提供了基础的组件</li>
</ul>
</li>
</ul>
<h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p>核心组件是用来做高性能包处理 app 的一系列库。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20240909135406179.png" alt="核心组件" style="zoom: 67%;" /></p>
<h1 id="大页技术"><a href="#大页技术" class="headerlink" title="大页技术"></a>大页技术</h1><h2 id="物理内存和虚拟内存"><a href="#物理内存和虚拟内存" class="headerlink" title="物理内存和虚拟内存"></a>物理内存和虚拟内存</h2><p>CPU 的内存管理包含两个概念：</p>
<ul>
<li>物理内存：即安装在计算机的物理内存条</li>
<li>虚拟内存：虚拟的内存地址</li>
</ul>
<p>多进程操作系统，进程不能直接访问物理内存，避免不安全行为，每个进程都维护了一套自己的虚拟地址，由 CPU 的内存管理单元（MMU）将虚拟地址转换到物理地址，再通过物理地址访问实际的物理内存，保证各个进程之间内存不互相干涉。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20240908150407363.png" style="zoom:50%;" /></p>
<p>转换过程对进程是全透明的，进程可认为程序直接通过虚拟地址访问虚拟内存得到了数据，实际是通过虚拟地址映射到的物理地址在物理内存得到的数据。</p>
<h2 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h2><p>分页是整个虚拟和物理内存空间切成一段段固定尺寸的大小的页（Page），在 Linux 的缺省配置，页大小为 4 KB。</p>
<p>分页机制下，虚拟地址分为了页号和页内偏移量两个部分</p>
<ol>
<li>根据虚拟页号，在页表中找到对应的物理页号</li>
<li>在物理页号对应的物理内存页上，加上页内偏移量，得到物理内存地址</li>
</ol>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20240908154512478.png" alt="内存分页机制"></p>
<h2 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h2><p>但分页方式依旧有缺陷，假如每个进程的虚拟内存有 4GB，采用默认的页大小 4KB，也就是需要对应 1M 个物理页，即需要 1M 个页表项，每个页表项 4B，那么每个进程都需要 4MB 的大小空间用于存储页表。100 个进程就会需要 400 MB 空间。</p>
<p>由此引出多级页表，将虚拟页号和物理页号的对应拆成多级，对于相同的物理页数量，映射使用的页表总大小减小。</p>
<p>以二级页表为例，虚拟地址分为了一级页号、二级页号和页内偏移量三个部分</p>
<ol>
<li>在一级页表，根据一级页号找到对应的二级页表地址</li>
<li>在二级页表地址对应的二级页表上，根据二级页号找到对应的物理页号</li>
<li>在物理页号对应的物理内存页上，加上页内偏移量，得到物理内存地址</li>
</ol>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20240908162116839.png" alt="多级页表"></p>
<h2 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h2><p>多级页表虽然解决了空间问题，但是多了几道地址转换的查表，时间成本增加。</p>
<p>由此引入 TLB（Translation Lookaside Buffer）快表，程序有局部性，对于一个程序而言，往往访问的都是内存的某些区域，所以可以将进程经常访问的页表项存入 Cache 中，这个 Cache 即是 TLB 快表。</p>
<p>在之前的步骤前加上查询 TLB 快表的流程，TLB 快表中存储了经常访问的虚拟页号到物理页号的映射。</p>
<ol>
<li>先查询 TLB，如果查到了，则直接快速拿到物理地址</li>
<li>如果 TLB 未能查到，也就是 TLB miss，则按照正常地流程步骤获取物理地址，并将其加入 TLB 中</li>
</ol>
<h2 id="大页"><a href="#大页" class="headerlink" title="大页"></a>大页</h2><p>TLB 的大小有限，即可以存储的快速查找的虚拟页号到物理页号的映射有限。</p>
<p>在 Linux 的缺省配置，页大小为 4 KB。但也支持更大的尺寸，如 2MB 或 1 GB 的大页，这样虽然 TLB 的页表项数量不变，但是每一项对应的物理页面的大小增加，可以由 TLB 直接命中的范围也就增加了。</p>
<p>TLB 命中概率增加，TLB miss 发生概率减小，如此大大增加了访存效率。</p>
<h2 id="激活大页"><a href="#激活大页" class="headerlink" title="激活大页"></a>激活大页</h2><p>设置大页，2MB 的大页设置 1024 个</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">echo <span class="number">1024</span> &gt; /sys/kernel/mm/hugepages/hugepages<span class="literal">-2048kB</span>/nr_hugepages</span><br></pre></td></tr></table></figure>
<p>查看大页设置</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># cat /proc/meminfo |grep Hu</span></span><br><span class="line">AnonHugePages:         <span class="number">0</span> kB</span><br><span class="line">ShmemHugePages:        <span class="number">0</span> kB</span><br><span class="line">FileHugePages:         <span class="number">0</span> kB</span><br><span class="line">HugePages_Total:    <span class="number">1024</span></span><br><span class="line">HugePages_Free:     <span class="number">1024</span></span><br><span class="line">HugePages_Rsvd:        <span class="number">0</span></span><br><span class="line">HugePages_Surp:        <span class="number">0</span></span><br><span class="line">Hugepagesize:       <span class="number">2048</span> kB</span><br><span class="line">Hugetlb:         <span class="number">2097152</span> kB</span><br></pre></td></tr></table></figure>
<h1 id="环境抽象层-EAL"><a href="#环境抽象层-EAL" class="headerlink" title="环境抽象层 EAL"></a>环境抽象层 EAL</h1><p>EAL（Environment Abstraction Layer，环境抽象层）用于获取底层资源。EAL 可以使用通用接口，屏蔽应用和库的环境特殊性，同时负责初始化分配资源。</p>
<p>EAL 主要提供下列典型服务：</p>
<ul>
<li>DPDK 的加载和启动：DPDK 和指定的程序链接成一个独立的进程，并以某种方式加载</li>
<li>CPU 亲和性和分配处理：DPDK 提供机制将执行单元绑定到特定的核上，就像创建一个执行程序一样。</li>
<li>系统内存分配：EAL 实现了不同区域内存的分配，例如为设备接口提供了物理内存。</li>
<li>PCI 地址抽象：EAL 提供了对 PCI 地址空间的访问接口。</li>
<li>跟踪调试功能：日志信息，堆栈打印、异常挂起等等。</li>
<li>公用功能：提供了标准 libc 不提供的自旋锁、原子计数器等。</li>
<li>CPU 特征辨识：用于决定 CPU 运行时的一些特殊功能，决定当前 CPU 支持的特性，以便编译对应的二进制文件。</li>
<li>中断处理：提供接口用于向中断注册/解注册回掉函数。</li>
<li>告警功能：提供接口用于设置/取消指定时间环境下运行的毁掉函数。</li>
</ul>
<h2 id="EAL-参数"><a href="#EAL-参数" class="headerlink" title="EAL 参数"></a>EAL 参数</h2><p><a href="https://doc.dpdk.org/guides/linux_gsg/linux_eal_parameters.html" target="_blank" rel="noopener">EAL parameters</a></p>
<h2 id="内核初始化与启动"><a href="#内核初始化与启动" class="headerlink" title="内核初始化与启动"></a>内核初始化与启动</h2><p>内核的初始化由 <code>rte_eal_init()</code> 函数完成，待所有核完成初始化后，通过 <code>`rte_eal_remote_launch()</code> ` 函数启动各个核上的应用，具体过程如下</p>
<ol>
<li>MAIN lcore 启动 <code>main()</code> 函数</li>
<li><p>MAIN lcore 调用 <code>rte_eal_init()</code> 进行各种初始化</p>
<ol>
<li>命令行参数 <code>-l</code> 可以设置运行 lcore，第一个作为 MAIN lcore，剩下的作为 WORKER lcores，如不设置，</li>
<li>在 MAIN lcore 中主要包括内存、日志、PCI 等初始化工作</li>
<li>在 WORKER lcores 启动线程，并使之处于 WAIT 状态</li>
<li>MAIN lcore 等待所有逻辑核初始化完毕</li>
</ol>
</li>
<li><p>其他初始化工作，如初始化 lib 库和驱动</p>
</li>
<li><p>MAIN lcore 调用 <code>rte_eal_remote_launch(func, arg, worker_id)</code> 函数，给 WORKER lcore 分配 function 并启动</p>
<ol>
<li>发送信息到对应 worker_id 的 WORKER lcore，确认该核处在 WAIT 状态</li>
<li>WORKER lcore 接收到信息，切换到 RUNNING 状态，并执行 function 带 arg 参数</li>
<li>WORKER lcore 执行 function 完毕后，切换回 WAIT 状态，function 的返回值可以通过 <code>rte_eal_wait_lcore()</code> 读取</li>
</ol>
</li>
<li><p>MAIN lcore 调用 <code>rte_cal_mp_wait_Icore()</code> 函数，等待所有 WORKER lcores 完成 app</p>
<ol>
<li>如果不设置等待，MAIN lcore 会直接结束，不知道其他核的运行情况</li>
<li>等待所有的核完成 function 切回 WAIT 状态</li>
</ol>
</li>
</ol>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20240908213559764.png" alt="内核初始化与启动"></p>
<h2 id="关闭与清理环境"><a href="#关闭与清理环境" class="headerlink" title="关闭与清理环境"></a>关闭与清理环境</h2><p>在 MAIN lcore 程序的最后运行 <code>rte_eal_cleanup()</code> 函数，用于清理 EAL 环境。<code>rte_eal_cleanup()</code> 将会释放 <code>rte_eal_init()</code> 分配的内存，在清理之后，DPDK 函数就无法再被调用了。</p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="MEMPOOL-Library"><a href="#MEMPOOL-Library" class="headerlink" title="MEMPOOL Library"></a>MEMPOOL Library</h2><p>rte_pktmbuf_pool_create</p>
<p>rte_pktmbuf_pool_create_by_ops</p>
<p>rte_mempool_lookup</p>
<p>rte_mempool_free</p>
<h1 id="DPDK-环境搭建"><a href="#DPDK-环境搭建" class="headerlink" title="DPDK 环境搭建"></a>DPDK 环境搭建</h1><p>以 Ubuntu 20.04.6 安装 DPDK 23.11 为例</p>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ul>
<li><p>安装 C 编译器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install build-essential</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 meson 和 ninja</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install meson ninja</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 pyelftools</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install pyelftools</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 NUMA Library</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install libnuma-dev</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="大页-1"><a href="#大页-1" class="headerlink" title="大页"></a>大页</h2><p>设置大页</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">echo <span class="number">1024</span> &gt; /sys/kernel/mm/hugepages/hugepages<span class="literal">-2048kB</span>/nr_hugepages</span><br></pre></td></tr></table></figure>
<h2 id="DPDK-安装"><a href="#DPDK-安装" class="headerlink" title="DPDK 安装"></a>DPDK 安装</h2><ul>
<li><p>下载解压</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wget http://fast.dpdk.org/rel/dpdk<span class="literal">-23</span>.<span class="number">11</span>.tar.xz</span><br><span class="line">tar xJf dpdk<span class="literal">-23</span>.<span class="number">11</span>.tar.xz</span><br><span class="line">cd dpdk<span class="literal">-23</span>.<span class="number">11</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置编译选项</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">meson setup build</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">cd build</span><br><span class="line">ninja</span><br><span class="line">meson install</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="DPDK-与网卡"><a href="#DPDK-与网卡" class="headerlink" title="DPDK 与网卡"></a>DPDK 与网卡</h1><h1 id="官方实例"><a href="#官方实例" class="headerlink" title="官方实例"></a>官方实例</h1><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><h3 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h3><ul>
<li><p>编译</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">cd build</span><br><span class="line">meson configure <span class="literal">-Dexamples</span>=helloworld</span><br><span class="line">ninja</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">echo <span class="number">1024</span> &gt; /sys/kernel/mm/hugepages/hugepages<span class="literal">-2048kB</span>/nr_hugepages</span><br><span class="line">cd build</span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/opt/dpdk<span class="literal">-23</span>.<span class="number">11</span>/build<span class="comment"># ./examples/dpdk-helloworld</span></span><br><span class="line">EAL: Detected CPU lcores: <span class="number">3</span></span><br><span class="line">EAL: Detected NUMA nodes: <span class="number">1</span></span><br><span class="line">EAL: Detected <span class="keyword">static</span> linkage of DPDK</span><br><span class="line">EAL: Multi<span class="literal">-process</span> socket /var/run/dpdk/rte/mp_socket</span><br><span class="line">EAL: Selected IOVA mode <span class="string">'PA'</span></span><br><span class="line">EAL: VFIO support initialized</span><br><span class="line">TELEMETRY: No legacy callbacks, legacy socket not created</span><br><span class="line">hello from core <span class="number">1</span></span><br><span class="line">hello from core <span class="number">2</span></span><br><span class="line">hello from core <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><p>建立一个多核（线程）运行环境，每个线程打印<code>hello from core</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: BSD-3-Clause</span></span><br><span class="line"><span class="comment"> * Copyright(c) 2010-2014 Intel Corporation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/queue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rte_memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rte_launch.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rte_eal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rte_per_lcore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rte_lcore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;rte_debug.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Launch a function on lcore. 8&lt; */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">lcore_hello(__rte_unused <span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> lcore_id;</span><br><span class="line">	lcore_id = rte_lcore_id();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hello from core %u\n"</span>, lcore_id);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* &gt;8 End of launching function on lcore. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialization of Environment Abstraction Layer (EAL). 8&lt; */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="keyword">unsigned</span> lcore_id;</span><br><span class="line"></span><br><span class="line">	ret = rte_eal_init(argc, argv);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		rte_panic(<span class="string">"Cannot init EAL\n"</span>);</span><br><span class="line">	<span class="comment">/* &gt;8 End of initialization of Environment Abstraction Layer */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Launches the function on each lcore. 8&lt; */</span></span><br><span class="line">	RTE_LCORE_FOREACH_WORKER(lcore_id) &#123;</span><br><span class="line">		<span class="comment">/* Simpler equivalent. 8&lt; */</span></span><br><span class="line">		rte_eal_remote_launch(lcore_hello, <span class="literal">NULL</span>, lcore_id);</span><br><span class="line">		<span class="comment">/* &gt;8 End of simpler equivalent. */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* call it on main lcore too */</span></span><br><span class="line">	lcore_hello(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">/* &gt;8 End of launching the function on each lcore. */</span></span><br><span class="line"></span><br><span class="line">	rte_eal_mp_wait_lcore();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* clean up the EAL */</span></span><br><span class="line">	rte_eal_cleanup();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://doc.dpdk.org" target="_blank" rel="noopener">DPDK 官方文档</a></li>
<li>《深入浅出DPDK》</li>
<li><a href="https://zzqcn.github.io/opensource/dpdk/index.html" target="_blank" rel="noopener">https://zzqcn.github.io/opensource/dpdk/index.html</a></li>
</ul>
]]></content>
      <tags>
        <tag>DPDK</tag>
      </tags>
  </entry>
  <entry>
    <title>Canny边缘检测算法（C++实现）</title>
    <url>/2019/12/16/Canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%EF%BC%88C++%E5%AE%9E%E7%8E%B0%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>用高斯滤波器平滑图像；</li>
<li>用一阶偏导有限差分计算梯度幅值和方向；</li>
<li>对梯度幅值应用非极大值抑制；</li>
<li>用双阈值算法检测和连接边缘。</li>
</ol>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20191109012754920.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVU1RFUl9HeQ==,size_16,color_FFFFFF,t_70" style="zoom:50%;" /></p>
<a id="more"></a>
<h1 id="openCV在C-中的应用"><a href="#openCV在C-中的应用" class="headerlink" title="openCV在C++中的应用"></a>openCV在C++中的应用</h1><p>首先，在mac的Xcode上安装配置openCV库，参考一下链接（科学上网访问）<a href="https://medium.com/@jaskaranvirdi/setting-up-opencv-and-c-development-environment-in-xcode-b6027728003" target="_blank" rel="noopener">https://medium.com/@jaskaranvirdi/setting-up-opencv-and-c-development-environment-in-xcode-b6027728003</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv; <span class="comment">// 使用命名空间cv</span></span><br></pre></td></tr></table></figure>
<p>如此可以减少输入，例如 cv :: Mat 就可省略为 Mat</p>
<h3 id="Mat"><a href="#Mat" class="headerlink" title="Mat"></a>Mat</h3><p>Mat的优点是不再需要手动分配其内存，并在不需要它时立即发布它。在执行此操作仍然是可能的情况下，大多数OpenCV功能将自动分配其输出数据。</p>
<p>Mat作为一个类，包含</p>
<ul>
<li>矩阵头（包含矩阵的大小，用于存储的方法，存储在哪个地址的信息等等）</li>
<li>指向包含像素值（取决于所选存储方法的任何维度）</li>
</ul>
<p>从文件中加载图像：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mat img = imread(filename);</span><br></pre></td></tr></table></figure>
<p>如果需要加载灰度图：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mat img = imread(filename, IMREAD_GRAYSCALE);</span><br></pre></td></tr></table></figure>
<p>显示图像：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">namedWindow(<span class="string">"图片"</span>); <span class="comment">//打开名为“图片”的窗口</span></span><br><span class="line">imshow(<span class="string">"图片"</span>, img); <span class="comment">//显示图像</span></span><br></pre></td></tr></table></figure>
<p> openCV加载图像显示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv; <span class="comment">// 使用命名空间cv</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat img = imread(<span class="string">"building.jpg"</span>, IMREAD_GRAYSCALE); <span class="comment">//从文件中加载灰度图像</span></span><br><span class="line">    <span class="comment">//显示图像</span></span><br><span class="line">    namedWindow(<span class="string">"原图"</span>);</span><br><span class="line">    imshow(<span class="string">"原图"</span>, img);</span><br><span class="line"></span><br><span class="line">    waitKey(); <span class="comment">//等待键值输入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何访问图像每一个像素点"><a href="#如何访问图像每一个像素点" class="headerlink" title="如何访问图像每一个像素点"></a>如何访问图像每一个像素点</h2><p>利用指针访问，调用 Mat::ptr(i) 来获取第i行的首地址，通过循环进行访问。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按行遍历所有点(单通道)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nr; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nc; i++) &#123;</span><br><span class="line">        <span class="comment">//每个点为 img.ptr&lt;uchar&gt;(j)[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用高斯滤波器平滑图像"><a href="#用高斯滤波器平滑图像" class="headerlink" title="用高斯滤波器平滑图像"></a>用高斯滤波器平滑图像</h2><h3 id="高斯滤波器（openCV）"><a href="#高斯滤波器（openCV）" class="headerlink" title="高斯滤波器（openCV）"></a>高斯滤波器（openCV）</h3><p>openCV自带的高斯滤波器：<a href="http://docs.opencv.org/master/d4/d86/group__imgproc__filter.html#gaabe8c836e97159a9193fb0b11ac52cf1" target="_blank" rel="noopener">cv :: GaussianBlur</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>void cv::GaussianBlur</th>
<th>(</th>
<th><a href="https://docs.opencv.org/master/dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba" target="_blank" rel="noopener">InputArray</a></th>
<th><em>src</em>,</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td><a href="https://docs.opencv.org/master/dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0" target="_blank" rel="noopener">OutputArray</a></td>
<td><em>dst</em>,</td>
</tr>
<tr>
<td></td>
<td></td>
<td><a href="https://docs.opencv.org/master/dc/d84/group__core__basic.html#ga346f563897249351a34549137c8532a0" target="_blank" rel="noopener">Size</a></td>
<td><em>ksize</em>,</td>
</tr>
<tr>
<td></td>
<td></td>
<td>double</td>
<td><em>sigmaX</em>,</td>
</tr>
<tr>
<td></td>
<td></td>
<td>double</td>
<td><em>sigmaY</em> = <code>0</code>,</td>
</tr>
<tr>
<td></td>
<td></td>
<td>int</td>
<td><em>borderType</em> = <a href="https://docs.opencv.org/master/d2/de8/group__core__array.html#gga209f2f4869e304c82d07739337eae7c5afe14c13a4ea8b8e3b3ef399013dbae01" target="_blank" rel="noopener">BORDER_DEFAULT</a></td>
</tr>
<tr>
<td></td>
<td></td>
<td>)</td>
</tr>
</tbody>
</table>
</div>
<h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <opencv2/imgproc.hpp></h1><p>使用高斯滤镜模糊图像。</p>
<p>该函数将源图像与指定的高斯内核进行卷积。支持就地过滤。</p>
<h4 id="参量"><a href="#参量" class="headerlink" title="参量"></a>参量</h4><div class="table-container">
<table>
<thead>
<tr>
<th><strong>src</strong></th>
<th>输入图像；图像可以具有任意数量的通道，这些通道可以独立处理，但深度应为CV_8U，CV_16U，CV_16S，CV_32F或CV_64F。</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>dst</strong></td>
<td>输出与src大小和类型相同的图像。</td>
</tr>
<tr>
<td><strong>size</strong></td>
<td>高斯核大小。ksize.width和ksize.height可以不同，但它们都必须为正数和奇数。或者，它们可以为零，然后根据sigma计算得出。</td>
</tr>
<tr>
<td><strong>sigmaX</strong></td>
<td>X方向上的高斯核标准偏差。</td>
</tr>
<tr>
<td><strong>sigmaY</strong></td>
<td>Y方向的高斯核标准差；如果sigmaY为零，则将其设置为等于sigmaX；如果两个sigmas为零，则分别从ksize.width和ksize.height计算得出（有关详细信息，请参见<a href="https://docs.opencv.org/master/d4/d86/group__imgproc__filter.html#gac05a120c1ae92a6060dd0db190a61afa" target="_blank" rel="noopener">getGaussianKernel</a>）；为了完全控制结果，而不管将来可能对所有这些语义进行的修改，建议指定所有ksize，sigmaX和sigmaY。</td>
</tr>
<tr>
<td><strong>borderType</strong></td>
<td>像素外推方法，请参见<a href="https://docs.opencv.org/master/d2/de8/group__core__array.html#ga209f2f4869e304c82d07739337eae7c5" target="_blank" rel="noopener">BorderTypes</a></td>
</tr>
</tbody>
</table>
</div>
<h3 id="高斯滤波器的C-实现"><a href="#高斯滤波器的C-实现" class="headerlink" title="高斯滤波器的C++实现"></a>高斯滤波器的C++实现</h3><ol>
<li>对图像使用一维高斯卷积模版，在一个方向上进行滤波（例如水平方向）；</li>
<li>转置图像；</li>
<li>对转置后的图像使用同一个高斯卷积模版，在同样的方向上进行滤波；</li>
<li>将图像转置回原来的位置，得到二维高斯滤波的图像。</li>
</ol>
<p>一维高斯卷积模版可以由二项式展开的系数来模拟，如3*3模版:     1/4 * [1  2  1]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 高斯滤波器，利用3*3的高斯模版进行高斯卷积</span></span><br><span class="line"><span class="comment"> img 输入原图像</span></span><br><span class="line"><span class="comment"> dst  高斯滤波后的输出图像</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gaussianFilter</span><span class="params">(Mat &amp;img, Mat &amp;dst)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对水平方向进行滤波</span></span><br><span class="line">    Mat dst1 = img.clone();</span><br><span class="line">    gaussianConvolution(img, dst1);</span><br><span class="line">    <span class="comment">//图像矩阵转置</span></span><br><span class="line">    Mat dst2;</span><br><span class="line">    transpose(dst1, dst2);</span><br><span class="line">    <span class="comment">// 对垂直方向进行滤波</span></span><br><span class="line">    Mat dst3 = dst2.clone();</span><br><span class="line">    gaussianConvolution(dst2, dst3);</span><br><span class="line">    <span class="comment">// 再次转置</span></span><br><span class="line">    transpose(dst3, dst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 一维高斯卷积，对每行进行高斯卷积</span></span><br><span class="line"><span class="comment"> img 输入原图像</span></span><br><span class="line"><span class="comment"> dst  一维高斯卷积后的输出图像</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gaussianConvolution</span><span class="params">(Mat &amp;img, Mat &amp;dst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nr = img.rows;</span><br><span class="line">    <span class="keyword">int</span> nc = img.cols;</span><br><span class="line">    <span class="keyword">int</span> templates[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按行遍历除每行边缘点的所有点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nr; j++) &#123;</span><br><span class="line">        uchar* data= img.ptr&lt;uchar&gt;(j); <span class="comment">//提取该行地址</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nc<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">3</span>; n++) &#123;</span><br><span class="line">                sum += data[i<span class="number">-1</span>+n] * templates[n]; <span class="comment">//相称累加</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum /= <span class="number">4</span>;</span><br><span class="line">            dst.ptr&lt;uchar&gt;(j)[i] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>高斯滤波前后的图像：</p>
<p><img src="https://img-blog.csdnimg.cn/20191108122357494.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVU1RFUl9HeQ==,size_16,color_FFFFFF,t_70" alt=""></p>
<p>高斯滤波</p>
<h2 id="用一阶偏导有限差分计算梯度幅值和方向"><a href="#用一阶偏导有限差分计算梯度幅值和方向" class="headerlink" title="用一阶偏导有限差分计算梯度幅值和方向"></a>用一阶偏导有限差分计算梯度幅值和方向</h2><p>用一阶偏导有限差分计算偏导数的两个阵列P与Q</p>
<p><img src="https://private.codecogs.com/gif.latex?P%5Cleft%20%5B%20y%2Cx%20%5Cright%20%5D%20%5Capprox%20%5Cleft%20%28%20S%5Cleft%20%5B%20y%2Cx&plus;1%20%5Cright%20%5D-S%5Cleft%20%5B%20y%2Cx%20%5Cright%20%5D%20&plus;S%5Cleft%20%5B%20y&plus;1%2Cx&plus;1%20%5Cright%20%5D-S%5By&plus;1%2Cx%5D%5Cright%20%29/2" alt="P\left [ y,x \right ] \approx \left ( S\left [ y,x+1 \right ]-S\left [ y,x \right ] +S\left [ y+1,x+1 \right ]-S[y+1,x]\right )/2"></p>
<p><img src="https://private.codecogs.com/gif.latex?Q%5Cleft%20%5B%20y%2Cx%20%5Cright%20%5D%20%5Capprox%20%5Cleft%20%28%20S%5Cleft%20%5B%20y&plus;1%2Cx%20%5Cright%20%5D-S%5Cleft%20%5B%20y%2Cx%20%5Cright%20%5D%20&plus;S%5Cleft%20%5B%20y&plus;1%2Cx&plus;1%20%5Cright%20%5D-S%5By%2Cx&plus;1%5D%5Cright%20%29/2" alt="Q\left [ y,x \right ] \approx \left ( S\left [ y+1,x \right ]-S\left [ y,x \right ] +S\left [ y+1,x+1 \right ]-S[y,x+1]\right )/2"></p>
<p>再由P和Q算出梯度幅值和方向角</p>
<p><img src="https://private.codecogs.com/gif.latex?M%5Cleft%20%5B%20y%2Cx%20%5Cright%20%5D%3D%20%5Csqrt%7BP%5Cleft%20%5B%20y%2Cx%20%5Cright%20%5D%5E%7B2%7D&plus;Q%5Cleft%20%5B%20y%2Cx%20%5Cright%20%5D%5E%7B2%7D%7D" alt="M\left [ y,x \right ]= \sqrt{P\left [ y,x \right ]^{2}+Q\left [ y,x \right ]^{2}}"></p>
<p><img src="https://private.codecogs.com/gif.latex?%5Ctheta%20%5Cleft%20%5B%20y%2Cx%20%5Cright%20%5D%3D%5Carctan%20%5Cleft%20%28%20Q%5Cleft%20%5B%20y%2Cx%20%5Cright%20%5D%20/P%5Cleft%20%5B%20y%2Cx%20%5Cright%20%5D%5Cright%20%29" alt="\theta \left [ y,x \right ]=\arctan \left ( Q\left [ y,x \right ] /P\left [ y,x \right ]\right )"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 用一阶偏导有限差分计算梯度幅值和方向</span></span><br><span class="line"><span class="comment"> img 输入原图像</span></span><br><span class="line"><span class="comment"> gradXY 输出的梯度幅值</span></span><br><span class="line"><span class="comment"> theta 输出的梯度方向</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getGrandient</span> <span class="params">(Mat &amp;img, Mat &amp;gradXY, Mat &amp;theta)</span> </span>&#123;</span><br><span class="line">    gradXY = Mat::zeros(img.<span class="built_in">size</span>(), CV_8U);</span><br><span class="line">    theta = Mat::zeros(img.<span class="built_in">size</span>(), CV_8U);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; img.rows<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; img.cols<span class="number">-1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">double</span> p = (img.ptr&lt;uchar&gt;(j)[i+<span class="number">1</span>] - img.ptr&lt;uchar&gt;(j)[i] + img.ptr&lt;uchar&gt;(j+<span class="number">1</span>)[i+<span class="number">1</span>] - img.ptr&lt;uchar&gt;(j+<span class="number">1</span>)[i])/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">double</span> q = (img.ptr&lt;uchar&gt;(j+<span class="number">1</span>)[i] - img.ptr&lt;uchar&gt;(j)[i] + img.ptr&lt;uchar&gt;(j+<span class="number">1</span>)[i+<span class="number">1</span>] - img.ptr&lt;uchar&gt;(j)[i+<span class="number">1</span>])/<span class="number">2</span>;</span><br><span class="line">            gradXY.ptr&lt;uchar&gt;(j)[i] = <span class="built_in">sqrt</span>(p*p + q*q); <span class="comment">//计算梯度</span></span><br><span class="line">            theta.ptr&lt;uchar&gt;(j)[i] = <span class="built_in">atan</span>(q/p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时输入输出图像为：</p>
<p><img src="https://img-blog.csdnimg.cn/20191108121702859.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVU1RFUl9HeQ==,size_16,color_FFFFFF,t_70" alt=""></p>
<p>二维梯度算法</p>
<p> 可以看出，二维计算梯度只区分出了部分边界，边界损失过大，于是采用三维算法计算梯度((y,x)为a11)。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>a00</th>
<th>a01</th>
<th>a02</th>
</tr>
</thead>
<tbody>
<tr>
<td>a10</td>
<td>a11</td>
<td>a12</td>
</tr>
<tr>
<td>a20</td>
<td>a21</td>
<td>a22</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> gradX = <span class="keyword">double</span>(a02 + <span class="number">2</span> * a12 + a22 - a00 - <span class="number">2</span> * a10 - a20);</span><br><span class="line"><span class="keyword">double</span> gradY = <span class="keyword">double</span>(a00 + <span class="number">2</span> * a01 + a02 - a20 - <span class="number">2</span> * a21 - a22);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 用一阶偏导有限差分计算梯度幅值和方向</span></span><br><span class="line"><span class="comment"> img 输入原图像</span></span><br><span class="line"><span class="comment"> gradXY 输出的梯度幅值</span></span><br><span class="line"><span class="comment"> theta 输出的梯度方向</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getGrandient</span> <span class="params">(Mat &amp;img, Mat &amp;gradXY, Mat &amp;theta)</span> </span>&#123;</span><br><span class="line">    gradXY = Mat::zeros(img.<span class="built_in">size</span>(), CV_8U);</span><br><span class="line">    theta = Mat::zeros(img.<span class="built_in">size</span>(), CV_8U);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; img.rows<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; img.cols<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">double</span> gradY = <span class="keyword">double</span>(img.ptr&lt;uchar&gt;(j<span class="number">-1</span>)[i<span class="number">-1</span>] + <span class="number">2</span> * img.ptr&lt;uchar&gt;(j<span class="number">-1</span>)[i] + img.ptr&lt;uchar&gt;(j<span class="number">-1</span>)[i+<span class="number">1</span>] - img.ptr&lt;uchar&gt;(j+<span class="number">1</span>)[i<span class="number">-1</span>] - <span class="number">2</span> * img.ptr&lt;uchar&gt;(j+<span class="number">1</span>)[i] - img.ptr&lt;uchar&gt;(j+<span class="number">1</span>)[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">double</span> gradX = <span class="keyword">double</span>(img.ptr&lt;uchar&gt;(j<span class="number">-1</span>)[i+<span class="number">1</span>] + <span class="number">2</span> * img.ptr&lt;uchar&gt;(j)[i+<span class="number">1</span>] + img.ptr&lt;uchar&gt;(j+<span class="number">1</span>)[i+<span class="number">1</span>] - img.ptr&lt;uchar&gt;(j<span class="number">-1</span>)[i<span class="number">-1</span>] - <span class="number">2</span> * img.ptr&lt;uchar&gt;(j)[i<span class="number">-1</span>] - img.ptr&lt;uchar&gt;(j+<span class="number">1</span>)[i<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">            gradXY.ptr&lt;uchar&gt;(j)[i] = <span class="built_in">sqrt</span>(gradX*gradX + gradY*gradY); <span class="comment">//计算梯度</span></span><br><span class="line">            theta.ptr&lt;uchar&gt;(j)[i] = <span class="built_in">atan</span>(gradY/gradX); <span class="comment">//计算梯度方向</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三维梯度算法的输入输出图像：</p>
<p><img src="https://img-blog.csdnimg.cn/20191108132415101.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVU1RFUl9HeQ==,size_16,color_FFFFFF,t_70" alt=""></p>
<p>三维梯度算法</p>
<h2 id="对梯度幅值应用非极大值抑制"><a href="#对梯度幅值应用非极大值抑制" class="headerlink" title="对梯度幅值应用非极大值抑制"></a>对梯度幅值应用非极大值抑制</h2><p>仅仅得到全局梯度并不足以确定边缘，保留局部梯度最大的点，而抑制非极大点。将梯度角的变化范围减小到圆周的四个扇区之一；</p>
<ol>
<li><p>四个扇区的标号为0到3，对应3*3领域的四种可能组合方向；</p>
</li>
<li><p>每一个点上领域的中心像素M与沿着梯度线的两个像素比较；</p>
</li>
<li><p>如果M梯度值不比沿梯度线的两个相邻像素梯度值大，则令M=0。    </p>
<p>  由 atan() 得到的角度在 <img src="https://private.codecogs.com/gif.latex?%5Cleft%20%5B%20-%5Cpi%20/2%2C%20%5Cpi%20/2%5Cright%20%5D" alt="\left [ -\pi /2, \pi /2\right ]"> 范围内，将此范围均分为四个等份。</p>
<p><img src="https://img-blog.csdnimg.cn/2019110816014884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVU1RFUl9HeQ==,size_16,color_FFFFFF,t_70" style="zoom:25%;" /> <img src="https://img-blog.csdnimg.cn/20191108160159422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVU1RFUl9HeQ==,size_16,color_FFFFFF,t_70" style="zoom:27%;" /></p>
</li>
</ol>
<pre><code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 局部非极大值抑制</span></span><br><span class="line"><span class="comment"> gradXY 输入的梯度幅值</span></span><br><span class="line"><span class="comment"> theta 输入的梯度方向</span></span><br><span class="line"><span class="comment"> dst 输出的经局部非极大值抑制后的图像</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nonLocalMaxValue</span> <span class="params">(Mat &amp;gradXY, Mat &amp;theta, Mat &amp;dst)</span> </span>&#123;</span><br><span class="line">    dst = gradXY.clone();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; gradXY.rows<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; gradXY.cols<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">double</span> t = <span class="keyword">double</span>(theta.ptr&lt;uchar&gt;(j)[i]);</span><br><span class="line">            <span class="keyword">double</span> g = <span class="keyword">double</span>(dst.ptr&lt;uchar&gt;(j)[i]);</span><br><span class="line">            <span class="keyword">if</span> (g == <span class="number">0.0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">double</span> g0, g1;</span><br><span class="line">            <span class="keyword">if</span> ((t &gt;= -(<span class="number">3</span>*M_PI/<span class="number">8</span>)) &amp;&amp; (t &lt; -(M_PI/<span class="number">8</span>))) &#123;</span><br><span class="line">                g0 = <span class="keyword">double</span>(dst.ptr&lt;uchar&gt;(j<span class="number">-1</span>)[i<span class="number">-1</span>]);</span><br><span class="line">                g1 = <span class="keyword">double</span>(dst.ptr&lt;uchar&gt;(j+<span class="number">1</span>)[i+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((t &gt;= -(M_PI/<span class="number">8</span>)) &amp;&amp; (t &lt; M_PI/<span class="number">8</span>)) &#123;</span><br><span class="line">                g0 = <span class="keyword">double</span>(dst.ptr&lt;uchar&gt;(j)[i<span class="number">-1</span>]);</span><br><span class="line">                g1 = <span class="keyword">double</span>(dst.ptr&lt;uchar&gt;(j)[i+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((t &gt;= M_PI/<span class="number">8</span>) &amp;&amp; (t &lt; <span class="number">3</span>*M_PI/<span class="number">8</span>)) &#123;</span><br><span class="line">                g0 = <span class="keyword">double</span>(dst.ptr&lt;uchar&gt;(j<span class="number">-1</span>)[i+<span class="number">1</span>]);</span><br><span class="line">                g1 = <span class="keyword">double</span>(dst.ptr&lt;uchar&gt;(j+<span class="number">1</span>)[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                g0 = <span class="keyword">double</span>(dst.ptr&lt;uchar&gt;(j<span class="number">-1</span>)[i]);</span><br><span class="line">                g1 = <span class="keyword">double</span>(dst.ptr&lt;uchar&gt;(j+<span class="number">1</span>)[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (g &lt;= g0 || g &lt;= g1) &#123;</span><br><span class="line">                dst.ptr&lt;uchar&gt;(j)[i] = <span class="number">0.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>输入的经梯度计算后的图像和输出的局部非极大值抑制后的图像：</p>
<p><img src="https://img-blog.csdnimg.cn/20191108174023525.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVU1RFUl9HeQ==,size_16,color_FFFFFF,t_70" alt=""></p>
<p>局部非极大值抑制</p>
<h2 id="用双阈值算法检测和连接边缘"><a href="#用双阈值算法检测和连接边缘" class="headerlink" title="用双阈值算法检测和连接边缘"></a>用双阈值算法检测和连接边缘</h2><p>1、Canny算法采用双阈值，高阈值一般是低阈值的两倍，遍历所有像素点：</p>
<p>X &lt; 低阈值 ，像素点置0，被抑制掉；</p>
<p>低阈值 &lt; X &lt;高阈值，像素点为弱边缘点，像素点值先不变；</p>
<p>X &gt; 高阈值，像素点为强边缘点，置255。</p>
<p>2、弱边缘点补充连接强边缘点：</p>
<p>如果弱边缘点的8邻点域存在强边缘点，则将此点置255，用以连接强边缘点；如果不存在强边缘点，则这是一个孤立的弱边缘点，此点置0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 用双阈值算法检测和连接边缘</span></span><br><span class="line"><span class="comment"> low 输入的低阈值</span></span><br><span class="line"><span class="comment"> high 输入的高阈值</span></span><br><span class="line"><span class="comment"> img 输入的原图像</span></span><br><span class="line"><span class="comment"> dst 输出的用双阈值算法检测和连接边缘后的图像</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doubleThreshold</span> <span class="params">(<span class="keyword">double</span> low, <span class="keyword">double</span> high, Mat &amp;img, Mat &amp;dst)</span> </span>&#123;</span><br><span class="line">    dst = img.clone();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 区分出弱边缘点和强边缘点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; img.rows<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; img.cols<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">double</span> x = <span class="keyword">double</span>(dst.ptr&lt;uchar&gt;(j)[i]);</span><br><span class="line">            <span class="comment">// 像素点为强边缘点，置255</span></span><br><span class="line">            <span class="keyword">if</span> (x &gt; high) &#123;</span><br><span class="line">                dst.ptr&lt;uchar&gt;(j)[i] = <span class="number">255</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 像素点置0，被抑制掉</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; low) &#123;</span><br><span class="line">                dst.ptr&lt;uchar&gt;(j)[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 弱边缘点补充连接强边缘点</span></span><br><span class="line">    doubleThresholdLink(dst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 弱边缘点补充连接强边缘点</span></span><br><span class="line"><span class="comment"> img 弱边缘点补充连接强边缘点的输入和输出图像</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doubleThresholdLink</span> <span class="params">(Mat &amp;img)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 循环找到强边缘点，把其领域内的弱边缘点变为强边缘点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; img.rows<span class="number">-2</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; img.cols<span class="number">-2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果该点是强边缘点</span></span><br><span class="line">            <span class="keyword">if</span> (img.ptr&lt;uchar&gt;(j)[i] == <span class="number">255</span>) &#123;</span><br><span class="line">                <span class="comment">// 遍历该强边缘点领域</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">-1</span>; m &lt; <span class="number">1</span>; m++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">-1</span>; n &lt; <span class="number">1</span>; n++) &#123;</span><br><span class="line">                        <span class="comment">// 该点为弱边缘点（不是强边缘点，也不是被抑制的0点）</span></span><br><span class="line">                        <span class="keyword">if</span> (img.ptr&lt;uchar&gt;(j+m)[i+n] != <span class="number">0</span> &amp;&amp; img.ptr&lt;uchar&gt;(j+m)[i+n] != <span class="number">255</span>) &#123;</span><br><span class="line">                            img.ptr&lt;uchar&gt;(j+m)[i+n] = <span class="number">255</span>; <span class="comment">//该弱边缘点补充为强边缘点</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; img.rows<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; img.cols<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果该点依旧是弱边缘点，及此点是孤立边缘点</span></span><br><span class="line">            <span class="keyword">if</span> (img.ptr&lt;uchar&gt;(j)[i] != <span class="number">255</span> &amp;&amp; img.ptr&lt;uchar&gt;(j)[i] != <span class="number">255</span>) &#123;</span><br><span class="line">                img.ptr&lt;uchar&gt;(j)[i] = <span class="number">0</span>; <span class="comment">//该孤立弱边缘点抑制</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双阈值算法前后的输入输出图像 ：</p>
<p><img src="https://img-blog.csdnimg.cn/20191109012221209.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVU1RFUl9HeQ==,size_16,color_FFFFFF,t_70" alt=""></p>
<p>双阈值算法</p>
<p>Canny边缘检测代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _USE_MATH_DEFINES</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;<span class="comment">// 使用命名空间cv</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 将两个图像拼接，以便在同一个窗口显示</span></span><br><span class="line"><span class="comment"> dst 输出的拼接后的图像</span></span><br><span class="line"><span class="comment"> src1 拼接的第一幅图</span></span><br><span class="line"><span class="comment"> src2 拼接的第二幅图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeImg</span><span class="params">(Mat &amp; dst,Mat &amp;src1,Mat &amp;src2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = src1.rows;</span><br><span class="line">    <span class="keyword">int</span> cols = src1.cols+<span class="number">5</span>+src2.cols;</span><br><span class="line">    CV_Assert(src1.type () == src2.type ());</span><br><span class="line">    dst.create (rows,cols,src1.type ());</span><br><span class="line">    src1.copyTo (dst(Rect(<span class="number">0</span>,<span class="number">0</span>,src1.cols,src1.rows)));</span><br><span class="line">    src2.copyTo (dst(Rect(src1.cols+<span class="number">5</span>,<span class="number">0</span>,src2.cols,src2.rows)));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 一维高斯卷积，对每行进行高斯卷积</span></span><br><span class="line"><span class="comment"> img 输入原图像</span></span><br><span class="line"><span class="comment"> dst  一维高斯卷积后的输出图像</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gaussianConvolution</span><span class="params">(Mat &amp;img, Mat &amp;dst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nr = img.rows;</span><br><span class="line">    <span class="keyword">int</span> nc = img.cols;</span><br><span class="line">    <span class="keyword">int</span> templates[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按行遍历除每行边缘点的所有点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nr; j++) &#123;</span><br><span class="line">        uchar* data= img.ptr&lt;uchar&gt;(j); <span class="comment">//提取该行地址</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nc<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">3</span>; n++) &#123;</span><br><span class="line">                sum += data[i<span class="number">-1</span>+n] * templates[n]; <span class="comment">//相称累加</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum /= <span class="number">4</span>;</span><br><span class="line">            dst.ptr&lt;uchar&gt;(j)[i] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 高斯滤波器，利用3*3的高斯模版进行高斯卷积</span></span><br><span class="line"><span class="comment"> img 输入原图像</span></span><br><span class="line"><span class="comment"> dst  高斯滤波后的输出图像</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gaussianFilter</span><span class="params">(Mat &amp;img, Mat &amp;dst)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对水平方向进行滤波</span></span><br><span class="line">    Mat dst1 = img.clone();</span><br><span class="line">    gaussianConvolution(img, dst1);</span><br><span class="line">    <span class="comment">//图像矩阵转置</span></span><br><span class="line">    Mat dst2;</span><br><span class="line">    transpose(dst1, dst2);</span><br><span class="line">    <span class="comment">// 对垂直方向进行滤波</span></span><br><span class="line">    Mat dst3 = dst2.clone();</span><br><span class="line">    gaussianConvolution(dst2, dst3);</span><br><span class="line">    <span class="comment">// 再次转置</span></span><br><span class="line">    transpose(dst3, dst);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 用一阶偏导有限差分计算梯度幅值和方向</span></span><br><span class="line"><span class="comment"> img 输入原图像</span></span><br><span class="line"><span class="comment"> gradXY 输出的梯度幅值</span></span><br><span class="line"><span class="comment"> theta 输出的梯度方向</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getGrandient</span> <span class="params">(Mat &amp;img, Mat &amp;gradXY, Mat &amp;theta)</span> </span>&#123;</span><br><span class="line">    gradXY = Mat::zeros(img.<span class="built_in">size</span>(), CV_8U);</span><br><span class="line">    theta = Mat::zeros(img.<span class="built_in">size</span>(), CV_8U);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; img.rows<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; img.cols<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">double</span> gradY = <span class="keyword">double</span>(img.ptr&lt;uchar&gt;(j<span class="number">-1</span>)[i<span class="number">-1</span>] + <span class="number">2</span> * img.ptr&lt;uchar&gt;(j<span class="number">-1</span>)[i] + img.ptr&lt;uchar&gt;(j<span class="number">-1</span>)[i+<span class="number">1</span>] - img.ptr&lt;uchar&gt;(j+<span class="number">1</span>)[i<span class="number">-1</span>] - <span class="number">2</span> * img.ptr&lt;uchar&gt;(j+<span class="number">1</span>)[i] - img.ptr&lt;uchar&gt;(j+<span class="number">1</span>)[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">double</span> gradX = <span class="keyword">double</span>(img.ptr&lt;uchar&gt;(j<span class="number">-1</span>)[i+<span class="number">1</span>] + <span class="number">2</span> * img.ptr&lt;uchar&gt;(j)[i+<span class="number">1</span>] + img.ptr&lt;uchar&gt;(j+<span class="number">1</span>)[i+<span class="number">1</span>] - img.ptr&lt;uchar&gt;(j<span class="number">-1</span>)[i<span class="number">-1</span>] - <span class="number">2</span> * img.ptr&lt;uchar&gt;(j)[i<span class="number">-1</span>] - img.ptr&lt;uchar&gt;(j+<span class="number">1</span>)[i<span class="number">-1</span>]);</span><br><span class="line"> </span><br><span class="line">            gradXY.ptr&lt;uchar&gt;(j)[i] = <span class="built_in">sqrt</span>(gradX*gradX + gradY*gradY); <span class="comment">//计算梯度</span></span><br><span class="line">            theta.ptr&lt;uchar&gt;(j)[i] = <span class="built_in">atan</span>(gradY/gradX); <span class="comment">//计算梯度方向</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 局部非极大值抑制</span></span><br><span class="line"><span class="comment"> gradXY 输入的梯度幅值</span></span><br><span class="line"><span class="comment"> theta 输入的梯度方向</span></span><br><span class="line"><span class="comment"> dst 输出的经局部非极大值抑制后的图像</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nonLocalMaxValue</span> <span class="params">(Mat &amp;gradXY, Mat &amp;theta, Mat &amp;dst)</span> </span>&#123;</span><br><span class="line">    dst = gradXY.clone();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; gradXY.rows<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; gradXY.cols<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">double</span> t = <span class="keyword">double</span>(theta.ptr&lt;uchar&gt;(j)[i]);</span><br><span class="line">            <span class="keyword">double</span> g = <span class="keyword">double</span>(dst.ptr&lt;uchar&gt;(j)[i]);</span><br><span class="line">            <span class="keyword">if</span> (g == <span class="number">0.0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">double</span> g0, g1;</span><br><span class="line">            <span class="keyword">if</span> ((t &gt;= -(<span class="number">3</span>*M_PI/<span class="number">8</span>)) &amp;&amp; (t &lt; -(M_PI/<span class="number">8</span>))) &#123;</span><br><span class="line">                g0 = <span class="keyword">double</span>(dst.ptr&lt;uchar&gt;(j<span class="number">-1</span>)[i<span class="number">-1</span>]);</span><br><span class="line">                g1 = <span class="keyword">double</span>(dst.ptr&lt;uchar&gt;(j+<span class="number">1</span>)[i+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((t &gt;= -(M_PI/<span class="number">8</span>)) &amp;&amp; (t &lt; M_PI/<span class="number">8</span>)) &#123;</span><br><span class="line">                g0 = <span class="keyword">double</span>(dst.ptr&lt;uchar&gt;(j)[i<span class="number">-1</span>]);</span><br><span class="line">                g1 = <span class="keyword">double</span>(dst.ptr&lt;uchar&gt;(j)[i+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((t &gt;= M_PI/<span class="number">8</span>) &amp;&amp; (t &lt; <span class="number">3</span>*M_PI/<span class="number">8</span>)) &#123;</span><br><span class="line">                g0 = <span class="keyword">double</span>(dst.ptr&lt;uchar&gt;(j<span class="number">-1</span>)[i+<span class="number">1</span>]);</span><br><span class="line">                g1 = <span class="keyword">double</span>(dst.ptr&lt;uchar&gt;(j+<span class="number">1</span>)[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                g0 = <span class="keyword">double</span>(dst.ptr&lt;uchar&gt;(j<span class="number">-1</span>)[i]);</span><br><span class="line">                g1 = <span class="keyword">double</span>(dst.ptr&lt;uchar&gt;(j+<span class="number">1</span>)[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (g &lt;= g0 || g &lt;= g1) &#123;</span><br><span class="line">                dst.ptr&lt;uchar&gt;(j)[i] = <span class="number">0.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 弱边缘点补充连接强边缘点</span></span><br><span class="line"><span class="comment"> img 弱边缘点补充连接强边缘点的输入和输出图像</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doubleThresholdLink</span> <span class="params">(Mat &amp;img)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 循环找到强边缘点，把其领域内的弱边缘点变为强边缘点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; img.rows<span class="number">-2</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; img.cols<span class="number">-2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果该点是强边缘点</span></span><br><span class="line">            <span class="keyword">if</span> (img.ptr&lt;uchar&gt;(j)[i] == <span class="number">255</span>) &#123;</span><br><span class="line">                <span class="comment">// 遍历该强边缘点领域</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">-1</span>; m &lt; <span class="number">1</span>; m++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">-1</span>; n &lt; <span class="number">1</span>; n++) &#123;</span><br><span class="line">                        <span class="comment">// 该点为弱边缘点（不是强边缘点，也不是被抑制的0点）</span></span><br><span class="line">                        <span class="keyword">if</span> (img.ptr&lt;uchar&gt;(j+m)[i+n] != <span class="number">0</span> &amp;&amp; img.ptr&lt;uchar&gt;(j+m)[i+n] != <span class="number">255</span>) &#123;</span><br><span class="line">                            img.ptr&lt;uchar&gt;(j+m)[i+n] = <span class="number">255</span>; <span class="comment">//该弱边缘点补充为强边缘点</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; img.rows<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; img.cols<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果该点依旧是弱边缘点，及此点是孤立边缘点</span></span><br><span class="line">            <span class="keyword">if</span> (img.ptr&lt;uchar&gt;(j)[i] != <span class="number">255</span> &amp;&amp; img.ptr&lt;uchar&gt;(j)[i] != <span class="number">255</span>) &#123;</span><br><span class="line">                img.ptr&lt;uchar&gt;(j)[i] = <span class="number">0</span>; <span class="comment">//该孤立弱边缘点抑制</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 用双阈值算法检测和连接边缘</span></span><br><span class="line"><span class="comment"> low 输入的低阈值</span></span><br><span class="line"><span class="comment"> high 输入的高阈值</span></span><br><span class="line"><span class="comment"> img 输入的原图像</span></span><br><span class="line"><span class="comment"> dst 输出的用双阈值算法检测和连接边缘后的图像</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doubleThreshold</span> <span class="params">(<span class="keyword">double</span> low, <span class="keyword">double</span> high, Mat &amp;img, Mat &amp;dst)</span> </span>&#123;</span><br><span class="line">    dst = img.clone();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 区分出弱边缘点和强边缘点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; img.rows<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; img.cols<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">double</span> x = <span class="keyword">double</span>(dst.ptr&lt;uchar&gt;(j)[i]);</span><br><span class="line">            <span class="comment">// 像素点为强边缘点，置255</span></span><br><span class="line">            <span class="keyword">if</span> (x &gt; high) &#123;</span><br><span class="line">                dst.ptr&lt;uchar&gt;(j)[i] = <span class="number">255</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 像素点置0，被抑制掉</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; low) &#123;</span><br><span class="line">                dst.ptr&lt;uchar&gt;(j)[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 弱边缘点补充连接强边缘点</span></span><br><span class="line">    doubleThresholdLink(dst);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Mat img = imread(<span class="string">"woman.jpg"</span>, IMREAD_GRAYSCALE); <span class="comment">//从文件中加载灰度图像</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 读取图片失败，则停止</span></span><br><span class="line">    <span class="keyword">if</span> (img.empty()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"读取图像文件失败"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 高斯滤波</span></span><br><span class="line">    Mat gauss_img;</span><br><span class="line">    gaussianFilter(img, gauss_img); <span class="comment">//高斯滤波器</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用一阶偏导有限差分计算梯度幅值和方向</span></span><br><span class="line">    Mat gradXY, theta;</span><br><span class="line">    getGrandient(gauss_img, gradXY, theta);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 局部非极大值抑制</span></span><br><span class="line">    Mat local_img;</span><br><span class="line">    nonLocalMaxValue(gradXY, theta, local_img);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用双阈值算法检测和连接边缘</span></span><br><span class="line">    Mat dst;</span><br><span class="line">    doubleThreshold(<span class="number">40</span>, <span class="number">80</span>, local_img, dst);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 图像显示</span></span><br><span class="line">    Mat outImg;</span><br><span class="line">    mergeImg (outImg,img,dst); <span class="comment">//图像拼接</span></span><br><span class="line">    namedWindow(<span class="string">"img"</span>);</span><br><span class="line">    imshow(<span class="string">"img"</span>,outImg);<span class="comment">// 图像显示</span></span><br><span class="line">    imwrite(<span class="string">"canny算法.jpg"</span>, outImg);</span><br><span class="line"> </span><br><span class="line">    waitKey(); <span class="comment">//等待键值输入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Canny边缘检测的前后图像</p>
<p><img src="https://img-blog.csdnimg.cn/20191109012754920.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hVU1RFUl9HeQ==,size_16,color_FFFFFF,t_70" alt=""></p>
<p>Canny边缘检测算法</p>
<hr>
<p>参考资源：</p>
<p>【1】<a href="https://medium.com/@jaskaranvirdi/setting-up-opencv-and-c-development-environment-in-xcode-b6027728003" target="_blank" rel="noopener">Setting up OpenCV and C++ development environment in Xcode for Computer Vision projects</a></p>
<p>【2】<a href="https://docs.opencv.org/master/d9/df8/tutorial_root.html" target="_blank" rel="noopener">OpenCV Tutorials</a></p>
<p>【3】<a href="https://www.w3cschool.cn/opencv/opencv-2gnx28u3.html" target="_blank" rel="noopener">OpenCV教程</a></p>
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Canny</tag>
        <tag>OpenCV</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/2024/09/19/Docker/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>基于 Go 的开源应用容器引擎 Docker</p>
<a id="more"></a>
<h1 id="快速了解-Docker"><a href="#快速了解-Docker" class="headerlink" title="快速了解 Docker"></a>快速了解 Docker</h1><p>快速了解 docker 的小视频</p>
<p>【docker是什么？和kubernetes(k8s)是什么关系？-哔哩哔哩】 </p>
<iframe src="//player.bilibili.com/player.html?isOutside=true&aid=1102796777&bvid=BV1aA4m1w7Ew&cid=1501859959&p=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>

<ul>
<li>Docker 是一款能将程序和环境一起打包并运行的工具软件。Docker 作为中间层，使得应用和机器基础架构分离，从而实现不同架构下的快速交付部署。</li>
<li>程序和环境打包构建成一个容器镜像文件，根据 Dockerfile 构建出容器镜像，Dockerfile 中设置包括指定环境的基础镜像（如 ubuntu/centos、python/go 等等）以及后续需执行的命令（比如安装依赖、运行服务等）。</li>
<li>部署环境部署容器镜像，就会在 Linux 上以一个进程的形式运行该 docker 容器，利用操作系统的用户空间构建出应用所需的环境，运行相应服务。</li>
<li>Docker Registy：相当于 docker 镜像的代码仓，也就是镜像仓，可以将 docker 镜像推到 Registy，部署环境再从 Registy 拉取镜像。</li>
<li>Docker Compose：一整套服务经常包含多个 docker 镜像部署到单节点，这时候就可以使用 Docker Compose 来部署，通过 yaml 文件呢规定各个 docker 镜像间的部署顺序与其他部署配置信息。</li>
<li>Docker Swarm：解决一整套服务在多个节点间的部署问题，如迁移、扩缩容。</li>
<li>k8s：与 Docker Swarm 类似，也是解决一整套服务在多个节点间的部署问题，如迁移、扩缩容。</li>
</ul>
<h1 id="虚拟化过程"><a href="#虚拟化过程" class="headerlink" title="虚拟化过程"></a>虚拟化过程</h1><h2 id="物理机"><a href="#物理机" class="headerlink" title="物理机"></a>物理机</h2><p>物理机存在的痛点：</p>
<ul>
<li>各个应用会共享依赖库，所以有可能存在不同应用依赖有冲突的问题，比如需要同一个依赖的不同版本</li>
<li>低使用率，可能仅有几个应用在运行，却得占用一整台物理机</li>
<li>爆炸半径大，比如改变一个应用的依赖，可以会导致另一应用变得不可用</li>
<li>开关机慢</li>
<li>创建和搭建物理机慢</li>
</ul>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20241013193557973.png" alt="image-20241013193557973" style="zoom:40%;" /></p>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>物理机上的 Hypervisor 会从物理机分离出独立的资源池，在这个资源池中生成虚拟化硬件以及与物理机相同的上方结构。</p>
<p>Hypervisor 分为两类：</p>
<ul>
<li>Type 1：不依赖物理机上的 OS，比如 VMware、Hyper-V</li>
<li>Type 2：依赖物理机上的 OS，比如 Virtual Box</li>
</ul>
<p>虚拟机一定程度上缓解了物理机的问题。</p>
<ul>
<li>应用运行在不同的虚拟机上，实现相互隔离，解决了依赖冲突问题</li>
<li>可以根据需要分配相应的规格，提高使用率</li>
<li>减小了爆炸半径</li>
<li>开关机变为分钟级</li>
<li>最大的好处：可以快速构建虚拟机</li>
</ul>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20241014005509938.png" alt="image-20241014005509938" style="zoom:40%;" /></p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>容器的载体可以是物理机也可以是虚拟机，和虚拟机的 Hypervisor 相对，容器通过 Container Runtime 控制。</p>
<p>容器与虚拟机的最大不同点：</p>
<ul>
<li>虚拟机复制了一份 Linux 内核</li>
<li>容器并不存在内核，而是与载体的 OS 共用一个内核</li>
</ul>
<p>容器的好处：</p>
<ul>
<li>无依赖冲突问题</li>
<li>进一步提高了资源利用率。虚拟机还需要构造一套 OS，而容器可以直接依赖于宿主机的 OS</li>
<li>进一步减小了爆炸半径。每个容器所占的资源相对更少了，爆炸半径也就相对减小。不过其实隔离性是不如虚拟机的</li>
<li>开关容器时间短（秒级）</li>
<li>极快速部署</li>
</ul>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20241014015955548.png" alt="image-20241014015955548" style="zoom:40%;" /></p>
<h2 id="日常结构"><a href="#日常结构" class="headerlink" title="日常结构"></a>日常结构</h2><p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20241015021636441.png" alt="image-20241015021636441" style="zoom:60%;" /></p>
<h1 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h1><p>Docker 采用 client-server 架构，由 Docker Client 发出指令，命令 Docker daemon 构建、运行、分发 Docker containers。Docker Client 和 Docker daemon 可以运行在同一个节点，也可以用 Docker Client 控制远程的 Docker daemon。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/docker-architecture.webp" alt=""></p>
<h2 id="镜像-Image"><a href="#镜像-Image" class="headerlink" title="镜像 Image"></a>镜像 Image</h2><p>容器镜像是一个由程序和环境构建出的标准包，包括了用来运行容器所需的文件、二进制文件、库以及配置。</p>
<h2 id="容器-Container"><a href="#容器-Container" class="headerlink" title="容器 Container"></a>容器 Container</h2><h1 id="Docker-从构建到部署"><a href="#Docker-从构建到部署" class="headerlink" title="Docker 从构建到部署"></a>Docker 从构建到部署</h1><h2 id="Docker-镜像构建"><a href="#Docker-镜像构建" class="headerlink" title="Docker 镜像构建"></a>Docker 镜像构建</h2><h2 id="Docker-镜像仓"><a href="#Docker-镜像仓" class="headerlink" title="Docker 镜像仓"></a>Docker 镜像仓</h2><h2 id="Docker-容器部署"><a href="#Docker-容器部署" class="headerlink" title="Docker 容器部署"></a>Docker 容器部署</h2><h1 id="Docker-命令"><a href="#Docker-命令" class="headerlink" title="Docker 命令"></a>Docker 命令</h1><p>查看正在运行的容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<p>查看所有容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>
<p>开启容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker start &lt;CONTAINER ID&gt;</span><br></pre></td></tr></table></figure>
<p>停止容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop &lt;CONTAINER ID&gt;</span><br></pre></td></tr></table></figure>
<p>执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it &lt;CONTAINER ID&gt; &lt;CLI&gt;</span><br></pre></td></tr></table></figure>
<h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><h1 id="Docker-Swarm-与-k8s"><a href="#Docker-Swarm-与-k8s" class="headerlink" title="Docker Swarm 与 k8s"></a>Docker Swarm 与 k8s</h1><h1 id="Ubuntu-中安装-Docker-Engine"><a href="#Ubuntu-中安装-Docker-Engine" class="headerlink" title="Ubuntu 中安装 Docker Engine"></a>Ubuntu 中安装 Docker Engine</h1><p><a href="https://docs.docker.com/engine/install/ubuntu/" target="_blank" rel="noopener">https://docs.docker.com/engine/install/ubuntu/</a></p>
<ol>
<li><p>卸载老版本</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> pkg <span class="keyword">in</span> docker.io docker<span class="literal">-doc</span> docker<span class="literal">-compose</span> docker<span class="literal">-compose</span><span class="literal">-v2</span> podman<span class="literal">-docker</span> containerd runc; <span class="keyword">do</span> sudo apt<span class="literal">-get</span> remove <span class="variable">$pkg</span>; done</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新 Ubuntu 源列表</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">apt<span class="literal">-get</span> update</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 docker 依赖包</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">apt<span class="literal">-get</span> install ca<span class="literal">-certificates</span> curl</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加 docker 官方 GPG 密钥</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">install <span class="literal">-m</span> <span class="number">0755</span> <span class="literal">-d</span> /etc/apt/keyrings</span><br><span class="line">curl <span class="literal">-fsSL</span> https://download.docker.com/linux/ubuntu/gpg <span class="literal">-o</span> /etc/apt/keyrings/docker.asc</span><br><span class="line">chmod a+r /etc/apt/keyrings/docker.asc</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加 docker 官方库</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">echo \</span><br><span class="line">  <span class="string">"deb [arch=<span class="variable">$</span>(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="variable">$</span>(. /etc/os-release &amp;&amp; echo "</span><span class="variable">$VERSION_CODENAME</span><span class="string">") stable"</span> | \</span><br><span class="line">  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新 Ubuntu 源列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看 docker 服务运行状态</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.docker.com" target="_blank" rel="noopener">docker 官网</a></li>
<li><a href="https://www.youtube.com/watch?v=RqTEHSBrYFw" target="_blank" rel="noopener">https://www.youtube.com/watch?v=RqTEHSBrYFw</a></li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB调试工具</title>
    <url>/2023/04/17/GDB%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>GDB调试器的</p>
<a id="more"></a>
<p>GDB可以完成以下功能：</p>
<ul>
<li>开始并设置参数</li>
<li>打断点</li>
<li></li>
</ul>
<p>GDB支持多种语言，常见的比如 C、C++、Go</p>
<h1 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h1><ul>
<li><p>安装GDB</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install gdb</span><br></pre></td></tr></table></figure>
<p>  如brew下载缓慢，也可以在官网下载</p>
</li>
</ul>
<ul>
<li>查看GDB版本</li>
</ul>
<h1 id="QuickStart"><a href="#QuickStart" class="headerlink" title="QuickStart"></a>QuickStart</h1>]]></content>
      <tags>
        <tag>GDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Go学习路线</title>
    <url>/2024/09/04/Go%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Golang 学习路线梳理</p>
<a id="more"></a>
<p><img src="https://github.com/darius-khll/golang-developer-roadmap/blob/master/i18n/zh-CN/golang-developer-roadmap-zh-CN.png?raw=true" alt=""></p>
<ol>
<li>Go 基础<ul>
<li><a href="https://gy23333.github.io/2023/03/15/Go基本语法/">Go 基本语法</a></li>
<li><a href="https://gy23333.github.io/2024/09/05/Go并发编程/">Go 并发编程</a></li>
</ul>
</li>
<li>SQL</li>
<li>数据结构与算法</li>
<li>网络编程</li>
<li>命令行工具<ul>
<li>cobra</li>
</ul>
</li>
<li>Web 框架<ul>
<li>Gin</li>
</ul>
</li>
<li>数据库<ul>
<li>PostgreSQL</li>
<li>MongoDB</li>
<li>Redis</li>
<li>Mysql</li>
<li>kafka</li>
</ul>
</li>
<li>日志<ul>
<li>zap</li>
<li>logrus</li>
</ul>
</li>
<li>微服务<ul>
<li>gRPC</li>
<li>goKit</li>
</ul>
</li>
<li>云原生<ul>
<li>gitlab</li>
<li><a href="https://gy23333.github.io/2024/09/19/Docker/">Docker</a></li>
<li>Kubernetes</li>
<li>Promethues</li>
</ul>
</li>
<li>其他<ul>
<li>Opentelemetry</li>
<li>Promethues</li>
</ul>
</li>
</ol>
<p><a href="https://github.com/talkgo/read" target="_blank" rel="noopener">https://github.com/talkgo/read</a></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>学习路线</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基本语法</title>
    <url>/2023/03/15/Go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>GoLang基本语法</p>
<a id="more"></a>
<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><ul>
<li><p><a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">go下载地址</a></p>
</li>
<li><p>配置环境变量，命令行输入</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;go&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时可在命令行中使用<code>go</code>命令</p>
<p>  新建一个<code>test.go</code>文件</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">"Hello, World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在命令行中输入，即可运行</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go run test.go</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h2 id="go的基本结构和语法"><a href="#go的基本结构和语法" class="headerlink" title="go的基本结构和语法"></a>go的基本结构和语法</h2><p>一个简单的go程序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义包</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Print(<span class="string">"Hello, World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>包声明</p>
<p>  必须在非注释的第一行进行包声明</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br></pre></td></tr></table></figure>
<p>  每个Go应用程序都必须包含一个<code>main</code>包</p>
</li>
<li><p>引入包</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>行分隔符</p>
<p>  go中每一行代表一个语句结束，结尾不需要加像C那样加<code>;</code></p>
</li>
</ul>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="Printf-格式化字符串"><a href="#Printf-格式化字符串" class="headerlink" title="Printf 格式化字符串"></a>Printf 格式化字符串</h3><p>使用<code>fmt.Printf</code>来格式化输出字符串</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(格式化样式, 参数列表…)</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>格  式</th>
<th>描  述</th>
</tr>
</thead>
<tbody>
<tr>
<td>%s</td>
<td>字符串</td>
</tr>
<tr>
<td>%f</td>
<td>浮点数</td>
</tr>
<tr>
<td>%d</td>
<td>十进制整型</td>
</tr>
<tr>
<td>%b</td>
<td>二进制整型</td>
</tr>
<tr>
<td>%o</td>
<td>八进制整型</td>
</tr>
<tr>
<td>%x</td>
<td>十六进制整型</td>
</tr>
<tr>
<td>%X</td>
<td>十六进制整型，字母大写方式显示</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">name := <span class="string">"John"</span></span><br><span class="line">age := <span class="number">23</span></span><br><span class="line">fmt.Printf(<span class="string">"%s is %d"</span>, name, age)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出:</p>
<p>John is 23</p>
</blockquote>
<h1 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量名由字母、数字、下划线组成，其中首个字符不能为数字</p>
<p>使用 <code>var</code> 来声明变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier <span class="keyword">type</span></span><br></pre></td></tr></table></figure>
<p>可以一次声明多个变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier1, identifier2 <span class="keyword">type</span></span><br></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">"Hello"</span></span><br><span class="line"><span class="keyword">var</span> num1, num2 <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>如果没有初始化，则变量默认为零值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> f <span class="keyword">float64</span></span><br><span class="line">	<span class="keyword">var</span> b <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">	fmt.Printf(<span class="string">"%v %v %v %q\n"</span>, i, f, b, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出：</p>
<p>0 0 false “”</p>
</blockquote>
<p>可以根据值自行判断变量类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str, num = <span class="string">"Hello"</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可省略<code>var</code>，使用关键字<code>:=</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str, num := <span class="string">"Hello"</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量不会被修改，数据类型只可以是布尔型、数字型和字符串型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> identifier [<span class="keyword">type</span>] = value</span><br></pre></td></tr></table></figure>
<p>因为可以通过<code>value</code>来判断数据类型，所有<code>type</code>可省略</p>
<ul>
<li><p>显式表示</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str <span class="keyword">string</span> = <span class="string">"abc"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>隐式表示</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"abc"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以一次声明多个常量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str, num = <span class="string">"Hello"</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>或者用枚举：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	str  = <span class="string">"Hello"</span></span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line">	b</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这里，<code>a</code>和<code>b</code>都是<code>1</code>，<code>b</code>会继承<code>a</code>的<code>=1</code></p>
<h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><p><code>iota</code>是一个可以被编译器修改的特殊常量，代表了位于<code>const</code>的第几行，如第 n 行 <code>=iota</code> 则为 <code>n</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	a = <span class="literal">iota</span>	  <span class="comment">// 0</span></span><br><span class="line">	b          <span class="comment">// 1</span></span><br><span class="line">	c = <span class="string">"hello"</span></span><br><span class="line">	d          <span class="comment">// "hello"</span></span><br><span class="line">	e = <span class="literal">iota</span>	  <span class="comment">// 4</span></span><br><span class="line">	f          <span class="comment">// 5</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>数组，是相同元素类型的集合。</p>
<p>数组由两个维度描述：</p>
<ul>
<li>元素类型</li>
<li>最多存储的元素个数</li>
</ul>
<p>只有这两个条件都相同的数组才是同一类型</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h3 id="访问和赋值"><a href="#访问和赋值" class="headerlink" title="访问和赋值"></a>访问和赋值</h3><p>声明数组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [SIZE] variable_type</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nums [<span class="number">5</span>] <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<p>初始化数组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nums = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nums := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>
<p>如果数组长度不确定，可以用<code>...</code>代替，编译器会根据元素个数自行推断数组的长度</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nums := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过下标，只初始化特定的几个</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化 nums[1] = 2.1 , nums[3] = 1.6</span></span><br><span class="line">nums := [<span class="number">5</span>]<span class="keyword">float64</span>&#123;<span class="number">1</span>: <span class="number">2.1</span>, <span class="number">3</span>: <span class="number">1.6</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>以二维数组为例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayName [ x ][ y ] variable_type</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<p>每行的结尾都要加<code>,</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nums := [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">	&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">	&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nums := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">row1 := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">row2 := []<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">nums = <span class="built_in">append</span>(nums, row1)</span><br><span class="line">nums = <span class="built_in">append</span>(nums, row2)</span><br></pre></td></tr></table></figure>
<h3 id="数组作为函数参数"><a href="#数组作为函数参数" class="headerlink" title="数组作为函数参数"></a>数组作为函数参数</h3><p>一维数组做参数：</p>
<ul>
<li><p>设定数组大小</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(nums [10]<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>未设定数组大小</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(nums []<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>go中指针的规则与C类似</p>
<p><code>&amp;</code>用来取地址，<code>*</code>用来取内容</p>
<p>定义指针：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> var_name *<span class="keyword">var</span>-<span class="keyword">type</span></span><br></pre></td></tr></table></figure>
<h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><p>当一个指针被定义后没有分配到任何变量时，即为一个空指针 <code>nil</code></p>
<h3 id="指针数组-amp-数组指针"><a href="#指针数组-amp-数组指针" class="headerlink" title="指针数组 &amp; 数组指针"></a>指针数组 &amp; 数组指针</h3><div class="table-container">
<table>
<thead>
<tr>
<th>指针数组</th>
<th>数组指针</th>
</tr>
</thead>
<tbody>
<tr>
<td>是一个数组</td>
<td>是一个指针</td>
</tr>
<tr>
<td>每个元素都是一个指针</td>
<td>指向一个数组</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">n1, n2, n3 := <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">nums := [<span class="number">3</span>]<span class="keyword">int</span>&#123;n1, n2, n3&#125;     <span class="comment">//普通数组</span></span><br><span class="line">ptrs := [<span class="number">3</span>]*<span class="keyword">int</span>&#123;&amp;n1, &amp;n2, &amp;n3&#125; <span class="comment">//指针数组</span></span><br><span class="line">nums_ptr1 := &amp;nums             <span class="comment">//数组指针</span></span><br><span class="line"><span class="keyword">var</span> nums_ptr2 *[<span class="number">3</span>]<span class="keyword">int</span> = &amp;nums  <span class="comment">//数组指针</span></span><br></pre></td></tr></table></figure>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>定义结构体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> struct_variable_type <span class="keyword">struct</span> &#123;</span><br><span class="line">   member definition</span><br><span class="line">   member definition</span><br><span class="line">   ...</span><br><span class="line">   member definition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明结构体变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">variable_name := structure_variable_type &#123;value1, value2...valuen&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">variable_name := structure_variable_type &#123; key1: value1, key2: value2..., keyn: valuen&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>.</code> 来访问结构体成员</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">	title  <span class="keyword">string</span></span><br><span class="line">	author <span class="keyword">string</span></span><br><span class="line">	id     <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	book := Book&#123;id: <span class="number">1</span>, title: <span class="string">"BookName"</span>, author: <span class="string">"John"</span>&#125;</span><br><span class="line">	fmt.Println(book.id, book.title, book.author)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><p>（与C不同）同样用 <code>.</code> 来访问结构体成员</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">book_ptr := &amp;book</span><br><span class="line">fmt.Println(book_ptr.id, book_ptr.title, book_ptr.author)</span><br></pre></td></tr></table></figure>
<h2 id="Slice-切片"><a href="#Slice-切片" class="headerlink" title="Slice 切片"></a>Slice 切片</h2><p>与C++中的 <code>vector</code> 类似，长度不固定的动态数组，可以追加元素</p>
<h3 id="定义切片"><a href="#定义切片" class="headerlink" title="定义切片"></a>定义切片</h3><ul>
<li><p>定义一个未指定大小的数组</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier []<span class="keyword">type</span></span><br></pre></td></tr></table></figure></li>
<li><p>也可以使用 make() 函数来创建切片</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>, capacity)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="初始化切片"><a href="#初始化切片" class="headerlink" title="初始化切片"></a>初始化切片</h3><ul>
<li><p>直接初始化切片，声明一个未指定大小的数组</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过引用数组/切片初始化切片</p>
<p>  如有一数组/切片<code>arr</code>，可以通过引用这个数组/切片来初始化切片</p>
<p>  引用全部的数组</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := arr[:]</span><br></pre></td></tr></table></figure>
<p>  引用从下标 <code>startIndex</code> 到 <code>endIndex-1</code> 的部分</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := arr[startIndex:endIndex]</span><br></pre></td></tr></table></figure>
<p>  引用从下标 <code>startIndex</code> 到 最后一个元素 的部分</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := arr[startIndex:]</span><br></pre></td></tr></table></figure>
<p>  引用从 第一个元素 到 <code>endIndex-1</code> 的部分</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := arr[:endIndex]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="len-和-cap"><a href="#len-和-cap" class="headerlink" title="len() 和 cap()"></a>len() 和 cap()</h3><ul>
<li><p><code>len(s)</code> 获取切片长度</p>
</li>
<li><p><code>cap(s)</code> 获取切片容量</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s) <span class="comment">//3 5 [0 0 0]</span></span><br></pre></td></tr></table></figure>
<h3 id="append"><a href="#append" class="headerlink" title="append()"></a>append()</h3><p>append扩展切片，原切片不变，返回的新切片在原切片上加上扩展项</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">new_slice = <span class="built_in">append</span>(old_slice []Type, elems ...Type)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>append()的原理：</p>
<p>如果 old slice 的 capacity够加，则 new slice 直接在 old slice 的内存上追加，共享内存；<br>如果capacity不够加，则 new slice 不与 old slice 共享内存，而是另开一片内存，复制 old slice 的数据</p>
</blockquote>
<p>示例：</p>
<p>old slice 的 capacity 不够加</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">0</span>&#125;</span><br><span class="line">s2 := <span class="built_in">append</span>(s1, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">//s1的cap不够，s2与s1不共内存</span></span><br><span class="line">fmt.Println(s1, s2)    <span class="comment">//[0] [0 1 2]</span></span><br><span class="line">s1[<span class="number">0</span>] = <span class="number">-1</span> <span class="comment">//s2与s1不共内存，s1修改，不影响s2</span></span><br><span class="line">fmt.Println(s1, s2) <span class="comment">//[-1] [0 1 2]</span></span><br></pre></td></tr></table></figure>
<p>old slice 的 capacity 够加</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">s2 := <span class="built_in">append</span>(s1, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">//s1的cap足够，s2与s1共内存</span></span><br><span class="line">fmt.Println(s1, s2) <span class="comment">//[0] [0 1 2]</span></span><br><span class="line">s1[<span class="number">0</span>] = <span class="number">-1</span> <span class="comment">//s4与s3共内存，s3修改，s4也会相应变化</span></span><br><span class="line">fmt.Println(s1, s2) <span class="comment">//[-1] [-1 1 2]</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/append_go.jpg" alt=""></p>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy()"></a>copy()</h3><p>copy复制切片，必须创造一个比原切片 capacity 更大的新切片，才能复制过来</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">copy</span>(new_slice, old_slice)</span><br></pre></td></tr></table></figure>
<p><code>copy</code> 和 <code>=</code> 的区别：</p>
<ul>
<li><code>=</code> 赋值拷贝，会将原来slice的地址拷贝，新旧slice共享内存</li>
<li><code>copy</code> 将slice内容进行拷贝，新旧slice不共享内存</li>
</ul>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/go_copy.jpg" alt=""></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">s2 := s1 <span class="comment">//`=`赋值，指向同一片内存</span></span><br><span class="line"></span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(s1), <span class="number">2</span>*<span class="built_in">cap</span>(s1))</span><br><span class="line"><span class="built_in">copy</span>(s3, s1) <span class="comment">//copy复制，不共享内存</span></span><br><span class="line"></span><br><span class="line">fmt.Println(s1, s2, s3) <span class="comment">//[0 1 2] [0 1 2] [0 1 2]</span></span><br><span class="line"></span><br><span class="line">s1[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">fmt.Println(s1, s2, s3) <span class="comment">//[-1 1 2] [-1 1 2] [0 1 2]</span></span><br></pre></td></tr></table></figure>
<h2 id="Map-集合"><a href="#Map-集合" class="headerlink" title="Map 集合"></a>Map 集合</h2><p>无序的键值对，与C++中的map类似，但与C++中的map不同，</p>
<h3 id="定义-Map"><a href="#定义-Map" class="headerlink" title="定义 Map"></a>定义 Map</h3><ul>
<li><p>使用 <code>make</code> 函数</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">map_variable := <span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType, initialCapacity)</span><br></pre></td></tr></table></figure>
<p>  <code>initialCapacity</code> 可选填，用于指定 Map 的初始容量。Map 的容量是指 Map 中可以保存的键值对的数量。</p>
<p>  示例：</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的 Map</span></span><br><span class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个初始容量为 10 的 Map</span></span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>map</code> 关键字</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m1 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">m2 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="string">"a"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"b"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">"c"</span>: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><ul>
<li><p>获取元素</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v1 := m[<span class="string">"a"</span>] </span><br><span class="line"></span><br><span class="line">v2, ok := m[<span class="string">"d"</span>] <span class="comment">// 如果键不存在，v2为该类型的零值，ok=false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改元素</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m[<span class="string">"a"</span>] = <span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除元素</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(m, <span class="string">"a"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取长度</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">l := <span class="built_in">len</span>(m)</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历 map</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h1><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p>与C中类似，但是条件语句不需要用括号包住</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition2 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> expression &#123;</span><br><span class="line"><span class="keyword">case</span> val1:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">case</span> val2:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>先执行 <code>expression</code></li>
<li>从上往下依次找匹配的 case</li>
<li>go中的 <code>switch</code> 默认自带 <code>break</code>，匹配成功后，就不会执行其他 case</li>
<li>如果希望匹配成功后继续执行后面的 case，可以使用 <code>fallthrough</code></li>
</ul>
<p>示例1:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> tag &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">	f1()</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>, <span class="number">2</span>:</span><br><span class="line">	f2()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	f3()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例2:</p>
<p><code>expression</code> 可以为空</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> tag == <span class="number">0</span>:</span><br><span class="line">	f1()</span><br><span class="line"><span class="keyword">case</span> tag == <span class="number">1</span>, tag == <span class="number">2</span>:</span><br><span class="line">	f2()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	f3()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Type-Switch"><a href="#Type-Switch" class="headerlink" title="Type Switch"></a>Type Switch</h4><p>switch还可以用来判断某个 <code>interface</code> 变量中实际存储的变量类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> i := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">	f1()</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">	f2()</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">	f3()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	f4()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fallthrough"><a href="#fallthrough" class="headerlink" title="fallthrough"></a>fallthrough</h4><p>如果在 case 的最后加上了 <code>fallthrough</code>，则无论紧接着的下一条 case 为 ture 还是 false，都会执行。</p>
<p>示例1:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tag := <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> tag == <span class="number">0</span>: <span class="comment">// false</span></span><br><span class="line">	fmt.Println(<span class="string">"0"</span>) <span class="comment">// 不执行</span></span><br><span class="line">	<span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> tag == <span class="number">1</span>: <span class="comment">// true</span></span><br><span class="line">	fmt.Println(<span class="string">"1"</span>) <span class="comment">// 执行</span></span><br><span class="line">	<span class="keyword">fallthrough</span>      <span class="comment">// 下一个case无条件执行</span></span><br><span class="line"><span class="keyword">case</span> tag == <span class="number">2</span>: <span class="comment">// 不必判断，直接执行</span></span><br><span class="line">	fmt.Println(<span class="string">"2"</span>) <span class="comment">// 执行</span></span><br><span class="line">	<span class="comment">// 这里其实有个默认的 break</span></span><br><span class="line"><span class="keyword">case</span> tag == <span class="number">3</span>:</span><br><span class="line">	fmt.Println(<span class="string">"3"</span>) <span class="comment">// 不执行</span></span><br><span class="line">	<span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	fmt.Println(<span class="string">"default"</span>) <span class="comment">// 不执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出：<br>1<br>2</p>
</blockquote>
<p>示例2:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">tag := <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> tag == <span class="number">0</span>: <span class="comment">// false</span></span><br><span class="line">	fmt.Println(<span class="string">"0"</span>) <span class="comment">// 不执行</span></span><br><span class="line">	<span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> tag == <span class="number">1</span>: <span class="comment">// true</span></span><br><span class="line">	fmt.Println(<span class="string">"1"</span>) <span class="comment">// 执行</span></span><br><span class="line">	<span class="keyword">fallthrough</span>      <span class="comment">// 下一个case无条件执行</span></span><br><span class="line"><span class="keyword">case</span> tag == <span class="number">2</span>: <span class="comment">// 不必判断，直接执行</span></span><br><span class="line">	fmt.Println(<span class="string">"2"</span>) <span class="comment">// 执行</span></span><br><span class="line">	<span class="keyword">fallthrough</span>      <span class="comment">// 下一个case无条件执行</span></span><br><span class="line"><span class="keyword">case</span> tag == <span class="number">3</span>: <span class="comment">// 不必判断，直接执行</span></span><br><span class="line">	fmt.Println(<span class="string">"3"</span>) <span class="comment">// 执行</span></span><br><span class="line">	<span class="keyword">fallthrough</span>      <span class="comment">// 下一个case无条件执行</span></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">// 不必判断，直接执行</span></span><br><span class="line">	fmt.Println(<span class="string">"default"</span>) <span class="comment">// 执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出：<br>1<br>2<br>3<br>default</p>
</blockquote>
<h3 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h3><p><code>select</code> 类似于 <code>switch</code>，但是 <code>select</code> 只能用于通道操作</p>
<ul>
<li><code>select</code> 会监听所有通道，一旦有通道准备好，就<strong>随机</strong>选择其中一个通道执行</li>
<li>如果所有通道都没准备好，则执行 <code>default</code></li>
<li>如果没有 <code>default</code>，<code>select</code> 将阻塞，直到某个通道可以运行</li>
</ul>
<blockquote>
<p>多个case匹配时，switch从上至下匹配第一个，select随机匹配一个</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="comment">// 随机执行一个准备好了的通道</span></span><br><span class="line"><span class="keyword">case</span> &lt;- channel1:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">case</span> value := &lt;- channel2:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">case</span> channel3 &lt;- value:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// 所有通道都没有准备好，执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义两个通道</span></span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动两个 goroutine，分别从两个通道中获取数据</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			ch1 &lt;- <span class="string">"from 1"</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			ch2 &lt;- <span class="string">"from 2"</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 select 语句非阻塞地从两个通道中获取数据</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> msg1 := &lt;-ch1:</span><br><span class="line">			fmt.Println(msg1)</span><br><span class="line">		<span class="keyword">case</span> msg2 := &lt;-ch2:</span><br><span class="line">			fmt.Println(msg2)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">// 如果两个通道都没有可用的数据，则执行这里的语句</span></span><br><span class="line">			fmt.Println(<span class="string">"no message received"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出：<br>no message received<br>from 1<br>from 2<br>from 1<br>from 2<br>no message received<br>no message received<br>from 2<br>from 1<br>no message received</p>
</blockquote>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h3><p>go的 <code>for</code> 语句有多种用法：</p>
<ul>
<li><p>与C的 <code>for</code> 相似的用法</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> init; condition; post &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>与C的 <code>while</code> 相似的用法</p>
<p>  只留下 <code>condition</code> 项，则只需判断 <code>condition</code></p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> condition &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>与C的 <code>while(1)</code> 相似的用法</p>
<p>  三项都不填，则无限循环</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>range</code>格式</p>
<p>  <code>for</code> 循环的 <code>range</code> 格式可以对 slice、map、数组、字符串等进行迭代循环</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldMap &#123;</span><br><span class="line">    newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  也可以只提取 <code>key</code> 或者 <code>value</code></p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> oldMap &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  只提取 <code>value</code> 时，需要用 <code>_,</code> 占掉 <code>key</code> 的位置</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> oldMap &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>与C中的break用法相似，但多一个标号的功能：</p>
<p>在多重循环中，可以使用标号 <code>label</code> 跳出指定的循环。</p>
<p>示例：</p>
<p>不加标号时，与C一样，只会 break 掉最里面的那层循环</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">    	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123; <span class="comment">// break掉这层循环</span></span><br><span class="line">    		fmt.Printf(<span class="string">"i = %d, j = %d\n"</span>, i, j)</span><br><span class="line">    		<span class="keyword">break</span> </span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出：<br>i = 0, j = 0<br>i = 1, j = 0<br>i = 2, j = 0</p>
</blockquote>
<p>加上标号后，会 break 掉标号的那层循环</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">re:</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123; <span class="comment">// break掉标号re这层循环</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"i = %d, j = %d\n"</span>, i, j)</span><br><span class="line">			<span class="keyword">break</span> re</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出：<br>i = 0, j = 0</p>
</blockquote>
<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>与 <code>break</code> 一样，可以通过标号 <code>label</code> 指定需要 continue 的循环</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span> [<span class="title">return_types</span>]</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>parameter list</code> 参数列表，选填，可以无参，格式为 <code>parameter_name1 type1, parameter_name2 type2, ...</code></li>
<li><code>return_types</code> 返回类型，选填，可以无返回值（相当于C中的void），也可以返回多个值，格式为 <code>(type1, type2, ...)</code></li>
</ul>
<p>示例1：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(num1, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> num1 &gt; num2 &#123;</span><br><span class="line">		<span class="keyword">return</span> num1</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> num2</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例2:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">y, x := swap(<span class="string">"hello"</span>, <span class="string">"world"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="引用传递参数"><a href="#引用传递参数" class="headerlink" title="引用传递参数"></a>引用传递参数</h2><p>与C中的指针类似，传递地址指针</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x *<span class="keyword">int</span>, y *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	temp := *x</span><br><span class="line">	*x = *y</span><br><span class="line">	*y = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数变量"><a href="#函数变量" class="headerlink" title="函数变量"></a>函数变量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 声明函数变量</span></span><br><span class="line">	findMax := <span class="function"><span class="keyword">func</span><span class="params">(num1, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> num1 &gt; num2 &#123;</span><br><span class="line">			<span class="keyword">return</span> num1</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> num2</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	max := findMax(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">	fmt.Println(max)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包包含两点：</p>
<ul>
<li><p>存在函数外部定义，但在函数内部引用的自由变量</p>
</li>
<li><p>脱离了形成闭包的上下文，闭包也能照常使用这些自由变量，通常称这些自由变量为捕获变量</p>
</li>
</ul>
<p>go语言中函数是头等对象，闭包可以充当C++中类的变量功能，也经常称闭包为有状态的函数</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getSequence函数的返回值为一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSequence</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="comment">// 闭包函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		<span class="comment">//返回函数内部，使用了返回函数外部定义的变量i</span></span><br><span class="line">		i++</span><br><span class="line">		<span class="keyword">return</span> i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//声明一个函数变量，此时会执行getSequence函数，令i=0，并定义一个累加函数nextNumber</span></span><br><span class="line">	nextNumber1 := getSequence()</span><br><span class="line">	nextNumber2 := getSequence()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 即使getSequence执行结束，依旧可以通过nextNumber调用闭包函数，并使用i</span></span><br><span class="line">	<span class="comment">// nextNumber每调用一次，i加一</span></span><br><span class="line">	fmt.Println(nextNumber1()) <span class="comment">// 输出1</span></span><br><span class="line">	fmt.Println(nextNumber1()) <span class="comment">// 输出2</span></span><br><span class="line">	fmt.Println(nextNumber1()) <span class="comment">// 输出3</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//两个闭包函数互不影响</span></span><br><span class="line">	fmt.Println(nextNumber2()) <span class="comment">// 输出1</span></span><br><span class="line">	fmt.Println(nextNumber2()) <span class="comment">// 输出2</span></span><br><span class="line">	fmt.Println(nextNumber2()) <span class="comment">// 输出3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>getSequence返回一个闭包函数</p>
</li>
<li><p>变量i就是在闭包外定义，闭包内使用的变量</p>
</li>
<li><p>即使脱离了闭包的上下文，在main中，也可以调用nextNumber闭包函数，并使用定义在getSequence中的局部变量变量i</p>
</li>
<li><p><code>nextNumber1 := getSequence()</code> 和 <code>nextNumber2 := getSequence()</code> 分别独立，各自的捕获变量i不影响</p>
</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>在其他语言中，函数和方法是一样的，但在go中有所区别</p>
<p>方法是一种有接收者的特殊函数，可以实现C++类的函数功能</p>
<p>接受者可以是命名类型或者结构体类型的一个值或者是一个指针</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(variable_name variable_data_type)</span> <span class="title">function_name</span><span class="params">()</span> [<span class="title">return_type</span>]</span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>variable_name</code> 接受者名</li>
<li><code>variable_data_type</code> 接受者类型</li>
</ul>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆的结构体</span></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">	radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法，接受者必须为为 c Circle</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span> <span class="title">getArea</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">3.14</span> * c.radius * c.radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c1 Circle</span><br><span class="line">	c1.radius = <span class="number">1</span></span><br><span class="line">	fmt.Println(c1.getArea()) <span class="comment">//调用求面积的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="数值类型转换"><a href="#数值类型转换" class="headerlink" title="数值类型转换"></a>数值类型转换</h2><p>格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">type_name(expression)</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> v2 <span class="keyword">float64</span> = <span class="keyword">float64</span>(v1)</span><br></pre></td></tr></table></figure>
<h2 id="字符串类型转换"><a href="#字符串类型转换" class="headerlink" title="字符串类型转换"></a>字符串类型转换</h2><ul>
<li><p>string 转 int</p>
<p>  使用 <code>strconv.Atoi</code> 将 string 转换为 int，第二个返回值为可能发生的错误，可以用 <code>_</code> 来忽略这个错误</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">"10"</span></span><br><span class="line">	num, err := strconv.Atoi(str)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(num)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>int 转 string</p>
<p>  使用 <code>strconv.Itoa</code> 将 int 转换为 string</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">num := <span class="number">10</span></span><br><span class="line">str := strconv.Itoa(num)</span><br></pre></td></tr></table></figure>
</li>
<li><p>string 转 float</p>
<p>  使用 <code>strconv.ParseFloat</code> 将 string 转换为 float，第二个参数为 bitSize，用来选择究竟是64位还是32位的 float</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str := <span class="string">"3.14"</span></span><br><span class="line">num, err := strconv.ParseFloat(str, <span class="number">64</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="接口类型转换"><a href="#接口类型转换" class="headerlink" title="接口类型转换"></a>接口类型转换</h2><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>go 通过接口实现了C++中多态的效果。</p>
<ul>
<li><p>接口把所有的具有共性的方法定义在一起</p>
</li>
<li><p>隐式实现，不用声明某个struct实现了那个接口，如果一个struct实现了一个接口定义的所有方法，那么它就自动地实现了该接口</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义接口 */</span></span><br><span class="line"><span class="keyword">type</span> interface_name <span class="keyword">interface</span> &#123;</span><br><span class="line">   method_name1 [return_type]</span><br><span class="line">   method_name2 [return_type]</span><br><span class="line">   method_name3 [return_type]</span><br><span class="line">   ...</span><br><span class="line">   method_namen [return_type]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义结构体 */</span></span><br><span class="line"><span class="keyword">type</span> struct_name <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">/* variables */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现接口方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span> <span class="title">method_name1</span><span class="params">()</span> [<span class="title">return_type</span>]</span> &#123;</span><br><span class="line">   <span class="comment">/* 方法实现 */</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span> <span class="title">method_namen</span><span class="params">()</span> [<span class="title">return_type</span>]</span> &#123;</span><br><span class="line">   <span class="comment">/* 方法实现*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口声明</span></span><br><span class="line"><span class="keyword">type</span> Sleeper <span class="keyword">interface</span> &#123;</span><br><span class="line">	sleep() <span class="comment">//声明方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cat和Dog都分别实现了Sleeper的sleep方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span> <span class="title">sleep</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"Cat %s is sleeping\n"</span>, c.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span> <span class="title">sleep</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"Dog %s is sleeping\n"</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AnimalSleep函数实现了一个函数多个状态，也就是多态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AnimalSleep</span><span class="params">(s Sleeper)</span></span> &#123;</span><br><span class="line">	s.sleep()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s Sleeper</span><br><span class="line"></span><br><span class="line">	s = Cat&#123;name: <span class="string">"cici"</span>&#125;</span><br><span class="line">	AnimalSleep(s) <span class="comment">//Cat cici is sleeping</span></span><br><span class="line"></span><br><span class="line">	s = Dog&#123;name: <span class="string">"dodo"</span>&#125;</span><br><span class="line">	AnimalSleep(s) <span class="comment">//Dog dodo is sleeping</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个 <code>Sleeper</code> 接口，<code>Cat</code> 和 <code>Dog</code> 都实现了<code>Sleeper</code> 接口的所有方法，所以隐式实现了接口。</p>
<p>如此 <code>AnimalSleep()</code> 函数实现了一个函数多个状态，也就是多态</p>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>函数定义时，使用 <code>errors.New</code> 返回错误信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(f <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 错误时，返回错误信息</span></span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">"math: square root of negative number"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用函数时，接收返回的错误信息err</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">result, err:= Sqrt(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   fmt.Println(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="goroutine-线程"><a href="#goroutine-线程" class="headerlink" title="goroutine 线程"></a>goroutine 线程</h2><p>goroutine 是轻量级线程，通过 <code>go</code> 关键字开启，如此可以同时多个线程并发进行。</p>
<p>同一个程序中的所有 goroutine 共享同一个地址空间。</p>
<p>格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(x, y, z)</span></span></span><br></pre></td></tr></table></figure>
<p>如此，就开启了一个新的线程 <code>func(x, y, z)</code></p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">		fmt.Println(<span class="string">"eating"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">drink</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">		fmt.Println(<span class="string">"drinking"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> eat() <span class="comment">// 开启一个eat线程</span></span><br><span class="line">	drink() <span class="comment">// eat和drink两个线程并发执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出：<br>drinking<br>eating<br>drinking<br>eating<br>eating<br>drinking</p>
</blockquote>
<p>可以看出 eat 和 drink 两个线程并发执行，一下输出 eating，一下输出 drinking</p>
<h2 id="channel-通道"><a href="#channel-通道" class="headerlink" title="channel 通道"></a>channel 通道</h2><p>通道是用来传递数据的一种数据结构，可用于两个 goroutine 之间通过传递值来同步运行和通讯</p>
<h3 id="发送和接收"><a href="#发送和接收" class="headerlink" title="发送和接收"></a>发送和接收</h3><p>用 <code>&lt;-</code> 来发送和接收数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- value    <span class="comment">// 把 value 发送到通道 ch</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v := &lt;-ch  <span class="comment">// 从 ch 接收数据</span></span><br><span class="line">           <span class="comment">// 并把值赋给 v</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&lt;-ch  <span class="comment">// 从 ch 接收数据</span></span><br><span class="line">      <span class="comment">// 并丢弃值</span></span><br></pre></td></tr></table></figure>
<h3 id="定义通道"><a href="#定义通道" class="headerlink" title="定义通道"></a>定义通道</h3><p>利用 <code>chan</code> 关键字定义通道，使用 <code>make</code> 创建一个引用，当复制一个channel或用于函数参数传递时，实际只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象</p>
<ul>
<li><p>不带缓冲区的通道（默认）</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<p>  如此定义了一个不带缓冲区的通道，通道可以传递 int 参数</p>
</li>
<li><p>带缓冲区的通道</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>  如此定义了一个带缓冲区的通道，缓冲区大小为100</p>
</li>
</ul>
<p>默认不带缓冲区，发送端发送数据，同时必须有接收端相应的接收数据。如果迟迟没有接收，发送方会阻塞直到接收方从通道中接收了值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">//没有缓冲区的通道</span></span><br><span class="line">	ch &lt;- <span class="number">1</span>              <span class="comment">//这里发送端会直接卡死，一直卡在这里等待接收端的出现</span></span><br><span class="line">	fmt.Println(&lt;-ch)    <span class="comment">//无法运行到此</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>带缓冲区的通道允许发送端和接收端异步，发送端可以先把数据放进缓存区内，发送端进程进行向下进行，不需要等待接收端接收。</p>
<p>但如果缓冲区满了，发送端同样会像不带缓冲区的通道那样卡住，直到有接收方从通道中接收了值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">//有大小为1缓冲区的通道</span></span><br><span class="line">	ch &lt;- <span class="number">1</span>                 <span class="comment">//1放入缓冲区，不会卡住</span></span><br><span class="line">	fmt.Println(&lt;-ch)       <span class="comment">//可以运行输出1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关闭通道"><a href="#关闭通道" class="headerlink" title="关闭通道"></a>关闭通道</h3><p>关闭通道后，不会再发送数据到通道上了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>
<p>接收端在接收时，可以通过额外的第二个变量来判断通道是否关闭</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v, ok := &lt;- ch</span><br></pre></td></tr></table></figure>
<h3 id="遍历通道"><a href="#遍历通道" class="headerlink" title="遍历通道"></a>遍历通道</h3><p>与数组、切片相同，使用 <code>range</code> 关键字来遍历通道</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>规则：</p>
<ul>
<li>遍历一个空的通道（nil）时，阻塞</li>
<li>遍历一个 阻塞 &amp;&amp; 未关闭 的通道（nil）时，阻塞</li>
<li>遍历一个 阻塞 &amp;&amp; 已关闭 的通道（nil）时，不做任何操作</li>
<li>遍历一个 非阻塞 &amp;&amp; 未关闭 的通道（nil）时，接收所有缓存数据，然后阻塞</li>
<li>遍历一个 非阻塞 &amp;&amp; 已关闭 的通道（nil）时，接收所有缓存数据，然后返回</li>
</ul>
<h2 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h2><h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><h2 id="单引号、双引号、反引号"><a href="#单引号、双引号、反引号" class="headerlink" title="单引号、双引号、反引号"></a>单引号、双引号、反引号</h2><ul>
<li>单引号 <code>&#39;&#39;</code>：包裹字符</li>
<li>双引号 <code>&quot;&quot;</code>：包裹字符串，会解析其中的转义符</li>
<li>反引号 ````：包裹字符串，不会解析其中的转义符</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Print(<span class="string">"Hello, World!\n"</span>) <span class="comment">//双引号，会解析其中的转义符</span></span><br><span class="line">fmt.Print(<span class="string">`Hello, World!\n`</span>) <span class="comment">//反引号，不会解析其中的转义符</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出：</p>
<p>Hello, World!<br>Hello, World!\n% </p>
</blockquote>
<h1 id="Go-modules"><a href="#Go-modules" class="headerlink" title="Go modules"></a>Go modules</h1><p>go modules 是 go 的依赖包管理工具</p>
<h2 id="go-的包管理发展"><a href="#go-的包管理发展" class="headerlink" title="go 的包管理发展"></a>go 的包管理发展</h2><p>在引入 go modules 之前，go 管理依赖包先是用 GOPATH，后来用 go vender</p>
<h3 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h3><p>go path 理论上并不算是包管理工具，需要手动管理依赖包，写程序代码必须放在 <code>$GOPATH/src</code> 目录下，且依赖包没有版本可言</p>
<h3 id="go-vendor"><a href="#go-vendor" class="headerlink" title="go vendor"></a>go vendor</h3><p>解决了包管理问题，所有依赖包下载到项目的 <code>vendor</code> 目录下</p>
<h2 id="go-modules-的使用"><a href="#go-modules-的使用" class="headerlink" title="go modules 的使用"></a>go modules 的使用</h2><p>首先要确定 go 语言的版本，至少需是 v1.11 以上版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go version</span><br></pre></td></tr></table></figure>
<h3 id="环境设置"><a href="#环境设置" class="headerlink" title="环境设置"></a>环境设置</h3><p>查看 go 的环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go env</span><br></pre></td></tr></table></figure>
<p>其中与 Go Modules 相关的环境设置如下</p>
<h4 id="GO111MODULE"><a href="#GO111MODULE" class="headerlink" title="GO111MODULE"></a><code>GO111MODULE</code></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go env -w GO111MODULE&#x3D;on</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://books.studygolang.com/gopl-zh/" target="_blank" rel="noopener">Go语言圣经（中文版）</a></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>语言基本语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Go并发编程</title>
    <url>/2024/09/05/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Go 并发编程</p>
<a id="more"></a>
<h1 id="并发基本概念"><a href="#并发基本概念" class="headerlink" title="并发基本概念"></a>并发基本概念</h1><h2 id="进程-Process-与线程-Thread"><a href="#进程-Process-与线程-Thread" class="headerlink" title="进程 Process 与线程 Thread"></a>进程 Process 与线程 Thread</h2><ul>
<li>进程是系统进行资源分配和调度的一个基本单位，程序在操作系统中的一次执行过程</li>
<li>线程是进程的执行单位，是CPU调度和分派的基本单位</li>
<li>一个进程可以创建和撤销多个线程;同一个进程中的多个线程之间可以并发执行</li>
</ul>
<h2 id="并行-Concurrent-与并发-Paralled"><a href="#并行-Concurrent-与并发-Paralled" class="headerlink" title="并行 Concurrent 与并发 Paralled"></a>并行 Concurrent 与并发 Paralled</h2><ul>
<li><p>并行：多个线程同时操作多个资源类</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20240905132345930.png" alt="并行"></p>
</li>
<li><p>并发：多个线程交替操作同一资源类</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20240905132404280.png" alt="并发"></p>
</li>
</ul>
<h2 id="进程-process-与线程-thread-与协程-coroutine"><a href="#进程-process-与线程-thread-与协程-coroutine" class="headerlink" title="进程 process 与线程 thread 与协程 coroutine"></a>进程 process 与线程 thread 与协程 coroutine</h2><ul>
<li>一个进程上可以跑多个线程，一个线程上可以跑多个协程</li>
<li>多个线程可以利用多个 CPU 并行，但一个线程内的多个协程是串行的，同一时刻只能有一个在运行，无法利用 CPU 多核，但不同线程内的协程之间可以并行</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>进程 process</th>
<th>线程 thread</th>
<th>协程 coroutine</th>
</tr>
</thead>
<tbody>
<tr>
<td>切换者</td>
<td>操作系统</td>
<td>操作系统</td>
<td>用户</td>
</tr>
<tr>
<td>切换内容</td>
<td>页全局目录、内核栈、硬件上下文</td>
<td>内核栈、硬件上下文</td>
<td>硬件上下文</td>
</tr>
<tr>
<td>切换内容保存位置</td>
<td>内存</td>
<td>内核栈</td>
<td>用户栈或堆（变量）</td>
</tr>
<tr>
<td>状态切换</td>
<td>用户态 —&gt; 内核态 —&gt; 用户态</td>
<td>用户态 —&gt; 内核态 —&gt; 用户态</td>
<td>用户态</td>
</tr>
<tr>
<td>切换效率</td>
<td>低</td>
<td>中</td>
<td>高</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>进程、线程的切换者是操作系统，操作系统决定切换时刻，用户无感</li>
<li>协程的切换者是用户，由用户程序决定切换时间</li>
<li>进程切换内容：页全局目录、内核栈、硬件上下文，切换的内容保存在内存中，采用 用户态 —&gt; 内核态 —&gt; 用户态</li>
<li>线程切换内容：内核栈、硬件上下文，切换的内容保存在内核栈中，采用 用户态 —&gt; 内核态 —&gt; 用户态</li>
<li>协程切换内容：硬件上下文，切换的内容保存在用户栈或堆（变量）中，切换过程始终处于用户态</li>
</ul>
<h1 id="协程-Goroutine"><a href="#协程-Goroutine" class="headerlink" title="协程 Goroutine"></a>协程 Goroutine</h1><p>Go 不需要自己编写进程、线程、协程，直接使用 goroutine，在语言中内置了调度和上下文切换机制，可轻松开启上万 goroutine。</p>
<p>goroutine 协程概念上类似于线程，Go 程序可以智能地将 goroutine 分配给不同的 CPU，由Go的运行时（runtime）调度和管理的。</p>
<h2 id="使用-goroutine"><a href="#使用-goroutine" class="headerlink" title="使用 goroutine"></a>使用 goroutine</h2><p>goroutine 使用时将任务包装成函数，通过 <code>go</code> 关键字开启</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>如果 goroutine 没有执行完，但主线程已经结束，goroutine 也会跟着结束。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>每两秒输出一次 go routine，每秒输出一次 hello，输出 10 次 hello 后结束</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"go routine"</span>)</span><br><span class="line">		time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> runtime()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="协程调度"><a href="#协程调度" class="headerlink" title="协程调度"></a>协程调度</h1><h2 id="GPM-模型"><a href="#GPM-模型" class="headerlink" title="GPM 模型"></a>GPM 模型</h2><p>goroutine 调度系统为 GPM 运行时（runtime）调度器，包括了 3 个部分—— goroutine G、处理器 P、线程 M</p>
<ul>
<li>G：goroutine<ul>
<li>存放本 goroutine 的一些信息，以及与 P 绑定等信息</li>
</ul>
</li>
<li>P：Processor，处理器<ul>
<li>P 对 goroutine 队列进行调度</li>
<li>goroutine 与线程的中间层，管理着一组 goroutine 队列，储存所管 goroutine 运行的上下文</li>
<li>P 的数量决定了最大可并行数量，个数由 <code>runtime.GOMAXPROCS</code> 设置，最大 256，默认为 CPU 数</li>
</ul>
</li>
<li>M：Machine，线程<ul>
<li>Go 运行时对操作内核线程的虚拟，与内核线程一一对应</li>
</ul>
</li>
</ul>
<p>P 管理着一群 G，调度在 M 上运行。一般比例为 G : P : M = n : 1 : 1</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20240912012030653.png" alt="GPM调度" style="zoom:50%;" /></p>
<p>调度机制：</p>
<ul>
<li>把占用 CPU 时间过长的 goroutine 暂停，去运行后续的 goroutine</li>
<li>当自己队列的消费光了，则去取全局队列中的 goroutine</li>
<li>如全局队列也消费光了，则去抢其他 P 的 goroutine</li>
<li>如果一个 G 长时间占据着 M，runtime 就会新建一个 M，管理阻塞 G 的 P 会将其他的 G 都挂到新建的 M 上。当旧的 M 上的 G 运行完或者被判定为死掉时，就会回收旧有的 M。</li>
</ul>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/view.png" alt="GPM调度机制"></p>
<p>由此可以看出，从调度角度看，goroutine 相较于线程的优势：</p>
<ul>
<li>goroutine 的调度由 runtime 调度器调度，全程在用户态</li>
<li>线程需要内核进行调度，需要内核态和用户态之间频繁切换</li>
</ul>
<h2 id="runtime-包"><a href="#runtime-包" class="headerlink" title="runtime 包"></a>runtime 包</h2><p>runtime 运行时用来调度和管理 goroutine，可通过 runtime 包程序控制 goroutine 以及获取环境信息。</p>
<h3 id="runtime-Gosched"><a href="#runtime-Gosched" class="headerlink" title="runtime.Gosched()"></a>runtime.Gosched()</h3><p>释放当前 goroutine 的 CPU 时间片给其他 goroutine 执行，当前 goroutine 等待未来的时间片再执行。</p>
<p><strong>示例</strong></p>
<p>下面代码，运行后有两种可能：</p>
<ul>
<li>一段数字 + 两个 hello<ul>
<li>CPU 时间片先给数字协程，再分配给 hello 主协程</li>
</ul>
</li>
<li>两个 hello<ul>
<li>CPU 时间片先给 hello 主协程，主协程结束后程序直接结束，不输出数字，再分配数字协程</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ &#123;</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 主协程</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时在主协程运行输出 <code>hello</code> 前，添加 <code>runtime.Gosched()</code>，会切到其他 goroutine 输出多次数字，等数字协程的时间片用完时，切回主协程输出 <code>hello</code> ，再切回数字协程输出数字，最后主协程输出 <code>hello</code> 后结束程序。</p>
<p>即输出：一段数字 + hello + 一段数字 + hello</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 主协程</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 切到其他进程先执行</span></span><br><span class="line">		runtime.Gosched()</span><br><span class="line">		fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="runtime-Goexit"><a href="#runtime-Goexit" class="headerlink" title="runtime.Goexit()"></a>runtime.Goexit()</h3><p>退出当前 goroutine，不过退出前还是会正常执行 defer 语句。</p>
<p><strong>示例</strong></p>
<p>下面代码，主协程休眠一秒，数字协程输出一段数字之后，主协程苏醒输出 <code>hello</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">      <span class="comment">// runtime.Goexit()</span></span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加 <code>runtime.Goexit()</code> 后，直接结束协程，不会输出数字，只输出 <code>hello</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">			runtime.Goexit()</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="runtime-GOMAXPROCS"><a href="#runtime-GOMAXPROCS" class="headerlink" title="runtime.GOMAXPROCS()"></a>runtime.GOMAXPROCS()</h3><p>设置可同时使用最大 CPU 核数，并返回之前的设置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runtime</span>.<span class="title">GOMAXPROCS</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>
<h3 id="其他运行时信息"><a href="#其他运行时信息" class="headerlink" title="其他运行时信息"></a>其他运行时信息</h3><ul>
<li><p>获取 CPU 核数量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">runtime.NumCPU()</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取 GOROOT 路径</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">runtime.GOROOT()</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取操作系统</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">runtime.GOOS</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h1><h2 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h2><p>临界资源：并发环境中多个进程/线程/协程共享的资源。</p>
<p>多个 goroutine 访问同一资源时，多个写 goroutine，会造成临界资源安全问题。</p>
<p>下面示例中，4 个售票员并发卖 10 张票，原本是希望卖到无票时所有售票员停止卖票，但同时读写就可能导致资源安全问题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numTicket = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">saleTicket</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> numTicket &gt; <span class="number">0</span> &#123;</span><br><span class="line">			time.Sleep(time.Duration(rand.Intn(<span class="number">1000</span>)) * time.Millisecond)</span><br><span class="line">			numTicket--</span><br><span class="line">			fmt.Printf(<span class="string">"Saler %d sales one ticket, left %d tickets.\n"</span>, i, numTicket)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"Saler %d detects no ticket.\n"</span>, i)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	numSaler := <span class="number">4</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numSaler; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> saleTicket(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如这次跑的结果，最后三个售票员检查时还有余票，但卖时已经无票了，导致票成负数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Saler 3 sales one ticket, left 9 tickets.</span><br><span class="line">Saler 0 sales one ticket, left 8 tickets.</span><br><span class="line">Saler 0 sales one ticket, left 7 tickets.</span><br><span class="line">Saler 2 sales one ticket, left 6 tickets.</span><br><span class="line">Saler 1 sales one ticket, left 5 tickets.</span><br><span class="line">Saler 3 sales one ticket, left 4 tickets.</span><br><span class="line">Saler 1 sales one ticket, left 3 tickets.</span><br><span class="line">Saler 0 sales one ticket, left 2 tickets.</span><br><span class="line">Saler 2 sales one ticket, left 1 tickets.</span><br><span class="line">Saler 3 sales one ticket, left 0 tickets.</span><br><span class="line">Saler 3 detects no ticket.</span><br><span class="line">Saler 2 sales one ticket, left -1 tickets.</span><br><span class="line">Saler 2 detects no ticket.</span><br><span class="line">Saler 1 sales one ticket, left -2 tickets.</span><br><span class="line">Saler 1 detects no ticket.</span><br><span class="line">Saler 0 sales one ticket, left -3 tickets.</span><br><span class="line">Saler 0 detects no ticket.</span><br></pre></td></tr></table></figure>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><h3 id="互斥锁-sync-Mutex"><a href="#互斥锁-sync-Mutex" class="headerlink" title="互斥锁 sync.Mutex"></a>互斥锁 sync.Mutex</h3><p>多个 goroutine 同时操作同一个资源（临界区）会导致竞态问题，需要通过对资源上锁，确保同一时刻只有一个 goroutine 访问该共享资源。</p>
<ul>
<li><p>声明一个互斥锁</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mutex sync.Mutex</span><br></pre></td></tr></table></figure>
</li>
<li><p>在使用资源前加锁，防止其他 goroutine 同时使用该资源</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mutex.Lock()</span><br></pre></td></tr></table></figure>
</li>
<li><p>在使用完资源后解锁，释放该资源给其他 goroutine 使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mutex.Unlock()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面的用例，在查看票数前加锁，再售票和退出前解锁，如此就不会出现多卖出票的情况。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line"><span class="keyword">var</span> numTicket = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">saleTicket</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">		mutex.Lock()</span><br><span class="line">		<span class="keyword">if</span> numTicket &gt; <span class="number">0</span> &#123;</span><br><span class="line">			time.Sleep(time.Duration(rand.Intn(<span class="number">1000</span>)) * time.Millisecond)</span><br><span class="line">			numTicket--</span><br><span class="line">			fmt.Printf(<span class="string">"Saler %d sales one ticket, left %d tickets.\n"</span>, i, numTicket)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//解锁</span></span><br><span class="line">			mutex.Unlock()</span><br><span class="line">			fmt.Printf(<span class="string">"Saler %d detects no ticket.\n"</span>, i)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">		mutex.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	numSaler := <span class="number">4</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numSaler; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> saleTicket(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读写互斥锁-sync-RWMutex"><a href="#读写互斥锁-sync-RWMutex" class="headerlink" title="读写互斥锁 sync.RWMutex"></a>读写互斥锁 sync.RWMutex</h3><p>互斥锁是完全互斥的，无关是读还是写。但其实并发读并不会出现资源竞争的问题，所以引入读写锁，不限制并发读，但限制并发读写、写写。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>读</th>
<th>写</th>
</tr>
</thead>
<tbody>
<tr>
<td>读</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>写</td>
<td>N</td>
<td>N</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>声明一个读写互斥锁</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mutex sync.RWMutex</span><br></pre></td></tr></table></figure>
</li>
<li><p>在写资源前加写锁，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mutex.Lock()</span><br></pre></td></tr></table></figure>
</li>
<li><p>在写完资源后解写锁，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mutex.Unlock()</span><br></pre></td></tr></table></figure>
</li>
<li><p>在读资源前加读锁</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mutex.RLock()</span><br></pre></td></tr></table></figure>
</li>
<li><p>在读完资源后解读锁</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mutex.RUnlock()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	x      <span class="keyword">int64</span></span><br><span class="line">	wg     sync.WaitGroup</span><br><span class="line">	lock   sync.Mutex</span><br><span class="line">	rwlock sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rwlock.Lock() <span class="comment">// 加写锁</span></span><br><span class="line">	x = x + <span class="number">1</span></span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Millisecond) <span class="comment">// 假设读操作耗时10毫秒</span></span><br><span class="line">	rwlock.Unlock()                   <span class="comment">// 解写锁</span></span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rwlock.RLock()               <span class="comment">// 加读锁</span></span><br><span class="line">	time.Sleep(time.Millisecond) <span class="comment">// 假设读操作耗时1毫秒</span></span><br><span class="line">	rwlock.RUnlock()             <span class="comment">// 解读锁</span></span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> write()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> read()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	end := time.Now()</span><br><span class="line">	fmt.Println(end.Sub(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原子操作-atomic"><a href="#原子操作-atomic" class="headerlink" title="原子操作 atomic"></a>原子操作 atomic</h2><blockquote>
<p>原子操作即不能被中断的操作，对资源进行原子操作时，CPU 不会再对该资源进行其他操作。原子操作无锁，通过 CPU 指令直接实现。</p>
</blockquote>
<p>通过互斥锁操作会涉及内核态的上下文切换，Go 可以调用 atomic 包在用户态完成原子操作来保证并发安全。</p>
<ul>
<li>原子操作支持的类型：<code>int32</code>、<code>int64</code>、<code>uint32</code>、<code>uint64</code>、<code>uintptr</code>、<code>unsafe.Pointer</code>，即整数和指针</li>
</ul>
<p>以 <code>int64</code> 为例，取变量地址用于操作</p>
<ul>
<li><p>读取</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atomic</span>.<span class="title">LoadInt64</span><span class="params">(addr *<span class="keyword">int64</span>)</span> <span class="params">(val <span class="keyword">int64</span>)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>写入</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atomic</span>.<span class="title">StoreInt64</span><span class="params">(addr *<span class="keyword">int64</span>, val <span class="keyword">int64</span>)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atomic</span>.<span class="title">AddInt64</span><span class="params">(addr *<span class="keyword">int64</span>, delta <span class="keyword">int64</span>)</span> <span class="params">(<span class="built_in">new</span> <span class="keyword">int64</span>)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>交换</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atomic</span>.<span class="title">SwapInt64</span><span class="params">(addr *<span class="keyword">int64</span>, <span class="built_in">new</span> <span class="keyword">int64</span>)</span> <span class="params">(old <span class="keyword">int64</span>)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>比较交换，交换前先检查当前值是否是 old，如是则交换成 new，如不是则不交换</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atomic</span>.<span class="title">CompareAndSwapInt64</span><span class="params">(addr *<span class="keyword">int64</span>, old <span class="keyword">int64</span>, <span class="built_in">new</span> <span class="keyword">int64</span>)</span> <span class="params">(swapped <span class="keyword">bool</span>)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="管道-Channel"><a href="#管道-Channel" class="headerlink" title="管道 Channel"></a>管道 Channel</h2><p>Go 的并发模型是 CSP，Communicating Sequential Process，提倡使用通信共享内存，而不是通过共享内存方式进行通信。</p>
<p>Go 可以通过共享内存来实现数据共享，使用锁来防止竞态，但这不可避免的加大了性能问题。由此引入了管道 Channel 的概念，用于 goroutine 之间通信。</p>
<h3 id="创建-Channel"><a href="#创建-Channel" class="headerlink" title="创建 Channel"></a>创建 Channel</h3><p>Channel 是引用类型，每个 Channel 都需要定义其允许传输的数据类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> 数据类型  <span class="comment">//零值为nil</span></span><br></pre></td></tr></table></figure>
<p>通道的零值为 <code>nil</code>，因此需要使用 <code>make</code> 来定义（缓冲区大小可缺省）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> 数据类型 [, 缓冲区大小])</span><br></pre></td></tr></table></figure>
<h3 id="Channel-操作"><a href="#Channel-操作" class="headerlink" title="Channel 操作"></a>Channel 操作</h3><p>在定义了 Channel 后，可对其进行下面操作，以 <code>int</code> 类型为例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>发送</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- <span class="number">10</span></span><br></pre></td></tr></table></figure>
<ol>
<li>当存在等待的接收者时，直接将数据发送给阻塞的接收者</li>
<li>当不存在等待的接收者，但缓冲区存在空余空间时，将数据写入缓冲区</li>
<li>当不存在等待的接收者，且不存在缓冲区或者缓冲区已满时，阻塞等待其他 goroutine 从 Channel 中接收数据</li>
</ol>
</li>
<li><p><strong>接收</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&lt;-ch <span class="comment">//丢弃通道值</span></span><br><span class="line">data := &lt;-ch <span class="comment">//接收通道值到data</span></span><br><span class="line">data, ok := &lt;-ch <span class="comment">//接收通道值到data，ok接收通道是否关闭（false，则通道已关闭）</span></span><br></pre></td></tr></table></figure>
<ol>
<li>当存在等待的发送者时，从阻塞的发送者或者缓冲区中获取数据</li>
<li>当不存在等待的发送者，但缓冲区存在数据时，从缓冲区接收数据</li>
<li>当不存在等待的发送者，且不存在缓冲区或者缓冲区不存在数据时，阻塞等待其他 goroutine 向 Channel 中发送数据</li>
</ol>
</li>
<li><p><strong>关闭</strong>，如果不再需要往通道发送值，则可以关闭通道，关闭通道不是必须的，可以自动通过垃圾回收机制回收</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>
<p>关闭后的通道：</p>
<ol>
<li>对关闭后的通道发送值会导致 panic</li>
<li>对关闭后的通道接收会一直获取到值，知道通道空</li>
<li>对关闭后且已经空的通道接收会得到对应数据类型的零值</li>
<li>关闭已经关闭的通道会导致 panic</li>
</ol>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Channel缓冲区</th>
<th>nil</th>
<th>非空</th>
<th>空</th>
<th>满</th>
<th>非空非满</th>
</tr>
</thead>
<tbody>
<tr>
<td>发送</td>
<td>阻塞</td>
<td>发送值</td>
<td>发送值</td>
<td>阻塞</td>
<td>发送值</td>
</tr>
<tr>
<td>接收</td>
<td>阻塞</td>
<td>接收值</td>
<td>阻塞</td>
<td>接收值</td>
<td>接收值</td>
</tr>
<tr>
<td>关闭</td>
<td>panic</td>
<td>关闭成功，读取所有数据后，返回零值</td>
<td>关闭成功，返回零值</td>
<td>关闭成功，读取所有数据后，返回零值</td>
<td>关闭成功，读取所有数据后，返回零值</td>
</tr>
</tbody>
</table>
</div>
<h3 id="无缓冲的通道"><a href="#无缓冲的通道" class="headerlink" title="无缓冲的通道"></a>无缓冲的通道</h3><p>无缓冲通道，又称阻塞通道、同步通道，定义 Channel 时不设置缓冲区大小即为无缓冲通道。</p>
<p>此类 Channel 发送和接收都无缓冲，所以无接收时发送会被阻塞，直到其他 goroutine 从该通道读取数据；同理，无发送时接收会被阻塞，直到其他 goroutine 发送到该通道。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/3.png" alt="无缓冲Channel"></p>
<p>下面错误用例，发送数据到 Channel，无接收，阻塞，无法运行到接收步骤，于是发生死锁报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	ch &lt;- <span class="number">10</span> <span class="comment">//无接收发送，死锁</span></span><br><span class="line">	data := &lt;-ch</span><br><span class="line">	fmt.Println(data)</span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要启动另一个 goroutine 接收，解开死锁</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recvFromChannel</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	data := &lt;-ch</span><br><span class="line">	fmt.Println(data)</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> recvFromChannel(ch)</span><br><span class="line">	ch &lt;- <span class="number">10</span></span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有缓冲的通道"><a href="#有缓冲的通道" class="headerlink" title="有缓冲的通道"></a>有缓冲的通道</h3><p>定义 Channel 时设置缓冲区大小即可设置为有缓冲通道，在缓冲区有剩余时，即使无接收者，也不阻塞发送。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/4.png" alt="有缓冲Channel"></p>
<p>上述死锁用例，加上缓冲区，即可正常运行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">//创建容量为1的缓冲区的通道</span></span><br><span class="line">	ch &lt;- <span class="number">10</span></span><br><span class="line">	data := &lt;-ch</span><br><span class="line">	fmt.Println(data)</span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h3><p>有些 goroutine 函数调用 Channel 仅需发送或者接收，则可以使用单向通道进行限制。</p>
<ul>
<li><p>只能发送的通道</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">chan</span>&lt;- <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>只能接收的通道</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&lt;-<span class="keyword">chan</span> <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>下面例子，两个函数一个仅需要发送，一个仅需要接收，即可传入单向通道</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recvFromChannel</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123; <span class="comment">//仅接收通道</span></span><br><span class="line">	data := &lt;-ch</span><br><span class="line">	fmt.Println(data)</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendToChannel</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123; <span class="comment">//仅发送通道</span></span><br><span class="line">	ch &lt;- <span class="number">10</span></span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> recvFromChannel(ch)</span><br><span class="line">	<span class="keyword">go</span> sendToChannel(ch)</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通道的遍历"><a href="#通道的遍历" class="headerlink" title="通道的遍历"></a>通道的遍历</h3><p>循环从通道取值的方法</p>
<p>方法一：使用 <code>for</code> 持续循环</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendToChannel</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		ch &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> sendToChannel(ch)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		data, ok := &lt;-ch</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(data)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：<code>for...range</code>，既可以循环取值，并且在通道关闭后退出</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendToChannel</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		ch &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> sendToChannel(ch)</span><br><span class="line">	<span class="keyword">for</span> data := <span class="keyword">range</span> ch &#123;</span><br><span class="line">		fmt.Println(data)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通道的调度"><a href="#通道的调度" class="headerlink" title="通道的调度"></a>通道的调度</h3><p>通过 <code>select</code> 随机运行一个接收到的 Channel 的 case</p>
<ol>
<li>如果有可接收的 Channel，则随机运行其中一个 case</li>
<li>如果没有可接收的 Channel，则运行 <code>default</code> case</li>
<li>如果没有可接收的 Channel，且没有 <code>default</code> case，则会阻塞直到有接收到 Channel</li>
</ol>
<p>使用无限 <code>for</code> 循环包裹 <code>select</code>，则可实现持续监听多个通道，触发相应操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> data1, ok := &lt;-ch1:</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      fmt.Println(<span class="string">"ch1 closed."</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ch1处理</span></span><br><span class="line">  <span class="keyword">case</span> &lt;-ch2:</span><br><span class="line">		<span class="comment">// ch2处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="sync-包"><a href="#sync-包" class="headerlink" title="sync 包"></a>sync 包</h1><h2 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h2><p>在多线程并发过程中，如果主协程结束，其他 goroutine 也会跟着结束，所以经常需要让主协程等待其他 goroutine 结束。使用 <code>time.Sleep</code> 过于生硬，不合适。于是引入了 <code>sync.WaitGroup</code> 处理该问题 。</p>
<ul>
<li><code>(wg * WaitGroup) Add(delta int)</code>：计数器 + delta</li>
<li><code>(wg *WaitGroup) Done()</code>：计数器 -1</li>
<li><code>(wg *WaitGroup) Wait()</code>：阻塞直到计数器变为 0</li>
</ul>
<p>每开一个并发 goroutine 就让计数器 +1，并发 goroutine 结束时则让计数器 -1，主协程调用 <code>Wait()</code> 阻塞直到所有 goroutine 结束，计数器清零。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup <span class="comment">//声明一个WaitGroup</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Done() <span class="comment">//一个goroutine结束，计数器-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	numGoroutine := <span class="number">4</span></span><br><span class="line">	wg.Add(numGoroutine) <span class="comment">//计数器+并发goroutine数</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numGoroutine; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> funcA()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait() <span class="comment">//主协程阻塞直到所有goroutine跑完</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h2><p><code>sync.Once</code> 提供函数只执行一次的方法，如初始化配置、数据库连接此类并发只需要调用一次的函数，可用此方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span></span><br></pre></td></tr></table></figure>
<p>下面示例，<code>funcA</code> 和 <code>funcB</code> 都需要调用 <code>InitConfig</code> 函数，使用 <code>sync.Once</code>，可使得该函数只被调用一次。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	wg   sync.WaitGroup</span><br><span class="line">	once sync.Once <span class="comment">//声明once</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitConfig</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Init Configuration"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">()</span></span> &#123;</span><br><span class="line">	once.Do(InitConfig) <span class="comment">//并发只调用一次</span></span><br><span class="line">	fmt.Println(<span class="string">"function A"</span>)</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcB</span><span class="params">()</span></span> &#123;</span><br><span class="line">	once.Do(InitConfig) <span class="comment">//并发只调用一次</span></span><br><span class="line">	fmt.Println(<span class="string">"function B"</span>)</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> funcA()</span><br><span class="line">	<span class="keyword">go</span> funcB()</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Init Configuration</span><br><span class="line">function B</span><br><span class="line">function A</span><br></pre></td></tr></table></figure>
<h2 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h2><p>Go 原生的 map 并不是并发安全的，需要额外加锁。sync 包提供 <code>sync.Map</code> 则是一种并发安全的 map，无需加锁。内置了诸如Store、Load、LoadOrStore、Delete、Range等操作方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"strconv"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	wg   sync.WaitGroup</span><br><span class="line">	once sync.Once</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := sync.Map&#123;&#125; <span class="comment">//定义map</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			key := strconv.Itoa(n)</span><br><span class="line">			m.Store(key, n) <span class="comment">//存值</span></span><br><span class="line">			value, _ := m.Load(key) <span class="comment">//取值</span></span><br><span class="line">			fmt.Printf(<span class="string">"key: %v, value: %v\n"</span>, key, value)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><h2 id="周期性定时器-ticker"><a href="#周期性定时器-ticker" class="headerlink" title="周期性定时器 ticker"></a>周期性定时器 ticker</h2><p>ticker 是周期性定时器，除非主动停止，就会一直循环计时下去。如果希望每隔一段时间执行一次，推荐使用 <code>ticker</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>用法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>func time.NewTicker(d time.Duration) *time.Ticker</code></td>
<td>定义一个定时器 ticker，每隔一个间隔时间就会向 <code>.C</code> 通道发送当前时间</td>
</tr>
<tr>
<td><code>func (t *time.Ticker) Stop()</code></td>
<td>回收资源，否则会产生内存泄漏</td>
</tr>
<tr>
<td><code>&lt;-t.C</code></td>
<td>每隔一个设置的时间就会从通道接收到当前时间</td>
</tr>
</tbody>
</table>
</div>
<p>以下示例，每隔 5s 输出当前时间</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ticker := time.NewTicker(<span class="number">5</span> * time.Second) <span class="comment">//定义5s一次的定时器</span></span><br><span class="line">	<span class="keyword">defer</span> ticker.Stop() <span class="comment">//回收资源</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(t *time.Ticker)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"Time: "</span>, time.Now().Format(<span class="string">"2006-01-02 15:04:05"</span>))</span><br><span class="line">			&lt;-t.C <span class="comment">//每隔5s触发一次</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(ticker)</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">15</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一次性定时器-timer"><a href="#一次性定时器-timer" class="headerlink" title="一次性定时器 timer"></a>一次性定时器 timer</h2><p>timer 是一次性定时器，只计时一次，重新开始计时需要重置。如果希望只执行一次，或者需要重新设置间隔时间的，推荐使用 <code>timer</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>用法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>func time.NewTimer(d time.Duration) *time.Timer</code></td>
<td>定义一个定时器 timer，过一个间隔时间后会向 <code>.C</code> 通道发送当前时间</td>
</tr>
<tr>
<td><code>&lt;-t.C</code></td>
<td>过一个设置的时间从通道接收到当前时间</td>
</tr>
<tr>
<td><code>func (t *time.Timer) Stop() bool</code></td>
<td>停止当前计时，如果当前在计时，则返回 true，并不会再发送到通道；如果不在计时中，则返回 fasle</td>
</tr>
<tr>
<td><code>func (t *time.Timer) Reset(d time.Duration) bool</code></td>
<td>重置计时器，如果现在正在计时，则停止当前计时，重新计时（返回同 <code>Stop</code>）</td>
</tr>
</tbody>
</table>
</div>
<p>以下示例，使用一次性计时器 timer 模拟周期性计时器 ticker</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	timer := time.NewTimer(<span class="number">5</span> * time.Second) <span class="comment">//定义一次性计时器timer</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"Time: "</span>, time.Now().Format(<span class="string">"2006-01-02 15:04:05"</span>))</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(t *time.Timer)</span></span> &#123;</span><br><span class="line">		times := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			&lt;-t.C <span class="comment">//计时</span></span><br><span class="line">			fmt.Println(<span class="string">"Time: "</span>, time.Now().Format(<span class="string">"2006-01-02 15:04:05"</span>))</span><br><span class="line"></span><br><span class="line">			times++</span><br><span class="line">			t.Reset(<span class="number">5</span> * time.Second) <span class="comment">//重新开始计时</span></span><br><span class="line">			<span class="keyword">if</span> times &gt; <span class="number">3</span> &#123;</span><br><span class="line">				t.Stop() <span class="comment">//停止计时</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(timer)</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">30</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><p><a href="https://www.topgoer.com/并发编程/" target="_blank" rel="noopener">并发编程</a></p>
</li>
<li><p><a href="https://hedon954.github.io/noteSite/backend/golang/high/goroutine_channel.html" target="_blank" rel="noopener">Golang 并发编程</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建记录</title>
    <url>/2020/02/25/Hexo%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>记录Hexo博客的搭建过程。包括Hexo的书写技巧与主题优化。</p>
<a id="more"></a>
<h1 id="Hexo书写技巧"><a href="#Hexo书写技巧" class="headerlink" title="Hexo书写技巧"></a>Hexo书写技巧</h1><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><h3 id="Hexo引入数学公式"><a href="#Hexo引入数学公式" class="headerlink" title="Hexo引入数学公式"></a>Hexo引入数学公式</h3><p>Hexo默认不支持数学公式，需要引入数学公式的响应环境。</p>
<ol>
<li><p>更换Hexo的markdown渲染引擎</p>
<p> 卸载原有的渲染器 <code>hexo-renderer-marked</code>，安装渲染器<code>hexo-renderer-kramed</code></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked</span><br><span class="line">npm install hexo-renderer-kramed</span><br></pre></td></tr></table></figure>
</li>
<li><p>在next主题中开启mathJax开关</p>
<p>在 <code>next/_config.yml</code> 中将 <code>mathjax</code> 的 <code>enable</code> 打开。</p>
<figure class="highlight yaml"><figcaption><span>/themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># per_page为true，则需要每页自己添加`mathjax: true`；</span></span><br><span class="line"><span class="comment"># per_page为false，则每页自动允许数学公式</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">engine:</span> <span class="string">mathjax</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mhchem:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如此即可在每片文章中自动允许数学公式。</p>
<h3 id="数学公式书写规则"><a href="#数学公式书写规则" class="headerlink" title="数学公式书写规则"></a>数学公式书写规则</h3><p>Hexo的markdown数学公式书写规则与Latex相同，具体规则见 <a href="https://gy23333.github.io/2020/02/13/Latex入门/#数学公式">Latex入门/数学公式</a></p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><h3 id="Hexo引入flowchart流程图"><a href="#Hexo引入flowchart流程图" class="headerlink" title="Hexo引入flowchart流程图"></a>Hexo引入flowchart流程图</h3><p>Hexo默认不支持markdown的流程图，需安装<a href="https://github.com/bubkoo/hexo-filter-flowchart" target="_blank" rel="noopener">hexo-filter-flowchart插件</a>。</p>
<ol>
<li>安装hexo-filter-flowchart插件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-filter-flowchart</span><br></pre></td></tr></table></figure></li>
<li><p>在主题配置文件下添加flowchart配置</p>
 <figure class="highlight yaml"><figcaption><span>/themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">flowchart:</span></span><br><span class="line"><span class="comment"># raphael:   # optional, the source url of raphael.js</span></span><br><span class="line"><span class="comment"># flowchart: # optional, the source url of flowchart.js</span></span><br><span class="line"><span class="attr">options:</span> <span class="comment"># options used for `drawSVG`</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>绘制流程图</p>
<p>范例：下列代码包在flow之间</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"flowchart-0"</span> <span class="attr">class</span>=<span class="string">"flow-chart"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<div id="flowchart-1" class="flow-chart"></div>

<h3 id="流程图绘制规则"><a href="#流程图绘制规则" class="headerlink" title="流程图绘制规则"></a>流程图绘制规则</h3><p>流程图语法分为两个部分：</p>
<ul>
<li>前半部分：定义流程图元素</li>
<li>后半部分：连接流程图元素</li>
</ul>
<p>前半部分定义元素的语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tag&#x3D;&gt;type: content:&gt;url</span><br></pre></td></tr></table></figure>
<ul>
<li><code>tag</code>：元素标签，连接元素时用来代表元素。名称可以任意，一般为流程的英文缩写和数字的组合。</li>
<li><code>type</code>：元素类型，一共有6种类型，分别为<code>start</code>、<code>end</code>、<code>operation</code>、<code>subroutine</code>、<code>condition</code>、<code>inputoutput</code></li>
<li><code>content</code>：文本框中的内容，注意<code>type:</code>和<code>content</code>间一定要有空格</li>
<li><code>url</code>：文本绑定的链接，点击可跳转</li>
</ul>
<p>后半部分连接流程图元素</p>
<ul>
<li>用<code>-&gt;</code>来连接两个元素</li>
<li><code>condition</code>类型有<code>yes</code>和<code>no</code>两个分支，如<code>cond(yes)</code>和<code>cond(no)</code></li>
<li>每个元素可以制定分支走向，默认向下，也可以用right指向右边，如<code>sub1(right)</code></li>
</ul>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;flowchart-2&quot; class&#x3D;&quot;flow-chart&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<div id="flowchart-3" class="flow-chart"></div>

<h3 id="Hexo引入Mermaid流程图"><a href="#Hexo引入Mermaid流程图" class="headerlink" title="Hexo引入Mermaid流程图"></a>Hexo引入Mermaid流程图</h3><ol>
<li>安装hexo-filter-mermaid-diagrams插件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-filter-mermaid-diagrams</span><br></pre></td></tr></table></figure></li>
<li><p>在主题配置文件下添加mermaid配置</p>
 <figure class="highlight yaml"><figcaption><span>/themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Mermaid tag</span></span><br><span class="line"><span class="attr">mermaid:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Available themes: default | dark | forest | neutral</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">forest</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><a href="https://mermaid.js.org/intro/" target="_blank" rel="noopener">Mermaid官方文档</a></p>
<p><a href="https://mermaid.live/" target="_blank" rel="noopener">Mermaid在线编辑器</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/440934038" target="_blank" rel="noopener">简单教程</a></p>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>markdown的代码块写法有两种——<code>```...``` </code>和<code>{ % ... % }</code>，这里主要使用<code>```...``` </code>来实现功能。</p>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><h4 id="写法一"><a href="#写法一" class="headerlink" title="写法一"></a>写法一</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;[language] [title] [url] [link text]</span><br><span class="line">code snippet</span><br><span class="line">&#96;&#96;&#96;</span><br></pre></td></tr></table></figure>
<ul>
<li>language: 语言名称，引导渲染引擎正确解析并高亮显示关键字</li>
<li>title: 代码块标题，将会显示在左上角</li>
<li>url: 链接地址，如果没有指定 link text 则会在右上角显示 link</li>
<li>link text: 链接名称，指定 url 后有效，将会显示在右上角</li>
</ul>
<p>url 必须为有效链接地址才会以链接的形式显示在右上角，否则将作为标题显示在左上角。以 url 为分界，左侧除了第一个单词会被解析为 language，其他所有单词都会被解析为 title，而右侧的所有单词都会被解析为 link text。</p>
<p>如果不想填写 title，可以在 language 和 url 之间添加至少三个空格。</p>
<ul>
<li><p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;C HelloWorld https:&#x2F;&#x2F;gy23333.github.io&#x2F;2020&#x2F;02&#x2F;25&#x2F;Hexo搭建记录&#x2F; 下载地址</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;hello world\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;</span><br></pre></td></tr></table></figure>
</li>
<li><p>效果</p>
<figure class="highlight c"><figcaption><span>HelloWorld</span><a href="https://gy23333.github.io/2020/02/25/Hexo搭建记录/">下载地址</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="写法二"><a href="#写法二" class="headerlink" title="写法二"></a>写法二</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock [title] [lang:language] [url] [link text] [additional options] %&#125;</span><br><span class="line">code snippet</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h3><ul>
<li><p>格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock [lang:language] %&#125;</span><br><span class="line">code snippet</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock lang:C %&#125;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;hello world\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>效果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="设置标题"><a href="#设置标题" class="headerlink" title="设置标题"></a>设置标题</h3><ul>
<li><p>格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock [title] %&#125;</span><br><span class="line">code snippet</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock HelloWorld %&#125;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;hello world\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>效果</p>
<figure class="highlight plain"><figcaption><span>HelloWorld</span></figcaption><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;hello world\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="设置链接"><a href="#设置链接" class="headerlink" title="设置链接"></a>设置链接</h3><ul>
<li><p>格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock [url] [link text] %&#125;</span><br><span class="line">code snippet</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock HelloWorld lang:C https:&#x2F;&#x2F;gy23333.github.io&#x2F;2020&#x2F;02&#x2F;25&#x2F;Hexo搭建记录&#x2F; 下载地址 %&#125;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;hello world\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>效果</p>
<figure class="highlight c"><figcaption><span>HelloWorld</span><a href="https://gy23333.github.io/2020/02/25/Hexo搭建记录/">下载地址</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="是否显示行号"><a href="#是否显示行号" class="headerlink" title="是否显示行号"></a>是否显示行号</h3><ul>
<li><p>格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock [line_number:(true|false)] %&#125;</span><br><span class="line">code snippet</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>
<p><code>line_number</code>的默认值为true。</p>
</li>
<li><p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock lang:C line_number:false %&#125;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;hello world\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>效果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="设置起始行号"><a href="#设置起始行号" class="headerlink" title="设置起始行号"></a>设置起始行号</h3><ul>
<li><p>格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock [first_line:number] %&#125;</span><br><span class="line">code snippet</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>
<p><code>first_line</code>的默认值为1。</p>
</li>
<li><p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock lang:C first_line:10 %&#125;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;hello world\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>效果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<!-- ### 标记选定行

在站点配置文件中设置`highlight.auto_detect: true`来开启自动语言检测高亮。

<figure class="highlight yml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line"><span class="bullet">-</span>  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line"><span class="string">+</span>  <span class="attr">auto_detect:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">''</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hljs:</span> <span class="literal">false</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<ul>
<li><p>格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock [mark:#,#-#] %&#125;</span><br><span class="line">code snippet</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>
<p><code>#</code>代表行号，<code>#-#</code>代表行号范围。</p>
</li>
<li><p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock lang:C mark:1,3-6 %&#125;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;hello world\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>效果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line marked"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line marked"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line marked">    <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line marked">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line marked">&#125;</span><br></pre></td></tr></table></figure> -->
</li>
</ul>
<h3 id="设置代码添加删除标记"><a href="#设置代码添加删除标记" class="headerlink" title="设置代码添加删除标记"></a>设置代码添加删除标记</h3><p>设置语言为 diff，可以在代码前添加 + 和 - 来使用如上所示的高亮增删行提示效果。</p>
<ul>
<li><p>格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock lang:diff %&#125;</span><br><span class="line">code snippet</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock lang:diff %&#125;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">-    printf(&quot;delete\n&quot;);</span><br><span class="line">+    printf(&quot;add\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>效果</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"><span class="deletion">-    printf("delete\n");</span></span><br><span class="line"><span class="addition">+    printf("add\n");</span></span><br><span class="line">    return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Aplayer音乐播放器"><a href="#Aplayer音乐播放器" class="headerlink" title="Aplayer音乐播放器"></a>Aplayer音乐播放器</h2><p>&emsp;&emsp;在blog中添加一个音乐播放页面 <a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md" target="_blank" rel="noopener">Aplayer官方中文文档</a></p>
<h3 id="新建音乐页面"><a href="#新建音乐页面" class="headerlink" title="新建音乐页面"></a>新建音乐页面</h3><ol>
<li>新建一个页面</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page music</span><br></pre></td></tr></table></figure>
<ol>
<li><p>在新生成的  /source/music/index.md  中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 歌单</span><br><span class="line">date: 2020-02-25 19:50:11</span><br><span class="line">type: &quot;music&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在主题的 _config.yml文件中，设置页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">home: &#x2F; || home</span><br><span class="line">archives: &#x2F;archives&#x2F; || archive</span><br><span class="line">categories: &#x2F;categories&#x2F; || th</span><br><span class="line">tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">music: &#x2F;music&#x2F; || music</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>页面创建成功！</p>
<h3 id="使用hexo-tag-aplayer插件"><a href="#使用hexo-tag-aplayer插件" class="headerlink" title="使用hexo-tag-aplayer插件"></a>使用hexo-tag-aplayer插件</h3><ol>
<li>安装hexo-tag-aplayer</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-tag-aplayer</span><br></pre></td></tr></table></figure>
<ol>
<li><p>MeingJS支持</p>
<p><a href="https://github.com/metowolf/MetingJS" target="_blank" rel="noopener">    MetingJS</a> 是基于<a href="https://github.com/metowolf/Meting" target="_blank" rel="noopener">Meting API</a> 的 APlayer 衍生播放器，引入 MetingJS 后，播放器将支持对于 QQ音乐、网易云音乐、虾米、酷狗、百度等平台的音乐播放。</p>
<p>如果想在本插件中使用 MetingJS，请在 Hexo 配置文件 <code>_config.yml</code> 中设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aplayer:</span><br><span class="line">  meting: true</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 MetingJS 播放器</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- 简单示例 (id, server, type)  --&gt;</span></span></span><br><span class="line">&#123;% meting "60198" "netease" "playlist" %&#125;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 进阶示例 --&gt;</span></span></span><br><span class="line">&#123;% meting "60198" "netease" "playlist" "autoplay" "mutex:false" "listmaxheight:340px" "preload:none" "theme:#ad7a86"%&#125;</span><br></pre></td></tr></table></figure>
<p>有关选项列表如下:</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td><strong>必须值</strong></td>
<td>歌曲 id / 播放列表 id / 相册 id / 搜索关键字</td>
</tr>
<tr>
<td>server</td>
<td><strong>必须值</strong></td>
<td>音乐平台: <code>netease</code>, <code>tencent</code>, <code>kugou</code>, <code>xiami</code>, <code>baidu</code></td>
</tr>
<tr>
<td>type</td>
<td><strong>必须值</strong></td>
<td><code>song</code>（单首歌）, <code>playlist</code>（歌单）, <code>album</code>, <code>search</code>, <code>artist</code></td>
</tr>
<tr>
<td>fixed</td>
<td><code>false</code></td>
<td>开启固定模式</td>
</tr>
<tr>
<td>mini</td>
<td><code>false</code></td>
<td>开启迷你模式</td>
</tr>
<tr>
<td>loop</td>
<td><code>all</code></td>
<td>列表循环模式：<code>all</code>, <code>one</code>,<code>none</code></td>
</tr>
<tr>
<td>order</td>
<td><code>list</code></td>
<td>列表播放模式： <code>list</code>, <code>random</code></td>
</tr>
<tr>
<td>volume</td>
<td>0.7</td>
<td>播放器音量</td>
</tr>
<tr>
<td>lrctype</td>
<td>0</td>
<td>歌词格式类型</td>
</tr>
<tr>
<td>listfolded</td>
<td><code>false</code></td>
<td>指定音乐播放列表是否折叠</td>
</tr>
<tr>
<td>storagename</td>
<td><code>metingjs</code></td>
<td>LocalStorage 中存储播放器设定的键名</td>
</tr>
<tr>
<td>autoplay</td>
<td><code>true</code></td>
<td>自动播放，移动端浏览器暂时不支持此功能</td>
</tr>
<tr>
<td>mutex</td>
<td><code>true</code></td>
<td>该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停</td>
</tr>
<tr>
<td>listmaxheight</td>
<td><code>340px</code></td>
<td>播放列表的最大长度</td>
</tr>
<tr>
<td>preload</td>
<td><code>auto</code></td>
<td>音乐文件预载入模式，可选项： <code>none</code>, <code>metadata</code>, <code>auto</code></td>
</tr>
<tr>
<td>theme</td>
<td><code>#ad7a86</code></td>
<td>播放器风格色彩设置</td>
</tr>
</tbody>
</table>
</div>
<p>   配置结束！</p>
<p><img src="https://i.loli.net/2020/02/25/fuqwxW43kozZTVR.png" style="zoom: 20%;" /></p>
<h3 id="手动建立歌单（不推荐）"><a href="#手动建立歌单（不推荐）" class="headerlink" title="手动建立歌单（不推荐）"></a>手动建立歌单（不推荐）</h3><p>强迫症可手动将各平台的歌单整合在一起，这里提供一个<a href="https://music.liuzhijin.cn/" target="_blank" rel="noopener">下载各平台音乐的神器</a>。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% aplayerlist %&#125;</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">    "narrow": false,                          // （可选）播放器袖珍风格</span></span><br><span class="line"><span class="code">    "autoplay": true,                         // （可选) 自动播放，移动端浏览器暂时不支持此功能</span></span><br><span class="line"><span class="code">    "mode": "random",                         // （可选）曲目循环类型，有 'random'（随机播放）, 'single' (单曲播放), 'circulation' (循环播放), 'order' (列表播放)， 默认：'circulation' </span></span><br><span class="line"><span class="code">    "showlrc": 3,                             // （可选）歌词显示配置项，可选项有：1,2,3</span></span><br><span class="line"><span class="code">    "mutex": true,                            // （可选）该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停</span></span><br><span class="line"><span class="code">    "theme": "#e6d0b2",	                      // （可选）播放器风格色彩设置，默认：#b7daff</span></span><br><span class="line"><span class="code">    "preload": "metadata",                    // （可选）音乐文件预载入模式，可选项： 'none' 'metadata' 'auto', 默认: 'auto'</span></span><br><span class="line"><span class="code">    "listmaxheight": "513px",                 // (可选) 该播放列表的最大长度</span></span><br><span class="line"><span class="code">    "music": [</span></span><br><span class="line"><span class="code">        &#123;</span></span><br><span class="line"><span class="code">            "title": "CoCo",</span></span><br><span class="line"><span class="code">            "author": "Jeff Williams",</span></span><br><span class="line"><span class="code">            "url": "caffeine.mp3",</span></span><br><span class="line"><span class="code">            "pic": "caffeine.jpeg",</span></span><br><span class="line"><span class="code">            "lrc": "caffeine.txt"</span></span><br><span class="line"><span class="code">        &#125;,</span></span><br><span class="line"><span class="code">        &#123;</span></span><br><span class="line"><span class="code">            "title": "アイロニ",</span></span><br><span class="line"><span class="code">            "author": "鹿乃",</span></span><br><span class="line"><span class="code">            "url": "irony.mp3",</span></span><br><span class="line"><span class="code">            "pic": "irony.jpg"</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">    ]</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;% endaplayerlist %&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Hexo主题优化"><a href="#Hexo主题优化" class="headerlink" title="Hexo主题优化"></a>Hexo主题优化</h1><h2 id="个性化回到顶部"><a href="#个性化回到顶部" class="headerlink" title="个性化回到顶部"></a>个性化回到顶部</h2><p>​    猫耳FM同款回到顶部插件。</p>
<ol>
<li><a href="https://i.loli.net/2020/03/13/oCTlu4gV8GYNm2O.png" target="_blank" rel="noopener">下载图片</a>，将其添加到主题页面的 source\images\ 下；</li>
<li>在 /themes/next/source/css/_common/components/back-to-top.styl 中添加</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义回到顶部样式</span></span><br><span class="line">@media screen and (<span class="attribute">min-width</span>: <span class="number">900px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.back-to-top</span> &#123;</span><br><span class="line">      <span class="attribute">right</span>: <span class="number">60px</span>;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">70px</span>;  <span class="comment">//图片素材宽度</span></span><br><span class="line">      <span class="attribute">height</span>: <span class="number">900px</span>;  <span class="comment">//图片素材高度</span></span><br><span class="line">      <span class="attribute">top</span>: -<span class="number">900px</span>;</span><br><span class="line">      <span class="attribute">bottom</span>: unset;</span><br><span class="line">      transition: all .5s ease-in-out;</span><br><span class="line">      <span class="attribute">background</span>: url(<span class="string">"/images/scroll.png"</span>);</span><br><span class="line">      <span class="attribute">position</span>: fixed;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//隐藏箭头图标</span></span><br><span class="line">      &gt; <span class="selector-tag">i</span> &#123;</span><br><span class="line">        <span class="attribute">display</span>: none;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &amp;<span class="selector-class">.back-to-top-on</span> &#123;</span><br><span class="line">        <span class="attribute">bottom</span>: unset;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">100vh</span> &lt; (<span class="number">900px</span> + <span class="number">200px</span>) ? calc( <span class="number">100vh</span> - <span class="number">900px</span> - <span class="number">200px</span> ) : <span class="number">0px</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>效果图</p>
<p><img src="https://i.loli.net/2020/03/13/QjJ314LNwvZeOhg.gif" alt="scroll.gif"></p>
<h2 id="鼠标点击效果"><a href="#鼠标点击效果" class="headerlink" title="鼠标点击效果"></a>鼠标点击效果</h2><p>​    参考<a href="http://yearito.cn/" target="_blank" rel="noopener">Yearito’s Blog</a>有下面四种鼠标点击效果。在 themes\next\source\js\cursor\ 中加入下列js文件</p>
<div class="tabs" id="鼠标点击效果代码"><ul class="nav-tabs"><li class="tab active"><a href="#鼠标点击效果代码-1">explosion.min.js</a></li><li class="tab"><a href="#鼠标点击效果代码-2">love.min.js</a></li><li class="tab"><a href="#鼠标点击效果代码-3">fireworks.js</a></li><li class="tab"><a href="#鼠标点击效果代码-4">text.js</a></li></ul><div class="tab-content"><div class="tab-pane active" id="鼠标点击效果代码-1"><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;<span class="function"><span class="keyword">function</span> <span class="title">updateCoords</span>(<span class="params">e</span>)</span>&#123;pointerX=(e.clientX||e.touches[<span class="number">0</span>].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[<span class="number">0</span>].clientY-canvasEl.getBoundingClientRect().top&#125;<span class="function"><span class="keyword">function</span> <span class="title">setParticuleDirection</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> t=anime.random(<span class="number">0</span>,<span class="number">360</span>)*<span class="built_in">Math</span>.PI/<span class="number">180</span>,a=anime.random(<span class="number">50</span>,<span class="number">180</span>),n=[<span class="number">-1</span>,<span class="number">1</span>][anime.random(<span class="number">0</span>,<span class="number">1</span>)]*a;<span class="keyword">return</span>&#123;<span class="attr">x</span>:e.x+n*<span class="built_in">Math</span>.cos(t),<span class="attr">y</span>:e.y+n*<span class="built_in">Math</span>.sin(t)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">createParticule</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a=&#123;&#125;;<span class="keyword">return</span> a.x=e,a.y=t,a.color=colors[anime.random(<span class="number">0</span>,colors.length<span class="number">-1</span>)],a.radius=anime.random(<span class="number">16</span>,<span class="number">32</span>),a.endPos=setParticuleDirection(a),a.draw=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI,!<span class="number">0</span>),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;<span class="function"><span class="keyword">function</span> <span class="title">createCircle</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a=&#123;&#125;;<span class="keyword">return</span> a.x=e,a.y=t,a.color=<span class="string">"#F00"</span>,a.radius=<span class="number">.1</span>,a.alpha=<span class="number">.5</span>,a.lineWidth=<span class="number">6</span>,a.draw=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI,!<span class="number">0</span>),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=<span class="number">1</span>&#125;,a&#125;<span class="function"><span class="keyword">function</span> <span class="title">renderParticule</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> t=<span class="number">0</span>;t&lt;e.animatables.length;t++)e.animatables[t].target.draw()&#125;<span class="function"><span class="keyword">function</span> <span class="title">animateParticules</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> a=createCircle(e,t),n=[],i=<span class="number">0</span>;i&lt;numberOfParticules;i++)n.push(createParticule(e,t));anime.timeline().add(&#123;<span class="attr">targets</span>:n,<span class="attr">x</span>:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> e.endPos.x&#125;,<span class="attr">y</span>:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> e.endPos.y&#125;,<span class="attr">radius</span>:<span class="number">.1</span>,<span class="attr">duration</span>:anime.random(<span class="number">1200</span>,<span class="number">1800</span>),<span class="attr">easing</span>:<span class="string">"easeOutExpo"</span>,<span class="attr">update</span>:renderParticule&#125;).add(&#123;<span class="attr">targets</span>:a,<span class="attr">radius</span>:anime.random(<span class="number">80</span>,<span class="number">160</span>),<span class="attr">lineWidth</span>:<span class="number">0</span>,<span class="attr">alpha</span>:&#123;<span class="attr">value</span>:<span class="number">0</span>,<span class="attr">easing</span>:<span class="string">"linear"</span>,<span class="attr">duration</span>:anime.random(<span class="number">600</span>,<span class="number">800</span>)&#125;,<span class="attr">duration</span>:anime.random(<span class="number">1200</span>,<span class="number">1800</span>),<span class="attr">easing</span>:<span class="string">"easeOutExpo"</span>,<span class="attr">update</span>:renderParticule,<span class="attr">offset</span>:<span class="number">0</span>&#125;)&#125;<span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a;<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> n=<span class="keyword">this</span>,i=<span class="built_in">arguments</span>;clearTimeout(a),a=setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;e.apply(n,i)&#125;,t)&#125;&#125;<span class="keyword">var</span> canvasEl=<span class="built_in">document</span>.querySelector(<span class="string">".fireworks"</span>);<span class="keyword">if</span>(canvasEl)&#123;<span class="keyword">var</span> ctx=canvasEl.getContext(<span class="string">"2d"</span>),numberOfParticules=<span class="number">30</span>,pointerX=<span class="number">0</span>,pointerY=<span class="number">0</span>,tap=<span class="string">"mousedown"</span>,colors=[<span class="string">"#FF1461"</span>,<span class="string">"#18FF92"</span>,<span class="string">"#5A87FF"</span>,<span class="string">"#FBF38C"</span>],setCanvasSize=debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;canvasEl.width=<span class="number">2</span>*<span class="built_in">window</span>.innerWidth,canvasEl.height=<span class="number">2</span>*<span class="built_in">window</span>.innerHeight,canvasEl.style.width=<span class="built_in">window</span>.innerWidth+<span class="string">"px"</span>,canvasEl.style.height=<span class="built_in">window</span>.innerHeight+<span class="string">"px"</span>,canvasEl.getContext(<span class="string">"2d"</span>).scale(<span class="number">2</span>,<span class="number">2</span>)&#125;,<span class="number">500</span>),render=anime(&#123;<span class="attr">duration</span>:<span class="number">1</span>/<span class="number">0</span>,<span class="attr">update</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.clearRect(<span class="number">0</span>,<span class="number">0</span>,canvasEl.width,canvasEl.height)&#125;&#125;);<span class="built_in">document</span>.addEventListener(tap,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="string">"sidebar"</span>!==e.target.id&amp;&amp;<span class="string">"toggle-sidebar"</span>!==e.target.id&amp;&amp;<span class="string">"A"</span>!==e.target.nodeName&amp;&amp;<span class="string">"IMG"</span>!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!<span class="number">1</span>),setCanvasSize(),<span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>,setCanvasSize,!<span class="number">1</span>)&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="鼠标点击效果代码-2"><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e,t,a</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params"></span>)</span>&#123;c(<span class="string">".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"</span>),o(),r()&#125;<span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params"></span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> e=<span class="number">0</span>;e&lt;d.length;e++)d[e].alpha&lt;=<span class="number">0</span>?(t.body.removeChild(d[e].el),d.splice(e,<span class="number">1</span>)):(d[e].y--,d[e].scale+=<span class="number">.004</span>,d[e].alpha-=<span class="number">.013</span>,d[e].el.style.cssText=<span class="string">"left:"</span>+d[e].x+<span class="string">"px;top:"</span>+d[e].y+<span class="string">"px;opacity:"</span>+d[e].alpha+<span class="string">";transform:scale("</span>+d[e].scale+<span class="string">","</span>+d[e].scale+<span class="string">") rotate(45deg);background:"</span>+d[e].color+<span class="string">";z-index:99999"</span>);requestAnimationFrame(r)&#125;<span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> t=<span class="string">"function"</span>==<span class="keyword">typeof</span> e.onclick&amp;&amp;e.onclick;e.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;t&amp;&amp;t(),i(e)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">"div"</span>);a.className=<span class="string">"heart"</span>,d.push(&#123;<span class="attr">el</span>:a,<span class="attr">x</span>:e.clientX<span class="number">-5</span>,<span class="attr">y</span>:e.clientY<span class="number">-5</span>,<span class="attr">scale</span>:<span class="number">1</span>,<span class="attr">alpha</span>:<span class="number">1</span>,<span class="attr">color</span>:s()&#125;),t.body.appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">"style"</span>);a.type=<span class="string">"text/css"</span>;<span class="keyword">try</span>&#123;a.appendChild(t.createTextNode(e))&#125;<span class="keyword">catch</span>(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span><span class="string">"rgb("</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">","</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">","</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">")"</span>&#125;<span class="keyword">var</span> d=[];e.requestAnimationFrame=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;setTimeout(e,<span class="number">1e3</span>/<span class="number">60</span>)&#125;&#125;(),n()&#125;(<span class="built_in">window</span>,<span class="built_in">document</span>);</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="鼠标点击效果代码-3"><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(&#123; origin, speed, color, angle, context &#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.origin = origin</span><br><span class="line">    <span class="keyword">this</span>.position = &#123; ...this.origin &#125;</span><br><span class="line">    <span class="keyword">this</span>.color = color</span><br><span class="line">    <span class="keyword">this</span>.speed = speed</span><br><span class="line">    <span class="keyword">this</span>.angle = angle</span><br><span class="line">    <span class="keyword">this</span>.context = context</span><br><span class="line">    <span class="keyword">this</span>.renderCount = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  draw() &#123;</span><br><span class="line">    <span class="keyword">this</span>.context.fillStyle = <span class="keyword">this</span>.color</span><br><span class="line">    <span class="keyword">this</span>.context.beginPath()</span><br><span class="line">    <span class="keyword">this</span>.context.arc(<span class="keyword">this</span>.position.x, <span class="keyword">this</span>.position.y, <span class="number">2</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">this</span>.context.fill()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  move() &#123;</span><br><span class="line">    <span class="keyword">this</span>.position.x = (<span class="built_in">Math</span>.sin(<span class="keyword">this</span>.angle) * <span class="keyword">this</span>.speed) + <span class="keyword">this</span>.position.x</span><br><span class="line">    <span class="keyword">this</span>.position.y = (<span class="built_in">Math</span>.cos(<span class="keyword">this</span>.angle) * <span class="keyword">this</span>.speed) + <span class="keyword">this</span>.position.y + (<span class="keyword">this</span>.renderCount * <span class="number">0.3</span>)</span><br><span class="line">    <span class="keyword">this</span>.renderCount++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boom</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (&#123; origin, context, circleCount = <span class="number">16</span>, area &#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.origin = origin</span><br><span class="line">    <span class="keyword">this</span>.context = context</span><br><span class="line">    <span class="keyword">this</span>.circleCount = circleCount</span><br><span class="line">    <span class="keyword">this</span>.area = area</span><br><span class="line">    <span class="keyword">this</span>.stop = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.circles = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  randomArray(range) &#123;</span><br><span class="line">    <span class="keyword">const</span> length = range.length</span><br><span class="line">    <span class="keyword">const</span> randomIndex = <span class="built_in">Math</span>.floor(length * <span class="built_in">Math</span>.random())</span><br><span class="line">    <span class="keyword">return</span> range[randomIndex]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  randomColor() &#123;</span><br><span class="line">    <span class="keyword">const</span> range = [<span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'#'</span> + <span class="keyword">this</span>.randomArray(range) + <span class="keyword">this</span>.randomArray(range) + <span class="keyword">this</span>.randomArray(range) + <span class="keyword">this</span>.randomArray(range) + <span class="keyword">this</span>.randomArray(range) + <span class="keyword">this</span>.randomArray(range)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  randomRange(start, end) &#123;</span><br><span class="line">    <span class="keyword">return</span> (end - start) * <span class="built_in">Math</span>.random() + start</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.circleCount; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> circle = <span class="keyword">new</span> Circle(&#123;</span><br><span class="line">        context: <span class="keyword">this</span>.context,</span><br><span class="line">        origin: <span class="keyword">this</span>.origin,</span><br><span class="line">        color: <span class="keyword">this</span>.randomColor(),</span><br><span class="line">        angle: <span class="keyword">this</span>.randomRange(<span class="built_in">Math</span>.PI - <span class="number">1</span>, <span class="built_in">Math</span>.PI + <span class="number">1</span>),</span><br><span class="line">        speed: <span class="keyword">this</span>.randomRange(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">this</span>.circles.push(circle)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  move() &#123;</span><br><span class="line">    <span class="keyword">this</span>.circles.forEach(<span class="function">(<span class="params">circle, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (circle.position.x &gt; <span class="keyword">this</span>.area.width || circle.position.y &gt; <span class="keyword">this</span>.area.height) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.circles.splice(index, <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      circle.move()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.circles.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.stop = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  draw() &#123;</span><br><span class="line">    <span class="keyword">this</span>.circles.forEach(<span class="function"><span class="params">circle</span> =&gt;</span> circle.draw())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CursorSpecialEffects</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.computerCanvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>)</span><br><span class="line">    <span class="keyword">this</span>.renderCanvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.computerContext = <span class="keyword">this</span>.computerCanvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line">    <span class="keyword">this</span>.renderContext = <span class="keyword">this</span>.renderCanvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.globalWidth = <span class="built_in">window</span>.innerWidth</span><br><span class="line">    <span class="keyword">this</span>.globalHeight = <span class="built_in">window</span>.innerHeight</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.booms = []</span><br><span class="line">    <span class="keyword">this</span>.running = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleMouseDown(e) &#123;</span><br><span class="line">    <span class="keyword">const</span> boom = <span class="keyword">new</span> Boom(&#123;</span><br><span class="line">      origin: &#123; <span class="attr">x</span>: e.clientX, <span class="attr">y</span>: e.clientY &#125;,</span><br><span class="line">      context: <span class="keyword">this</span>.computerContext,</span><br><span class="line">      area: &#123;</span><br><span class="line">        width: <span class="keyword">this</span>.globalWidth,</span><br><span class="line">        height: <span class="keyword">this</span>.globalHeight</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    boom.init()</span><br><span class="line">    <span class="keyword">this</span>.booms.push(boom)</span><br><span class="line">    <span class="keyword">this</span>.running || <span class="keyword">this</span>.run()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handlePageHide() &#123;</span><br><span class="line">    <span class="keyword">this</span>.booms = []</span><br><span class="line">    <span class="keyword">this</span>.running = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">const</span> style = <span class="keyword">this</span>.renderCanvas.style</span><br><span class="line">    style.position = <span class="string">'fixed'</span></span><br><span class="line">    style.top = style.left = <span class="number">0</span></span><br><span class="line">    style.zIndex = <span class="string">'999999999999999999999999999999999999999999'</span></span><br><span class="line">    style.pointerEvents = <span class="string">'none'</span></span><br><span class="line"></span><br><span class="line">    style.width = <span class="keyword">this</span>.renderCanvas.width = <span class="keyword">this</span>.computerCanvas.width = <span class="keyword">this</span>.globalWidth</span><br><span class="line">    style.height = <span class="keyword">this</span>.renderCanvas.height = <span class="keyword">this</span>.computerCanvas.height = <span class="keyword">this</span>.globalHeight</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.body.append(<span class="keyword">this</span>.renderCanvas)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'mousedown'</span>, <span class="keyword">this</span>.handleMouseDown.bind(<span class="keyword">this</span>))</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'pagehide'</span>, <span class="keyword">this</span>.handlePageHide.bind(<span class="keyword">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="keyword">this</span>.running = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.booms.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.running = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    requestAnimationFrame(<span class="keyword">this</span>.run.bind(<span class="keyword">this</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.computerContext.clearRect(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.globalWidth, <span class="keyword">this</span>.globalHeight)</span><br><span class="line">    <span class="keyword">this</span>.renderContext.clearRect(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.globalWidth, <span class="keyword">this</span>.globalHeight)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.booms.forEach(<span class="function">(<span class="params">boom, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (boom.stop) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.booms.splice(index, <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      boom.move()</span><br><span class="line">      boom.draw()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.renderContext.drawImage(<span class="keyword">this</span>.computerCanvas, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.globalWidth, <span class="keyword">this</span>.globalHeight)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cursorSpecialEffects = <span class="keyword">new</span> CursorSpecialEffects()</span><br><span class="line">cursorSpecialEffects.init()</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="鼠标点击效果代码-4"><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a_idx = <span class="number">0</span>;</span><br><span class="line">jQuery(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line">  $(<span class="string">"body"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"喜欢我"</span>, <span class="string">"不喜欢我"</span>);</span><br><span class="line">    <span class="keyword">var</span> $i = $(<span class="string">"&lt;span/&gt;"</span>).text(a[a_idx]);</span><br><span class="line">    <span class="keyword">var</span> x = e.pageX,</span><br><span class="line">    y = e.pageY;</span><br><span class="line">    $i.css(&#123;</span><br><span class="line">      <span class="string">"z-index"</span>: <span class="number">99999</span>,</span><br><span class="line">      <span class="string">"top"</span>: y - <span class="number">28</span>,</span><br><span class="line">      <span class="string">"left"</span>: x - a[a_idx].length * <span class="number">8</span>,</span><br><span class="line">      <span class="string">"position"</span>: <span class="string">"absolute"</span>,</span><br><span class="line">      <span class="string">"color"</span>: <span class="string">"#ff7a45"</span></span><br><span class="line">    &#125;);</span><br><span class="line">    $(<span class="string">"body"</span>).append($i);</span><br><span class="line">    $i.animate(&#123;</span><br><span class="line">      <span class="string">"top"</span>: y - <span class="number">180</span>,</span><br><span class="line">      <span class="string">"opacity"</span>: <span class="number">0</span></span><br><span class="line">    &#125;, <span class="number">1500</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      $i.remove();</span><br><span class="line">    &#125;);</span><br><span class="line">    a_idx = (a_idx + <span class="number">1</span>) % a.length;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div></div></div>
<p>​    在 themes\next\layout_custom\custom.swig 中加入</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;# 鼠标点击特效 #&#125;</span><br><span class="line">&#123;% if theme.cursor_effect == "fireworks" %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"/js/cursor/fireworks.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% elseif theme.cursor_effect == "explosion" %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">class</span>=<span class="string">"fireworks"</span> <span class="attr">style</span>=<span class="string">"position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"</span> &gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.bootcss.com/animejs/2.2.0/anime.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"/js/cursor/explosion.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% elseif theme.cursor_effect == "love" %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"/js/cursor/love.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% elseif theme.cursor_effect == "text" %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"/js/cursor/text.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>​    如果 custom.swig 文件不存在，需要手动新建并在布局页面 themes\next\layout_layout.swig 中 body 末尾引入：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% include '_custom/custom.swig' %&#125;</span><br></pre></td></tr></table></figure>
<p>​    在主题配置文件 themes\next_config.yml 中添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mouse click effect: fireworks | explosion | love | text</span><br><span class="line">cursor_effect: fireworks</span><br></pre></td></tr></table></figure>
<p>​    则可通过配置主题配置文件来设置鼠标点击效果。</p>
<p>​    如explosion的效果</p>
<p><img src="https://i.loli.net/2020/03/16/KDVTNgcn7uxvmjS.gif" alt="explosion.gif"></p>
<h1 id="Hexo常见问题"><a href="#Hexo常见问题" class="headerlink" title="Hexo常见问题"></a>Hexo常见问题</h1><h2 id="hexo-d报错"><a href="#hexo-d报错" class="headerlink" title="hexo d报错"></a>hexo d报错</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal: Authentication failed for ‘https:&#x2F;&#x2F;github.com&#x2F;gy23333&#x2F;gy23333.github.io.git&#x2F;‘</span><br></pre></td></tr></table></figure>
<p>Github开启二次验证后导致博客提交错误，解决方法参考<a href="http://fezl.me/2017/05/20/GitHub二次验证带来的问题/" target="_blank" rel="noopener">GitHub二次验证带来的问题</a>。</p>
<p>生成<strong>Personal access tokens</strong>令牌码，使用该码作为密码登录。</p>
<ol>
<li>登录Github</li>
<li>Setttings -&gt; Developer Settings -&gt; Personal access tokens -&gt; Generate new token</li>
<li>设定token的Expiration为no expiration（永久），全选scopes</li>
<li>生成token，复制记录</li>
<li>hexo d，输入Github用户名和密码（token）</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo官方文档</a></li>
<li><a href="http://yearito.cn/posts/hexo-writing-skills.html" target="_blank" rel="noopener">Yearito’s Blog|Hexo 搭建个人博客系列：写作技巧篇</a></li>
<li><a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/MATH.md" target="_blank" rel="noopener">数学公式</a></li>
<li><a href="https://www.ofind.cn/blog/HEXO/HEXO下的语法高亮拓展修改.html#设置代码添加删除标记" target="_blank" rel="noopener">猪猪侠 | Hexo 下的语法高亮拓展修改</a><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">   st=>start: Start|past:>http://www.google.com[blank]
   e=>end: End:>http://www.google.com
   op1=>operation: My Operation|past
   op2=>operation: Stuff|current
   sub1=>subroutine: My Subroutine|invalid
   cond=>condition: Yes
   or No?|approved:>http://www.google.com
   c2=>condition: Good idea|rejected
   io=>inputoutput: catch something...|request
   
   st->op1(right)->cond
   cond(yes, right)->c2
   cond(no)->sub1(left)->op1
   c2(yes)->io->e
   c2(no)->op2->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">st=>start: Start|past:>http://www.google.com[blank]
e=>end: End:>http://www.google.com
op1=>operation: My Operation|past
op2=>operation: Stuff|current
sub1=>subroutine: My Subroutine|invalid
cond=>condition: Yes
or No?|approved:>http://www.google.com
c2=>condition: Good idea|rejected
io=>inputoutput: catch something...|request

st->op1(right)->cond
cond(yes, right)->c2
cond(no)->sub1(left)->op1
c2(yes)->io->e
c2(no)->op2->e</textarea><textarea id="flowchart-1-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script><textarea id="flowchart-2-code" style="display: none">st=>start: 开始
op1=>operation: 操作1
cond1=>condition: Yes or No?
sub=>subroutine: 子程序
e=>end: 结束

st->op1->cond1
cond1(yes)->e
cond1(no)->sub(right)->op1</textarea><textarea id="flowchart-2-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-2-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-2-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-2", options);</script><textarea id="flowchart-3-code" style="display: none">st=>start: 开始
op1=>operation: 操作1
cond1=>condition: Yes or No?
sub=>subroutine: 子程序
e=>end: 结束

st->op1->cond1
cond1(yes)->e
cond1(no)->sub(right)->op1</textarea><textarea id="flowchart-3-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-3-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-3-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-3", options);</script></li>
</ol>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML基础教程</title>
    <url>/2020/07/08/HTML%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>HTML基础知识总结。</p>
<a id="more"></a>
<h1 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h1><h2 id="基本标签"><a href="#基本标签" class="headerlink" title="基本标签"></a>基本标签</h2><div class="table-container">
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;html&gt;</code></td>
<td>HTML</td>
<td></td>
</tr>
<tr>
<td><code>&lt;body&gt;</code></td>
<td>主体</td>
<td></td>
</tr>
<tr>
<td><code>&lt;h1&gt;</code>～<code>&lt;h6&gt;</code></td>
<td>标题</td>
<td>从一级标题到六级标题，由大到小</td>
</tr>
<tr>
<td><code>&lt;p&gt;</code></td>
<td>段落</td>
<td>浏览器会自动地在段落的前后添加空行，如果在不产生一个新段落的情况下进行换行用<code>&lt;br /&gt;</code></td>
</tr>
<tr>
<td><code>&lt;br /&gt;</code></td>
<td>换行</td>
<td></td>
</tr>
<tr>
<td><code>&lt;a&gt;</code></td>
<td>链接</td>
<td>例<code>&lt;a href=&quot;http://www.w3school.com.cn&quot;&gt;This is a link&lt;/a&gt;</code></td>
</tr>
<tr>
<td><code>&lt;img&gt;</code></td>
<td>图像</td>
<td>例<code>&lt;img src=&quot;XXXX.jpg&quot; width=&quot;104&quot; height=&quot;142&quot; /&gt;</code></td>
</tr>
<tr>
<td><code>&lt;hr /&gt;</code></td>
<td>水平线</td>
<td></td>
</tr>
<tr>
<td><code>&lt;q&gt;</code></td>
<td>短引用</td>
<td></td>
</tr>
<tr>
<td><code>&lt;blockquote&gt;</code></td>
<td>长引用</td>
<td></td>
</tr>
<tr>
<td><code>&lt;abbr&gt;</code></td>
<td>缩略词</td>
</tr>
</tbody>
</table>
</div>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><div class="table-container">
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;table&gt;</code></td>
<td>表格</td>
</tr>
<tr>
<td><code>&lt;caption&gt;</code></td>
<td>标题</td>
</tr>
<tr>
<td><code>&lt;th&gt;</code></td>
<td>表头</td>
</tr>
<tr>
<td><code>&lt;tr&gt;</code></td>
<td>行</td>
</tr>
<tr>
<td><code>&lt;td&gt;</code></td>
<td>单元</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>head1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>head2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>border=&quot;1&quot;</code>则显示边框，<code>border=&quot;0&quot;</code>则不显示边框。</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><div class="table-container">
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;ol&gt;</code></td>
<td>有序列表</td>
</tr>
<tr>
<td><code>&lt;ul&gt;</code></td>
<td>无序列表</td>
</tr>
<tr>
<td><code>&lt;li&gt;</code></td>
<td>列表项</td>
</tr>
</tbody>
</table>
</div>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Tea<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 网络</title>
    <url>/2023/10/11/Linux-%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><a id="more"></a>
<h1 id="内核如何收包"><a href="#内核如何收包" class="headerlink" title="内核如何收包"></a>内核如何收包</h1><p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/202310112358835.png" alt=""></p>
<ol>
<li><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1></li>
</ol>
<ul>
<li><a href="http://arthurchiao.art/blog/linux-net-stack-implementation-rx-zh/" target="_blank" rel="noopener">Linux 网络栈接收数据</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Latex入门</title>
    <url>/2020/02/13/Latex%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>​    Latex是基于Tex的排版系统，可以方便的生成复杂公式，常常应用于论文的编写。本文介绍在Mac环境下利用Texpad编写Latex。</p>
<a id="more"></a>
<h1 id="在Mac环境下编写Latex"><a href="#在Mac环境下编写Latex" class="headerlink" title="在Mac环境下编写Latex"></a>在Mac环境下编写Latex</h1><h2 id="MacTeX"><a href="#MacTeX" class="headerlink" title="MacTeX"></a>MacTeX</h2><p>​    在Mac环境下必需下载相应的 <a href="http://www.tug.org/mactex/" target="_blank" rel="noopener">MacTeX</a></p>
<p>​    下载完成后会得到下面四个app。</p>
<p><img src="https://i.loli.net/2020/02/14/9sVQ2d3Mbhlkw7R.png" alt=""></p>
<p>​    其中TeXShop是Latex的编辑器，但功能较为简单，建议使用Sublime+Skim 或 TeXpad</p>
<p><img src="https://i.loli.net/2020/02/14/jBlypUZEQof3rPa.png" style="zoom:25%;" /></p>
<h2 id="Texpad"><a href="#Texpad" class="headerlink" title="Texpad"></a>Texpad</h2><p>​    一款功能强大的Latex编辑器 <a href="https://www.texpad.com/mac" target="_blank" rel="noopener">Texpad for macOS</a></p>
<h1 id="Latex"><a href="#Latex" class="headerlink" title="Latex"></a>Latex</h1><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>​    每个tex文件都包含导言区和正文区，导言区用于设置全局设置，正文区用于编写显示的内容。</p>
<h3 id="导言区"><a href="#导言区" class="headerlink" title="导言区"></a>导言区</h3><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span> <span class="comment">%文件类型，会根据不同的文件类型有不同的排版，例如article, book, letter等等</span></span><br></pre></td></tr></table></figure>
<h4 id="标题区"><a href="#标题区" class="headerlink" title="标题区"></a>标题区</h4><p>​    包括title、author、date等等，在正文中调用 </p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">maketitle</span></span></span><br></pre></td></tr></table></figure>
<p>​    此时，会显示标题区内容。</p>
<h3 id="正文区"><a href="#正文区" class="headerlink" title="正文区"></a>正文区</h3><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><p>​    正文部分直接输入，但是要注意：</p>
<ul>
<li><strong>使用空行分段</strong>。单个换行不会引起分段，必须中间有空行，多个空行和一个空行效果一致。</li>
<li><strong>段前不用空格</strong>。Latex会自动段前缩进，即使段前打了空格也会被省略。</li>
<li><strong>汉字后的空格会被省略</strong>，但英文字母之间不会，<strong>多个空格和一个空格效果一致</strong>。</li>
</ul>
<h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p>​    在 $ $ 中插入公式——行内公式，公式处于行内；</p>
<p>​    在 <script type="math/tex"> </script> 中插入公式——行间公式，公式前后自动换行，公式居中。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% exemple.tex</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%--------------------导言区-------------------</span></span><br><span class="line"><span class="comment">% 用于设置性质（全局设置），自定义一些命令</span></span><br><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span> <span class="comment">%文件类型，会根据不同的文件类型有不同的排版，例如article, book, letter等等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%----------标题区------------</span></span><br><span class="line"><span class="tag">\<span class="name">title</span><span class="string">&#123;Tex Introduction&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">author</span><span class="string">&#123;GuoYi&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">date</span><span class="string">&#123;\today&#125;</span></span> <span class="comment">%\today会自动同步到今天</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%--------------------正文区-------------------</span></span><br><span class="line"><span class="comment">% 一个tex有且只有一个document部分</span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">maketitle</span></span> <span class="comment">%实际输出标题区</span></span><br><span class="line">	</span><br><span class="line">	Hello world!</span><br><span class="line">	<span class="comment">% 正文中空行表换行</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">% $行内公式$    $$行间公式$$</span></span><br><span class="line">	Let <span class="formula">$f(x)$</span> be defined by the formula <span class="formula">$$f(x)=2sinx$$</span> which is a polynomial of degree 2.</span><br><span class="line">	</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/26/hkyaGXwelrmYAnc.png" style="zoom: 33%;" /></p>
<h2 id="Latex使用中文"><a href="#Latex使用中文" class="headerlink" title="Latex使用中文"></a>Latex使用中文</h2><h3 id="CTEX文档（推荐）"><a href="#CTEX文档（推荐）" class="headerlink" title="CTEX文档（推荐）"></a>CTEX文档（推荐）</h3><p>​    在UTF-8编码情况下，使用CTEX文档。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">[UTF8]</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">title</span><span class="string">&#123;标题&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">maketitle</span></span></span><br><span class="line">	中文输入。&#123;<span class="tag">\<span class="name">kaishu</span></span> 这里是楷体显示&#125;，&#123;<span class="tag">\<span class="name">songti</span></span> 这里是宋体显示&#125;，&#123;<span class="tag">\<span class="name">heiti</span></span> 这里是黑体显示&#125;，&#123;<span class="tag">\<span class="name">fangsong</span></span> 这里是仿宋显示&#125;。</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/26/y6KGMubvTBifnlm.png" style="zoom: 33%;" /></p>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><h3 id="字体族"><a href="#字体族" class="headerlink" title="字体族"></a>字体族</h3><p>​    字体族共有3种：罗马字体族（Roman Family）、无衬线字体族（Sans Serif Family）、打字机字体族（Typewriter Family）。</p>
<p>​    正文一般默认使用罗马字体族，可用下面两种字体族命令规定字体族。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">[UTF8]</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="comment">%字体族设置（罗马字体族、无衬线字体族、打字机字体族）</span></span><br><span class="line">	<span class="tag">\<span class="name">textrm</span><span class="string">&#123;Roman Family&#125;</span></span> <span class="tag">\<span class="name">textsf</span><span class="string">&#123;Sans Serif Family&#125;</span></span> <span class="tag">\<span class="name">texttt</span><span class="string">&#123;Typewriter Family&#125;</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">\<span class="name">rmfamily</span></span> Roman Family <span class="tag">\<span class="name">sffamily</span></span> Sans Serif Family <span class="tag">\<span class="name">ttfamily</span></span> Typewriter Family</span><br><span class="line">	</span><br><span class="line">	&#123;<span class="tag">\<span class="name">rmfamily</span></span> Roman Family&#125; &#123;<span class="tag">\<span class="name">sffamily</span></span> Sans Serif Family&#125; &#123;<span class="tag">\<span class="name">ttfamily</span></span> Typewriter Family&#125;</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/26/12yNEJrgSjRtMYP.png" alt="截屏2020-02-26上午1.47.37.png" style="zoom:50%;" /></p>
<h3 id="字体系列"><a href="#字体系列" class="headerlink" title="字体系列"></a>字体系列</h3><p>​    字体系列共有2种：中等（medium）、加宽加粗（bold extended）。</p>
<p>​    正文默认使用中等字体系列。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">[UTF8]</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="comment">%字体系列设置(粗细、宽度)</span></span><br><span class="line">	<span class="tag">\<span class="name">textmd</span><span class="string">&#123;Medium Series&#125;</span></span> <span class="tag">\<span class="name">textbf</span><span class="string">&#123;Boldface Series&#125;</span></span></span><br><span class="line">	</span><br><span class="line">	&#123;<span class="tag">\<span class="name">mdseries</span></span> Medium Series&#125; &#123;<span class="tag">\<span class="name">bfseries</span></span> Boldface Series&#125;	</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/26/Tw8QglBP2iMde4r.png" style="zoom: 50%;" /></p>
<h3 id="字体形状"><a href="#字体形状" class="headerlink" title="字体形状"></a>字体形状</h3><p>​    字体形状共有4种：直立（Upright Shape）、意大利（Italic Shape）、倾斜（Slanted Shape）、小型大写（Small Caps Shape）。</p>
<p>​    正文默认使用直立字体形状。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">[UTF8]</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="comment">%字体形状（直立、意大利、倾斜、小型大写）</span></span><br><span class="line">	<span class="tag">\<span class="name">textup</span><span class="string">&#123;Upright Shape&#125;</span></span> <span class="tag">\<span class="name">textit</span><span class="string">&#123;Italic Shape&#125;</span></span> <span class="tag">\<span class="name">textsl</span><span class="string">&#123;Slanted Shape&#125;</span></span> <span class="tag">\<span class="name">textsc</span><span class="string">&#123;Small Caps Shape&#125;</span></span></span><br><span class="line">	</span><br><span class="line">	&#123;<span class="tag">\<span class="name">upshape</span></span> Upright Shape&#125; &#123;<span class="tag">\<span class="name">itshape</span></span> Italic Shape&#125; &#123;<span class="tag">\<span class="name">slshape</span></span> Slanted Shape&#125; &#123;<span class="tag">\<span class="name">scshape</span></span> Small Caps Shape&#125;</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/26/Ch8rzKNc7Omg5Tp.png" style="zoom:50%;" /></p>
<h3 id="中文字体"><a href="#中文字体" class="headerlink" title="中文字体"></a>中文字体</h3><p>​    中文字体共有4种：宋体、黑体、仿宋、楷书。</p>
<p>​    ctexart文体，正文中的中文默认为宋体。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">[UTF8]</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="comment">%中文字体（宋体、黑体、仿宋、楷书）</span></span><br><span class="line">	&#123;<span class="tag">\<span class="name">songti</span></span> 宋体&#125; <span class="tag">\<span class="name">quad</span></span> &#123;<span class="tag">\<span class="name">heiti</span></span> 黑体&#125; <span class="tag">\<span class="name">quad</span></span> &#123;<span class="tag">\<span class="name">fangsong</span></span> 仿宋&#125; <span class="tag">\<span class="name">quad</span></span> &#123;<span class="tag">\<span class="name">kaishu</span></span> 楷书&#125;</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span> <span class="comment">%\quad为tap</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/26/qbpSzFWyQ1VOHBT.png" alt="截屏2020-02-26上午2.13.50.png" style="zoom:50%;" /></p>
<p>​    中文字体同样包含粗体和斜体。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">[UTF8]</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="comment">%中文字体的粗体和斜体</span></span><br><span class="line">	中文字体的<span class="tag">\<span class="name">textbf</span><span class="string">&#123;粗体&#125;</span></span>和<span class="tag">\<span class="name">textit</span><span class="string">&#123;斜体&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/26/h9zcbTYlMIZHFNa.png" alt="截屏2020-02-26上午2.20.15.png" style="zoom:50%;" /></p>
<h3 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h3><h4 id="英文字体大小"><a href="#英文字体大小" class="headerlink" title="英文字体大小"></a>英文字体大小</h4><p>​    以\normalsize的大小为基础，来设置字体大小。</p>
<p>​    正文字体默认为\normalsize，\normalsize字体大小默认为10pt。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">[12pt]</span><span class="string">&#123;ctexart&#125;</span></span> <span class="comment">%[]中可设置normalsize字体大小</span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="comment">% 字体大小</span></span><br><span class="line">	&#123;<span class="tag">\<span class="name">tiny</span></span>			tiny&#125;<span class="tag">\<span class="name">\</span></span> <span class="comment">% \\为换行</span></span><br><span class="line">	&#123;<span class="tag">\<span class="name">scriptsize</span></span>		scriptsize&#125;<span class="tag">\<span class="name">\</span></span></span><br><span class="line">	&#123;<span class="tag">\<span class="name">footnotesize</span></span>	footnotesize&#125;<span class="tag">\<span class="name">\</span></span></span><br><span class="line">	&#123;<span class="tag">\<span class="name">small</span></span>			small&#125;<span class="tag">\<span class="name">\</span></span></span><br><span class="line">	&#123;<span class="tag">\<span class="name">normalsize</span></span>		normalsize&#125;<span class="tag">\<span class="name">\</span></span></span><br><span class="line">	&#123;<span class="tag">\<span class="name">large</span></span>			large&#125;<span class="tag">\<span class="name">\</span></span></span><br><span class="line">	&#123;<span class="tag">\<span class="name">Large</span></span>			Large&#125;<span class="tag">\<span class="name">\</span></span></span><br><span class="line">	&#123;<span class="tag">\<span class="name">LARGE</span></span>			LARGE&#125;<span class="tag">\<span class="name">\</span></span></span><br><span class="line">	&#123;<span class="tag">\<span class="name">huge</span></span>			huge&#125;<span class="tag">\<span class="name">\</span></span></span><br><span class="line">	&#123;<span class="tag">\<span class="name">Huge</span></span>			Huge&#125;<span class="tag">\<span class="name">\</span></span></span><br><span class="line">		</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/26/1i7YuFMclHEzfsN.png" style="zoom:67%;" /></p>
<h4 id="中文字体大小"><a href="#中文字体大小" class="headerlink" title="中文字体大小"></a>中文字体大小</h4><p>​    以五号字体的大小为基础，来设置字体大小。</p>
<p>​    正文字体默认为 五号字体。</p>
<p><img src="https://i.loli.net/2020/02/26/LkzfSin341vI5E8.png" alt="截屏2020-02-26上午2.46.40.png" style="zoom:50%;" /></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="comment">% 中文字体大小</span></span><br><span class="line">	<span class="tag">\<span class="name">zihao</span><span class="string">&#123;2&#125;</span></span> 二号中文字体</span><br><span class="line">	</span><br><span class="line">	<span class="tag">\<span class="name">zihao</span><span class="string">&#123;-2&#125;</span></span> 小二号中文字体</span><br><span class="line">	</span><br><span class="line">	<span class="tag">\<span class="name">zihao</span><span class="string">&#123;5&#125;</span></span> 五号中文字体</span><br><span class="line">	</span><br><span class="line">	<span class="tag">\<span class="name">zihao</span><span class="string">&#123;-5&#125;</span></span> 小五号中文字体</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/26/lJ5SONLVvAEBke8.png" alt="截屏2020-02-26上午2.44.21.png" style="zoom:50%;" /></p>
<h2 id="篇章结构"><a href="#篇章结构" class="headerlink" title="篇章结构"></a>篇章结构</h2><h3 id="提纲"><a href="#提纲" class="headerlink" title="提纲"></a>提纲</h3><p>​    \section可以在正文中构建小节，相当于一级标题，在section前加sub套娃形成二级、三级、四级等等标题。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">section</span><span class="string">&#123;section title&#125;</span></span> <span class="comment">%一级标题</span></span><br><span class="line">	<span class="tag">\<span class="name">subsection</span><span class="string">&#123;subsection title&#125;</span></span> <span class="comment">%二级标题</span></span><br><span class="line">	<span class="tag">\<span class="name">subsubsection</span><span class="string">&#123;subsubsection title&#125;</span></span> <span class="comment">%三级标题</span></span><br><span class="line">	<span class="tag">\<span class="name">section</span><span class="string">&#123;section title&#125;</span></span> <span class="comment">%三级标题</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/26/C5s8Ed4cU1SPnWD.png" alt="截屏2020-02-26下午7.11.30.png" style="zoom: 67%;" /></p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>​    \tableofcontents 可生成目录。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">tableofcontents</span></span> <span class="comment">%生成目录</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">\<span class="name">section</span><span class="string">&#123;section title&#125;</span></span> <span class="comment">%一级标题</span></span><br><span class="line">	<span class="tag">\<span class="name">subsection</span><span class="string">&#123;subsection title&#125;</span></span> <span class="comment">%二级标题</span></span><br><span class="line">	<span class="tag">\<span class="name">section</span><span class="string">&#123;section title&#125;</span></span> <span class="comment">%三级标题</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/26/7lUf5wrPQDF6sCc.png" style="zoom: 80%;" /></p>
<h3 id="正文-1"><a href="#正文-1" class="headerlink" title="正文"></a>正文</h3><ul>
<li><strong>使用空行分段</strong>。单个换行不会引起分段，必须中间有空行，多个空行和一个空行效果一致。</li>
<li><strong>段前不用空格</strong>。Latex会自动段前缩进，即使段前打了空格也会被省略。</li>
<li><strong>汉字后的空格会被省略</strong>，但英文字母之间不会，<strong>多个空格和一个空格效果一致</strong>。</li>
<li><strong>\ \  用来换行</strong>。换行不会新开一个段落。</li>
<li><strong>\par 分段。</strong>一般不使用。</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	This is an article. This is an article. This is an article.</span><br><span class="line">	<span class="comment">%空行——新开一个段落</span></span><br><span class="line">	</span><br><span class="line">	This is an article. This is an article. This is an article.<span class="tag">\<span class="name">\</span></span>Change the line. Change the line. Change the line.  <span class="comment">% \\——换行</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/26/tV6QrHE5Ab8MGp7.png" alt=""></p>
<h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><h3 id="空白符号"><a href="#空白符号" class="headerlink" title="空白符号"></a>空白符号</h3><ul>
<li>英文字符之间多个空格当一个空格处理，中文字符之间的空格无效；</li>
<li>中文之间插入英文，在英文片段前后自动添加空格；</li>
<li>其他空格命令</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>\quad</td>
<td>1em的空白（推荐）</td>
</tr>
<tr>
<td>\qquad</td>
<td>2em的空白</td>
</tr>
<tr>
<td>\,</td>
<td>1/6em的空白</td>
</tr>
<tr>
<td>\thinspace</td>
<td>1/6em的空白</td>
</tr>
<tr>
<td>\enspace</td>
<td>0.5em的空白</td>
</tr>
<tr>
<td>\</td>
<td>空格（推荐）</td>
</tr>
<tr>
<td>～</td>
<td>硬空格</td>
</tr>
<tr>
<td>\kern 指定宽度</td>
<td>产生指定宽度的空白（宽度可为副值）</td>
</tr>
<tr>
<td>\hspace{指定宽度}</td>
<td>产生指定宽度的空白（宽度可为副值）</td>
</tr>
<tr>
<td>\hphantom{}</td>
<td>占位宽度的空格（空格长度等于{}内的字符应有的长度）</td>
</tr>
<tr>
<td>\hfill</td>
<td>产生一行的空格（前后分别在行首和行尾）</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="comment">% 1em的空白</span></span><br><span class="line">	a<span class="tag">\<span class="name">textbackslash</span></span> quad b --------------- a<span class="tag">\<span class="name">quad</span></span> b</span><br><span class="line">	</span><br><span class="line">	<span class="comment">% 2em的空白</span></span><br><span class="line">	a<span class="tag">\<span class="name">textbackslash</span></span> qquad b -------------- a<span class="tag">\<span class="name">qquad</span></span> b</span><br><span class="line">	</span><br><span class="line">	<span class="comment">% 1/6em的空白</span></span><br><span class="line">	a<span class="tag">\<span class="name">textbackslash</span></span>,b --------------------- a<span class="tag">\<span class="name">,</span></span>b</span><br><span class="line">	</span><br><span class="line">	<span class="comment">% 1/6em的空白</span></span><br><span class="line">	a<span class="tag">\<span class="name">textbackslash</span></span> thinspace b --------- a<span class="tag">\<span class="name">thinspace</span></span> b</span><br><span class="line">	</span><br><span class="line">	<span class="comment">% 0.5em的空白</span></span><br><span class="line">	a<span class="tag">\<span class="name">textbackslash</span></span> enspace b ------------ a<span class="tag">\<span class="name">enspace</span></span> b</span><br><span class="line">	</span><br><span class="line">	<span class="comment">% 空格</span></span><br><span class="line">	a<span class="tag">\<span class="name">textbackslash</span></span> b ----------------------- a<span class="tag">\<span class="name"> </span></span>b</span><br><span class="line">	</span><br><span class="line">	<span class="comment">% 硬空格</span></span><br><span class="line">	a<span class="tag">\<span class="name">~</span></span>b ------------------------ a~b</span><br><span class="line">	</span><br><span class="line">	<span class="comment">% 产生指定宽度的空白（宽度可为副值）</span></span><br><span class="line">	a<span class="tag">\<span class="name">textbackslash</span></span> kern 1em b ----------- a<span class="tag">\<span class="name">kern</span></span> 1em b</span><br><span class="line">	</span><br><span class="line">	<span class="comment">% 产生指定宽度的空白（宽度可为副值）</span></span><br><span class="line">	a<span class="tag">\<span class="name">textbackslash</span></span> hspace<span class="tag">\<span class="name">&#123;</span></span>1em<span class="tag">\<span class="name">&#125;</span></span>b ------ a<span class="tag">\<span class="name">hspace</span><span class="string">&#123;1em&#125;</span></span> b</span><br><span class="line">	</span><br><span class="line">	<span class="comment">% 占位宽度的空格（空格长度等于&#123;&#125;内的字符应有的长度）</span></span><br><span class="line">	a<span class="tag">\<span class="name">textbackslash</span></span> hphantom<span class="tag">\<span class="name">&#123;</span></span>xyz<span class="tag">\<span class="name">&#125;</span></span>b --- a<span class="tag">\<span class="name">hphantom</span><span class="string">&#123;xyz&#125;</span></span>b</span><br><span class="line">	</span><br><span class="line">	<span class="comment">% 产生一行的空格（前后分别在行首和行尾）</span></span><br><span class="line">	a<span class="tag">\<span class="name">textbackslash</span></span> hfill b ------------------ a<span class="tag">\<span class="name">hfill</span></span> b</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/28/i1cq6Go2mMXb9tR.png" alt=""></p>
<h3 id="控制符"><a href="#控制符" class="headerlink" title="控制符"></a>控制符</h3><p>​    对于有特殊含义的符号，要想其正常显示，需在符号前加 \ ，而 \ 本身由于\ \表示换行，所以用 \textbacklash 表示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>控制符</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>\</td>
<td>\textbackslash</td>
</tr>
<tr>
<td>#</td>
<td>\#</td>
</tr>
<tr>
<td>$</td>
<td>\$</td>
</tr>
<tr>
<td>{}</td>
<td>\{\}</td>
</tr>
</tbody>
</table>
</div>
<h3 id="排版符号"><a href="#排版符号" class="headerlink" title="排版符号"></a>排版符号</h3><div class="table-container">
<table>
<thead>
<tr>
<th>排版符号</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>§</td>
<td>\S</td>
</tr>
<tr>
<td>¶</td>
<td>\P</td>
</tr>
<tr>
<td>†</td>
<td>\dag</td>
</tr>
<tr>
<td>‡</td>
<td>\ddag</td>
</tr>
<tr>
<td>©</td>
<td>\copyright</td>
</tr>
<tr>
<td>£</td>
<td>\pounds</td>
</tr>
</tbody>
</table>
</div>
<h3 id="标志符号"><a href="#标志符号" class="headerlink" title="标志符号"></a>标志符号</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">TeX</span></span> <span class="tag">\<span class="name">quad</span></span> <span class="tag">\<span class="name">LaTeX</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/28/n2ZDaWwO1YJUp58.png" alt=""></p>
<h3 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h3><div class="table-container">
<table>
<thead>
<tr>
<th>符号名称</th>
<th>符号</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>左单引号</td>
<td><strong>‘</strong></td>
<td><strong>`</strong></td>
</tr>
<tr>
<td>右单引号</td>
<td><strong>’</strong></td>
<td><strong>‘</strong></td>
</tr>
<tr>
<td>左双引号</td>
<td><strong>“</strong></td>
<td><strong>``</strong></td>
</tr>
<tr>
<td>右双引号</td>
<td><strong>”</strong></td>
<td><strong>‘’</strong></td>
</tr>
</tbody>
</table>
</div>
<h2 id="插图"><a href="#插图" class="headerlink" title="插图"></a>插图</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><p>​    在LaTeX中，插图是由 graphics 或 graphicx 宏包所使用的 \includegraphics 命令完成的。graphics 和 graphicx 功能差别不大，但 graphicx 使用更方便一些。</p>
<p>​    插图适用格式：EPS、PDF、PNG、JPEG、BMP</p>
<p>​    搜索路径默认为tex文件所在文件夹，也可用\graphicspath 对搜索路径进行修改。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 调用graphicx宏包，使用插图功能</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;graphicx&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">graphicspath</span><span class="string">&#123;&#123;\figures&#125;</span></span>&#125; <span class="comment">%修改搜索路径</span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="comment">% 基于搜索路径插入图像</span></span><br><span class="line">	<span class="tag">\<span class="name">includegraphics</span><span class="string">&#123;Sx2ec.png&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/28/C56dIB9rRGgbzyP.png" style="zoom:50%;" /></p>
<h3 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h3><h4 id="大小缩放"><a href="#大小缩放" class="headerlink" title="大小缩放"></a>大小缩放</h4><p>​    width、height 和 scale 设置图形的宽度、高度或缩放比例。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 调用graphicx宏包，使用插图功能</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;graphicx&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="comment">% 基于搜索路径插入图像</span></span><br><span class="line">	<span class="tag">\<span class="name">includegraphics</span><span class="string">[width=10em]</span><span class="string">&#123;figures/Sx2ec&#125;</span></span> <span class="comment">%宽度为10em</span></span><br><span class="line">	<span class="tag">\<span class="name">includegraphics</span><span class="string">[height=5cm]</span><span class="string">&#123;figures/Sx2ec&#125;</span></span> <span class="comment">%高度为10cm</span></span><br><span class="line">	<span class="tag">\<span class="name">includegraphics</span><span class="string">[scale=0.5]</span><span class="string">&#123;figures/Sx2ec&#125;</span></span> <span class="comment">%缩放0.5倍</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/28/IZUC1yW7ourqjtM.png" alt=""></p>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>​    angle 选项可以让图形逆时针旋转一定的角度，旋转的中心可以用 origin 选项确定。origin的值可以用字符 l，r，c，t，b，B中的一个或者两个，分别表示左，右，中，上，下和基线，默认值为 lb。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 调用graphicx宏包，使用插图功能</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;graphicx&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="comment">% 基于搜索路径插入图像</span></span><br><span class="line">	<span class="tag">\<span class="name">includegraphics</span><span class="string">[angle=90]</span><span class="string">&#123;figures/Sx2ec&#125;</span></span> <span class="comment">%基于左下，逆时针旋转90度</span></span><br><span class="line">	<span class="tag">\<span class="name">includegraphics</span><span class="string">[angle=-45,origin=c]</span><span class="string">&#123;figures/Sx2ec&#125;</span></span> <span class="comment">%基于中心，顺时针旋转45度</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/28/Nvt3mWH1YU7oOqS.png" alt=""></p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>​    LaTeX表格使用环境录入：在文本或数学模式下都可以使用 tabular 环境，在数学模式下还可以使用 array 环境。tabular 和 array 的一般格式基本相同。</p>
<h3 id="基本-1"><a href="#基本-1" class="headerlink" title="基本"></a>基本</h3><p>​    每行后用 \\ 表示换行，一行内的不同列之间用 &amp; 分开。</p>
<p>​    列格式说明，用 l、c、r 分别表示 左对齐、居中、右对齐。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">% \begin&#123;tabular&#125;[(垂直对齐)]&#123;(列格式说明)&#125;</span></span><br><span class="line">	<span class="comment">% 	(表项)&amp;(表项)&amp;...&amp;(表项)\\</span></span><br><span class="line">	<span class="comment">%		....</span></span><br><span class="line">	<span class="comment">% \end&#123;tabular&#125;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;tabular&#125;</span><span class="string">&#123;lcr&#125;</span></span> <span class="comment">%三列 分别为：左对齐、居中、右对齐</span></span><br><span class="line">		l &amp; c &amp; r <span class="tag">\<span class="name">\</span></span> <span class="comment">%一行</span></span><br><span class="line">		left &amp; center &amp; right <span class="tag">\<span class="name">\</span></span> <span class="comment">%一行</span></span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;tabular&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/28/uPISn4x2JW6ztdy.png" alt=""></p>
<h3 id="表格线"><a href="#表格线" class="headerlink" title="表格线"></a>表格线</h3><p>​    列表格线：在列格式说明中加 |</p>
<p>​    行表格线：\hline</p>
<p>​    需要双线是重复 || 或 \hline\hline。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">% \begin&#123;tabular&#125;[(垂直对齐)]&#123;(列格式说明)&#125;</span></span><br><span class="line">	<span class="comment">% 	(表项)&amp;(表项)&amp;...&amp;(表项)\\</span></span><br><span class="line">	<span class="comment">%	....</span></span><br><span class="line">	<span class="comment">% \end&#123;tabular&#125;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;tabular&#125;</span><span class="string">&#123;|l|c|r|&#125;</span></span> <span class="comment">%三列 分别为：左对齐、居中、右对齐</span></span><br><span class="line">		<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">		l &amp; c &amp; r <span class="tag">\<span class="name">\</span></span> <span class="comment">%一行</span></span><br><span class="line">		<span class="tag">\<span class="name">hline</span></span> <span class="tag">\<span class="name">hline</span></span></span><br><span class="line">		left &amp; center &amp; right <span class="tag">\<span class="name">\</span></span> <span class="comment">%一行</span></span><br><span class="line">		<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;tabular&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/28/yX5xlGALUkavV9o.png" alt=""></p>
<h3 id="垂直对齐"><a href="#垂直对齐" class="headerlink" title="垂直对齐"></a>垂直对齐</h3><p>​    确定表格的基线位置。</p>
<ul>
<li>t    按表格顶部对齐</li>
<li>b   按表格底部对齐</li>
<li>默认  垂直居中</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	---line1---</span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;tabular&#125;</span><span class="string">&#123;|rr|&#125;</span></span> <span class="comment">%默认垂直居中</span></span><br><span class="line">		<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">		Input &amp; Output <span class="tag">\<span class="name">\</span></span> </span><br><span class="line">		<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">		<span class="formula">$-2$</span> &amp; 4 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">		0 &amp; 0 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">		2 &amp; 4 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">		<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;tabular&#125;</span></span></span><br><span class="line">	</span><br><span class="line">	---line2---</span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;tabular&#125;</span><span class="string">[t]</span><span class="string">&#123;|rr|&#125;</span></span> <span class="comment">%按表格顶部对齐</span></span><br><span class="line">		<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">		Input &amp; Output <span class="tag">\<span class="name">\</span></span> </span><br><span class="line">		<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">		<span class="formula">$-2$</span> &amp; 4 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">		0 &amp; 0 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">		2 &amp; 4 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">		<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;tabular&#125;</span></span></span><br><span class="line">	</span><br><span class="line">	---line3---</span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;tabular&#125;</span><span class="string">[b]</span><span class="string">&#123;|rr|&#125;</span></span> <span class="comment">%按表格底部对齐</span></span><br><span class="line">		<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">		Input &amp; Output <span class="tag">\<span class="name">\</span></span> </span><br><span class="line">		<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">		<span class="formula">$-2$</span> &amp; 4 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">		0 &amp; 0 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">		2 &amp; 4 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">		<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;tabular&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/29/mTsturYygJo9fhe.png" alt="截屏2020-02-29上午12.19.31.png" style="zoom: 60%;" /></p>
<h3 id="列格式说明"><a href="#列格式说明" class="headerlink" title="列格式说明"></a>列格式说明</h3><ul>
<li><strong>l</strong>    本列左对齐</li>
<li><strong>c</strong>    本列居中</li>
<li><strong>r</strong>    本列右对齐</li>
<li><strong>p{(宽)}</strong>    本列具有固定宽度，且可以自动换行。</li>
<li><strong>|</strong>    画一条竖线</li>
<li><strong>@{(内容)}</strong>    添加任意内容，不占表项计数。</li>
<li><strong>*{(计数)}{(列格式说明符)}</strong>    将给出的列格式说明符重复多次。</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;tabular&#125;</span><span class="string">&#123;|c|*&#123;3&#125;</span><span class="string">&#123;r@&#123;.&#125;</span></span>l|&#125;&#125;</span><br><span class="line">		<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">		revenue &amp; 1234&amp;6 &amp; 2345&amp;23 &amp; 239&amp;0 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">		<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">		cost &amp; 231&amp;24 &amp; 123&amp;0 &amp; 329&amp;18 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">		<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;tabular&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/29/7aA5PZSlqDUWYmw.png" style="zoom:50%;" /></p>
<h3 id="表格单元的合并与分割"><a href="#表格单元的合并与分割" class="headerlink" title="表格单元的合并与分割"></a>表格单元的合并与分割</h3><h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><h5 id="行合并"><a href="#行合并" class="headerlink" title="行合并"></a>行合并</h5><p>​    <strong>\multicolumn{(项数)}{(新列格式)}{(内容)}</strong> 可用于将一行中的几个不同的表项合并为一项。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;tabular&#125;</span><span class="string">&#123;|r|r|&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">	<span class="tag">\<span class="name">multicolumn</span><span class="string">&#123;2&#125;</span><span class="string">&#123;|c|&#125;</span><span class="string">&#123;score&#125;</span></span> <span class="tag">\<span class="name">\</span></span> <span class="comment">%居中合并两个单元格，内容为score</span></span><br><span class="line">	<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">	Maths &amp; English <span class="tag">\<span class="name">\</span></span></span><br><span class="line">	<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">	80 &amp; 85 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">	<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;tabular&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/29/lpj4KDto8cHTCun.png" alt="截屏2020-02-29上午2.01.15.png" style="zoom: 50%;" /></p>
<h5 id="列合并"><a href="#列合并" class="headerlink" title="列合并"></a>列合并</h5><h6 id="cline（容易实现，但效果不佳）"><a href="#cline（容易实现，但效果不佳）" class="headerlink" title="\cline（容易实现，但效果不佳）"></a>\cline（容易实现，但效果不佳）</h6><p>​    <strong>\cline{(起始列号)-(终止列号)}</strong> 和 \hline 一样可以画水平的表格线，但是 \cline 可以规定表格线起始和终止的列号，即可相当于合并列单元。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;tabular&#125;</span><span class="string">&#123;|c|r|r|&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">	&amp; Maths &amp; English <span class="tag">\<span class="name">\</span></span></span><br><span class="line">	<span class="tag">\<span class="name">cline</span><span class="string">&#123;2-3&#125;</span></span> <span class="comment">%只画2到3列</span></span><br><span class="line">	score &amp; 80 &amp; 85 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">	<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;tabular&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/29/wut7MNIgUn3KPSi.png" style="zoom:50%;" /></p>
<h6 id="multirow-（效果较好）"><a href="#multirow-（效果较好）" class="headerlink" title="\multirow （效果较好）"></a>\multirow （效果较好）</h6><p>​    \multirow{(行数)}{(宽度)}{(内容)}    或    \multirow{(行数)}*{(内容)}</p>
<p>​    第一种形式可自动换行。</p>
<p>​    使用\multirow得先引入宏包multirow。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 使用\multirow得先引入宏包multirow</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;multirow&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;tabular&#125;</span><span class="string">&#123;|c|r|r|&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">	<span class="tag">\<span class="name">multirow</span><span class="string">&#123;2&#125;</span></span>*&#123;score&#125; &amp; Maths &amp; English <span class="tag">\<span class="name">\</span></span></span><br><span class="line">	<span class="tag">\<span class="name">cline</span><span class="string">&#123;2-3&#125;</span></span></span><br><span class="line">	&amp; 80 &amp; 85 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">	<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;tabular&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/29/VgM3E8PpruIJSXd.png" style="zoom:50%;" /></p>
<h4 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h4><p>​    \diagbox 自动判断是把表头分成两部分还是三部分。</p>
<p>​    使用\diagbox得先引入宏包diagbox。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 使用\diagbox得先引入宏包diagbox</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;diagbox&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;tabular&#125;</span><span class="string">&#123;|c|c|c|&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">	<span class="tag">\<span class="name">diagbox</span><span class="string">&#123;Letter&#125;</span><span class="string">&#123;Number&#125;</span></span>&amp; 1 &amp; 2 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">	<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">	a &amp; 0.1 &amp; 0.3 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">	<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">	b &amp; 0.3 &amp; 0.8 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">	<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;tabular&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/29/KvHNhkXzAMSOm3Z.png" style="zoom:50%;" /></p>
<h2 id="浮动体"><a href="#浮动体" class="headerlink" title="浮动体"></a>浮动体</h2><p>​    浮动体用于实现灵活分页，给图表添加标题，交叉应用。</p>
<p>​    图片使用 figure环境，表格使用 table环境。</p>
<p>格式（以figure为例）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;figure&#125;[&lt;允许位置&gt;]</span><br><span class="line">&lt; 任意内容 &gt;</span><br><span class="line">\end&#123;figure&#125;</span><br></pre></td></tr></table></figure>
<p>&lt;允许位置&gt;参数（默认tbp）：</p>
<ul>
<li>h —- 此处（here），代码所在的上下文位置</li>
<li>t —- 页顶（top），代码所在页面或之后的页面的顶部</li>
<li>b —- 页底（bottom），代码所在页面或之后的页面的底部</li>
<li>p —- 独立一页（page），浮动页面</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 调用graphicx宏包，使用插图功能</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;graphicx&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	下面<span class="tag">\<span class="name">ref</span><span class="string">&#123;Latex&#125;</span></span> 是<span class="tag">\<span class="name">LaTeX</span><span class="string">&#123;&#125;</span></span>的标志。<span class="comment">% \ref为引用标签</span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;figure&#125;</span><span class="string">[htbp]</span></span> <span class="comment">%htbp可以让图表随文字运动</span></span><br><span class="line">		<span class="tag">\<span class="name">centering</span></span> <span class="comment">%浮动体居中</span></span><br><span class="line">		<span class="tag">\<span class="name">includegraphics</span><span class="string">&#123;figures/Sx2ec&#125;</span></span></span><br><span class="line">		<span class="tag">\<span class="name">caption</span><span class="string">&#123;\LaTeX 的标志&#125;</span></span> <span class="comment">%标题</span></span><br><span class="line">		<span class="tag">\<span class="name">label</span><span class="string">&#123;Latex&#125;</span></span> <span class="comment">%标签（用于引用）</span></span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;figure&#125;</span></span></span><br><span class="line">	</span><br><span class="line">	引用下面<span class="tag">\<span class="name">ref</span><span class="string">&#123;InAndOut&#125;</span></span> 中的数据。<span class="comment">% \ref为引用标签</span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;table&#125;</span><span class="string">[htbp]</span></span> <span class="comment">%htbp可以让图表随文字运动</span></span><br><span class="line">		<span class="tag">\<span class="name">centering</span></span> <span class="comment">%浮动体居中</span></span><br><span class="line">		<span class="tag">\<span class="name">begin</span><span class="string">&#123;tabular&#125;</span><span class="string">&#123;|rr|&#125;</span></span></span><br><span class="line">			<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">			Input &amp; Output <span class="tag">\<span class="name">\</span></span> </span><br><span class="line">			<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">			<span class="formula">$-2$</span> &amp; 4 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">			0 &amp; 0 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">			2 &amp; 4 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">			<span class="tag">\<span class="name">hline</span></span></span><br><span class="line">		<span class="tag">\<span class="name">end</span><span class="string">&#123;tabular&#125;</span></span></span><br><span class="line">		<span class="tag">\<span class="name">caption</span><span class="string">&#123;输入输出数据&#125;</span></span> <span class="comment">%标题</span></span><br><span class="line">		<span class="tag">\<span class="name">label</span><span class="string">&#123;InAndOut&#125;</span></span> <span class="comment">%标签（用于引用）</span></span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;table&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/29/j5J4sp9ci8ePxOf.png" style="zoom: 60%;" /></p>
<h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><p>​    LaTeX 将排版内内容分为文本模式和数学模式。文本模式适用于普通文本排版，数学模式用于数学公式排版。</p>
<h3 id="基本-2"><a href="#基本-2" class="headerlink" title="基本"></a>基本</h3><h4 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h4><p>​    不需换行的公式。下面三种方法均可生成行内公式。</p>
<h5 id="美元符号"><a href="#美元符号" class="headerlink" title="$ 美元符号"></a>$ 美元符号</h5><p>​    格式：    <script type="math/tex"><数学公式></script></p>
<h5 id="小括号"><a href="#小括号" class="headerlink" title="小括号"></a>小括号</h5><p>​    格式：    <code>\(&lt;数学公式&gt;\)</code></p>
<h5 id="math环境"><a href="#math环境" class="headerlink" title="math环境"></a>math环境</h5><p>​    格式：    <code>\begin{math}&lt;数学公式&gt;\end{math}</code></p>
<p>​    使用math环境需引入 amsmath宏包。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amsmath&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="comment">% $ 美元符号</span></span><br><span class="line">	交换律是 <span class="formula">$a+b=b+a$</span>，如 <span class="formula">$1+2=2+1=3$</span>。</span><br><span class="line">	</span><br><span class="line">	<span class="comment">% 小括号</span></span><br><span class="line">	交换律是 <span class="tag">\<span class="name">(</span></span>a+b=b+a<span class="tag">\<span class="name">)</span></span>，如 <span class="tag">\<span class="name">(</span></span>1+2=2+1=3<span class="tag">\<span class="name">)</span></span>。</span><br><span class="line">	</span><br><span class="line">	<span class="comment">%math环境</span></span><br><span class="line">	交换律是 <span class="tag">\<span class="name">begin</span><span class="string">&#123;math&#125;</span></span> a+b=b+a<span class="tag">\<span class="name">end</span><span class="string">&#123;math&#125;</span></span>，如 <span class="tag">\<span class="name">begin</span><span class="string">&#123;math&#125;</span></span> 1+2=2+1=3<span class="tag">\<span class="name">end</span><span class="string">&#123;math&#125;</span></span>。</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/29/TfFR9WA57zcv3EZ.png" style="zoom: 67%;" /></p>
<h4 id="行间公式"><a href="#行间公式" class="headerlink" title="行间公式"></a>行间公式</h4><p>​    行间公式换行不分段。下面三种方法均可生成行间公式。</p>
<h5 id="美元符号-1"><a href="#美元符号-1" class="headerlink" title="$ 美元符号"></a>$ 美元符号</h5><p>​    格式：    $$$&lt;数学公式&gt;$$$</p>
<h5 id="中括号"><a href="#中括号" class="headerlink" title="中括号"></a>中括号</h5><p>​    格式：    <code>\[&lt;数学公式&gt;\]</code></p>
<h5 id="displaymath环境"><a href="#displaymath环境" class="headerlink" title="displaymath环境"></a>displaymath环境</h5><p>​    格式：    <code>\begin{displaymath}&lt;数学公式&gt;\end{displaymath}</code></p>
<p>​    使用displaymath环境需引入 amsmath宏包。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amsmath&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="comment">% $ 美元符号</span></span><br><span class="line">	交换律是</span><br><span class="line">	<span class="formula">$$a+b=b+a$$</span></span><br><span class="line">	如 </span><br><span class="line">	<span class="formula">$$1+2=2+1=3$$</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">% 中括号</span></span><br><span class="line">	交换律是</span><br><span class="line">	<span class="tag">\<span class="name">[</span></span>a+b=b+a<span class="tag">\<span class="name">]</span></span></span><br><span class="line">	如</span><br><span class="line">	<span class="tag">\<span class="name">[</span></span>1+2=2+1=3<span class="tag">\<span class="name">]</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">%displaymath环境</span></span><br><span class="line">	交换律是</span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;displaymath&#125;</span></span> a+b=b+a<span class="tag">\<span class="name">end</span><span class="string">&#123;displaymath&#125;</span></span></span><br><span class="line">	如</span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;displaymath&#125;</span></span> 1+2=2+1=3<span class="tag">\<span class="name">end</span><span class="string">&#123;displaymath&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/29/Nr8g9EewFlmUaqY.png" style="zoom:40%;" /></p>
<h4 id="自动编号公式——equation环境"><a href="#自动编号公式——equation环境" class="headerlink" title="自动编号公式——equation环境"></a>自动编号公式——equation环境</h4><p>​    equation环境可以对公式自动编号，此时添加 <code>\label</code> 标签方便引用。</p>
<p>​    格式：<code>\begin{equation}&lt;数学公式&gt;\end{equation}</code></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	调用下面的公式<span class="tag">\<span class="name">ref</span><span class="string">&#123;eq:exchange&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line">		a+b=b+a <span class="tag">\<span class="name">label</span><span class="string">&#123;eq:exchange&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/29/O6CsmgiHYjMlVES.png" style="zoom:40%;" /></p>
<h3 id="数学结构"><a href="#数学结构" class="headerlink" title="数学结构"></a>数学结构</h3><h4 id="上标与下标"><a href="#上标与下标" class="headerlink" title="上标与下标"></a>上标与下标</h4><h5 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h5><p>​    用 <code>^{}</code> 表示上标。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="comment">% 上标^&#123;&#125;</span></span><br><span class="line">	<span class="formula">$ f(x)=x^2 + x^&#123;20&#125; + 2x^&#123;4x^2+1&#125; $</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/29/eMkWZHv8gFBos23.png" style="zoom:40%;" /></p>
<h5 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h5><p>​    用 <code>_{}</code> 表示下标。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="comment">% 下标_&#123;&#125;</span></span><br><span class="line">	<span class="formula">$a_0,a_1,a_2,...,a_&#123;100&#125;$</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/29/HEX1yk4QDsmoNf3.png" style="zoom:50%;" /></p>
<h5 id="其他上下标"><a href="#其他上下标" class="headerlink" title="其他上下标"></a>其他上下标</h5><div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>‘</td>
<td>‘</td>
</tr>
<tr>
<td>°</td>
<td>^\circ</td>
</tr>
</tbody>
</table>
</div>
<h4 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h4><p>​    格式：    <code>\sum_{&lt;下限&gt;}^{&lt;上限&gt;} &lt;函数&gt;</code></p>
<p>​                    或（上面的格式上下限在右边，下面的\limit格式上下限在正上下方 ）</p>
<p>​                    <code>\sum\limits_{&lt;下限&gt;}^{&lt;上限&gt;} &lt;函数&gt;</code>                    </p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="formula">$ <span class="tag">\<span class="name">sum</span></span>_&#123;i=0&#125;^&#123;n&#125; a_i $</span> <span class="comment">%上下限在右边</span></span><br><span class="line">	<span class="tag">\<span class="name">quad</span></span> </span><br><span class="line">	<span class="formula">$ <span class="tag">\<span class="name">sum</span></span><span class="tag">\<span class="name">limits</span></span>_&#123;i=0&#125;^&#123;n&#125; a_i $</span> <span class="comment">%上下限在正上下方</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/29/oSAUxv9rjCP64FR.png" style="zoom: 33%;" /></p>
<h4 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h4><p>​    格式:    <code>\int_{&lt;下限&gt;}^{&lt;上限&gt;} &lt;函数&gt; d\! &lt;变量&gt;</code></p>
<p>​    多重积分用 <code>\iint</code> <code>\iiint</code></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="formula">$ <span class="tag">\<span class="name">int</span></span>_0^1 f(t) d<span class="tag">\<span class="name">!</span></span> t $</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="http://imglf4.nosdn0.126.net/img/d2tnT2w1QS9GOGhpMnA2MzB4cVJaTzlRZGZYSG53M0V6RFBlVmYvYWNlMm5nSVErZzNEekdRPT0.png" style="zoom: 50%;" /></p>
<h4 id="分式"><a href="#分式" class="headerlink" title="分式"></a>分式</h4><p>​    格式：    <code>\frac &lt;分子&gt;&lt;分母&gt;</code></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="formula">$ <span class="tag">\<span class="name">frac</span></span> 12 + <span class="tag">\<span class="name">frac</span></span> 1a = <span class="tag">\<span class="name">frac</span><span class="string">&#123;2+a&#125;</span><span class="string">&#123;2a&#125;</span></span> $</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="http://imglf4.nosdn0.126.net/img/d2tnT2w1QS9GOGhpMnA2MzB4cVJaTW9jZW5TMUFpdzZYQlZwemtqUlNwRGF1b3hLMWRvUE9nPT0.png" style="zoom: 50%;" /></p>
<h4 id="根式"><a href="#根式" class="headerlink" title="根式"></a>根式</h4><p>​    格式：    <code>\sqrt[&lt;开方次数&gt;]{&lt;被开方数&gt;}</code></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="formula">$ <span class="tag">\<span class="name">sqrt</span><span class="string">[n]</span><span class="string">&#123;\frac&#123;x^2+\sqrt&#123;2&#125;</span></span>&#125;&#123;x+y&#125;&#125; $</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="http://imglf4.nosdn0.126.net/img/d2tnT2w1QS9GOGhpMnA2MzB4cVJaTUhubkFCYWx6OVRLQVREQXdMcWhkeEpZeUFwc3ovU09BPT0.png" style="zoom:50%;" /></p>
<h4 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h4><p>​    amsmath宏包提供一下矩阵形式。</p>
<p><img src="http://imglf5.nosdn0.126.net/img/d2tnT2w1QS9GOGhpMnA2MzB4cVJaT3VhdzFyR24zYk1GU211cEVqVHJMRzRHRkdZbGdzUTFBPT0.png" style="zoom: 50%;" /></p>
<p>​    编写格式与表格相似。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 使用矩阵，引入amsmath宏包</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amsmath&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="formula">$ A = <span class="tag">\<span class="name">begin</span><span class="string">&#123;pmatrix&#125;</span></span></span></span><br><span class="line"><span class="formula">		a_&#123;11&#125; &amp; a_&#123;12&#125; &amp; a_&#123;13&#125; <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">		0 &amp; a_&#123;22&#125; &amp; a_&#123;23&#125; <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">		0 &amp; 0 &amp; a_&#123;33&#125;</span></span><br><span class="line"><span class="formula">	<span class="tag">\<span class="name">end</span><span class="string">&#123;pmatrix&#125;</span></span> $</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="http://imglf6.nosdn0.126.net/img/d2tnT2w1QS9GOGhpMnA2MzB4cVJaRlBhUC9IVlpxeU5UTlhOZEEvOG9GRGFpc1IvOGhMcmhRPT0.png" style="zoom:50%;" /></p>
<h5 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h5><ul>
<li>行省略号    <code>\dots</code></li>
<li>列省略号    <code>\vdots</code></li>
<li>斜省略号    <code>\ddots</code></li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 使用矩阵，引入amsmath宏包</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amsmath&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="formula">$A = <span class="tag">\<span class="name">begin</span><span class="string">&#123;bmatrix&#125;</span></span></span></span><br><span class="line"><span class="formula">		a_&#123;11&#125; &amp; <span class="tag">\<span class="name">dots</span></span> &amp; a_&#123;1n&#125; <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">		&amp; <span class="tag">\<span class="name">ddots</span></span> &amp; <span class="tag">\<span class="name">vdots</span></span> <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">		0 &amp; &amp; a_&#123;nn&#125;</span></span><br><span class="line"><span class="formula">	<span class="tag">\<span class="name">end</span><span class="string">&#123;bmatrix&#125;</span></span>_&#123;n<span class="tag">\<span class="name">times</span></span> n&#125;$</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="http://imglf4.nosdn0.126.net/img/d2tnT2w1QS9GOGlkb3dEbkVzbEtFb2NyemVNL2Q5SHRWajcyK2trYVJrdVREU0dlVnlPUFB3PT0.png?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0" style="zoom:35%;" /></p>
<ul>
<li>多列省略号    <code>\hdotsfor{&lt;列数&gt;}</code></li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 使用矩阵，引入amsmath宏包</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amsmath&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="formula">$A = <span class="tag">\<span class="name">begin</span><span class="string">&#123;bmatrix&#125;</span></span></span></span><br><span class="line"><span class="formula">		a_&#123;11&#125; &amp; <span class="tag">\<span class="name">dots</span></span> &amp; a_&#123;1n&#125; <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">		<span class="tag">\<span class="name">hdotsfor</span><span class="string">&#123;3&#125;</span></span> <span class="tag">\<span class="name">\</span></span> %跨3列的省略号</span></span><br><span class="line"><span class="formula">		0 &amp; &amp; a_&#123;nn&#125;</span></span><br><span class="line"><span class="formula">	<span class="tag">\<span class="name">end</span><span class="string">&#123;bmatrix&#125;</span></span>_&#123;n<span class="tag">\<span class="name">times</span></span> n&#125;$</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="http://imglf6.nosdn0.126.net/img/d2tnT2w1QS9GOGlkb3dEbkVzbEtFaUtBWDNBQk9OaVc0S0tEZlQ1aDZGWUpxbFlqMkRvNkxBPT0.png?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0" style="zoom:35%;" /></p>
<h3 id="符号与类型"><a href="#符号与类型" class="headerlink" title="符号与类型"></a>符号与类型</h3><div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>LaTeX</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\geq$</td>
<td><code>\geq</code></td>
</tr>
<tr>
<td>$\leq$</td>
<td><code>\leq</code></td>
</tr>
<tr>
<td>$\approx$</td>
<td><code>\approx</code></td>
</tr>
<tr>
<td>$\pm$</td>
<td><code>\pm</code></td>
</tr>
<tr>
<td>$\partial$</td>
<td><code>\partial</code></td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>LaTeX</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\vec x$</td>
<td><code>\vec x</code></td>
</tr>
<tr>
<td>$\hat x$</td>
<td><code>\hat x</code></td>
</tr>
<tr>
<td>$\widehat x$</td>
<td><code>\widehat x</code></td>
</tr>
</tbody>
</table>
</div>
<h4 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h4><p><img src="http://imglf5.nosdn0.126.net/img/d2tnT2w1QS9GOGhpMnA2MzB4cVJaRE52U3VFQTdsMXQyazJSV3dvUzU1aVZDeWtYdE5FYTRRPT0.png?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0" style="zoom:150%;" /></p>
<p><img src="http://imglf6.nosdn0.126.net/img/d2tnT2w1QS9GOGhpMnA2MzB4cVJaQjdsSVhKNjBFbFFjK2lubUk3cENYTTZWYy9uUmtieHZRPT0.png?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0" style="zoom:150%;" /></p>
<h4 id="数学普通符号"><a href="#数学普通符号" class="headerlink" title="数学普通符号"></a>数学普通符号</h4><p><img src="http://imglf5.nosdn0.126.net/img/d2tnT2w1QS9GOGhpMnA2MzB4cVJaR1pHenBnQ0pjYmsrY0pXdTdtZnVHMUxtQTc1dXpuV3hRPT0.png?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0" style="zoom:150%;" /></p>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p><img src="http://imglf3.nosdn0.126.net/img/d2tnT2w1QS9GOGhpMnA2MzB4cVJaUC9QV3lCZmFmeHFIYkk3Q1ZpUXphTzRpR2JNdHZPL3lnPT0.png?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0" style="zoom:150%;" /></p>
<h4 id="数学算子"><a href="#数学算子" class="headerlink" title="数学算子"></a>数学算子</h4><p><img src="http://imglf5.nosdn0.126.net/img/d2tnT2w1QS9GOGhpMnA2MzB4cVJaRUluMVpUaGNRU0dlRVI4ZFhmaVNtWGswUDI4SnlPV2xBPT0.png?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0" style="zoom:150%;" /></p>
<p><img src="http://imglf4.nosdn0.126.net/img/d2tnT2w1QS9GOGhpMnA2MzB4cVJaRDQzN2ViNisxSkdSM240S0pGbTc4dlhiT3BucU1wT3dRPT0.png?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0" style="zoom:150%;" /></p>
<h3 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h3><p>​    equation环境中，换行命令\\无效，所以多行公式需要使用其他环境，使其可用\\换行。</p>
<p>​    使用多行公式的环境，均需引入 amsmath宏包。</p>
<h4 id="gather环境"><a href="#gather环境" class="headerlink" title="gather环境"></a>gather环境</h4><p>​    gather环境中公式自带编号，如要阻止编号，需使用 <code>\notag</code> 命令。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 使用gather环境，引入amsmath宏包</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amsmath&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;gather&#125;</span></span></span><br><span class="line">		a+b = b+a <span class="tag">\<span class="name">\</span></span> <span class="comment">%带编号</span></span><br><span class="line">		ab = ba <span class="tag">\<span class="name">notag</span></span> <span class="comment">%不带编号</span></span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;gather&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="http://imglf5.nosdn0.126.net/img/d2tnT2w1QS9GOGhpMnA2MzB4cVJaQ09XS2Rlb3BCdlVhc2dQNjRhd1lWU3hGUUd5R0cwK0xRPT0.png?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0" style="zoom:150%;" /></p>
<h4 id="gather-环境"><a href="#gather-环境" class="headerlink" title="gather*环境"></a>gather*环境</h4><p>​    与gather环境不同的是，公式不带编号。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 使用gather环境，引入amsmath宏包</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amsmath&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;gather*&#125;</span></span> <span class="comment">%不带编号	</span></span><br><span class="line">		a+b = b+a <span class="tag">\<span class="name">\</span></span></span><br><span class="line">		ab = ba </span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;gather*&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="http://imglf4.nosdn0.126.net/img/d2tnT2w1QS9GOGhpMnA2MzB4cVJaR21NM2RyM1JsUVljMkExZWliMStKZkkxWW9uU0VIK0hnPT0.png?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0" style="zoom: 33%;" /></p>
<h4 id="align环境"><a href="#align环境" class="headerlink" title="align环境"></a>align环境</h4><p>​    align环境允许公式按等号或其他关系符对齐，在关系符前加 &amp; 表示对齐。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 使用gather环境，引入amsmath宏包</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amsmath&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;align&#125;</span></span> <span class="comment">%关于&amp;对齐，带编号</span></span><br><span class="line">		x &amp;= t + <span class="tag">\<span class="name">cos</span></span> t + 1 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">		y &amp;= 2<span class="tag">\<span class="name">sin</span></span> t</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;align&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="http://imglf6.nosdn0.126.net/img/d2tnT2w1QS9GOGlsS0UvUWQ3cFpLNzBGNmJNaitnRFFkTGFsVUgvTTVJTWxiQmZvOW5vdlJnPT0.png?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0" alt=""></p>
<h4 id="align-环境"><a href="#align-环境" class="headerlink" title="align*环境"></a>align*环境</h4><p>​    与align环境不同的是，但公式不带编号。</p>
<h2 id="自定义命令"><a href="#自定义命令" class="headerlink" title="自定义命令"></a>自定义命令</h2><h3 id="newcommand-定义新的命令"><a href="#newcommand-定义新的命令" class="headerlink" title="\newcommand 定义新的命令"></a>\newcommand 定义新的命令</h3><ul>
<li>格式：<code>\newcommand&lt;命令&gt;[&lt;参数个数&gt;][&lt;首参数默认值&gt;]{&lt;具体定义&gt;}</code></li>
<li>命令只能由字母组成，不能以 \end 开头</li>
<li>参数可以从1到9，用 #1，#2，….，#9 表示</li>
<li>默认值为非必填项，只能设定 #1 的参数</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 设置新命令</span></span><br><span class="line"><span class="tag">\<span class="name">newcommand</span><span class="string">&#123;\PRC&#125;</span><span class="string">&#123;People's Republic of China&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">newcommand</span><span class="string">&#123;\loves&#125;</span><span class="string">[2]</span><span class="string">&#123;#1 love #2&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">PRC</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">\<span class="name">loves</span><span class="string">&#123;I&#125;</span><span class="string">&#123;apple&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="http://imglf4.nosdn0.126.net/img/d2tnT2w1QS9GOGpWYVJKVENiZ2tBNW1VWmZ2Wm55cHU2aFFkSC9sYVU3Tm1rMUF6bjhRSEZBPT0.png?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0" style="zoom:67%;" /></p>
<h3 id="renewcommand-重新定义命令"><a href="#renewcommand-重新定义命令" class="headerlink" title="\renewcommand 重新定义命令"></a>\renewcommand 重新定义命令</h3><ul>
<li>格式：<code>\renewcommand&lt;命令&gt;[&lt;参数个数&gt;][&lt;首参数默认值&gt;]{&lt;具体定义&gt;}</code></li>
<li>只能定义已有命令</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 重新定义已有命令</span></span><br><span class="line"><span class="tag">\<span class="name">renewcommand</span></span> <span class="tag">\<span class="name">abstractname</span><span class="string">&#123;简介&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">abstractname</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="http://imglf6.nosdn0.126.net/img/d2tnT2w1QS9GOGpWYVJKVENiZ2tBdzdKalU2Z2Z5NEt6ZXQyL080b04wRzRvTFpTVGVRcENnPT0.png?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>Latex</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>Latex</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac使用Matlab卡顿严重且闪退的解决办法</title>
    <url>/2019/12/16/Mac%E4%BD%BF%E7%94%A8Matlab%E5%8D%A1%E9%A1%BF%E4%B8%A5%E9%87%8D%E4%B8%94%E9%97%AA%E9%80%80%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>安装Matlab后发现使用时十分卡顿且易闪退。</p>
<a id="more"></a>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>关闭 “MathWorks源代码管理集成”。</p>
<p>1、打开 “主页 &gt; 环境 &gt; 预设”；</p>
<p><img src="https://res.cloudinary.com/dh7ramrlh/image/upload/v1576577602/gy/img7_oxoxex.png" style="zoom:50%;" /></p>
<p>2、打开 “常规  &gt; 原代码管理”，选择 “无”。</p>
<p><img src="https://res.cloudinary.com/dh7ramrlh/image/upload/v1576577645/gy/img8_cebx5p.png" style="zoom:50%;" /></p>
<p>问题解决。</p>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac WiFi连接无法弹出验证页面问题解决办法</title>
    <url>/2019/12/21/Mac-WiFi%E8%BF%9E%E6%8E%A5%E6%97%A0%E6%B3%95%E5%BC%B9%E5%87%BA%E9%AA%8C%E8%AF%81%E9%A1%B5%E9%9D%A2%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>连接公共Wi-Fi时常有弹出的验证页面，Mac显示已连接上Wi-Fi，但未弹出验证页面，无法使用网络。</p>
<a id="more"></a>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><ol>
<li>打开“设置 &gt; 网络 &gt; 高级 ”；</li>
<li>确定 “TCP/IP”的“配置IPv4”选中“使用DHCP”；</li>
<li>“DNS”中的“DNS服务器”减去添加配置，恢复原始配置。</li>
</ol>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>Mac</tag>
        <tag>Wi-Fi连接</tag>
      </tags>
  </entry>
  <entry>
    <title>FRRouting</title>
    <url>/2024/09/19/FRRouting/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>FRRouting（FRR）是一款提供 IP 路由服务的开源套件，支持 BGP、OSPF、RIP、IS-IS 等等路由协议。FRR 可以在网络栈中与其他路由器交换路由信息，做出路由策略决策，并将决策通知给其他层。</p>
<a id="more"></a>
<h1 id="FRR-安装"><a href="#FRR-安装" class="headerlink" title="FRR 安装"></a>FRR 安装</h1><p>Ubuntu 20.04 LTS 安装 FRR，且以 root 权限运行</p>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt-get install \</span><br><span class="line">   git autoconf automake libtool make libreadline-dev texinfo \</span><br><span class="line">   pkg-config libpam0g-dev libjson-c-dev bison flex \</span><br><span class="line">   libc-ares-dev python3-dev python3-sphinx \</span><br><span class="line">   install-info build-essential libsnmp-dev perl \</span><br><span class="line">   protobuf-c-compiler libprotobuf-c-dev \</span><br><span class="line">   libcap-dev libelf-dev libunwind-dev</span><br><span class="line">apt-get install cmake libpcre2-dev</span><br></pre></td></tr></table></figure>
<h2 id="安装-libyang"><a href="#安装-libyang" class="headerlink" title="安装 libyang"></a>安装 libyang</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;CESNET&#x2F;libyang.git</span><br><span class="line">cd libyang</span><br><span class="line">git checkout v2.1.128</span><br><span class="line">mkdir build; cd build</span><br><span class="line">cmake --install-prefix &#x2F;usr \</span><br><span class="line">      -D CMAKE_BUILD_TYPE:String&#x3D;&quot;Release&quot; ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h2 id="安装-FRR"><a href="#安装-FRR" class="headerlink" title="安装 FRR"></a>安装 FRR</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;frrouting&#x2F;frr.git frr</span><br><span class="line">cd frr</span><br><span class="line">.&#x2F;bootstrap.sh</span><br><span class="line">.&#x2F;configure \</span><br><span class="line">    --prefix&#x3D;&#x2F;usr \</span><br><span class="line">    --includedir&#x3D;\$&#123;prefix&#125;&#x2F;include \</span><br><span class="line">    --bindir&#x3D;\$&#123;prefix&#125;&#x2F;bin \</span><br><span class="line">    --sbindir&#x3D;\$&#123;prefix&#125;&#x2F;lib&#x2F;frr \</span><br><span class="line">    --libdir&#x3D;\$&#123;prefix&#125;&#x2F;lib&#x2F;frr \</span><br><span class="line">    --libexecdir&#x3D;\$&#123;prefix&#125;&#x2F;lib&#x2F;frr \</span><br><span class="line">    --sysconfdir&#x3D;&#x2F;etc \</span><br><span class="line">    --localstatedir&#x3D;&#x2F;var \</span><br><span class="line">    --with-moduledir&#x3D;\$&#123;prefix&#125;&#x2F;lib&#x2F;frr&#x2F;modules \</span><br><span class="line">    --enable-configfile-mask&#x3D;0640 \</span><br><span class="line">    --enable-logfile-mask&#x3D;0640 \</span><br><span class="line">    --enable-snmp&#x3D;agentx \</span><br><span class="line">    --enable-multipath&#x3D;64 \</span><br><span class="line">    --enable-user&#x3D;root \</span><br><span class="line">    --enable-group&#x3D;root \</span><br><span class="line">    --enable-vty-group&#x3D;root \</span><br><span class="line">    --with-pkg-git-version \</span><br><span class="line">    --with-pkg-extra-version&#x3D;-MyOwnFRRVersion</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<h2 id="生成配置"><a href="#生成配置" class="headerlink" title="生成配置"></a>生成配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo install -m 775 -o root -g root -d &#x2F;var&#x2F;log&#x2F;frr</span><br><span class="line">sudo install -m 775 -o root -g root -d &#x2F;etc&#x2F;frr</span><br><span class="line">sudo install -m 640 -o root -g root tools&#x2F;etc&#x2F;frr&#x2F;vtysh.conf &#x2F;etc&#x2F;frr&#x2F;vtysh.conf</span><br><span class="line">sudo install -m 640 -o root -g root tools&#x2F;etc&#x2F;frr&#x2F;frr.conf &#x2F;etc&#x2F;frr&#x2F;frr.conf</span><br><span class="line">sudo install -m 640 -o root -g root tools&#x2F;etc&#x2F;frr&#x2F;daemons.conf &#x2F;etc&#x2F;frr&#x2F;daemons.conf</span><br><span class="line">sudo install -m 640 -o root -g root tools&#x2F;etc&#x2F;frr&#x2F;daemons &#x2F;etc&#x2F;frr&#x2F;daemons</span><br></pre></td></tr></table></figure>
<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo install -m 644 tools&#x2F;frr.service &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;frr.service</span><br><span class="line">sudo systemctl enable frr</span><br></pre></td></tr></table></figure>
<p>查看安装完成的 FRR</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/home/guoyi/frr/frr<span class="comment"># systemctl status frr</span></span><br><span class="line">● frr.service - FRRouting</span><br><span class="line">     Loaded: loaded (/etc/systemd/system/frr.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: active (running) since Wed <span class="number">2024</span><span class="literal">-10</span><span class="literal">-16</span> <span class="number">05</span>:<span class="number">46</span>:<span class="number">16</span> PDT; <span class="number">1</span>s ago</span><br><span class="line">       Docs: https://frrouting.readthedocs.io/en/latest/setup.html</span><br><span class="line">    <span class="keyword">Process</span>: <span class="number">55748</span> ExecStart=/usr/lib/frr/frrinit.sh start (code=exited, status=<span class="number">0</span>/SUCCESS)</span><br><span class="line">   Main PID: <span class="number">55760</span> (watchfrr)</span><br><span class="line">     Status: <span class="string">"FRR Operational"</span></span><br><span class="line">      Tasks: <span class="number">8</span> (limit: <span class="number">4540</span>)</span><br><span class="line">     Memory: <span class="number">14.5</span>M</span><br><span class="line">     CGroup: /system.slice/frr.service</span><br><span class="line">             ├─<span class="number">55760</span> /usr/lib/frr/watchfrr <span class="literal">-d</span> <span class="operator">-F</span> traditional zebra mgmtd staticd</span><br><span class="line">             ├─<span class="number">55771</span> /usr/lib/frr/zebra <span class="literal">-d</span> <span class="operator">-F</span> traditional <span class="literal">-A</span> <span class="number">127.0</span>.<span class="number">0.1</span> <span class="literal">-s</span> <span class="number">90000000</span></span><br><span class="line">             ├─<span class="number">55776</span> /usr/lib/frr/mgmtd <span class="literal">-d</span> <span class="operator">-F</span> traditional <span class="literal">-A</span> <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line">             └─<span class="number">55778</span> /usr/lib/frr/staticd <span class="literal">-d</span> <span class="operator">-F</span> traditional <span class="literal">-A</span> <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"></span><br><span class="line">Oct <span class="number">16</span> <span class="number">05</span>:<span class="number">46</span>:<span class="number">16</span> ubuntu zebra[<span class="number">55771</span>]: [<span class="type">VTVCM</span>-<span class="type">Y2NW3</span>] Configuration Read <span class="keyword">in</span> Took: <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">Oct <span class="number">16</span> <span class="number">05</span>:<span class="number">46</span>:<span class="number">16</span> ubuntu mgmtd[<span class="number">55776</span>]: [<span class="type">VTVCM</span>-<span class="type">Y2NW3</span>] Configuration Read <span class="keyword">in</span> Took: <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">Oct <span class="number">16</span> <span class="number">05</span>:<span class="number">46</span>:<span class="number">16</span> ubuntu watchfrr[<span class="number">55760</span>]: [<span class="type">VTVCM</span>-<span class="type">Y2NW3</span>] Configuration Read <span class="keyword">in</span> Took: <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">Oct <span class="number">16</span> <span class="number">05</span>:<span class="number">46</span>:<span class="number">16</span> ubuntu staticd[<span class="number">55778</span>]: [<span class="type">VTVCM</span>-<span class="type">Y2NW3</span>] Configuration Read <span class="keyword">in</span> Took: <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">Oct <span class="number">16</span> <span class="number">05</span>:<span class="number">46</span>:<span class="number">16</span> ubuntu watchfrr[<span class="number">55760</span>]: [<span class="type">QDG3Y</span>-<span class="type">BY5TN</span>] zebra state -&gt; up : connect succeeded</span><br><span class="line">Oct <span class="number">16</span> <span class="number">05</span>:<span class="number">46</span>:<span class="number">16</span> ubuntu watchfrr[<span class="number">55760</span>]: [<span class="type">QDG3Y</span>-<span class="type">BY5TN</span>] mgmtd state -&gt; up : connect succeeded</span><br><span class="line">Oct <span class="number">16</span> <span class="number">05</span>:<span class="number">46</span>:<span class="number">16</span> ubuntu watchfrr[<span class="number">55760</span>]: [<span class="type">QDG3Y</span>-<span class="type">BY5TN</span>] staticd state -&gt; up : connect succeeded</span><br><span class="line">Oct <span class="number">16</span> <span class="number">05</span>:<span class="number">46</span>:<span class="number">16</span> ubuntu watchfrr[<span class="number">55760</span>]: [<span class="type">KWE5Q</span>-<span class="type">QNGFC</span>] all daemons up, doing startup<span class="literal">-complete</span> notify</span><br><span class="line">Oct <span class="number">16</span> <span class="number">05</span>:<span class="number">46</span>:<span class="number">16</span> ubuntu frrinit.sh[<span class="number">55748</span>]:  * Started watchfrr</span><br><span class="line">Oct <span class="number">16</span> <span class="number">05</span>:<span class="number">46</span>:<span class="number">16</span> ubuntu systemd[<span class="number">1</span>]: Started FRRouting.</span><br></pre></td></tr></table></figure>
<h2 id="安装问题"><a href="#安装问题" class="headerlink" title="安装问题"></a>安装问题</h2><p>启动 frr 时报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Oct 15 09:02:45 ubuntu systemd[1]: Starting FRRouting...</span><br><span class="line">Oct 15 09:02:45 ubuntu frrinit.sh[28693]:  * Starting watchfrr with command: &#39;  &#x2F;usr&#x2F;lib&#x2F;frr&#x2F;watchfrr  -d  -F traditional   zebra mgmtd staticd&#39;</span><br><span class="line">Oct 15 09:02:45 ubuntu frrinit.sh[28703]: &#x2F;usr&#x2F;lib&#x2F;frr&#x2F;watchfrr: error while loading shared libraries: libyang.so.2: cannot open shared object file: No such file or directory</span><br><span class="line">Oct 15 09:02:45 ubuntu frrinit.sh[28693]:  * Failed to start watchfrr!</span><br></pre></td></tr></table></figure>
<p>查到 libyang 已安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~&#x2F;frr&#x2F;libyang# ll &#x2F;usr&#x2F;local&#x2F;lib&#x2F;libyang.so</span><br><span class="line">lrwxrwxrwx 1 root root 12 Oct 15 08:22 &#x2F;usr&#x2F;local&#x2F;lib&#x2F;libyang.so -&gt; libyang.so.2</span><br></pre></td></tr></table></figure>
<p>但 watchfrr 无法链接到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~&#x2F;frr&#x2F;libyang# ldd &#x2F;usr&#x2F;lib&#x2F;frr&#x2F;watchfrr</span><br><span class="line">	linux-vdso.so.1 (0x00007fff64d68000)</span><br><span class="line">	libfrr.so.0 &#x3D;&gt; &#x2F;usr&#x2F;lib&#x2F;frr&#x2F;libfrr.so.0 (0x00007f749a134000)</span><br><span class="line">	libpthread.so.0 &#x3D;&gt; &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libpthread.so.0 (0x00007f749a0f8000)</span><br><span class="line">	libc.so.6 &#x3D;&gt; &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6 (0x00007f7499f06000)</span><br><span class="line">	libcap.so.2 &#x3D;&gt; &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libcap.so.2 (0x00007f7499efd000)</span><br><span class="line">	libunwind.so.8 &#x3D;&gt; &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libunwind.so.8 (0x00007f7499ee0000)</span><br><span class="line">	libcrypt.so.1 &#x3D;&gt; &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libcrypt.so.1 (0x00007f7499ea5000)</span><br><span class="line">	libdl.so.2 &#x3D;&gt; &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libdl.so.2 (0x00007f7499e9d000)</span><br><span class="line">	libm.so.6 &#x3D;&gt; &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libm.so.6 (0x00007f7499d4e000)</span><br><span class="line">	libprotobuf-c.so.1 &#x3D;&gt; &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libprotobuf-c.so.1 (0x00007f7499d43000)</span><br><span class="line">	libyang.so.2 &#x3D;&gt; not found</span><br><span class="line">	libjson-c.so.4 &#x3D;&gt; &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libjson-c.so.4 (0x00007f7499d31000)</span><br><span class="line">	&#x2F;lib64&#x2F;ld-linux-x86-64.so.2 (0x00007f749a387000)</span><br><span class="line">	liblzma.so.5 &#x3D;&gt; &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;liblzma.so.5 (0x00007f7499d08000)</span><br></pre></td></tr></table></figure>
<p>更新动态链接库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ldconfig</span><br></pre></td></tr></table></figure>
<h1 id="FRR-基础"><a href="#FRR-基础" class="headerlink" title="FRR 基础"></a>FRR 基础</h1><h2 id="Daemons-配置文件"><a href="#Daemons-配置文件" class="headerlink" title="Daemons 配置文件"></a>Daemons 配置文件</h2><p>Daemons 配置文件用来设置 FRR 的哪些 daemon 需要在 FRR 启动时被激活，并且设置 daemon 启动时的参数。</p>
<p>通常放在 <code>/etc/frr/daemons</code>，如果修改了里面的内容，需要重启 FRR 服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># This file tells the frr package which daemons to start.</span><br><span class="line">#</span><br><span class="line"># Sample configurations for these daemons can be found in</span><br><span class="line"># &#x2F;usr&#x2F;share&#x2F;doc&#x2F;frr&#x2F;examples&#x2F;.</span><br><span class="line">#</span><br><span class="line"># ATTENTION:</span><br><span class="line">#</span><br><span class="line"># When activating a daemon for the first time, a config file, even if it is</span><br><span class="line"># empty, has to be present *and* be owned by the user and group &quot;frr&quot;, else</span><br><span class="line"># the daemon will not be started by &#x2F;etc&#x2F;init.d&#x2F;frr. The permissions should</span><br><span class="line"># be u&#x3D;rw,g&#x3D;r,o&#x3D;.</span><br><span class="line"># When using &quot;vtysh&quot; such a config file is also needed. It should be owned by</span><br><span class="line"># group &quot;frrvty&quot; and set to ug&#x3D;rw,o&#x3D; though. Check &#x2F;etc&#x2F;pam.d&#x2F;frr, too.</span><br><span class="line">#</span><br><span class="line"># The watchfrr, zebra and staticd daemons are always started.</span><br><span class="line">#</span><br><span class="line">bgpd&#x3D;no</span><br><span class="line">ospfd&#x3D;yes</span><br><span class="line">ospf6d&#x3D;no</span><br><span class="line">ripd&#x3D;no</span><br><span class="line">ripngd&#x3D;no</span><br><span class="line">isisd&#x3D;no</span><br><span class="line">pimd&#x3D;no</span><br><span class="line">pim6d&#x3D;no</span><br><span class="line">ldpd&#x3D;no</span><br><span class="line">nhrpd&#x3D;no</span><br><span class="line">eigrpd&#x3D;no</span><br><span class="line">babeld&#x3D;no</span><br><span class="line">sharpd&#x3D;no</span><br><span class="line">pbrd&#x3D;no</span><br><span class="line">bfdd&#x3D;no</span><br><span class="line">fabricd&#x3D;no</span><br><span class="line">vrrpd&#x3D;no</span><br><span class="line">pathd&#x3D;no</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># If this option is set the &#x2F;etc&#x2F;init.d&#x2F;frr script automatically loads</span><br><span class="line"># the config via &quot;vtysh -b&quot; when the servers are started.</span><br><span class="line"># Check &#x2F;etc&#x2F;pam.d&#x2F;frr if you intend to use &quot;vtysh&quot;!</span><br><span class="line">#</span><br><span class="line">vtysh_enable&#x3D;yes</span><br><span class="line">zebra_options&#x3D;&quot;  -A 127.0.0.1 -s 90000000&quot;</span><br><span class="line">mgmtd_options&#x3D;&quot;  -A 127.0.0.1&quot;</span><br><span class="line">bgpd_options&#x3D;&quot;   -A 127.0.0.1&quot;</span><br><span class="line">ospfd_options&#x3D;&quot;  -A 127.0.0.1&quot;</span><br><span class="line">ospf6d_options&#x3D;&quot; -A ::1&quot;</span><br><span class="line">ripd_options&#x3D;&quot;   -A 127.0.0.1&quot;</span><br><span class="line">ripngd_options&#x3D;&quot; -A ::1&quot;</span><br><span class="line">isisd_options&#x3D;&quot;  -A 127.0.0.1&quot;</span><br><span class="line">pimd_options&#x3D;&quot;   -A 127.0.0.1&quot;</span><br><span class="line">pim6d_options&#x3D;&quot;  -A ::1&quot;</span><br><span class="line">ldpd_options&#x3D;&quot;   -A 127.0.0.1&quot;</span><br><span class="line">nhrpd_options&#x3D;&quot;  -A 127.0.0.1&quot;</span><br><span class="line">eigrpd_options&#x3D;&quot; -A 127.0.0.1&quot;</span><br><span class="line">babeld_options&#x3D;&quot; -A 127.0.0.1&quot;</span><br><span class="line">sharpd_options&#x3D;&quot; -A 127.0.0.1&quot;</span><br><span class="line">pbrd_options&#x3D;&quot;   -A 127.0.0.1&quot;</span><br><span class="line">staticd_options&#x3D;&quot;-A 127.0.0.1&quot;</span><br><span class="line">bfdd_options&#x3D;&quot;   -A 127.0.0.1&quot;</span><br><span class="line">fabricd_options&#x3D;&quot;-A 127.0.0.1&quot;</span><br><span class="line">vrrpd_options&#x3D;&quot;  -A 127.0.0.1&quot;</span><br><span class="line">pathd_options&#x3D;&quot;  -A 127.0.0.1&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># If you want to pass a common option to all daemons, you can use the</span><br><span class="line"># &quot;frr_global_options&quot; variable.</span><br><span class="line">#</span><br><span class="line">#frr_global_options&#x3D;&quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># The list of daemons to watch is automatically generated by the init script.</span><br><span class="line"># This variable can be used to pass options to watchfrr that will be passed</span><br><span class="line"># prior to the daemon list.</span><br><span class="line">#</span><br><span class="line"># To make watchfrr create&#x2F;join the specified netns, add the the &quot;--netns&quot;</span><br><span class="line"># option here. It will only have an effect in &#x2F;etc&#x2F;frr&#x2F;&lt;somename&gt;&#x2F;daemons, and</span><br><span class="line"># you need to start FRR with &quot;&#x2F;usr&#x2F;lib&#x2F;frr&#x2F;frrinit.sh start &lt;somename&gt;&quot;.</span><br><span class="line">#</span><br><span class="line">#watchfrr_options&#x3D;&quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># configuration profile</span><br><span class="line">#</span><br><span class="line">#frr_profile&#x3D;&quot;traditional&quot;</span><br><span class="line">#frr_profile&#x3D;&quot;datacenter&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># This is the maximum number of FD&#39;s that will be available.  Upon startup this</span><br><span class="line"># is read by the control files and ulimit is called.  Uncomment and use a</span><br><span class="line"># reasonable value for your setup if you are expecting a large number of peers</span><br><span class="line"># in say BGP.</span><br><span class="line">#</span><br><span class="line">#MAX_FDS&#x3D;1024</span><br><span class="line"></span><br><span class="line"># Uncomment this option if you want to run FRR as a non-root user. Note that</span><br><span class="line"># you should know what you are doing since most of the daemons need root</span><br><span class="line"># to work. This could be useful if you want to run FRR in a container</span><br><span class="line"># for instance.</span><br><span class="line"># FRR_NO_ROOT&#x3D;&quot;yes&quot;</span><br><span class="line"></span><br><span class="line"># For any daemon, you can specify a &quot;wrap&quot; command to start instead of starting</span><br><span class="line"># the daemon directly. This will simply be prepended to the daemon invocation.</span><br><span class="line"># These variables have the form daemon_wrap, where &#39;daemon&#39; is the name of the</span><br><span class="line"># daemon (the same pattern as the daemon_options variables).</span><br><span class="line">#</span><br><span class="line"># Note that when daemons are started, they are told to daemonize with the &#96;-d&#96;</span><br><span class="line"># option. This has several implications. For one, the init script expects that</span><br><span class="line"># when it invokes a daemon, the invocation returns immediately. If you add a</span><br><span class="line"># wrap command here, it must comply with this expectation and daemonize as</span><br><span class="line"># well, or the init script will never return. Furthermore, because daemons are</span><br><span class="line"># themselves daemonized with -d, you must ensure that your wrapper command is</span><br><span class="line"># capable of following child processes after a fork() if you need it to do so.</span><br><span class="line">#</span><br><span class="line"># If your desired wrapper does not support daemonization, you can wrap it with</span><br><span class="line"># a utility program that daemonizes programs, such as &#39;daemonize&#39;. An example</span><br><span class="line"># of this might look like:</span><br><span class="line">#</span><br><span class="line"># bgpd_wrap&#x3D;&quot;&#x2F;usr&#x2F;bin&#x2F;daemonize &#x2F;usr&#x2F;bin&#x2F;mywrapper&quot;</span><br><span class="line">#</span><br><span class="line"># This is particularly useful for programs which record processes but lack</span><br><span class="line"># daemonization options, such as perf and rr.</span><br><span class="line">#</span><br><span class="line"># If you wish to wrap all daemons in the same way, you may set the &quot;all_wrap&quot;</span><br><span class="line"># variable.</span><br><span class="line">#</span><br><span class="line">#all_wrap&#x3D;&quot;&quot;</span><br></pre></td></tr></table></figure>
<h2 id="crash-日志"><a href="#crash-日志" class="headerlink" title="crash 日志"></a>crash 日志</h2><p>FRR 各个 daemon 的 crash 日志储存在固定位置，即 <code>/var/tmp/frr/&lt;daemon&gt;[-&lt;instance&gt;].&lt;pid&gt;/crashlog</code></p>
<h2 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h2><p>在 frr.conf 中可以配置日志文件输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log file &#x2F;var&#x2F;log&#x2F;frr&#x2F;frr.log [logging_level]</span><br></pre></td></tr></table></figure>
<h1 id="vtysh"><a href="#vtysh" class="headerlink" title="vtysh"></a>vtysh</h1><p>root 权限或者 frrvty 权限可以使用 <code>vtysh</code> 命令进入交互模式</p>
<h2 id="show-命令"><a href="#show-命令" class="headerlink" title="show 命令"></a>show 命令</h2><ul>
<li><code>show ip ospf neighbor</code> 查看 OSPF 邻居，其中<ul>
<li>Neighbor ID：邻居的 Router ID</li>
<li>Pri：邻居的 Priority</li>
<li>State：邻居状态</li>
</ul>
</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">568</span>ade633bf9<span class="comment"># show ip ospf neighbor</span></span><br><span class="line"></span><br><span class="line">Neighbor ID     Pri State           Up Time         Dead Time Address         Interface                        RXmtL RqstL DBsmL</span><br><span class="line"><span class="number">12.12</span>.<span class="number">0.2</span>         <span class="number">1</span> Full/Backup     <span class="number">22</span>h48m43s         <span class="number">37.418</span>s <span class="number">11.11</span>.<span class="number">0.3</span>       eth1:<span class="number">11.11</span>.<span class="number">0.2</span>                       <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>FRR 和其他路由器交换路由信息、</p>
<p>支持北向grpc接口 或 vtysh 命令</p>
<p>进入配置模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">configure terminal</span><br></pre></td></tr></table></figure>
<p>配置网卡</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface ens38</span><br></pre></td></tr></table></figure>
<p>VIP是<code>192.168.1.1/24</code>，你要发布到OSPF区域0，且设置成本为10</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vtysh</span><br><span class="line">configure terminal</span><br><span class="line">interface eth0</span><br><span class="line"> ip address 192.168.1.1&#x2F;24</span><br><span class="line">!</span><br><span class="line">router ospf</span><br><span class="line"> </span><br><span class="line"> network 192.168.1.0&#x2F;24 area 0</span><br><span class="line">!</span><br><span class="line">interface eth0</span><br><span class="line"> ip ospf cost 10</span><br><span class="line"> </span><br><span class="line">end</span><br><span class="line">write memory</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vtysh</span><br><span class="line">configure terminal</span><br><span class="line">interface eth0</span><br><span class="line"> no ip address 192.168.1.1&#x2F;24</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> no network 192.168.1.0&#x2F;24 area 0</span><br><span class="line">!</span><br><span class="line">interface eth0</span><br><span class="line"> ip ospf cost 10</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show ip route ospf</span><br></pre></td></tr></table></figure>
<p>查看 DR</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show ip ospf neighbor</span><br></pre></td></tr></table></figure>
<p> 查看 ospf 路由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show ip ospf route</span><br></pre></td></tr></table></figure>
<h1 id="FRR-配置"><a href="#FRR-配置" class="headerlink" title="FRR 配置"></a>FRR 配置</h1><h2 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h2><ul>
<li><p>查看当前配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show running-config</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入配置模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">configure terminal</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="prefix-list-配置"><a href="#prefix-list-配置" class="headerlink" title="prefix-list 配置"></a>prefix-list 配置</h2><p>prefix-list（前缀列表）用于匹配和过滤 IP 地址</p>
<h3 id="定义-prefix-list"><a href="#定义-prefix-list" class="headerlink" title="定义 prefix-list"></a>定义 prefix-list</h3><p>下面只是定义一条前缀列表规则，如未设置应用，不会起任何作用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip prefix-list NAME [seq NUMBER] (permit|deny) PREFIX [le LEN] [ge LEN]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>NAME</code>：定义的该前缀列表的名字，用于唯一标识该 prefix-list</li>
<li><code>seq</code>：规则序号，匹配的优先级，序号越小越先匹配，可自动设置，自动设置以 5 为增量</li>
<li><code>permit|deny</code>：匹配到的前缀将被允许通过/被过滤掉</li>
<li><code>PREFIX</code>：匹配的网络地址和前缀长度</li>
<li><code>le</code>：匹配的最长子网掩码长度</li>
<li><code>ge</code>：匹配的最短子网掩码长度</li>
</ul>
<p>配置示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义一个命名为 PLIST-1 的 prefix-list，拒绝所有前缀</span><br><span class="line">ip prefix-list PLIST-1 seq 5 deny 0.0.0.0&#x2F;0 le 32</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义一个命名为 PLIST-2 的 prefix-list，接受前缀 IP 为 1.1.1.1 和 2.2.2.2 的前缀</span><br><span class="line">ip prefix-list PLIST-2 seq 5 permit 1.1.1.1&#x2F;32</span><br><span class="line">ip prefix-list PLIST-2 seq 10 permit 2.2.2.2&#x2F;32</span><br></pre></td></tr></table></figure>
<h3 id="前缀匹配规则"><a href="#前缀匹配规则" class="headerlink" title="前缀匹配规则"></a>前缀匹配规则</h3><ol>
<li>优先匹配 seq 小的规则，逐条检查匹配，如果匹配上，则后续条目无需再检查</li>
<li>如果未设置任何 prefix-list，则视为所有 prefix 都 permit</li>
<li>默认拒绝：如果设置有 prefix-list，但未匹配到任何一条规则，则默认拒绝该 prefix</li>
<li>匹配规则：<ol>
<li>检查 prefix IP 是否匹配 <code>network/prefix-length</code></li>
<li>如果有设置 <code>ge</code> 或 <code>le</code>，则检查 prefix 长度是否在 <code>&gt;=ge</code> 以及 <code>&lt;=le</code> 范围内</li>
<li>比如 <code>192.168.1.0/24 ge 25 le 30</code><ul>
<li>IP 匹配范围 <code>192.168.1.0</code> ~ <code>192.168.1.255</code></li>
<li>前缀长度在 25 ~ 30</li>
<li><code>192.168.1.0/24</code> 不匹配（前缀长度不匹配）、<code>192.168.1.0/25</code> 匹配、<code>192.168.1.30/28</code> 匹配</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="查看-prefix-list"><a href="#查看-prefix-list" class="headerlink" title="查看 prefix-list"></a>查看 prefix-list</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show ip prefix-list</span><br></pre></td></tr></table></figure>
<h2 id="route-map-配置"><a href="#route-map-配置" class="headerlink" title="route-map 配置"></a>route-map 配置</h2><p>用于匹配和过滤路由</p>
<h3 id="定义-route-map"><a href="#定义-route-map" class="headerlink" title="定义 route-map"></a>定义 route-map</h3><p>下面只是定义一条路由匹配规则，如未设置应用，不会起任何作用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">route-map ROUTE-MAP-NAME (permit|deny) ORDER</span><br><span class="line">  match &lt;conditions&gt;</span><br><span class="line">  set &lt;actions&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ROUTE-MAP-NAME</code>：定义的该 route-map 的名字，用于唯一标识该 route-map</li>
<li><code>permit|deny</code> ：是否允许匹配的路由通过</li>
<li><code>ORDER</code>：规则序号，匹配的优先级，序号越小越先匹配，可自动设置，自动设置以 10 为增量</li>
<li><code>match</code>：匹配条件</li>
<li><code>set</code>：设置动作，如果 <code>match</code> 匹配上了，则给该条路由执行设置动作</li>
</ul>
<p>配置示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">route-map EXAMPLE permit 10</span><br><span class="line">  match ip address prefix-list LIST-1</span><br><span class="line">  set local-preference 200</span><br><span class="line"></span><br><span class="line">route-map EXAMPLE permit 20</span><br><span class="line">  match ip address prefix-list LIST-2</span><br><span class="line">  set local-preference 100</span><br></pre></td></tr></table></figure>
<h3 id="match-匹配条件"><a href="#match-匹配条件" class="headerlink" title="match 匹配条件"></a>match 匹配条件</h3><p>路由匹配条件，只有全部满足才算匹配</p>
<ul>
<li><code>match ip address prefix-list PREFIX_LIST</code><ul>
<li>IP 地址被 prefix-list  PREFIX_LIST 匹配并允许通过的路由则匹配</li>
</ul>
</li>
</ul>
<h3 id="set-设置动作"><a href="#set-设置动作" class="headerlink" title="set 设置动作"></a>set 设置动作</h3><h3 id="路由匹配规则"><a href="#路由匹配规则" class="headerlink" title="路由匹配规则"></a>路由匹配规则</h3><ol>
<li>优先匹配 order 小的 route map，逐条检查匹配，如果匹配上，则后续条目无需再检查</li>
<li>默认拒绝：如果所有的 route map 都没匹配上，则默认拒绝该路由</li>
<li>匹配规则：<ol>
<li>检查是否匹配上 <code>match</code> 的匹配规则，如果是匹配 prefix-list，需要被 prefix-list permit 才算匹配上该 <code>match</code></li>
<li></li>
</ol>
</li>
</ol>
<h2 id="route-map-应用"><a href="#route-map-应用" class="headerlink" title="route-map 应用"></a>route-map 应用</h2><h1 id="OSPF-组网"><a href="#OSPF-组网" class="headerlink" title="OSPF 组网"></a>OSPF 组网</h1><p>搭建下面一个网络，使用 Docker 模拟出三台 FRR 路由器，并给其配网，其中有两个网段：Router 1 的 eth1 和 Router 2 的 eth1、Router 3 的 eth1 和 Router 2 的 eth2，使用 FRR 让 Router 1 和 Router 3 学习到到对方的路由。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20241029023145100.png" alt="OSPF实验拓扑" style="zoom:50%;" /></p>
<h2 id="1-Docker-模拟-FRR-路由器"><a href="#1-Docker-模拟-FRR-路由器" class="headerlink" title="1. Docker 模拟 FRR 路由器"></a>1. Docker 模拟 FRR 路由器</h2><p>模拟 3 台 FRR 路由器 Docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --privileged --net&#x3D;none --name frr-01 quay.io&#x2F;frrouting&#x2F;frr:10.0.0</span><br><span class="line">docker run -d --privileged --net&#x3D;none --name frr-02 quay.io&#x2F;frrouting&#x2F;frr:10.0.0</span><br><span class="line">docker run -d --privileged --net&#x3D;none --name frr-03 quay.io&#x2F;frrouting&#x2F;frr:10.0.0</span><br></pre></td></tr></table></figure>
<p>查看 docker 进程</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE                          COMMAND                  CREATED         STATUS         PORTS     NAMES</span><br><span class="line"><span class="number">6185</span>c04f06d1   quay.io/frrouting/frr:<span class="number">10.0</span>.<span class="number">0</span>   <span class="string">"/sbin/tini -- /usr/…"</span>   <span class="number">2</span> minutes ago   Up <span class="number">2</span> minutes             frr<span class="literal">-03</span></span><br><span class="line"><span class="number">1681</span>fd9bd374   quay.io/frrouting/frr:<span class="number">10.0</span>.<span class="number">0</span>   <span class="string">"/sbin/tini -- /usr/…"</span>   <span class="number">3</span> minutes ago   Up <span class="number">3</span> minutes             frr<span class="literal">-02</span></span><br><span class="line"><span class="number">568</span>ade633bf9   quay.io/frrouting/frr:<span class="number">10.0</span>.<span class="number">0</span>   <span class="string">"/sbin/tini -- /usr/…"</span>   <span class="number">24</span> hours ago    Up <span class="number">24</span> hours              frr<span class="literal">-01</span></span><br></pre></td></tr></table></figure>
<h2 id="2-OvS-配网"><a href="#2-OvS-配网" class="headerlink" title="2. OvS 配网"></a>2. OvS 配网</h2><p>由于安装 docker 容器时使用 <code>--net=none</code> 无网络，需根据拓扑对容器配网</p>
<p>查看各个路由器的网卡，当前各 docker 容器无网卡</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker exec -it frr-01 ifconfig</span></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:<span class="number">127.0</span>.<span class="number">0.1</span>  Mask:<span class="number">255.0</span>.<span class="number">0.0</span></span><br><span class="line">          inet6 addr: ::<span class="number">1</span>/<span class="number">128</span> Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:<span class="number">65536</span>  Metric:<span class="number">1</span></span><br><span class="line">          RX packets:<span class="number">0</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> frame:<span class="number">0</span></span><br><span class="line">          TX packets:<span class="number">0</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> carrier:<span class="number">0</span></span><br><span class="line">          collisions:<span class="number">0</span> txqueuelen:<span class="number">1000</span></span><br><span class="line">          RX bytes:<span class="number">0</span> (<span class="number">0.0</span> B)  TX bytes:<span class="number">0</span> (<span class="number">0.0</span> B)</span><br><span class="line"></span><br><span class="line">root@ubuntu:~<span class="comment"># docker exec -it frr-02 ifconfig</span></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:<span class="number">127.0</span>.<span class="number">0.1</span>  Mask:<span class="number">255.0</span>.<span class="number">0.0</span></span><br><span class="line">          inet6 addr: ::<span class="number">1</span>/<span class="number">128</span> Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:<span class="number">65536</span>  Metric:<span class="number">1</span></span><br><span class="line">          RX packets:<span class="number">0</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> frame:<span class="number">0</span></span><br><span class="line">          TX packets:<span class="number">0</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> carrier:<span class="number">0</span></span><br><span class="line">          collisions:<span class="number">0</span> txqueuelen:<span class="number">1000</span></span><br><span class="line">          RX bytes:<span class="number">0</span> (<span class="number">0.0</span> B)  TX bytes:<span class="number">0</span> (<span class="number">0.0</span> B)</span><br><span class="line"></span><br><span class="line">root@ubuntu:~<span class="comment"># docker exec -it frr-03 ifconfig</span></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:<span class="number">127.0</span>.<span class="number">0.1</span>  Mask:<span class="number">255.0</span>.<span class="number">0.0</span></span><br><span class="line">          inet6 addr: ::<span class="number">1</span>/<span class="number">128</span> Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:<span class="number">65536</span>  Metric:<span class="number">1</span></span><br><span class="line">          RX packets:<span class="number">0</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> frame:<span class="number">0</span></span><br><span class="line">          TX packets:<span class="number">0</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> carrier:<span class="number">0</span></span><br><span class="line">          collisions:<span class="number">0</span> txqueuelen:<span class="number">1000</span></span><br><span class="line">          RX bytes:<span class="number">0</span> (<span class="number">0.0</span> B)  TX bytes:<span class="number">0</span> (<span class="number">0.0</span> B)</span><br></pre></td></tr></table></figure>
<p>安装 OvS 虚拟交换机用来搭建容器网络</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install openvswitch-switch</span><br></pre></td></tr></table></figure>
<p>创建一个网桥交换机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ovs-vsctl add-br brConn</span><br></pre></td></tr></table></figure>
<p>如需删除，使用 <code>ovs-vsctl del-br brConn</code></p>
<p>查看创建好的网桥</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># ovs-vsctl show</span></span><br><span class="line">cb63c817<span class="literal">-8d63</span><span class="literal">-4d1f</span><span class="literal">-b599</span><span class="literal">-9950b0aeb2eb</span></span><br><span class="line">    Bridge brConn</span><br><span class="line">        Port brConn</span><br><span class="line">            Interface brConn</span><br><span class="line">                type: internal</span><br><span class="line">    ovs_version: <span class="string">"2.13.8"</span></span><br></pre></td></tr></table></figure>
<p>让三台 docker 路由器都连接到这个交换机，并配置 IP</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ovs-docker add-port brConn eth1 frr-01 --ipaddress&#x3D;11.11.0.2&#x2F;24</span><br><span class="line">ovs-docker add-port brConn eth1 frr-02 --ipaddress&#x3D;11.11.0.3&#x2F;24</span><br><span class="line">ovs-docker add-port brConn eth2 frr-02 --ipaddress&#x3D;12.12.0.2&#x2F;24</span><br><span class="line">ovs-docker add-port brConn eth1 frr-03 --ipaddress&#x3D;12.12.0.3&#x2F;24</span><br></pre></td></tr></table></figure>
<p>再次查看网桥</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># ovs-vsctl show</span></span><br><span class="line">cb63c817<span class="literal">-8d63</span><span class="literal">-4d1f</span><span class="literal">-b599</span><span class="literal">-9950b0aeb2eb</span></span><br><span class="line">    Bridge brConn</span><br><span class="line">        Port brConn</span><br><span class="line">            Interface brConn</span><br><span class="line">                type: internal</span><br><span class="line">        Port <span class="string">"0021a5f25d344_l"</span></span><br><span class="line">            Interface <span class="string">"0021a5f25d344_l"</span></span><br><span class="line">        Port <span class="string">"1529171a9a294_l"</span></span><br><span class="line">            Interface <span class="string">"1529171a9a294_l"</span></span><br><span class="line">        Port df2bf7ec96bd4_l</span><br><span class="line">            Interface df2bf7ec96bd4_l</span><br><span class="line">        Port a67433ae00b04_l</span><br><span class="line">            Interface a67433ae00b04_l</span><br><span class="line">    ovs_version: <span class="string">"2.13.8"</span></span><br></pre></td></tr></table></figure>
<p>此时上各个 Docker 可以看到已配好的网卡</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker exec -it frr-01 ifconfig</span></span><br><span class="line">eth1      Link encap:Ethernet  HWaddr <span class="number">1</span>A:CF:B4:C0:<span class="number">93</span>:<span class="number">4</span>B</span><br><span class="line">          inet addr:<span class="number">11.11</span>.<span class="number">0.2</span>  Bcast:<span class="number">0.0</span>.<span class="number">0.0</span>  Mask:<span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line">          inet6 addr: fe80::<span class="number">18</span>cf:b4ff:fec0:<span class="number">934</span>b/<span class="number">64</span> Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:<span class="number">1500</span>  Metric:<span class="number">1</span></span><br><span class="line">          RX packets:<span class="number">165</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> frame:<span class="number">0</span></span><br><span class="line">          TX packets:<span class="number">42</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> carrier:<span class="number">0</span></span><br><span class="line">          collisions:<span class="number">0</span> txqueuelen:<span class="number">1000</span></span><br><span class="line">          RX bytes:<span class="number">13826</span> (<span class="number">13.5</span> KiB)  TX bytes:<span class="number">3036</span> (<span class="number">2.9</span> KiB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:<span class="number">127.0</span>.<span class="number">0.1</span>  Mask:<span class="number">255.0</span>.<span class="number">0.0</span></span><br><span class="line">          inet6 addr: ::<span class="number">1</span>/<span class="number">128</span> Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:<span class="number">65536</span>  Metric:<span class="number">1</span></span><br><span class="line">          RX packets:<span class="number">0</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> frame:<span class="number">0</span></span><br><span class="line">          TX packets:<span class="number">0</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> carrier:<span class="number">0</span></span><br><span class="line">          collisions:<span class="number">0</span> txqueuelen:<span class="number">1000</span></span><br><span class="line">          RX bytes:<span class="number">0</span> (<span class="number">0.0</span> B)  TX bytes:<span class="number">0</span> (<span class="number">0.0</span> B)</span><br><span class="line"></span><br><span class="line">root@ubuntu:~<span class="comment"># docker exec -it frr-02 ifconfig</span></span><br><span class="line">eth1      Link encap:Ethernet  HWaddr DE:<span class="number">38</span>:AD:<span class="number">91</span>:D8:<span class="number">24</span></span><br><span class="line">          inet addr:<span class="number">11.11</span>.<span class="number">0.3</span>  Bcast:<span class="number">0.0</span>.<span class="number">0.0</span>  Mask:<span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line">          inet6 addr: fe80::dc38:adff:fe91:d824/<span class="number">64</span> Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:<span class="number">1500</span>  Metric:<span class="number">1</span></span><br><span class="line">          RX packets:<span class="number">200</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> frame:<span class="number">0</span></span><br><span class="line">          TX packets:<span class="number">42</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> carrier:<span class="number">0</span></span><br><span class="line">          collisions:<span class="number">0</span> txqueuelen:<span class="number">1000</span></span><br><span class="line">          RX bytes:<span class="number">16592</span> (<span class="number">16.2</span> KiB)  TX bytes:<span class="number">3036</span> (<span class="number">2.9</span> KiB)</span><br><span class="line"></span><br><span class="line">eth2      Link encap:Ethernet  HWaddr E2:<span class="number">4</span>D:<span class="number">1</span>E:<span class="number">69</span>:<span class="number">47</span>:D2</span><br><span class="line">          inet addr:<span class="number">12.12</span>.<span class="number">0.2</span>  Bcast:<span class="number">0.0</span>.<span class="number">0.0</span>  Mask:<span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line">          inet6 addr: fe80::e04d:<span class="number">1</span>eff:fe69:<span class="number">47</span>d2/<span class="number">64</span> Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:<span class="number">1500</span>  Metric:<span class="number">1</span></span><br><span class="line">          RX packets:<span class="number">190</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> frame:<span class="number">0</span></span><br><span class="line">          TX packets:<span class="number">39</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> carrier:<span class="number">0</span></span><br><span class="line">          collisions:<span class="number">0</span> txqueuelen:<span class="number">1000</span></span><br><span class="line">          RX bytes:<span class="number">15768</span> (<span class="number">15.3</span> KiB)  TX bytes:<span class="number">2798</span> (<span class="number">2.7</span> KiB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:<span class="number">127.0</span>.<span class="number">0.1</span>  Mask:<span class="number">255.0</span>.<span class="number">0.0</span></span><br><span class="line">          inet6 addr: ::<span class="number">1</span>/<span class="number">128</span> Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:<span class="number">65536</span>  Metric:<span class="number">1</span></span><br><span class="line">          RX packets:<span class="number">0</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> frame:<span class="number">0</span></span><br><span class="line">          TX packets:<span class="number">0</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> carrier:<span class="number">0</span></span><br><span class="line">          collisions:<span class="number">0</span> txqueuelen:<span class="number">1000</span></span><br><span class="line">          RX bytes:<span class="number">0</span> (<span class="number">0.0</span> B)  TX bytes:<span class="number">0</span> (<span class="number">0.0</span> B)</span><br><span class="line"></span><br><span class="line">root@ubuntu:~<span class="comment"># docker exec -it frr-03 ifconfig</span></span><br><span class="line">eth1      Link encap:Ethernet  HWaddr <span class="number">16</span>:<span class="number">47</span>:A2:B7:F5:<span class="number">4</span>F</span><br><span class="line">          inet addr:<span class="number">12.12</span>.<span class="number">0.3</span>  Bcast:<span class="number">0.0</span>.<span class="number">0.0</span>  Mask:<span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line">          inet6 addr: fe80::<span class="number">1447</span>:a2ff:feb7:f54f/<span class="number">64</span> Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:<span class="number">1500</span>  Metric:<span class="number">1</span></span><br><span class="line">          RX packets:<span class="number">182</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> frame:<span class="number">0</span></span><br><span class="line">          TX packets:<span class="number">38</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> carrier:<span class="number">0</span></span><br><span class="line">          collisions:<span class="number">0</span> txqueuelen:<span class="number">1000</span></span><br><span class="line">          RX bytes:<span class="number">15112</span> (<span class="number">14.7</span> KiB)  TX bytes:<span class="number">2756</span> (<span class="number">2.6</span> KiB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:<span class="number">127.0</span>.<span class="number">0.1</span>  Mask:<span class="number">255.0</span>.<span class="number">0.0</span></span><br><span class="line">          inet6 addr: ::<span class="number">1</span>/<span class="number">128</span> Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:<span class="number">65536</span>  Metric:<span class="number">1</span></span><br><span class="line">          RX packets:<span class="number">0</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> frame:<span class="number">0</span></span><br><span class="line">          TX packets:<span class="number">0</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> carrier:<span class="number">0</span></span><br><span class="line">          collisions:<span class="number">0</span> txqueuelen:<span class="number">1000</span></span><br><span class="line">          RX bytes:<span class="number">0</span> (<span class="number">0.0</span> B)  TX bytes:<span class="number">0</span> (<span class="number">0.0</span> B)</span><br></pre></td></tr></table></figure>
<h2 id="3-FRR-组网"><a href="#3-FRR-组网" class="headerlink" title="3. FRR 组网"></a>3. FRR 组网</h2><p>由于 Router 1 eth1 和 Router 3 eth1 属于不同网段，在组网前两者间无路由，ping 不通</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker exec -it frr-01 bash</span></span><br><span class="line"><span class="number">568</span>ade633bf9:/<span class="comment"># ping 12.12.0.3</span></span><br><span class="line">PING <span class="number">12.12</span>.<span class="number">0.3</span> (<span class="number">12.12</span>.<span class="number">0.3</span>): <span class="number">56</span> <span class="keyword">data</span> bytes</span><br><span class="line">ping: sendto: Network unreachable</span><br><span class="line"><span class="number">568</span>ade633bf9:/<span class="comment"># route -ne</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</span><br><span class="line"><span class="number">11.11</span>.<span class="number">0.0</span>       <span class="number">0.0</span>.<span class="number">0.0</span>         <span class="number">255.255</span>.<span class="number">255.0</span>   U         <span class="number">0</span> <span class="number">0</span>          <span class="number">0</span> eth1</span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker exec -it frr-03 bash</span></span><br><span class="line"><span class="number">6185</span>c04f06d1:/<span class="comment"># ping 11.11.0.2</span></span><br><span class="line">PING <span class="number">11.11</span>.<span class="number">0.2</span> (<span class="number">11.11</span>.<span class="number">0.2</span>): <span class="number">56</span> <span class="keyword">data</span> bytes</span><br><span class="line">ping: sendto: Network unreachable</span><br><span class="line"><span class="number">6185</span>c04f06d1:/<span class="comment"># route -ne</span></span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</span><br><span class="line"><span class="number">12.12</span>.<span class="number">0.0</span>       <span class="number">0.0</span>.<span class="number">0.0</span>         <span class="number">255.255</span>.<span class="number">255.0</span>   U         <span class="number">0</span> <span class="number">0</span>          <span class="number">0</span> eth1</span><br></pre></td></tr></table></figure>
<p>通过配置 FRR 使得两个网段学习到对方的路由，实现 OSPF 组网</p>
<p>FRR 开启 OSPF 进程</p>
<ol>
<li><p>编辑 <code>/etc/frr/daemons</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ospfd&#x3D;yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启 FRR 服务</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;frr restart</span><br></pre></td></tr></table></figure>
<p>vtysh 配置 FRR OSPF</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">--- frr<span class="literal">-01</span> ---</span><br><span class="line"><span class="number">568</span>ade633bf9<span class="comment"># configure</span></span><br><span class="line"><span class="number">568</span>ade633bf9(config)<span class="comment"># router ospf</span></span><br><span class="line"><span class="number">568</span>ade633bf9(config<span class="literal">-router</span>)<span class="comment"># network 11.11.0.2/24 area 0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">--- frr<span class="literal">-02</span> ---</span><br><span class="line"><span class="number">1681</span>fd9bd374<span class="comment"># configure</span></span><br><span class="line"><span class="number">1681</span>fd9bd374(config)<span class="comment"># router ospf</span></span><br><span class="line"><span class="number">1681</span>fd9bd374(config<span class="literal">-router</span>)<span class="comment"># network 11.11.0.3/24 area 0</span></span><br><span class="line"><span class="number">1681</span>fd9bd374(config<span class="literal">-router</span>)<span class="comment"># network 12.12.0.2/24 area 0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">--- frr<span class="literal">-03</span> ---</span><br><span class="line"><span class="number">6185</span>c04f06d1<span class="comment"># configure</span></span><br><span class="line"><span class="number">6185</span>c04f06d1(config)<span class="comment"># router ospf</span></span><br><span class="line"><span class="number">6185</span>c04f06d1(config<span class="literal">-router</span>)<span class="comment"># network 12.12.0.3/24 area 0</span></span><br></pre></td></tr></table></figure>
<p>配置完毕后，frr-01 和 frr-03 的 OSPF 便能学习到对方的路由，互相能 ping 通</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">--- frr<span class="literal">-01</span> ---</span><br><span class="line"><span class="number">568</span>ade633bf9<span class="comment"># show ip ospf route</span></span><br><span class="line">============ OSPF network routing table ============</span><br><span class="line">N    <span class="number">11.11</span>.<span class="number">0.0</span>/<span class="number">24</span>          [<span class="number">10</span>] area: <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line">                           directly attached to eth1</span><br><span class="line">N    <span class="number">12.12</span>.<span class="number">0.0</span>/<span class="number">24</span>          [<span class="number">20</span>] area: <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line">                           via <span class="number">11.11</span>.<span class="number">0.3</span>, eth1</span><br><span class="line"></span><br><span class="line">============ OSPF router routing table =============</span><br><span class="line"></span><br><span class="line">============ OSPF external routing table ===========</span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">--- frr<span class="literal">-01</span> ---</span><br><span class="line"><span class="number">568</span>ade633bf9:/<span class="comment"># ping 12.12.0.3</span></span><br><span class="line">PING <span class="number">12.12</span>.<span class="number">0.3</span> (<span class="number">12.12</span>.<span class="number">0.3</span>): <span class="number">56</span> <span class="keyword">data</span> bytes</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">12.12</span>.<span class="number">0.3</span>: seq=<span class="number">0</span> ttl=<span class="number">63</span> time=<span class="number">0.725</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">12.12</span>.<span class="number">0.3</span>: seq=<span class="number">1</span> ttl=<span class="number">63</span> time=<span class="number">0.225</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">12.12</span>.<span class="number">0.3</span>: seq=<span class="number">2</span> ttl=<span class="number">63</span> time=<span class="number">0.128</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">12.12</span>.<span class="number">0.3</span>: seq=<span class="number">3</span> ttl=<span class="number">63</span> time=<span class="number">0.205</span> ms</span><br><span class="line">^C</span><br><span class="line">--- <span class="number">12.12</span>.<span class="number">0.3</span> ping statistics ---</span><br><span class="line"><span class="number">4</span> packets transmitted, <span class="number">4</span> packets received, <span class="number">0</span>% packet loss</span><br><span class="line">round<span class="literal">-trip</span> min/avg/max = <span class="number">0.128</span>/<span class="number">0.320</span>/<span class="number">0.725</span> ms</span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">--- frr<span class="literal">-03</span> ---</span><br><span class="line"><span class="number">6185</span>c04f06d1<span class="comment"># show ip ospf route</span></span><br><span class="line">============ OSPF network routing table ============</span><br><span class="line">N    <span class="number">11.11</span>.<span class="number">0.0</span>/<span class="number">24</span>          [<span class="number">20</span>] area: <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line">                           via <span class="number">12.12</span>.<span class="number">0.2</span>, eth1</span><br><span class="line">N    <span class="number">12.12</span>.<span class="number">0.0</span>/<span class="number">24</span>          [<span class="number">10</span>] area: <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line">                           directly attached to eth1</span><br><span class="line"></span><br><span class="line">============ OSPF router routing table =============</span><br><span class="line"></span><br><span class="line">============ OSPF external routing table ===========</span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">--- frr<span class="literal">-03</span> ---</span><br><span class="line"><span class="number">6185</span>c04f06d1:/<span class="comment"># ping 11.11.0.2</span></span><br><span class="line">PING <span class="number">11.11</span>.<span class="number">0.2</span> (<span class="number">11.11</span>.<span class="number">0.2</span>): <span class="number">56</span> <span class="keyword">data</span> bytes</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">11.11</span>.<span class="number">0.2</span>: seq=<span class="number">0</span> ttl=<span class="number">63</span> time=<span class="number">1.871</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">11.11</span>.<span class="number">0.2</span>: seq=<span class="number">1</span> ttl=<span class="number">63</span> time=<span class="number">0.236</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">11.11</span>.<span class="number">0.2</span>: seq=<span class="number">2</span> ttl=<span class="number">63</span> time=<span class="number">0.161</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">11.11</span>.<span class="number">0.2</span>: seq=<span class="number">3</span> ttl=<span class="number">63</span> time=<span class="number">0.151</span> ms</span><br><span class="line">^C</span><br><span class="line">--- <span class="number">11.11</span>.<span class="number">0.2</span> ping statistics ---</span><br><span class="line"><span class="number">4</span> packets transmitted, <span class="number">4</span> packets received, <span class="number">0</span>% packet loss</span><br><span class="line">round<span class="literal">-trip</span> min/avg/max = <span class="number">0.151</span>/<span class="number">0.604</span>/<span class="number">1.871</span> ms</span><br></pre></td></tr></table></figure>
<h1 id="DR-竞选"><a href="#DR-竞选" class="headerlink" title="DR 竞选"></a>DR 竞选</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://frrouting.org" target="_blank" rel="noopener">FRRouting 官网</a></li>
<li><a href="https://blog.csdn.net/puhaiyang/article/details/140189690" target="_blank" rel="noopener">Frrouting快速入门——OSPF组网（一）</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Linux学习</title>
    <url>/2023/03/19/Linux%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>基于Linux Ubuntu的学习</p>
<a id="more"></a>
<h1 id="Linux-虚拟机环境搭建"><a href="#Linux-虚拟机环境搭建" class="headerlink" title="Linux 虚拟机环境搭建"></a>Linux 虚拟机环境搭建</h1><h2 id="Linux虚拟机的安装"><a href="#Linux虚拟机的安装" class="headerlink" title="Linux虚拟机的安装"></a>Linux虚拟机的安装</h2><ul>
<li>安装<a href="https://store-us.vmware.com" target="_blank" rel="noopener">VMware</a></li>
<li>安装<a href="https://www.centos.org/download/" target="_blank" rel="noopener">Centos</a>版本的Linux，或 Ubuntu ，下载<code>iso</code>文件</li>
<li>将<code>iso</code>文件拖拽到VMware中</li>
</ul>
<h2 id="虚拟机网络模式"><a href="#虚拟机网络模式" class="headerlink" title="虚拟机网络模式"></a>虚拟机网络模式</h2><p>虚拟机和宿主机的网络拓扑关系有三种模式：桥接模式、主机模式、NAT 模式</p>
<p><a href="https://zhuanlan.zhihu.com/p/24758022" target="_blank" rel="noopener">VMware的三种网络模式</a></p>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>虚拟机网卡通过虚拟交换机 VMnet0 与宿主机网卡进行桥接，虚拟机网卡和宿主机网卡在拓扑处于同等地位，相当于局域网中的一台独立的主机。</p>
<p>桥接模式可以访问外网，但是需要占用该网段 IP，如果 IP 资源紧缺，使用 NAT 模式。</p>
<h3 id="主机模式"><a href="#主机模式" class="headerlink" title="主机模式"></a>主机模式</h3><p>虚拟机网卡和宿主机网卡都连在虚拟交换机 VMnet1 上，虚拟机与外界隔开成独立的系统，只与主机相互通信。</p>
<h3 id="NAT-模式"><a href="#NAT-模式" class="headerlink" title="NAT 模式"></a>NAT 模式</h3><p>在宿主机上建立单独的专用网络，虚拟机与主机之间都可以相互通信，虚拟机与外界通讯时，数据会被包裹，以主机的名义发出去。</p>
<p><a href="https://www.virtualbox.org/manual/ch06.html" target="_blank" rel="noopener">Virtual Networking</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Mode</th>
<th>VM —&gt; Host</th>
<th>VM &lt;— Host</th>
<th>VM1 &lt;—&gt; VM2</th>
<th>VM —&gt; Net</th>
<th>VM &lt;— Net</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bridge</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td>Host-Only</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>NAT</td>
<td>+</td>
<td>+</td>
<td>-</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td>NAT Network</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
</tbody>
</table>
</div>
<h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><h2 id="SSH连接虚拟机"><a href="#SSH连接虚拟机" class="headerlink" title="SSH连接虚拟机"></a>SSH连接虚拟机</h2><ol>
<li><p>虚拟机安装 openssh-server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install openssh-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启 sshd 服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start sshd</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置虚拟机网卡，至少需要一张 NAT 模式网卡用于 ssh 连接，查看该网卡</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip a</span><br></pre></td></tr></table></figure>
<p>网卡 IP 为 192.168.45.136</p>
</li>
<li><p>ssh 连接虚拟机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh guoyi@192.168.45.136</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="设置-ssh-别名"><a href="#设置-ssh-别名" class="headerlink" title="设置 ssh 别名"></a>设置 ssh 别名</h2><p>将下面直接登入方式改为别名登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh guoyi@192.168.45.136</span><br></pre></td></tr></table></figure>
<p>在 <code>~/.ssh/config</code> 文件中添加远端服务器信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host Ubuntu</span><br><span class="line">  HostName 192.168.45.136</span><br><span class="line">  User guoyi</span><br><span class="line">  Port 22</span><br></pre></td></tr></table></figure>
<p>即可用别名 Ubuntu 进行登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh Ubuntu</span><br></pre></td></tr></table></figure>
<h2 id="设置免密登录"><a href="#设置免密登录" class="headerlink" title="设置免密登录"></a>设置免密登录</h2><ol>
<li><p>查看本机的  <code>~/.ssh</code> 文件夹是否有公私钥对，没有则生成一对</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>
<p>默认命名为 id_rsa，也可输入自定义名字，如 mac_key，密码无需设置，自动生成私钥 mac_key 和公钥 mac_key.pub 两个文件</p>
</li>
<li><p>将公钥上传到服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i mac_key.pub Ubuntu</span><br></pre></td></tr></table></figure>
<p>此命令自动将公钥传到 Ubuntu 所指服务器和用户的 .ssh/known_hosts 文件中</p>
</li>
<li><p>（Mac 额外步骤）本机添加私钥文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-add -K mac_key</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面三步设置完成后，即可免密登录服务器</p>
<h2 id="开启-root-用户登录"><a href="#开启-root-用户登录" class="headerlink" title="开启 root 用户登录"></a>开启 root 用户登录</h2><p>Ubuntu默认不允许直接 ssh 到 root 用户，需在服务器上开启 root 用户登录开关</p>
<p>在 Ubuntu 服务器的 <code>/etc/ssh/sshd_config</code> 中，取消 PermitRootLogin 参数的注释，并将由其 prohibit-password 改为 yes</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PermitRootLogin yes</span><br></pre></td></tr></table></figure>
<p>重启 sshd</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure>
<h1 id="apt"><a href="#apt" class="headerlink" title="apt"></a>apt</h1><ul>
<li><p>更新 apt，有些包找不到，可能是因为 apt 没更新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt update</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
<h1 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h1><p>Linux的目录同样为树形结构，最顶级的根目录为<code>/</code></p>
<ul>
<li><p>绝对路径</p>
<p>  从根目录<code>/</code>写起，例如<code>/usr/share/doc</code></p>
</li>
<li><p>相对路径</p>
</li>
</ul>
<h1 id="Linux基础命令"><a href="#Linux基础命令" class="headerlink" title="Linux基础命令"></a>Linux基础命令</h1><ul>
<li><code>ls</code> 查看当前目录下的所有目录和文件</li>
<li><code>cat &lt;文件路径&gt;</code> 查看文件内容</li>
<li><code>clear</code> 清空命令行</li>
</ul>
<h2 id="rpm命令"><a href="#rpm命令" class="headerlink" title="rpm命令"></a>rpm命令</h2><p>redhat package manager，包管理命令</p>
<ul>
<li><code>rpm -q &lt;package name&gt;</code> ：查看包是否安装</li>
<li><code>rpm -qi &lt;package name&gt;</code> ：查看包的详细信息</li>
<li><code>rpm -ql &lt;package name&gt;</code> ：查看包列表（里面的文件）</li>
</ul>
<h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p>打开并编辑文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &lt;文件路径&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>i</code> 切换到输入模式</li>
<li><code>ESC``:wq</code>保存并退出</li>
</ul>
<h1 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h1><p>yum 是 Shell 前端软件包管理器，提供了方便的安装、卸载、更新软件包的命令</p>
<h2 id="yum的安装"><a href="#yum的安装" class="headerlink" title="yum的安装"></a>yum的安装</h2><h1 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h1><h2 id="扩展根目录"><a href="#扩展根目录" class="headerlink" title="扩展根目录"></a>扩展根目录</h2><p>查看当前磁盘占用情况，可以看到根目录占用率很高，且在 <code>/dev/mapper/ubuntu--vg-ubuntu--lv</code> 分区 </p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">guoyi@ubuntu2404:~<span class="variable">$</span> df <span class="literal">-h</span></span><br><span class="line">Filesystem                         Size  Used Avail Use% Mounted on</span><br><span class="line">tmpfs                              <span class="number">391</span>M  <span class="number">1.7</span>M  <span class="number">389</span>M   <span class="number">1</span>% /run</span><br><span class="line">efivarfs                           <span class="number">256</span>K   <span class="number">32</span>K  <span class="number">225</span>K  <span class="number">13</span>% /sys/firmware/efi/efivars</span><br><span class="line">/dev/mapper/ubuntu-<span class="literal">-vg</span><span class="literal">-ubuntu</span>-<span class="literal">-lv</span>  <span class="number">9.8</span>G  <span class="number">8.3</span>G  <span class="number">974</span>M  <span class="number">90</span>% /</span><br><span class="line">tmpfs                              <span class="number">2.0</span>G     <span class="number">0</span>  <span class="number">2.0</span>G   <span class="number">0</span>% /dev/shm</span><br><span class="line">tmpfs                              <span class="number">5.0</span>M  <span class="number">8.0</span>K  <span class="number">5.0</span>M   <span class="number">1</span>% /run/lock</span><br><span class="line">/dev/nvme0n1p2                     <span class="number">1.7</span>G  <span class="number">105</span>M  <span class="number">1.5</span>G   <span class="number">7</span>% /boot</span><br><span class="line">/dev/nvme0n1p1                     <span class="number">952</span>M  <span class="number">6.4</span>M  <span class="number">945</span>M   <span class="number">1</span>% /boot/efi</span><br><span class="line">tmpfs                              <span class="number">391</span>M  <span class="number">124</span>K  <span class="number">391</span>M   <span class="number">1</span>% /run/user/<span class="number">1000</span></span><br><span class="line">/dev/sr0                           <span class="number">2.4</span>G  <span class="number">2.4</span>G     <span class="number">0</span> <span class="number">100</span>% /media/guoyi/Ubuntu<span class="literal">-Server</span> <span class="number">24.04</span>.<span class="number">1</span> LTS arm64</span><br></pre></td></tr></table></figure>
<p>查看当前磁盘分区，<code>ubuntu--vg-ubuntu--lv</code> 在 <code>nvme0n1p3</code> 下</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">guoyi@ubuntu2404:~<span class="variable">$</span> lsblk</span><br><span class="line">NAME                      MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">loop0                       <span class="number">7</span>:<span class="number">0</span>    <span class="number">0</span>     <span class="number">4</span>K  <span class="number">1</span> loop /snap/bare/<span class="number">5</span></span><br><span class="line">loop1                       <span class="number">7</span>:<span class="number">1</span>    <span class="number">0</span>  <span class="number">68.8</span>M  <span class="number">1</span> loop /snap/core22/<span class="number">1666</span></span><br><span class="line">loop2                       <span class="number">7</span>:<span class="number">2</span>    <span class="number">0</span> <span class="number">250.3</span>M  <span class="number">1</span> loop /snap/firefox/<span class="number">5236</span></span><br><span class="line">loop3                       <span class="number">7</span>:<span class="number">3</span>    <span class="number">0</span> <span class="number">483.3</span>M  <span class="number">1</span> loop /snap/gnome<span class="literal">-42</span><span class="literal">-2204</span>/<span class="number">178</span></span><br><span class="line">loop4                       <span class="number">7</span>:<span class="number">4</span>    <span class="number">0</span>  <span class="number">91.7</span>M  <span class="number">1</span> loop /snap/gtk<span class="literal">-common</span><span class="literal">-themes</span>/<span class="number">1535</span></span><br><span class="line">loop5                       <span class="number">7</span>:<span class="number">5</span>    <span class="number">0</span>  <span class="number">33.7</span>M  <span class="number">1</span> loop /snap/snapd/<span class="number">21761</span></span><br><span class="line">loop6                       <span class="number">7</span>:<span class="number">6</span>    <span class="number">0</span> <span class="number">144.1</span>M  <span class="number">1</span> loop /snap/thunderbird/<span class="number">560</span></span><br><span class="line">sr0                        <span class="number">11</span>:<span class="number">0</span>    <span class="number">1</span>   <span class="number">2.3</span>G  <span class="number">0</span> rom  /media/guoyi/Ubuntu<span class="literal">-Server</span> <span class="number">24.04</span>.<span class="number">1</span> LTS arm64</span><br><span class="line">nvme0n1                   <span class="number">259</span>:<span class="number">0</span>    <span class="number">0</span>    <span class="number">50</span>G  <span class="number">0</span> disk</span><br><span class="line">├─nvme0n1p1               <span class="number">259</span>:<span class="number">1</span>    <span class="number">0</span>   <span class="number">953</span>M  <span class="number">0</span> part /boot/efi</span><br><span class="line">├─nvme0n1p2               <span class="number">259</span>:<span class="number">2</span>    <span class="number">0</span>   <span class="number">1.8</span>G  <span class="number">0</span> part /boot</span><br><span class="line">└─nvme0n1p3               <span class="number">259</span>:<span class="number">3</span>    <span class="number">0</span>  <span class="number">11.9</span>G  <span class="number">0</span> part</span><br><span class="line">  └─ubuntu-<span class="literal">-vg</span><span class="literal">-ubuntu</span>-<span class="literal">-lv</span> <span class="number">252</span>:<span class="number">0</span>    <span class="number">0</span>    <span class="number">10</span>G  <span class="number">0</span> lvm  /</span><br></pre></td></tr></table></figure>
<p>扩展步骤：</p>
<ol>
<li><p>通过 VMWare 扩展磁盘</p>
</li>
<li><p>通过 Disks 或者 GParted 软件将 <code>nvme0n1p3</code> 分区扩展</p>
</li>
<li><p>将剩余空间分配给  <code>/dev/mapper/ubuntu--vg-ubuntu--lv</code> 分区 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo lvextend -r -l +100%FREE &#x2F;dev&#x2F;mapper&#x2F;ubuntu--vg-ubuntu--lv</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>查看磁盘情况</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">guoyi@ubuntu2404:~<span class="variable">$</span> lsblk</span><br><span class="line">NAME                      MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">loop0                       <span class="number">7</span>:<span class="number">0</span>    <span class="number">0</span>     <span class="number">4</span>K  <span class="number">1</span> loop /snap/bare/<span class="number">5</span></span><br><span class="line">loop1                       <span class="number">7</span>:<span class="number">1</span>    <span class="number">0</span>  <span class="number">68.8</span>M  <span class="number">1</span> loop /snap/core22/<span class="number">1666</span></span><br><span class="line">loop2                       <span class="number">7</span>:<span class="number">2</span>    <span class="number">0</span> <span class="number">250.3</span>M  <span class="number">1</span> loop /snap/firefox/<span class="number">5236</span></span><br><span class="line">loop3                       <span class="number">7</span>:<span class="number">3</span>    <span class="number">0</span> <span class="number">483.3</span>M  <span class="number">1</span> loop /snap/gnome<span class="literal">-42</span><span class="literal">-2204</span>/<span class="number">178</span></span><br><span class="line">loop4                       <span class="number">7</span>:<span class="number">4</span>    <span class="number">0</span>  <span class="number">91.7</span>M  <span class="number">1</span> loop /snap/gtk<span class="literal">-common</span><span class="literal">-themes</span>/<span class="number">1535</span></span><br><span class="line">loop5                       <span class="number">7</span>:<span class="number">5</span>    <span class="number">0</span>  <span class="number">33.7</span>M  <span class="number">1</span> loop /snap/snapd/<span class="number">21761</span></span><br><span class="line">loop6                       <span class="number">7</span>:<span class="number">6</span>    <span class="number">0</span> <span class="number">144.1</span>M  <span class="number">1</span> loop /snap/thunderbird/<span class="number">560</span></span><br><span class="line">sr0                        <span class="number">11</span>:<span class="number">0</span>    <span class="number">1</span>   <span class="number">2.3</span>G  <span class="number">0</span> rom  /media/guoyi/Ubuntu<span class="literal">-Server</span> <span class="number">24.04</span>.<span class="number">1</span> LTS arm64</span><br><span class="line">nvme0n1                   <span class="number">259</span>:<span class="number">0</span>    <span class="number">0</span>    <span class="number">50</span>G  <span class="number">0</span> disk</span><br><span class="line">├─nvme0n1p1               <span class="number">259</span>:<span class="number">1</span>    <span class="number">0</span>   <span class="number">953</span>M  <span class="number">0</span> part /boot/efi</span><br><span class="line">├─nvme0n1p2               <span class="number">259</span>:<span class="number">2</span>    <span class="number">0</span>   <span class="number">1.8</span>G  <span class="number">0</span> part /boot</span><br><span class="line">└─nvme0n1p3               <span class="number">259</span>:<span class="number">3</span>    <span class="number">0</span>  <span class="number">47.3</span>G  <span class="number">0</span> part</span><br><span class="line">  └─ubuntu-<span class="literal">-vg</span><span class="literal">-ubuntu</span>-<span class="literal">-lv</span> <span class="number">252</span>:<span class="number">0</span>    <span class="number">0</span>  <span class="number">47.3</span>G  <span class="number">0</span> lvm  /</span><br><span class="line">  </span><br><span class="line">guoyi@ubuntu2404:~<span class="variable">$</span> df <span class="literal">-h</span></span><br><span class="line">Filesystem                         Size  Used Avail Use% Mounted on</span><br><span class="line">tmpfs                              <span class="number">391</span>M  <span class="number">1.7</span>M  <span class="number">389</span>M   <span class="number">1</span>% /run</span><br><span class="line">efivarfs                           <span class="number">256</span>K   <span class="number">32</span>K  <span class="number">225</span>K  <span class="number">13</span>% /sys/firmware/efi/efivars</span><br><span class="line">/dev/mapper/ubuntu-<span class="literal">-vg</span><span class="literal">-ubuntu</span>-<span class="literal">-lv</span>   <span class="number">47</span>G  <span class="number">8.3</span>G   <span class="number">37</span>G  <span class="number">19</span>% /</span><br><span class="line">tmpfs                              <span class="number">2.0</span>G     <span class="number">0</span>  <span class="number">2.0</span>G   <span class="number">0</span>% /dev/shm</span><br><span class="line">tmpfs                              <span class="number">5.0</span>M  <span class="number">8.0</span>K  <span class="number">5.0</span>M   <span class="number">1</span>% /run/lock</span><br><span class="line">/dev/nvme0n1p2                     <span class="number">1.7</span>G  <span class="number">105</span>M  <span class="number">1.5</span>G   <span class="number">7</span>% /boot</span><br><span class="line">/dev/nvme0n1p1                     <span class="number">952</span>M  <span class="number">6.4</span>M  <span class="number">945</span>M   <span class="number">1</span>% /boot/efi</span><br><span class="line">tmpfs                              <span class="number">391</span>M  <span class="number">128</span>K  <span class="number">391</span>M   <span class="number">1</span>% /run/user/<span class="number">1000</span></span><br><span class="line">/dev/sr0                           <span class="number">2.4</span>G  <span class="number">2.4</span>G     <span class="number">0</span> <span class="number">100</span>% /media/guoyi/Ubuntu<span class="literal">-Server</span> <span class="number">24.04</span>.<span class="number">1</span> LTS arm64</span><br></pre></td></tr></table></figure>
<h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><h2 id="su-root-时，报错-Authentication-failure"><a href="#su-root-时，报错-Authentication-failure" class="headerlink" title="su root 时，报错 Authentication failure"></a>su root 时，报错 Authentication failure</h2><p>首次 <code>su root</code> 时，需先录入密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure>
<p>否则会出现 Authentication failure 的报错</p>
]]></content>
  </entry>
  <entry>
    <title>MATLAB学习手册</title>
    <url>/2020/03/05/MATLAB%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>​    MATLAB是MATrix LABoratory（矩阵实验室）的缩写，是一款由美国The MathWorks公司出品的商业数学软件。MATLAB是一种用于算法开发、数据可视化、数据分析以及数值计算的高级技术计算语言和交互式环境。除了矩阵运算、绘制函数/数据图像等常用功能外，MATLAB还可以用来创建用户界面及与调用其它语言（包括C、C++、Java、Python和FORTRAN）编写的程序。下面是对<a href="https://ww2.mathworks.cn/help/matlab/index.html" target="_blank" rel="noopener">MATLAB官方中文文档</a>的学习总结。</p>
<a id="more"></a>
<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h2 id="矩阵和数组"><a href="#矩阵和数组" class="headerlink" title="矩阵和数组"></a>矩阵和数组</h2><p>​    所有 MATLAB 变量都是多维数组，与数据类型无关。矩阵是指通常用来进行线性代数运算的二维数组。</p>
<h3 id="数组创建"><a href="#数组创建" class="headerlink" title="数组创建"></a>数组创建</h3><h4 id="一般数组的创建"><a href="#一般数组的创建" class="headerlink" title="一般数组的创建"></a>一般数组的创建</h4><ul>
<li>在每行中，用 <code>,</code> 或者 <code>空格</code>来分隔每个元素；</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/03/05/43LTOiathcHGdgj.png" style="zoom:50%;" /></p>
<ul>
<li>用 <code>;</code> 来分隔每行，形成矩阵；</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/03/05/epbL2DuHclYton7.png" alt="截屏2020-03-05下午3.26.33.png" style="zoom:50%;" /></p>
<h4 id="函数创建矩阵"><a href="#函数创建矩阵" class="headerlink" title="函数创建矩阵"></a>函数创建矩阵</h4><h5 id="ones-函数"><a href="#ones-函数" class="headerlink" title="ones 函数"></a>ones 函数</h5><ul>
<li>格式：<code>ones(行数, 列数)</code></li>
<li>功能：创建由1构成的行数⨉列数的矩阵</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ones</span>(<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/03/05/4zrtkOKAP26g3lT.png" style="zoom:50%;" /></p>
<h5 id="zeros-函数"><a href="#zeros-函数" class="headerlink" title="zeros 函数"></a>zeros 函数</h5><ul>
<li>格式：<code>zeros(行数, 列数)</code></li>
<li>功能：创建由0构成的行数⨉列数的矩阵</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/03/05/8BSWTFO3UZX24J5.png" style="zoom:50%;" /></p>
<h3 id="矩阵和数组运算"><a href="#矩阵和数组运算" class="headerlink" title="矩阵和数组运算"></a>矩阵和数组运算</h3><p>​    MATLAB 允许使用单一的算术运算符或函数来处理矩阵中的所有值。</p>
<p>​    比如 <code>sin(a)</code> 即可将a矩阵中的所有值带入 sin函数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>a&#39;</code></td>
<td>矩阵转置</td>
</tr>
<tr>
<td><code>inv(a)</code></td>
<td>矩阵求逆</td>
</tr>
<tr>
<td><code>a*b</code></td>
<td>矩阵的乘法</td>
</tr>
<tr>
<td><code>a.*b</code></td>
<td>矩阵元素级乘法</td>
</tr>
</tbody>
</table>
</div>
<h3 id="矩阵串联"><a href="#矩阵串联" class="headerlink" title="矩阵串联"></a>矩阵串联</h3><ul>
<li><code>[a, a]</code> 水平串联</li>
<li><code>[a; a]</code> 垂直串联</li>
</ul>
<h2 id="数组索引"><a href="#数组索引" class="headerlink" title="数组索引"></a>数组索引</h2><p><strong>注意：MATLAB中数组的开始下标为 1。</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>a(行下标, 列下标)</code></td>
<td>得到指定行和列下标的元素</td>
</tr>
<tr>
<td><code>a(下标)</code></td>
<td>用单一下标按顺序向下遍历每一列，得到单一元素</td>
</tr>
<tr>
<td><code>a(开始行下标:结束行下标, 列下标)</code></td>
<td>得到指定列，从开始行到结束行的元素数组</td>
</tr>
<tr>
<td><code>a(:, 列下标)</code></td>
<td>得到指定列的元素数组</td>
</tr>
</tbody>
</table>
</div>
<h2 id="工作变量"><a href="#工作变量" class="headerlink" title="工作变量"></a>工作变量</h2><p>​    工作区包含在 MATLAB 中创建或从数据文件或其他程序导入的变量。</p>
<ul>
<li><strong>whos</strong> 可以查看工作区的内容。</li>
<li>退出 MATLAB 后，工作区变量不会保留。使用 <strong>save</strong> 命令保存数据以供将来使用 <code>save myfile.mat</code></li>
<li>要清除工作区中的所有变量，请使用 <strong>clear</strong> 命令。</li>
<li>使用 <strong>load</strong> 将 MAT 文件中的数据还原到工作区。<code>load myfile.mat</code></li>
</ul>
<h2 id="文本与字符"><a href="#文本与字符" class="headerlink" title="文本与字符"></a>文本与字符</h2><ul>
<li>MATLAB中用 <code>&quot;&quot;</code> 定义字符；</li>
<li><code>+</code>连接字符或数字；</li>
</ul>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><ul>
<li>格式：<code>[输出变量1, 输出变量2...] = functionName(输入变量1, 输入变量2...)</code></li>
<li>将任何字符输入括在单引号中</li>
<li><strong>clc</strong> 函数清空命令行窗口</li>
</ul>
<h2 id="二维图和三维图"><a href="#二维图和三维图" class="headerlink" title="二维图和三维图"></a>二维图和三维图</h2><h3 id="二维图"><a href="#二维图" class="headerlink" title="二维图"></a>二维图</h3><p>​    用 <code>plot</code> 函数创建二维线图。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">100</span>:<span class="number">2</span>*<span class="built_in">pi</span>; <span class="comment">%自变量数组</span></span><br><span class="line">y = <span class="built_in">sin</span>(x); <span class="comment">%因变量函数</span></span><br><span class="line"><span class="built_in">plot</span>(x,y) <span class="comment">%显示x-y图像</span></span><br><span class="line">xlabel(<span class="string">'x'</span>) <span class="comment">%x轴标题</span></span><br><span class="line">ylabel(<span class="string">'sin(x)'</span>) <span class="comment">%y轴标题</span></span><br><span class="line">title(<span class="string">'Plot of the Sine Function'</span>) <span class="comment">%总标题</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/03/05/9BJ6hinycleAMxf.jpg" style="zoom: 33%;" /></p>
<p>​    利用<code>hold on</code>一个窗口显示两个图。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">100</span>:<span class="number">2</span>*<span class="built_in">pi</span>; </span><br><span class="line">y = <span class="built_in">sin</span>(x); </span><br><span class="line"><span class="built_in">plot</span>(x,y)</span><br><span class="line"><span class="built_in">hold</span> on <span class="comment">%保留住现窗口</span></span><br><span class="line"><span class="comment">%显示第二个图形</span></span><br><span class="line">y2 = <span class="built_in">cos</span>(x); </span><br><span class="line"><span class="built_in">plot</span>(x,y2,<span class="string">':'</span>) </span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'sin'</span>,<span class="string">'cos'</span>)</span><br><span class="line"><span class="built_in">hold</span> off <span class="comment">%关闭窗口</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/03/05/DWoScr4Gyn8bC1p.jpg" style="zoom:33%;" /></p>
<h3 id="三维图"><a href="#三维图" class="headerlink" title="三维图"></a>三维图</h3><ul>
<li>使用 <code>meshgrid</code> 在此函数的域中创建一组 (x,y) 点</li>
<li><code>surf</code> 创建曲面图</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">mat[X,Y] = <span class="built_in">meshgrid</span>(<span class="number">-2</span>:<span class="number">.2</span>:<span class="number">2</span>); </span><br><span class="line">Z = X .* <span class="built_in">exp</span>(-X.^<span class="number">2</span> - Y.^<span class="number">2</span>);</span><br><span class="line">surf(X,Y,Z) <span class="comment">%创建曲面</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/03/05/bGFu1854h7sDWUy.jpg" style="zoom:33%;" /></p>
<h3 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h3><p>​    使用 <code>subplot</code> 函数可以在同一窗口的不同子区域显示多个绘图。</p>
<p>格式：<code>subplot(a, b, c)</code> </p>
<p>功能：a⨉b网格中的第c个位置显示图形。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">t = <span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">10</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">[X,Y,Z] = cylinder(<span class="number">4</span>*<span class="built_in">cos</span>(t));</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>); mesh(X); title(<span class="string">'X'</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>); mesh(Y); title(<span class="string">'Y'</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>); mesh(Z); title(<span class="string">'Z'</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>); mesh(X,Y,Z); title(<span class="string">'X,Y,Z'</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/03/05/q4OePTnEXGZxFJY.jpg" style="zoom:33%;" /></p>
]]></content>
      <categories>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac权限无法修改问题解决办法</title>
    <url>/2019/12/16/Mac%E6%9D%83%E9%99%90%E6%97%A0%E6%B3%95%E4%BF%AE%E6%94%B9%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Mac里文件夹必须以管理员身份才可写入，staff只有读的权限，且在文件夹简介中修改显示弹窗“无权限修改”。</p>
<p><a href="https://support.apple.com/zh-cn/HT203538" target="_blank" rel="noopener">苹果官方解决办法</a></p>
<a id="more"></a>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>下面以文件夹post为例，</p>
<p>此时staff为只读权限，需修改为读和写权限</p>
<p><img src="https://res.cloudinary.com/dh7ramrlh/image/upload/v1576577392/gy/img5_rnbylg.png" style="zoom:40%;" /></p>
<h4 id="在共享与权限设置中点击“应用到包含的项目”"><a href="#在共享与权限设置中点击“应用到包含的项目”" class="headerlink" title="在共享与权限设置中点击“应用到包含的项目”"></a>在共享与权限设置中点击“应用到包含的项目”</h4><p>先在“共享与权限”右下角的地方解锁，再在设置中选中“应用到包含的项目”，等待进度条结束即可。</p>
<p><img src="https://res.cloudinary.com/dh7ramrlh/image/upload/v1576577419/gy/img2_jmxbhq.png" style="zoom:40%;" /></p>
<h4 id="命令行操作"><a href="#命令行操作" class="headerlink" title="命令行操作"></a>命令行操作</h4><p>打开命令行，在根目录下输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">diskutil resetUserPermissions &#x2F; &#96;id -u&#96;</span><br></pre></td></tr></table></figure>
<p><img src="https://res.cloudinary.com/dh7ramrlh/image/upload/v1576577450/gy/img3_uogrou.png" style="zoom:40%;" /></p>
<h4 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h4><p>命令行运行结束后重启电脑。</p>
<h4 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h4><p>重启后再次打开该文件夹的“简介”，发现权限可修改了，权限修改完成。</p>
<p><img src="https://res.cloudinary.com/dh7ramrlh/image/upload/v1576577485/gy/img1_oqgi7b.png" style="zoom:40%;" /></p>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile教程</title>
    <url>/2022/01/13/Makefile%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>一份简单的Makefile介绍入门，帮助在Linux系统下编译C/C++。</p>
<a id="more"></a>
<h1 id="引出"><a href="#引出" class="headerlink" title="引出"></a>引出</h1><p>如果有一个<code>test.cpp</code>文件，在命令行里输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -o test</span><br></pre></td></tr></table></figure>
<p>即可对cpp文件进行编译，生成<code>test</code>可执行文件。</p>
<p>如此，每次对cpp文件进行修改后，都要重新输入该命令进行编译，过程复杂且重复。</p>
<p>所以，可以将这些命令打包成makefile文件，定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作。</p>
<p>在该文件夹下生成一个空文件，命名为<code>Makeflie</code>或<code>makefile</code></p>
<figure class="highlight makefile"><figcaption><span>makefile</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="section">test: test.cpp</span></span><br><span class="line">	g++ test.cpp -o test</span><br></pre></td></tr></table></figure>
<div class="note warning">
            <p>第二行的开头为Tab键，如为空格键则会出现<code>makefile:2: *** missing separator.  Stop.</code>的报错。</p><p>VSCode中默认Tab键转化为空格，如需输入Tab键，关闭设置中Editor: Insert Spaces选项。</p>
          </div>
<p>在命令行中输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<p>即可对<code>test.cpp</code>文件进行编译，效果与<code>gcc test.cpp -o test</code>相同。</p>
<h1 id="Makefile的规则"><a href="#Makefile的规则" class="headerlink" title="Makefile的规则"></a>Makefile的规则</h1><h2 id="Makefile的基础框架"><a href="#Makefile的基础框架" class="headerlink" title="Makefile的基础框架"></a>Makefile的基础框架</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">target: prerequisites</span></span><br><span class="line">	command</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>target</strong>（目标）：可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）</li>
<li><strong>prerequisites</strong>（依赖）：生成该target所依赖的文件和target</li>
<li><strong>command</strong>（命令）：该target要执行的命令（任意的shell命令）</li>
</ul>
<p>target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。</p>
<h2 id="一个示例"><a href="#一个示例" class="headerlink" title="一个示例"></a>一个示例</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">insert.o search.o files.o utils.o</span><br><span class="line">    cc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">    cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">    cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">    cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">    cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">    cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">    rm edit main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>
<h2 id="Makefile中使用变量"><a href="#Makefile中使用变量" class="headerlink" title="Makefile中使用变量"></a>Makefile中使用变量</h2><p>在makefile中使用变量类似于C/C++中的宏。</p>
<p>定义一个变量<code>objects</code></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o</span><br></pre></td></tr></table></figure>
<p>则可以在makefile中以<code>$(objects)</code>的方式来使用这个变量。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">    cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">    cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">    cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">    cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">    cc -c utils.c</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">    rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<h2 id="隐晦规则"><a href="#隐晦规则" class="headerlink" title="隐晦规则"></a>隐晦规则</h2><p>make可以自动识别和推倒指令。只要make看到一个 <code>.o</code> 文件，它就会自动的把 <code>.c</code> 文件加在依赖关系中，如果make找到一个<code>whatever.o</code> ，那么 <code>whatever.c</code> 就会是 <code>whatever.o</code> 的依赖文件， <code>cc -c whatever.c</code> 就会被推导出来。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line">main.o : defs.h</span><br><span class="line">kbd.o : defs.h command.h</span><br><span class="line">command.o : defs.h command.h</span><br><span class="line">display.o : defs.h buffer.h</span><br><span class="line">insert.o : defs.h buffer.h</span><br><span class="line">search.o : defs.h buffer.h</span><br><span class="line">files.o : defs.h buffer.h command.h</span><br><span class="line">utils.o : defs.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    -rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p><code>.PHONY</code>表示<code>clean</code>是个伪目标文件。</p>
<p>由于很多<code>.o</code>文件都依赖相同的<code>.h</code>文件，在此之上，可以进一步简化。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">        insert.o search.o files.o utils.o</span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span> : defs.h</span><br><span class="line">kbd.o command.o files.o : command.h</span><br><span class="line">display.o insert.o search.o files.o : buffer.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    -rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<h2 id="清空目标文件的规则"><a href="#清空目标文件的规则" class="headerlink" title="清空目标文件的规则"></a>清空目标文件的规则</h2><p>每个Makefile中都应该写一个清空目标文件（<code>.o</code>和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">clean :</span><br><span class="line">    rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>更为稳健的做法是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    -rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p><code>.PHONY</code> 表示<code>clean</code>是一个“伪目标”。</p>
<p>在<code>rm</code>命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。</p>
<h1 id="Makefile的运行"><a href="#Makefile的运行" class="headerlink" title="Makefile的运行"></a>Makefile的运行</h1><p>输入<code>make</code>命令后，</p>
<ol>
<li>在当前目录下找名字叫“Makefile”或“makefile”的文件；</li>
<li>找文件中的第一个目标文件（target），并把这个文件作为最终的目标文件；</li>
<li>如果最终的目标文件不存在，或是最终的目标文件所依赖的后面的 <code>.o</code> 文件的文件修改时间要比最终的目标文件新，则执行后面所定义的命令来生成最终的目标文件；</li>
<li>如果最终的目标文件所依赖的 <code>.o</code> 文件也不存在，那么make会在当前文件中找目标为 <code>.o</code> 文件的依赖性，如果找到则再根据那一个规则生成 <code>.o</code> 文件；</li>
<li>make会生成 <code>.o</code> 文件，然后再用 <code>.o</code> 文件生成make的最终的目标文件。</li>
</ol>
<p>如果target与第一个目标文件没有任何关联（如clean），则该命令不会执行。如要执行clean，则需另外输入<code>make clean</code>命令。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.bilibili.com/video/BV1Mx411m7fm?share_source=copy_web" target="_blank" rel="noopener">Makefile的写法（b站视频教程）</a></li>
<li><a href="https://seisman.github.io/how-to-write-makefile" target="_blank" rel="noopener">跟我一起写Makefile</a></li>
</ol>
]]></content>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>Python</title>
    <url>/2023/05/30/Python/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Python 学习记录</p>
<a id="more"></a>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">多行注释</span></span><br><span class="line"><span class="string">多行注释</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<h2 id="行与缩进"><a href="#行与缩进" class="headerlink" title="行与缩进"></a>行与缩进</h2><p>不使用 <code>{}</code>，而是使用缩进的方式来表示代码块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"True"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"False"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h2><p>过长的语句采用 <code>\</code> 换行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br></pre></td></tr></table></figure>
<p>在 <code>[]</code>, <code>{}</code>, 或 <code>()</code> 中的多行语句，不需要使用反斜杠 <code>\</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total = [<span class="string">'item_one'</span>, <span class="string">'item_two'</span>, <span class="string">'item_three'</span>,</span><br><span class="line">        <span class="string">'item_four'</span>, <span class="string">'item_five'</span>]</span><br></pre></td></tr></table></figure>
<h2 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h2><p>引入整个模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> somemodule</span><br></pre></td></tr></table></figure>
<p>引入模块中的部分函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> somemodule <span class="keyword">import</span> somefunction</span><br></pre></td></tr></table></figure>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>Python 中的变量赋值不需要类型声明，所以每个变量在使用前都必须赋值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>多个变量赋值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b = <span class="number">1</span>, <span class="string">'abc'</span></span><br></pre></td></tr></table></figure>
<p>允许连等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = b = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><p>支持 int、float、bool、complex</p>
<p>可以用 <code>type()</code> 来查询变量所指的对象类型</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a, b, c, d = <span class="number">1</span>, <span class="number">1.5</span>, <span class="literal">True</span>, <span class="number">4</span>+<span class="number">3j</span></span><br><span class="line">print(type(a), type(b), type(c), type(d))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;class &#39;int&#39;&gt; &lt;class &#39;float&#39;&gt; &lt;class &#39;bool&#39;&gt; &lt;class &#39;complex&#39;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h3><p>与其他语言不同，python 中 <code>\</code> 和 <code>\\</code> 都是除法，但是 <code>\</code> 得一浮点数，<code>\\</code> 得一整数 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; 1 / 2</span></span><br><span class="line">0.5</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; 1 // 2</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p><code>**</code> 表示乘方，<code>x ** y</code> 即 $x^y$</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; 2 ** 5</span></span><br><span class="line">32</span><br></pre></td></tr></table></figure>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>转换成数字类型直接用 <code>int()</code>、<code>float()</code> 这样的强制类型转换</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a, b, c = 1, 1.2, <span class="string">'123'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="built_in">float</span>(a)</span></span><br><span class="line">1.0</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; int(b)</span></span><br><span class="line">1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; int(c)</span></span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>可以用 <code>&#39;</code> 或 <code>&quot;</code> 来创建字符串</p>
<p>Python 不支持单字符类型，单字符也当作字符串处理</p>
<h3 id="索引与截取"><a href="#索引与截取" class="headerlink" title="索引与截取"></a>索引与截取</h3><p>字符串索引，前面从 0 开始，后面从 -1 开始</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/%E6%88%AA%E5%B1%8F2023-06-05%2002.04.31.png" alt=""></p>
<p>字符串截取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str[上标 : 下标]</span><br></pre></td></tr></table></figure>
<p>范围是 [上标, 下标)，不包括下标</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; str = <span class="string">'python'</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; str[0:3]</span></span><br><span class="line">'pyt'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; str[2:-1]</span></span><br><span class="line">'tho'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; str[1:]</span></span><br><span class="line">'ython'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; str[:-1]</span></span><br><span class="line">'pytho'</span><br></pre></td></tr></table></figure>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>列表 List 的数据项不需要是相同的类型，索引方式与 String 相同</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; list = [1, 2, <span class="string">"Red"</span>]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; list[0]</span></span><br><span class="line">1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; list[-1]</span></span><br><span class="line">'Red'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; list[1:]</span></span><br><span class="line">[2, 'Red']</span><br></pre></td></tr></table></figure>
<p>使用 <code>append()</code> 方法来添加列表项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; list.append(<span class="string">"Green"</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; list</span></span><br><span class="line">[1, 2, 'Red', 'Green']</span><br></pre></td></tr></table></figure>
<p>也可用 <code>+</code> 或 <code>*</code> 来扩展 List</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; [1, 2, 3] + [4, 5, 6]</span></span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; [1] * 3</span></span><br><span class="line">[1, 1, 1]</span><br></pre></td></tr></table></figure>
<p>使用 <code>del</code> 语句来删除列表的的元素</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; del list[2]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; list</span></span><br><span class="line">[1, 2, 'Green']</span><br></pre></td></tr></table></figure>
<p>求长度</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; len([1, 2, 3])</span></span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>判断元素是否在 List 中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; 1 <span class="keyword">in</span> [1, 2, 3]</span></span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>遍历 List</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>判断两个 List 是否相同，需引入 <code>operator</code> 模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line">list1, list2, list3 = [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(operator.eq(list1, list2)) <span class="comment"># True</span></span><br><span class="line">print(operator.eq(list1, list3)) <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<h2 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h2><p>元祖 Tuple 与 List 类似，但是 Tuple 不能修改</p>
<h2 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h2><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="部分运算符"><a href="#部分运算符" class="headerlink" title="部分运算符"></a>部分运算符</h2><div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>**</code></td>
</tr>
</tbody>
</table>
</div>
<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><h2 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h2><h1 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h1><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1>]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>OSPF 路由协议</title>
    <url>/2024/09/19/OSPF%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>OSPF 路由协议</p>
<a id="more"></a>
<iframe src="//player.bilibili.com/player.html?isOutside=true&aid=414959575&bvid=BV1YV41127U5&cid=245923181&p=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>

<h1 id="RIP-协议缺陷"><a href="#RIP-协议缺陷" class="headerlink" title="RIP 协议缺陷"></a>RIP 协议缺陷</h1><h2 id="缺陷一：以跳数评估的路由并非最优路径"><a href="#缺陷一：以跳数评估的路由并非最优路径" class="headerlink" title="缺陷一：以跳数评估的路由并非最优路径"></a>缺陷一：以跳数评估的路由并非最优路径</h2><p>RIP 路由协议选择跳数最短的路由，在下图中会选择 RTA —&gt; RTB 的路径。</p>
<p>但虽然 RTA —&gt; RTB 的路径跳数最短，但由于带宽的区别，对于大数据流走 RTA —&gt; RTC —&gt; RTD —&gt; RTB 反而快于跳数更短的 RTA —&gt; RTB 路径。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20241018132129111.png" alt=""></p>
<h2 id="缺陷二：最大跳数15限制网络规模"><a href="#缺陷二：最大跳数15限制网络规模" class="headerlink" title="缺陷二：最大跳数15限制网络规模"></a>缺陷二：最大跳数15限制网络规模</h2><p>RIP 允许的跳数最大只有15条，如果跳数大于等于16跳，则会被视为不可达，无法学习到16跳网段的路由，从而限制了网络规模的大小。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20241018132904557.png" alt="image-20241018132904557"></p>
<h2 id="缺陷三：更新路由发送全量路由信息，浪费网络资源"><a href="#缺陷三：更新路由发送全量路由信息，浪费网络资源" class="headerlink" title="缺陷三：更新路由发送全量路由信息，浪费网络资源"></a>缺陷三：更新路由发送全量路由信息，浪费网络资源</h2><p>RIP 每隔一段时间，都会向所有邻居发送全量的路由信息，十分消耗网络资源。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20241018133241441.png" alt="image-20241018133241441"></p>
<h2 id="缺陷四：收敛速度慢"><a href="#缺陷四：收敛速度慢" class="headerlink" title="缺陷四：收敛速度慢"></a>缺陷四：收敛速度慢</h2><p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20241018133454733.png" alt="image-20241018133454733"></p>
<h1 id="OSPF-链路状态路由协议"><a href="#OSPF-链路状态路由协议" class="headerlink" title="OSPF 链路状态路由协议"></a>OSPF 链路状态路由协议</h1><ul>
<li>工作在 IP 层，IP 协议号 89</li>
<li>以组播地址 224.0.0.5 发送协议包</li>
<li>每个路由器将已知的链路状态信息发送给邻居，收敛后，每个路由器对全网链路状态的认识相同，并独立计算自己的路由</li>
</ul>
<h2 id="OSPF-工作过程"><a href="#OSPF-工作过程" class="headerlink" title="OSPF 工作过程"></a>OSPF 工作过程</h2><h3 id="1-发现邻居"><a href="#1-发现邻居" class="headerlink" title="1. 发现邻居"></a>1. 发现邻居</h3><p>在广播域中组播 hello 包，收到互相的 hello 包，确认是自己的邻居，则加入邻居表中</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20241018135312193.png" alt="image-20241018135312193" style="zoom:50%;" /></p>
<h3 id="2-建立邻接关系"><a href="#2-建立邻接关系" class="headerlink" title="2. 建立邻接关系"></a>2. 建立邻接关系</h3><ul>
<li>并不是所有邻居都会建立邻接关系</li>
<li>网段的广播域中会选取 DR 和 BDR（副 DR，用于容灾），剩下的节点都是 DR_Others，该广播域中的所有路由器都只与 DR 和 BDR 建立邻接关系</li>
<li>只有和建立了邻接关系的邻居才会交换链路状态信息</li>
<li>只有在广播型网络中才会使用 DR 和 BDR，点到点（PPP，即一对一）不使用  DR 和 BDR</li>
</ul>
<p>如此，可以减少交换信息的次数，路由更新更高效</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20241020191232401.png" alt="image-20241020191232401"></p>
<h3 id="3-传递链路状态信息"><a href="#3-传递链路状态信息" class="headerlink" title="3. 传递链路状态信息"></a>3. 传递链路状态信息</h3><ul>
<li>每个节点都有一个 LSDB（链路状态数据库），里面的每一条是一个 LSA（链路状态公告）</li>
<li>每条 LSA 描述了网络中的一个路由器的编号、直连网段、cost 等信息</li>
</ul>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20241020191829391.png" alt="image-20241020191829391" style="zoom:30%;" /></p>
<p><strong>更新机制</strong></p>
<ul>
<li>触发更新或者每隔 30 分钟更新一次<ul>
<li>触发更新：网络发生变化时，则无需等到 30 分钟周期，立即向邻接节点发送信息</li>
</ul>
</li>
<li>增量更新，只发送邻居需要的 LSA</li>
<li>收敛后，网段内的所有路由器都有相同的 LSDB</li>
</ul>
<p><strong>路由信息交换过程</strong></p>
<p>下面是 RTA 触发更新后，向 RTB 交换路由信息的过程</p>
<ol>
<li>发送 RTA 所有 LSA 的摘要信息</li>
<li>RTB 比较收到的 LSA 摘要与自己本地的 LSA，发送请求，希望获得自己没有的 LSA 的详细信息</li>
<li>RTA 将要求的 LSA 发送给 RTB</li>
<li>RTB 向 RTA 回复收到</li>
</ol>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20241020192600552.png" alt="image-20241020192600552" style="zoom:50%;" /></p>
<h3 id="4-路由计算"><a href="#4-路由计算" class="headerlink" title="4. 路由计算"></a>4. 路由计算</h3><p>每台路由器根据 LSDB 算出每台路由器到自己的最短路径</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20241020193001364.png" alt="image-20241020193001364" style="zoom:50%;" /></p>
<h2 id="OSPF-分区域管理"><a href="#OSPF-分区域管理" class="headerlink" title="OSPF 分区域管理"></a>OSPF 分区域管理</h2><p>LSDB 记录网络所有路由器的 LSA，所以当网络规模变大时，会导致每台路由器上都要消耗大量资源储存 LSDB，且 LSDB 信息收敛也会变得很慢，因此需要分区域管理。</p>
<ul>
<li>每个区域内部的路由器的 LSDB 只需知道区域内的路由器的 LSA</li>
<li>不同区域之间通过 ASR（区域边界路由器）相连，同时有两边的 LSDB</li>
</ul>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20241020193546945.png" alt="image-20241020193546945"></p>
<p>非骨干区域之间不能直接通信，需要通过骨干区域（区域 0）进行转发。</p>
<p>如上图中有三个区域：区域 0、区域 1、区域 10.0.0.1，其中区域 1、区域 10.0.0.1 这样的非骨干区域不能直接通信，需要先发送给区域 0，再由区域 0 转发。</p>
<h2 id="Hello-包"><a href="#Hello-包" class="headerlink" title="Hello 包"></a>Hello 包</h2><h3 id="Hello-包组成"><a href="#Hello-包组成" class="headerlink" title="Hello 包组成"></a>Hello 包组成</h3><ul>
<li>功能：Hello 包用于发现邻居路由器，交换 OSPF 配置信息，并确认邻接状态。</li>
<li>内容：包括 Route ID、Priority、Hello 间隔、Dead 间隔等</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/etc/frr<span class="comment"># tcpdump -i vip0 proto ospf -vvv</span></span><br><span class="line">tcpdump: listening on vip0, link<span class="literal">-type</span> EN10MB (Ethernet), capture size <span class="number">262144</span> bytes</span><br><span class="line"><span class="number">11</span>:<span class="number">15</span>:<span class="number">29.874116</span> IP (tos <span class="number">0</span>xc0, ttl <span class="number">1</span>, id <span class="number">22009</span>, offset <span class="number">0</span>, flags [<span class="type">none</span>], proto OSPF (<span class="number">89</span>), length <span class="number">64</span>)</span><br><span class="line">    ubuntu &gt; ospf<span class="literal">-all</span>.mcast.net: OSPFv2, Hello, length <span class="number">44</span></span><br><span class="line">	Router<span class="literal">-ID</span> ubuntu, Backbone Area, Authentication Type: none (<span class="number">0</span>)</span><br><span class="line">	Options [<span class="type">External</span>]</span><br><span class="line">	  Hello Timer <span class="number">10</span>s, Dead Timer <span class="number">40</span>s, Mask <span class="number">255.255</span>.<span class="number">255.255</span>, Priority <span class="number">1</span></span><br><span class="line">	  Designated Router ubuntu</span><br></pre></td></tr></table></figure>
<h3 id="组播地址-ospf-all-mcast-net"><a href="#组播地址-ospf-all-mcast-net" class="headerlink" title="组播地址 ospf-all.mcast.net"></a>组播地址 <code>ospf-all.mcast.net</code></h3><p>OSPF 以组播地址的方式发送 Hello 包，将 Hello 包发往组播地址 <code>ospf-all.mcast.net</code>（224.0.0.5），所有 OSPF 路由器都会监听该地址，如此即可确保域内所有 OSPF 路由器都收到。</p>
<h3 id="Hello-包发送过程"><a href="#Hello-包发送过程" class="headerlink" title="Hello 包发送过程"></a>Hello 包发送过程</h3><ol>
<li><strong>定时发送</strong>：每个 OSPF 路由器按照配置的 Hello 间隔定期发送 Hello 包</li>
<li><strong>包的构造</strong>：路由器构造 Hello 包，将其发送到多播地址 <code>224.0.0.5</code></li>
<li><strong>邻居发现</strong>：接收到 Hello 包的其他 OSPF 路由器会解析包中的信息，加入邻居表中</li>
<li><strong>邻接关系维护</strong>：通过定期发送 Hello 包，OSPF 路由器可以维护与邻居的关系。如果在规定的 Dead 间隔内未收到某个邻居的 Hello 包，路由器将认为该邻居失效</li>
</ol>
<h2 id="DR-竞选"><a href="#DR-竞选" class="headerlink" title="DR 竞选"></a>DR 竞选</h2><p>广播型网络中需选出该广播域的 DR（指定路由） 和 BDR（备份指定路由，负责在 DR 失效时接管其功能）</p>
<h3 id="DR-竞选规则"><a href="#DR-竞选规则" class="headerlink" title="DR 竞选规则"></a>DR 竞选规则</h3><ol>
<li><strong>Priority 大者优先</strong>：优先选择 Priority 较大的路由为 DR，如果 Priority 设置为 0，则不参与 DR 竞选</li>
<li><strong>Route ID 大者优先</strong>：如果有多个 Priority 最大且相同的路由器，则选择其中 Route ID 最大的（Route ID 为路由器的唯一标识，通常是 IP，不可能相同）</li>
</ol>
<p>示例：下面三个路由器中，A 的 Priority 最大，为 DR；B、C 的 Priority 相同，但 B 的 Route ID 大于 C，所以 B 为 BDR</p>
<ul>
<li>A 的优先级为 2，Router ID 为 1.1.1.1（DR）</li>
<li>B 的优先级为 1，Router ID 为 2.2.2.2（BDR）</li>
<li>C 的优先级为 1，Router ID 为 3.3.3.3</li>
</ul>
<h3 id="DR-竞选过程"><a href="#DR-竞选过程" class="headerlink" title="DR 竞选过程"></a>DR 竞选过程</h3><ol>
<li>Hello 消息：所有路由器定期组播 Hello 消息，其中包含本路由的 Priority、Route ID 等信息</li>
<li>优先级比较：根据竞选规则比较各个路由器，优先级最高的为 DR，次高的为 BDR</li>
<li>选举后，DR 和 BDR 会向所有的路由器广播 LSA，其他所有路由器将与 DR 和 BDR 建立邻接关系</li>
</ol>
<h1 id="邻居状态机"><a href="#邻居状态机" class="headerlink" title="邻居状态机"></a>邻居状态机</h1><p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/download.png" alt="OSPF邻居状态机"></p>
<h1 id="RIP-和-OSPF-比较"><a href="#RIP-和-OSPF-比较" class="headerlink" title="RIP 和 OSPF 比较"></a>RIP 和 OSPF 比较</h1><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>RIP（距离矢量路由协议）</th>
<th>OSPF（链路状态路由协议）</th>
</tr>
</thead>
<tbody>
<tr>
<td>最优路径选择</td>
<td>跳数</td>
<td>链路开销</td>
</tr>
<tr>
<td>更新触发</td>
<td>每 30s</td>
<td>触发更新或每隔30分钟</td>
</tr>
<tr>
<td>发送对象</td>
<td>广播到所有邻居</td>
<td>发到邻接路由器</td>
</tr>
<tr>
<td>发送信息</td>
<td>全量 RIP 路由表</td>
<td>链路状态信息摘要</td>
</tr>
</tbody>
</table>
</div>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://support.huawei.com/enterprise/zh/doc/EDOC1100075308/57629336" target="_blank" rel="noopener">HUAWEI OSPF 配置</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>路由协议</tag>
        <tag>OSPF</tag>
      </tags>
  </entry>
  <entry>
    <title>SURF算子</title>
    <url>/2020/04/24/SURF%E7%AE%97%E5%AD%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;<strong>SURF (Speeded Up Robust Features, 加速稳健特征)</strong> 是一个稳健的图像识别和描述算法，首先于2006年发表在ECCV大会上。这个算法可被用于计算机视觉任务，如物件识别和3D重构。他部分的灵感来自于<a href="">SIFT算法</a>。SURF标准的版本比SIFT要快数倍，并且其作者声称在不同图像变换方面比SIFT更加稳健。</p>
<a id="more"></a>
<h1 id="SURF算子——原理"><a href="#SURF算子——原理" class="headerlink" title="SURF算子——原理"></a>SURF算子——原理</h1><h2 id="特征点检测"><a href="#特征点检测" class="headerlink" title="特征点检测"></a>特征点检测</h2><h3 id="基于Hessian矩阵的特征点检测"><a href="#基于Hessian矩阵的特征点检测" class="headerlink" title="基于Hessian矩阵的特征点检测"></a>基于Hessian矩阵的特征点检测</h3><p>&emsp;&emsp;对于输入图像中的一点$X=(x,y)$，其Hessian矩阵定义如下</p>
<script type="math/tex; mode=display">
H(X,\sigma)=
\begin{bmatrix}
L_{xx}(X,\sigma)&L_{xy}(X,\sigma)\\
L_{xy}(X,\sigma)&L_{yy}(X,\sigma)
\end{bmatrix}</script><p>其中$\sigma$为Hessian矩阵的尺度，$L_{xx}$是高斯二阶偏导数$\frac {\partial^2}{\partial x^2}g(\sigma)$与输入图像在点$X$处的卷积，其余类似。</p>
<p>&emsp;&emsp;行列式的值$det(H)$即为点$X$处的响应</p>
<script type="math/tex; mode=display">
det(H)=L_{xx}L_{yy}-L_{xy}^2</script><h3 id="基于Box滤波器的Hessian矩阵近似计算"><a href="#基于Box滤波器的Hessian矩阵近似计算" class="headerlink" title="基于Box滤波器的Hessian矩阵近似计算"></a>基于Box滤波器的Hessian矩阵近似计算</h3><p>&emsp;&emsp;利用Box滤波器做Hessian矩阵近似计算，加快计算速度。</p>
<p>在LoG算子中，</p>
<script type="math/tex; mode=display">
h(x,y)=e^{-\frac {x^2+y^2}{2\sigma^2}}</script><script type="math/tex; mode=display">
\triangledown^2h(r)=(\frac{r^2-\sigma^2}{\sigma^4})e^{-\frac {r^2}{2\sigma^2}},\quad r^2=x^2+y^2</script><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/SURF1.png" style="zoom: 33%;" /></p>
<p>&emsp;&emsp;可以用Box滤波器近似计算$\triangledown^2h(r)$</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/SURF2.png" style="zoom:36%;" /></p>
<p>&emsp;&emsp;如此对高斯二阶微分模板进行简化，从而降低计算量，高斯二阶导数函数的离散化和截断会造成一定的误差。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/SURF3.png" style="zoom:36%;" /></p>
<p>&emsp;&emsp;利用简化后的Box滤波模版对图像进行卷积，得到Hessian矩阵的近似计算</p>
<script type="math/tex; mode=display">
H(X,N)=
\begin{bmatrix}
D_{xx}(X,N)&D_{xy}(X,N)\\
D_{xy}(X,N)&D_{yy}(X,N)
\end{bmatrix}</script><p>其中，N为Box滤波器的大小。</p>
<p>&emsp;&emsp;行列式的值$det(H)$即为点$X$处的响应（但是要加上权重）</p>
<script type="math/tex; mode=display">
det(H_{approx})=D_{xx}D_{yy}-(wD_{xy})^2,\quad w \approx 0.9</script><p>其中，权重$w$为平衡因子</p>
<script type="math/tex; mode=display">
w=\frac {|L_{xy}(1.2)|_F|D_{yy}(9)|_F}{|L_{yy}(1.2)|_F|D_{xy}(9)|_F}=0.912...\approx 0.9</script><h3 id="基于积分图的Box滤波器快速计算"><a href="#基于积分图的Box滤波器快速计算" class="headerlink" title="基于积分图的Box滤波器快速计算"></a>基于积分图的Box滤波器快速计算</h3><p>&emsp;&emsp;利用积分图快速计算Box卷积滤波。</p>
<p>&emsp;&emsp;积分图是输入图像经过像素间的累加运算得到的新图像。任意一点$(x,y)$的值是从输入图像的左上角到这个点所构成的矩形区域内所有点的灰度值之和。</p>
<p>&emsp;&emsp;每个点的积分可以用迭代的方式获得</p>
<script type="math/tex; mode=display">
II(x,y)=II(x,y-1)+S(x-1,y)+I(x,y)</script><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/SURF4.png" style="zoom:30%;" /></p>
<p>&emsp;&emsp;计算矩阵ABCD中像素和只需要积分图中A、B、C、D四点的值和3次加法运算</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/SURF5.png" style="zoom:30%;" /></p>
<h3 id="尺度金字塔构建"><a href="#尺度金字塔构建" class="headerlink" title="尺度金字塔构建"></a>尺度金字塔构建</h3><p>&emsp;&emsp;一般尺度金字塔采用对图像的下采样，使用同一个滤波器滤波。</p>
<p>&emsp;&emsp;在SURF算子中，由于积分图和Box滤波的计算便利性，<strong>固定图像尺度，上采样滤波器</strong>。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/SURF6.png" alt=""></p>
<p>&emsp;&emsp;与SIFT算子类似，</p>
<ul>
<li>将尺度空间划分为若干组(Octaves)，每组又由若干固定层（Interval）组成</li>
<li>每组尺度金字塔的各层尺度成等差数列</li>
<li>不同组的尺度金字塔的公差等比增长（$O,S$为组索引、层索引，从$0$开始）</li>
</ul>
<script type="math/tex; mode=display">
Filter Size = 3\times[2^{o+1}\times (s+1)+1]</script><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/SURF7.png" alt=""></p>
<p>&emsp;&emsp;为了保持尺度空间的连续性，相邻组尺度金字塔有部分层重叠（SIFT中同样，$S+3$个图才能得到$S$个尺度的特征点检测结果）</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/SURF8.png" alt=""></p>
<h3 id="特征点定位"><a href="#特征点定位" class="headerlink" title="特征点定位"></a>特征点定位</h3><ul>
<li><p>非极大抑制</p>
<p>与SIFT中的做法相似，</p>
<ul>
<li><p>每组中选相邻3层Hessian行列式图像，对于中间层图像中的每个待比较点，选取同层的8个相邻点和上下层的9个相邻点进行比较</p>
</li>
<li><p>若该点值大于其他26点，则为特征点</p>
<p><img src="https://i.loli.net/2020/04/23/hVMXou7GcbmJE2j.png" style="zoom:50%;" /></p>
</li>
</ul>
</li>
<li><p>尺度空间插值</p>
<p>与SIFT中的做法相同，得到亚像素级的特征值，减小不同组第一层之间的差异。</p>
</li>
</ul>
<h2 id="特征点描述"><a href="#特征点描述" class="headerlink" title="特征点描述"></a>特征点描述</h2><h3 id="特征点主方向"><a href="#特征点主方向" class="headerlink" title="特征点主方向"></a>特征点主方向</h3><p>&emsp;&emsp;为了保证特征描述子具有旋转不变性，与SIFT一样，需要对每个特征点分配一个主方向。</p>
<ul>
<li><p>选择以特征点为中心、半径为$6s$（$s$为特征点的尺度）的圆形邻域</p>
</li>
<li><p>计算该圆形邻域内各点的$x$、$y$方向Haar小波响应（Haar小波边长取$4s$）</p>
<p>计算图像的Haar小波响应，实际上就是对图像进行梯度运算，只不过需要利用积分图，提高梯度计算效率。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/SURF9.png" style="zoom: 33%;" /></p>
</li>
<li><p>用$\sigma = 2.5s$的高斯函数对响应加权</p>
</li>
<li><p>以特征点为中心，张角为$\pi /3$的扇形滑动窗口，计算窗口内的Haar小波响应值$dx$、$dy$的累加</p>
<script type="math/tex; mode=display">
m_w=\sum\limits_w dx+\sum\limits_w dy\\
\theta_w=\arctan(\sum\limits_w dx/\sum\limits_w dy)</script></li>
<li><p>特征点主方向为最大的Haar响应累加值所对应的方向</p>
<script type="math/tex; mode=display">
\theta = \theta_w|max\{m_w\}</script><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/SURF10.png" style="zoom: 67%;" /></p>
</li>
</ul>
<h3 id="Haar小波响应和描述符"><a href="#Haar小波响应和描述符" class="headerlink" title="Haar小波响应和描述符"></a>Haar小波响应和描述符</h3><ul>
<li><p>构建以特征点为中心、方向为特征点主方向、边长为$20s$的正方形区域</p>
</li>
<li><p>将区域划分成$4\times 4$子块</p>
</li>
<li><p>每个子块均匀采样$5\times 5$个样本点</p>
</li>
<li><p>计算各采样点的Haar小波响应（Haar小波边长为$2s$）</p>
</li>
<li><p>用以特征点为中心点，$\sigma =3.3s$的高斯函数对响应加权</p>
</li>
<li><p>在各子块内统计$\sum dx$、$\sum |dx|$、$\sum dy$、$\sum |dy|$形成子块特征向量</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/SURF11.png" alt=""></p>
</li>
<li><p>每个子块统计一个四维特征向量$\vec v$</p>
<script type="math/tex; mode=display">
\vec v = (\sum dx,\sum |dx|,\sum dy,\sum |dy|)</script></li>
<li><p>将$4\times 4$个子块的特征向量$\vec v$相连，得长度为64的特征向量，具有亮度不变性</p>
</li>
<li><p>将特征向量归一化，具有对比度不变性</p>
</li>
</ul>
<p>SURF描述子对于不同纹理的区分性</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/SURF12.png" style="zoom:50%;" /></p>
<h2 id="快速索引匹配"><a href="#快速索引匹配" class="headerlink" title="快速索引匹配"></a>快速索引匹配</h2><ul>
<li>在检测阶段，记录拉普拉斯算子的符号（Hessian矩阵的迹的符号）</li>
<li>在匹配阶段，匹配拉普拉斯算子符号相同的特征，从而降低运算量</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.vision.ee.ethz.ch/~surf/eccv06.pdf" target="_blank" rel="noopener">Paper: SURF: Speeded Up Robust Features</a></li>
<li><a href="https://senitco.github.io/2017/06/27/image-feature-surf/" target="_blank" rel="noopener">SenitCo: 图像特征之SURF特征匹配</a></li>
</ol>
]]></content>
      <categories>
        <category>Computer Vision</category>
      </categories>
      <tags>
        <tag>SURF算子</tag>
        <tag>特征描述</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode环境配置</title>
    <url>/2023/01/24/VSCode%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>VSCode上的一些环境配置记录。</p>
<a id="more"></a>
<h1 id="C-C-环境配置"><a href="#C-C-环境配置" class="headerlink" title="C/C++环境配置"></a>C/C++环境配置</h1><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><ul>
<li>VSCode上安装插件<code>C/C++</code>、<code>Code Runner</code></li>
<li>配置<code>Code Runner</code><ul>
<li>点击<code>Code Runner</code>的<code>设置</code>-&gt;<code>扩展设置</code></li>
<li>建议勾选<code>Clear Previous Output</code>、<code>Ignore Selection</code>、<code>Run In Terminal</code>、<code>Save All Files Before Run</code>、<code>Save File Before Run</code></li>
<li>建议不勾选<code>Preserve Focus</code></li>
</ul>
</li>
<li><code>设置</code>中建议勾选<ul>
<li><code>Files: Auto Save</code>的<code>afterDelay</code></li>
</ul>
</li>
<li><code>设置</code>中建议不勾选<ul>
<li><code>C_Cpp: Debug Shortcut</code></li>
</ul>
</li>
</ul>
<h2 id="调试环境"><a href="#调试环境" class="headerlink" title="调试环境"></a>调试环境</h2><p>在需调试的cpp文件上</p>
<ul>
<li>生成<code>tasks.json</code>文件<ul>
<li>打开命令面板<code>command</code>+<code>shift</code>+<code>P</code></li>
<li>打开配置任务<code>Tasks: Configure Task</code></li>
<li>选择<code>clang++ 生成活动文件</code>，即生成<code>tasks.json</code>文件</li>
</ul>
</li>
<li>生成<code>launch.json</code>文件<ul>
<li>切换到<code>运行和调试</code>页面</li>
<li>点击<code>创建 launch.json 文件</code>，即生成<code>launch.json</code>文件</li>
</ul>
</li>
<li>编辑<code>launch.json</code>文件<ul>
<li>点击<code>添加配置</code> -&gt; <code>C/C++：(lldb)启动</code>，并编辑下面配置</li>
<li>修改<code>&quot;program&quot;: &quot;${fileDirname}/${fileBasenameNoExtension}&quot;,</code><br> 即程序可执行文件的完整路径：当前打开的文件的完整目录名 / 当前打开的文件的文件名 (不包含文件扩展名)</li>
<li>修改<code>&quot;externalConsole&quot;: true,</code></li>
<li>添加<code>&quot;preLaunchTask&quot;: &quot;C/C++: clang++ 生成活动文件&quot;</code><br> 即调试会话开始前要运行的任务，<code>tasks.json</code>文件的<code>label</code>配置</li>
</ul>
</li>
<li>点击调试</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://b23.tv/Z6AVpQk" target="_blank" rel="noopener">Mac用Visual Studio Code编写C/C++ 苹果电脑VS Code快速编写C/C++教程-哔哩哔哩</a></li>
</ul>
]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
        <tag>VSCode</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode上配置OpenCV和C++开发环境</title>
    <url>/2020/01/16/Xcode%E4%B8%8A%E9%85%8D%E7%BD%AEOpenCV%E5%92%8CC-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>​    在下载完OpenCV和新建完C++工程后，需在Xcode的C++文件上配置OpenCV。</p>
<a id="more"></a>
<h1 id="Xcode配置OpenCV步骤"><a href="#Xcode配置OpenCV步骤" class="headerlink" title="Xcode配置OpenCV步骤"></a>Xcode配置OpenCV步骤</h1><p>​    首先先新建好C++工程。</p>
<h2 id="设置库文件搜索路径-Header-Search-Paths"><a href="#设置库文件搜索路径-Header-Search-Paths" class="headerlink" title="设置库文件搜索路径(Header Search Paths)"></a>设置库文件搜索路径(Header Search Paths)</h2><p>​    找到OpenCV的header路径添加进Header Search Paths。</p>
<h3 id="用SpotLight搜索到隐藏文件夹"><a href="#用SpotLight搜索到隐藏文件夹" class="headerlink" title="用SpotLight搜索到隐藏文件夹"></a>用SpotLight搜索到隐藏文件夹</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;opencv&#x2F;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/01/16/UrLiybZHk8pmPwF.png" style="zoom: 50%;" /></p>
<h3 id="找到header的最终路径"><a href="#找到header的最终路径" class="headerlink" title="找到header的最终路径"></a>找到header的最终路径</h3><p>​    这里我的最终路径是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;opencv&#x2F;4.1.1_2&#x2F;include&#x2F;opencv4</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/01/16/41CqVSymTiX75u3.png" alt=""></p>
<h3 id="将OpenCV的header路径添加进Header-Search-Paths"><a href="#将OpenCV的header路径添加进Header-Search-Paths" class="headerlink" title="将OpenCV的header路径添加进Header Search Paths"></a>将OpenCV的header路径添加进Header Search Paths</h3><p>​    在该Xcode项目下，选择Building Settings -&gt; Header Search Paths，添加进入header的搜索路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;opencv&#x2F;4.1.1_2&#x2F;include&#x2F;opencv4</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/01/16/9fd3wCzqQSybgZA.png" alt=""></p>
<h2 id="设置库搜索路径（Library-Search-Paths）"><a href="#设置库搜索路径（Library-Search-Paths）" class="headerlink" title="设置库搜索路径（Library Search Paths）"></a>设置库搜索路径（Library Search Paths）</h2><p>​    在刚刚查询到的目录里面找到与include同级的lib文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;opencv&#x2F;4.1.1_2&#x2F;lib</span><br></pre></td></tr></table></figure>
<p>​    在该Xcode项目下，选择Building Settings -&gt; Library Search Paths，添加进入lib路径。    </p>
<p><img src="https://i.loli.net/2020/01/16/hi1cpuoNLPtfgJQ.png" alt=""></p>
<h2 id="设置其他链接器标志（Other-Linker-Flags）"><a href="#设置其他链接器标志（Other-Linker-Flags）" class="headerlink" title="设置其他链接器标志（Other Linker Flags）"></a>设置其他链接器标志（Other Linker Flags）</h2><p>​    通过pkg-config获取opencv所有的Linker Flags，添加进Other Linker Flags。</p>
<h3 id="在命令行中输入pkg-config命令，得到所有的Linker-Flags"><a href="#在命令行中输入pkg-config命令，得到所有的Linker-Flags" class="headerlink" title="在命令行中输入pkg-config命令，得到所有的Linker Flags"></a>在命令行中输入pkg-config命令，得到所有的Linker Flags</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pkg-config --libs opencv4</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/01/16/QUBPeHwdRZzV2up.png" alt=""></p>
<h3 id="将Linker-Flags添加进Other-Linker-Flags"><a href="#将Linker-Flags添加进Other-Linker-Flags" class="headerlink" title="将Linker Flags添加进Other Linker Flags"></a>将Linker Flags添加进Other Linker Flags</h3><p>​    在该Xcode项目下，选择Building Settings -&gt; Other Linker Flags，添加Linker Flags。</p>
<p><img src="https://i.loli.net/2020/01/16/vFzYhxpQOVGKJ8m.png" alt=""></p>
<p>​    此时，Xcode的OpenCV环境配置成功。</p>
<h2 id="调用OpenCV库文件"><a href="#调用OpenCV库文件" class="headerlink" title="调用OpenCV库文件"></a>调用OpenCV库文件</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/01/16/orUzdN1TkCIuiFg.png" alt=""></p>
<h1 id="使用文件的相对路径"><a href="#使用文件的相对路径" class="headerlink" title="使用文件的相对路径"></a>使用文件的相对路径</h1><p>​    做图像免不了要使用图片文件，全部使用绝对路径不易转移，所以需在Xcode里设置文件的相对路径。</p>
<h2 id="打开Edit-Scheme"><a href="#打开Edit-Scheme" class="headerlink" title="打开Edit Scheme"></a>打开Edit Scheme</h2><p>​    选择 Product -&gt; Scheme -&gt; Edit Scheme</p>
<p><img src="https://i.loli.net/2020/01/16/VbmhINLeXnfvocR.png" alt=""></p>
<h2 id="添加相对路径"><a href="#添加相对路径" class="headerlink" title="添加相对路径"></a>添加相对路径</h2><p>​    在 Run -&gt; Options 勾选 <em>Use Custom Working Directory</em>，并添加路径。</p>
<p><img src="https://i.loli.net/2020/01/16/fN5u3iD1TLK2JeZ.png" alt=""></p>
<p>​    现在即可使用相对地址引入文件。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://medium.com/@jaskaranvirdi/setting-up-opencv-and-c-development-environment-in-xcode-b6027728003" target="_blank" rel="noopener">Setting up OpenCV and C++ development environment in Xcode for Computer Vision projects</a></p>
<p>注意科学上网！！</p>
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Xcode</tag>
        <tag>OpenCV</tag>
        <tag>图像处理</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>TRex 教程</title>
    <url>/2024/08/23/TRex-%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>TRex 是基于 DPDK 的一个开源、低成本的流量生成器，支持生成 L3～7 流量，提供有状态、无状态两种模式。</p>
<a id="more"></a>
<h1 id="TRex-架构"><a href="#TRex-架构" class="headerlink" title="TRex 架构"></a>TRex 架构</h1><p>TRex 之所以能够产生相比其他流量生成器更大的流量，原因是使用了 DPDK。</p>
<p>传统的工具，比如 iperf，如果想要生成包，需要走 Linux 内核，经过绑定的 socket API、 TCP/IP 栈、设备驱动这样一套完整的流程，最终才能到达物理网卡。</p>
<p>而 TRex 使用 DPDK，这意味着它可以绕过 Linux 内核态协议栈，直接控制物理网卡，应用单独实现包处理过程，不用经历内核/用户态切换、内存拷贝、冗余的 TCP/IP 协议栈等步骤。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20240831003920365.png" alt="TRex架构"></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol>
<li><p>进入安装目录，比如 <code>/opt/trex</code> </p>
</li>
<li><p>下载 <a href="https://trex-tgn.cisco.com/trex/release/" target="_blank" rel="noopener">TRex 压缩包</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget --no-cache --no-check-certificate https://trex-tgn.cisco.com/trex/release/latest</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压 TRex 压缩包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xzvf latest</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="网卡配置"><a href="#网卡配置" class="headerlink" title="网卡配置"></a>网卡配置</h1><p>TRex 需要 DPDK 绑定网卡，通过 TRex 提供的脚本可以查看或修改网卡</p>
<h2 id="查看网卡状态"><a href="#查看网卡状态" class="headerlink" title="查看网卡状态"></a>查看网卡状态</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/opt/trex/v3.<span class="number">05</span><span class="comment"># ./dpdk_setup_ports.py -s</span></span><br><span class="line"></span><br><span class="line">Network devices <span class="keyword">using</span> DPDK-compatible driver</span><br><span class="line">============================================</span><br><span class="line">&lt;none&gt;</span><br><span class="line"></span><br><span class="line">Network devices <span class="keyword">using</span> kernel driver</span><br><span class="line">===================================</span><br><span class="line"><span class="number">0000</span>:<span class="number">02</span>:<span class="number">01.0</span> <span class="string">'82545EM Gigabit Ethernet Controller (Copper)'</span> <span class="keyword">if</span>=ens33 drv=e1000 unused=igb_uio,vfio<span class="literal">-pci</span>,uio_pci_generic *Active*</span><br><span class="line"><span class="number">0000</span>:<span class="number">02</span>:<span class="number">05.0</span> <span class="string">'82545EM Gigabit Ethernet Controller (Copper)'</span> <span class="keyword">if</span>=ens37 drv=e1000 unused=igb_uio,vfio<span class="literal">-pci</span>,uio_pci_generic</span><br><span class="line"><span class="number">0000</span>:<span class="number">02</span>:<span class="number">06.0</span> <span class="string">'82545EM Gigabit Ethernet Controller (Copper)'</span> <span class="keyword">if</span>=ens38 drv=e1000 unused=igb_uio,vfio<span class="literal">-pci</span>,uio_pci_generic</span><br><span class="line"></span><br><span class="line">Other network devices</span><br><span class="line">=====================</span><br><span class="line">&lt;none&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>当前三张网卡都绑定在 kernel 下，DPDK 未绑定网卡</li>
<li><code>Active</code>的网卡为 ssh 使用的管理网卡，不可以设置在 TRex 配置文件中，分配给 DPDK</li>
</ul>
<p>在运行 TRex 时，会自动将 TRex 配置文件中<code>interfaces</code>网卡绑定 DPDK</p>
<h1 id="TRex-配置"><a href="#TRex-配置" class="headerlink" title="TRex 配置"></a>TRex 配置</h1><p><a href="https://trex-tgn.cisco.com/trex/doc/trex_manual.html#_platform_yaml_cfg_argument" target="_blank" rel="noopener">官方文档</a></p>
<p>Yaml 格式配置文件，用来配置 TRex 服务器，包括：</p>
<ul>
<li>每个网卡的源、目的 IP 和 MAC 地址</li>
<li>屏蔽网卡，保证 TRex 不使用管理网卡作为流量网卡</li>
</ul>
<p>在运行 TRex 服务器时，通过 <code>--cfg</code>配置，如果未设置，则使用默认路径<code>/etc/trex_cfg.yaml</code>，TRex 提供了一些示例 TRex 配置文件在 <code>$TREX_ROOT/cfg</code></p>
<h2 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h2><ul>
<li><code>port_limit</code>：（必选）网卡数量，绑定 DPDK 的网卡数量，必须和<code>interfaces</code>中的网卡数量对应</li>
<li><code>version</code>：（必选）必须是 2</li>
<li><code>interfaces</code>：（必选）TRex 使用的网卡 PCI，顺序有意义，对应<code>port_info</code>中的顺序<ul>
<li>必须是偶数个，成对存在，按顺序分别为 clinet 和 server 网卡</li>
<li>如是奇数个网卡，可以使用<code>dummy</code>填充，但每对网卡对必须有非<code>dummy</code> 的网卡</li>
<li>通过 <code>./dpdk_setup_ports.py -s</code> 查看网卡 PCI</li>
<li>不能填入 ssh 使用的网卡</li>
</ul>
</li>
<li><code>c</code>：分配给每个网卡对的线程数，会被运行时的命令行参数<code>-c</code>覆盖</li>
<li><code>services_core</code>：（非必选）用来跑 scapy、PyBird、Emu 这些 service 的核，如果未设置，则会采用以下逻辑<ul>
<li><em>low_end</em> 开启，使用 <em>low_end_core</em></li>
<li><em>low_end</em> 未开启，使用 <em>master_thread_id</em></li>
<li><em>low_end</em> 未开启，使用 <em>master_thread_id</em>，使用 core 0</li>
</ul>
</li>
<li><code>port_info</code>：（必选）<ul>
<li>网卡信息，每项按顺序对应<code>interfaces</code>中的网卡</li>
<li>（必选）对于每张网卡，都必须要设置目的 MAC 地址，有两种设置方式：<ul>
<li>直接设置<code>dest_mac</code></li>
<li>设置<code>default_gw</code>，在未设置<code>dest_mac</code>时，TRex 会对<code>default_gw</code>这个 IP 发送 ARP 请求，使用回复的结果作为目的 MAC 地址</li>
</ul>
</li>
<li><code>dest_mac</code>：目的 MAC 地址，该网卡打流将打往这个 MAC 地址</li>
<li><code>default_gw</code>：默认网关，用于生成目的 MAC 地址</li>
<li><code>src_mac</code>：（非必选）该网卡生成流量的源 MAC 地址，如果未设置，将使用该网卡的 MAC 地址作为源 MAC 地址</li>
</ul>
</li>
<li><code>platform</code>：（非必选）<ul>
<li><code>master_thread_id</code>：控制线程使用的线程 id</li>
<li><code>latency_thread_id</code>：RX 线程使用的线程 id，用来计算延迟</li>
<li><code>dual_if</code>：<ul>
<li>与<code>interfaces</code>中的网卡对一一对应</li>
<li><code>socket</code>：该网卡对被分配的 NUMA 节点</li>
<li><code>threads</code>：该网卡对用来发包的线程 id</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">port_limit      :</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">version         :</span> <span class="number">2</span></span><br><span class="line"><span class="comment">#List of interfaces. Change to suit your setup. Use ./dpdk_setup_ports.py -s to see available options</span></span><br><span class="line">  <span class="attr">interfaces    :</span> <span class="string">["03:00.0","03:00.1"]</span></span><br><span class="line">  <span class="attr">port_info       :</span>  <span class="comment"># Port IPs. Change to suit your needs. In case of loopback, you can leave as is.</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">ip         :</span> <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">            <span class="attr">default_gw :</span> <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">ip         :</span> <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span></span><br><span class="line">            <span class="attr">default_gw :</span> <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">platform :</span></span><br><span class="line">      <span class="attr">master_thread_id  :</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">latency_thread_id :</span> <span class="number">7</span></span><br><span class="line">      <span class="attr">dual_if   :</span></span><br><span class="line">           <span class="bullet">-</span> <span class="attr">socket   :</span> <span class="number">0</span></span><br><span class="line">             <span class="attr">threads  :</span> <span class="string">[1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure>
<h1 id="Traffic-模版配置"><a href="#Traffic-模版配置" class="headerlink" title="Traffic 模版配置"></a>Traffic 模版配置</h1><p><a href="https://trex-tgn.cisco.com/trex/doc/trex_manual.html#_traffic_yaml_f_argument_of_stateful" target="_blank" rel="noopener">官方文档</a></p>
<p>Stateful 模式时需配置 Traffic 模版，用以生成流量。</p>
<p>运行 TRex 时，通过配置<code>-f &lt;file&gt;</code>参数来设置流量模版 yaml 文件。</p>
<h2 id="配置项-1"><a href="#配置项-1" class="headerlink" title="配置项"></a>配置项</h2><ul>
<li><p><code>duration</code>：测试持续时间，即打多久的流量，单位 s。会被运行时的命令行参数<code>-d</code>覆盖</p>
</li>
<li><p><code>generator</code>：</p>
<ul>
<li><p>生成流量的 IP 依据<code>clients_start</code>、<code>clients_end</code>、<code>servers_start</code>、<code>servers_end</code>、<code>dual_port_mask</code></p>
<ul>
<li><p><code>clients_start</code>、<code>clients_end</code>、<code>servers_start</code>、<code>servers_end</code> 分别设置了 client 和 server 的 IP 池，该范围即限定了 client 和 server 的总数</p>
</li>
<li><p><code>dual_port_mask</code> 设置网卡对的偏移量，使得可以为每个网卡对配置不同的静态路由，如需要发送同样的范围，则设置为<code>0.0.0.0</code></p>
</li>
<li><p>下面示例中，如果 TRex 配置设置了两个网卡对（4张网卡），则分配 IP 如下</p>
<ul>
<li>```powershell<br>port pair-0 (0,1) —&gt; C (16.0.0.1-16.0.0.128  ) &lt;-&gt; S( 48.0.0.1 - 48.0.0.128)<br>port pair-1 (2,3) —&gt; C (17.0.0.129-17.0.0.255  ) &lt;-&gt; S( 49.0.0.129 - 49.0.0.255) + mask  (“1.0.0.0”)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - client 和 server 数量即为设置范围的数量，都是 255，不会因为网卡数量而变化</span><br><span class="line"></span><br><span class="line">  - 网卡对偏移量为&#96;dual_port_mask&#96;，第二对网卡对比第一对偏移 &#96;1.0.0.0&#96;</span><br><span class="line"></span><br><span class="line">- 如果 &#96;dual_port_mask&#96; 设置为&#96;0.0.0.0&#96;，依旧设置 TRex 配置两个网卡对（4张网卡），则分配 IP 如下</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;powershell</span><br><span class="line">    port pair-0 (0,1) --&gt; C (16.0.0.1-16.0.0.128  ) &lt;-&gt; S( 48.0.0.1 - 48.0.0.128)</span><br><span class="line">    port pair-1 (2,3) --&gt; C (16.0.0.129-16.0.0.255  ) &lt;-&gt; S( 48.0.0.129 - 48.0.0.255)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>生成流量的 IP 范围</p>
<ul>
<li>client IP 范围：网卡对中的 client 发送流量的源 IP、网卡对中的 server 发送流量的目的 IP</li>
<li>server IP 范围：网卡对中的 client 发送流量的目的 IP、网卡对中的 server 发送流量的源 IP</li>
</ul>
</li>
</ul>
</li>
<li><p><code>clients_per_gb</code>：已废弃</p>
</li>
<li><p><code>min_clients</code>：已废弃</p>
</li>
<li><p><code>cap_info</code></p>
<ul>
<li><code>name</code>：pcap文件，流量模版文件<ul>
<li>只允许单数据流</li>
<li>生成流量时使用该流量模版，并将 IP 替换为 client 和 server 的 IP 池中的 IP</li>
</ul>
</li>
<li><code>cps</code>：每秒连接数，实际连接数需乘以运行时设置的 <code>-m</code></li>
<li><code>ipg</code>：报文间隙，单位 ms</li>
<li><code>rtt</code>：设置与<code>ipg</code>相同的值</li>
<li><code>w</code>：定义一个burst中该template生成几个flow，默认为 1</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">duration :</span> <span class="number">10.0</span></span><br><span class="line">  <span class="attr">generator :</span></span><br><span class="line">          <span class="attr">distribution :</span> <span class="string">"seq"</span></span><br><span class="line">          <span class="attr">clients_start :</span> <span class="string">"16.0.0.1"</span></span><br><span class="line">          <span class="attr">clients_end   :</span> <span class="string">"16.0.0.255"</span></span><br><span class="line">          <span class="attr">servers_start :</span> <span class="string">"48.0.0.1"</span></span><br><span class="line">          <span class="attr">servers_end   :</span> <span class="string">"48.0.0.255"</span></span><br><span class="line">          <span class="attr">clients_per_gb :</span> <span class="number">201</span></span><br><span class="line">          <span class="attr">min_clients    :</span> <span class="number">101</span></span><br><span class="line">          <span class="attr">dual_port_mask :</span> <span class="string">"1.0.0.0"</span></span><br><span class="line">          <span class="attr">tcp_aging      :</span> <span class="number">1</span></span><br><span class="line">          <span class="attr">udp_aging      :</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">cap_info :</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cap2/dns.pcap</span></span><br><span class="line">       <span class="attr">cps :</span> <span class="number">1.0</span></span><br><span class="line">       <span class="attr">ipg :</span> <span class="number">10000</span></span><br><span class="line">       <span class="attr">rtt :</span> <span class="number">10000</span></span><br><span class="line">       <span class="attr">w   :</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1 id="运行命令行参数"><a href="#运行命令行参数" class="headerlink" title="运行命令行参数"></a>运行命令行参数</h1><p>通过<code>./t-rex-64</code>运行 TRex 服务器，添加参数设置有状态/无状态以及其他选项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./t-rex-64 [mode] &lt;options&gt;</span><br></pre></td></tr></table></figure>
<p>使用 <code>./t-rex-64 -h</code>查看细节</p>
<p>设置 mode：</p>
<ul>
<li><code>-f &lt;file&gt;</code>：运行有状态模式，需设置流量模版 yaml 文件</li>
<li><code>-i</code>：运行无状态模式</li>
</ul>
<p>可选参数：</p>
<ul>
<li><code>--cfg &lt;file&gt;</code>：TRex 配置文件，如果未设置，则使用默认路径<code>/etc/trex_cfg.yaml</code></li>
<li><code>-c &lt;num&gt;</code>：给每个网卡对分配的线程数，会覆盖 TRex 配置中的<code>c</code></li>
<li><code>-m &lt;num&gt;</code>：流量放大倍数，生成基础流量大小乘以这个倍数的流量</li>
<li><code>-d</code>：持续时间，单位 s，默认3600s</li>
</ul>
<h1 id="Stateful-示例"><a href="#Stateful-示例" class="headerlink" title="Stateful 示例"></a>Stateful 示例</h1><p>使用下面测试交换机性能示例来理解 Stateful 运行模式。</p>
<p>该示例配置有一台 TRex 机器和一台交换机。</p>
<ul>
<li>Trex 机器有两张网卡绑定 DPDK，port 1 作为模拟 client 的网卡，port 2 作为模拟 server 的网卡</li>
<li>交换机配置有两条静态路由，如下图所示，可以将<code>16.0.0.0/8</code>的包传到 TRex 的 port 0，将<code>48.0.0.0/8</code>的包传到 TRex 的 port 1</li>
</ul>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20240902003128411.png" alt="TRex-Stateful示例"></p>
<p>根据下面配置，运行 TRex 有状态模式 <code>./t-rex-64 -f traffic.yaml</code>，打流流程如下</p>
<ol>
<li>Port 0 发包<ul>
<li>TRex 配置中的<code>interfaces</code>网卡对中的前一张网卡 port 0 作为 client 发包</li>
<li>发包使用 Traffic 模版配置中的 <code>cap_info</code> 中的第一个包，也就是其中的 DNS query 请求</li>
<li>发送的包中的源目的 IP 会随机被替换为 Traffic 模版中的配置的范围，其中，源 IP 范围 <code>16.0.0.1</code>(clients_start) ~ <code>16.0.0.255</code>(clients_end)，目的 IP 范围 <code>48.0.0.1</code>(servers_start) ~ <code>48.0.255.255</code>(servers_end)</li>
<li>包被发往 TRex 配置中设置的 port 0 网卡的目的 MAC 地址 <code>dest_mac</code>，本示例即通过默认网卡 <code>default_gw</code> 得到的目的 MAC 地址</li>
</ul>
</li>
<li>Port 1 收包<ul>
<li>交换机 port 2 收到 TRex 机器 port 1 发来的目的 IP 为<code>48.0.0.1</code>~ <code>48.0.255.255</code>的包，根据路由，将其通过 port 3 转发到 TRex 机器的 port 1</li>
<li>TRex 配置中的<code>interfaces</code>网卡对中的后一张网卡 port 1 作为 server 收包</li>
</ul>
</li>
<li>Port 1 发包<ul>
<li>TRex 配置中的<code>interfaces</code>网卡对中的后一张网卡  port 1 作为 server 发包</li>
<li>发包使用 Traffic 模版配置中的 <code>cap_info</code> 中的第二个包，也就是其中的 DNS response 回复</li>
<li>发送的包中的源目的 IP 会随机被替换为 Traffic 模版中的配置的范围，其中，源 IP 范围<code>48.0.0.1</code>(servers_start) ~ <code>48.0.255.255</code>(servers_end)，目的 IP 范围 <code>16.0.0.1</code>(clients_start) ~ <code>16.0.0.255</code>(clients_end)</li>
<li>包被发往 TRex 配置中设置的 port 1 网卡的目的 MAC 地址 <code>dest_mac</code>，本示例即通过默认网卡 <code>default_gw</code> 得到的目的 MAC 地址</li>
</ul>
</li>
<li>Port 0 收包<ul>
<li>交换机 port 3 收到 TRex 机器 port 2 发来的目的 IP 为<code>16.0.0.1</code> ~ <code>16.0.0.255</code>的包，根据路由，将其通过 port 2 转发到 TRex 机器的 port 0</li>
<li>TRex 配置中的<code>interfaces</code>网卡对中的后一张网卡 port 0 作为 server 收包</li>
</ul>
</li>
</ol>
<p>TRex 配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">port_limit :</span> <span class="number">2</span>  <span class="comment">#对应下面的网卡数量</span></span><br><span class="line">  <span class="attr">version :</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">interfaces :</span> <span class="string">["06:00.0","06:00.1"]</span>  <span class="comment">#port0、port1的PCI，网卡对，前一个为模拟client的网卡，后一个为模拟server的网卡</span></span><br><span class="line">  <span class="attr">c :</span> <span class="number">6</span>  <span class="comment">#对应下面的每对网卡几个发包threads</span></span><br><span class="line">  <span class="attr">port_info :</span></span><br><span class="line">  	<span class="comment">#port0的配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ip :</span> <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span>  <span class="comment">#port0的IP</span></span><br><span class="line">      <span class="attr">default_gw :</span> <span class="number">11.11</span><span class="number">.11</span><span class="number">.1</span>  <span class="comment">#port2（port0的网关）的IP，由此推出port0网卡发包时的目的MAC地址</span></span><br><span class="line">    <span class="comment">#port1的配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ip :</span> <span class="number">12.12</span><span class="number">.12</span><span class="number">.12</span>  <span class="comment">#port1的IP</span></span><br><span class="line">      <span class="attr">default_gw :</span> <span class="number">12.12</span><span class="number">.12</span><span class="number">.1</span>  <span class="comment">#port3（port1的网关）的IP，由此推出port1网卡发包时的目的MAC地址</span></span><br><span class="line">  <span class="attr">platform :</span></span><br><span class="line">    <span class="attr">master_thread_id  :</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">latency_thread_id :</span> <span class="number">7</span></span><br><span class="line">    <span class="attr">dual_if :</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">socket :</span> <span class="number">0</span></span><br><span class="line">         <span class="attr">threads :</span> <span class="string">[1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure>
<p>Traffic 模版配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">duration :</span> <span class="number">10.0</span></span><br><span class="line">  <span class="attr">generator :</span></span><br><span class="line">          <span class="attr">distribution :</span> <span class="string">"seq"</span></span><br><span class="line">          <span class="attr">clients_start :</span> <span class="string">"16.0.0.1"</span></span><br><span class="line">          <span class="attr">clients_end   :</span> <span class="string">"16.0.0.255"</span></span><br><span class="line">          <span class="attr">servers_start :</span> <span class="string">"48.0.0.1"</span></span><br><span class="line">          <span class="attr">servers_end   :</span> <span class="string">"48.0.255.255"</span></span><br><span class="line">          <span class="attr">clients_per_gb :</span> <span class="number">201</span></span><br><span class="line">          <span class="attr">min_clients    :</span> <span class="number">101</span></span><br><span class="line">          <span class="attr">dual_port_mask :</span> <span class="string">"1.0.0.0"</span></span><br><span class="line">          <span class="attr">tcp_aging      :</span> <span class="number">1</span></span><br><span class="line">          <span class="attr">udp_aging      :</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">cap_info :</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cap2/dns.pcap</span></span><br><span class="line">       <span class="attr">cps :</span> <span class="number">1.0</span></span><br><span class="line">       <span class="attr">ipg :</span> <span class="number">10000</span></span><br><span class="line">       <span class="attr">rtt :</span> <span class="number">10000</span></span><br><span class="line">       <span class="attr">w   :</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>pcap 包模版</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/opt/trex/v3.<span class="number">05</span><span class="comment"># tcpdump -r cap2/dns.pcap</span></span><br><span class="line">reading from file cap2/dns.pcap, link<span class="literal">-type</span> EN10MB (Ethernet)</span><br><span class="line"><span class="literal">-7</span>:<span class="number">00</span>:<span class="number">00.000000</span> IP <span class="number">21.0</span>.<span class="number">0.2</span>.<span class="number">1030</span> &gt; <span class="number">22.0</span>.<span class="number">0.12</span>.domain: <span class="number">48</span> A? www.cisco.com. (<span class="number">31</span>)</span><br><span class="line"><span class="literal">-7</span>:<span class="number">00</span>:<span class="number">00.020944</span> IP <span class="number">22.0</span>.<span class="number">0.12</span>.domain &gt; <span class="number">21.0</span>.<span class="number">0.2</span>.<span class="number">1030</span>: <span class="number">48</span>* <span class="number">1</span>/<span class="number">0</span>/<span class="number">0</span> A <span class="number">100.100</span>.<span class="number">100.100</span> (<span class="number">47</span>)</span><br></pre></td></tr></table></figure>
<h1 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h1><h2 id="Stateful"><a href="#Stateful" class="headerlink" title="Stateful"></a>Stateful</h2><p>在 Linux 虚拟机上演示 Stateful 模式简单示例，直接将流量从 ens37 打到 ens38，再从 ens38 回复到 ens37，配置如下</p>
<h3 id="初始网卡信息"><a href="#初始网卡信息" class="headerlink" title="初始网卡信息"></a>初始网卡信息</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/opt/trex/v3.<span class="number">05</span><span class="comment"># ./dpdk_setup_ports.py -s</span></span><br><span class="line"></span><br><span class="line">Network devices <span class="keyword">using</span> DPDK-compatible driver</span><br><span class="line">============================================</span><br><span class="line">&lt;none&gt;</span><br><span class="line"></span><br><span class="line">Network devices <span class="keyword">using</span> kernel driver</span><br><span class="line">===================================</span><br><span class="line"><span class="number">0000</span>:<span class="number">02</span>:<span class="number">01.0</span> <span class="string">'82545EM Gigabit Ethernet Controller (Copper)'</span> <span class="keyword">if</span>=ens33 drv=e1000 unused=igb_uio,vfio<span class="literal">-pci</span>,uio_pci_generic *Active*</span><br><span class="line"><span class="number">0000</span>:<span class="number">02</span>:<span class="number">05.0</span> <span class="string">'82545EM Gigabit Ethernet Controller (Copper)'</span> <span class="keyword">if</span>=ens37 drv=e1000 unused=igb_uio,vfio<span class="literal">-pci</span>,uio_pci_generic</span><br><span class="line"><span class="number">0000</span>:<span class="number">02</span>:<span class="number">06.0</span> <span class="string">'82545EM Gigabit Ethernet Controller (Copper)'</span> <span class="keyword">if</span>=ens38 drv=e1000 unused=igb_uio,vfio<span class="literal">-pci</span>,uio_pci_generic</span><br><span class="line"></span><br><span class="line">Other network devices</span><br><span class="line">=====================</span><br><span class="line">&lt;none&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/opt/trex/v3.<span class="number">05</span><span class="comment"># ip a</span></span><br><span class="line"><span class="number">1</span>: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="number">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="number">1000</span></span><br><span class="line">    link/loopback <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> brd <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">    inet <span class="number">127.0</span>.<span class="number">0.1</span>/<span class="number">8</span> scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::<span class="number">1</span>/<span class="number">128</span> scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="number">2</span>: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="number">1500</span> qdisc fq_codel state UP group default qlen <span class="number">1000</span></span><br><span class="line">    link/ether <span class="number">00</span>:<span class="number">0</span>c:<span class="number">29</span>:f6:<span class="number">9</span>c:<span class="number">9</span>a brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    altname enp2s1</span><br><span class="line">    inet <span class="number">192.168</span>.<span class="number">0.106</span>/<span class="number">24</span> brd <span class="number">192.168</span>.<span class="number">0.255</span> scope global dynamic noprefixroute ens33</span><br><span class="line">       valid_lft <span class="number">6304</span>sec preferred_lft <span class="number">6304</span>sec</span><br><span class="line">    inet6 fe80::dbd1:<span class="number">95</span>a:<span class="number">915</span>f:<span class="number">65</span>a7/<span class="number">64</span> scope link noprefixroute</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="number">3</span>: ens37: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="number">1500</span> qdisc fq_codel state UP group default qlen <span class="number">1000</span></span><br><span class="line">    link/ether <span class="number">00</span>:<span class="number">0</span>c:<span class="number">29</span>:f6:<span class="number">9</span>c:a4 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    altname enp2s5</span><br><span class="line">    inet <span class="number">192.168</span>.<span class="number">45.137</span>/<span class="number">24</span> brd <span class="number">192.168</span>.<span class="number">45.255</span> scope global dynamic noprefixroute ens37</span><br><span class="line">       valid_lft <span class="number">904</span>sec preferred_lft <span class="number">904</span>sec</span><br><span class="line">    inet6 fe80::<span class="number">205</span>c:eff4:<span class="number">8197</span>:d72f/<span class="number">64</span> scope link noprefixroute</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="number">4</span>: ens38: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="number">1500</span> qdisc fq_codel state UP group default qlen <span class="number">1000</span></span><br><span class="line">    link/ether <span class="number">00</span>:<span class="number">0</span>c:<span class="number">29</span>:f6:<span class="number">9</span>c:ae brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    altname enp2s6</span><br><span class="line">    inet <span class="number">192.168</span>.<span class="number">45.138</span>/<span class="number">24</span> brd <span class="number">192.168</span>.<span class="number">45.255</span> scope global dynamic noprefixroute ens38</span><br><span class="line">       valid_lft <span class="number">903</span>sec preferred_lft <span class="number">903</span>sec</span><br><span class="line">    inet6 fe80::<span class="number">99</span>b1:de77:f189:<span class="number">6869</span>/<span class="number">64</span> scope link noprefixroute</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<h3 id="TRex-配置-1"><a href="#TRex-配置-1" class="headerlink" title="TRex 配置"></a>TRex 配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">port_limit      :</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">version         :</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">interfaces    :</span> <span class="string">["02:05.0","02:06.0"]</span></span><br><span class="line">  <span class="attr">port_info :</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">ip         :</span> <span class="number">192.168</span><span class="number">.45</span><span class="number">.137</span></span><br><span class="line">            <span class="attr">dest_mac :</span> <span class="number">00</span><span class="string">:0c:29:f6:9c:ae</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">ip         :</span> <span class="number">192.168</span><span class="number">.45</span><span class="number">.138</span></span><br><span class="line">            <span class="attr">dest_mac :</span> <span class="number">00</span><span class="string">:0c:29:f6:9c:a4</span></span><br><span class="line">  <span class="attr">platform :</span></span><br><span class="line">    <span class="attr">master_thread_id  :</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">latency_thread_id :</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">dual_if   :</span></span><br><span class="line">           <span class="bullet">-</span> <span class="attr">socket   :</span> <span class="number">0</span></span><br><span class="line">             <span class="attr">threads  :</span> <span class="string">[2]</span></span><br></pre></td></tr></table></figure>
<h3 id="Traffic-配置"><a href="#Traffic-配置" class="headerlink" title="Traffic 配置"></a>Traffic 配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">duration :</span> <span class="number">10.0</span></span><br><span class="line">  <span class="attr">generator :</span></span><br><span class="line">          <span class="attr">distribution :</span> <span class="string">"seq"</span></span><br><span class="line">          <span class="attr">clients_start :</span> <span class="string">"16.0.0.1"</span></span><br><span class="line">          <span class="attr">clients_end   :</span> <span class="string">"16.0.0.255"</span></span><br><span class="line">          <span class="attr">servers_start :</span> <span class="string">"48.0.0.1"</span></span><br><span class="line">          <span class="attr">servers_end   :</span> <span class="string">"48.0.0.255"</span></span><br><span class="line">          <span class="attr">clients_per_gb :</span> <span class="number">201</span></span><br><span class="line">          <span class="attr">min_clients    :</span> <span class="number">101</span></span><br><span class="line">          <span class="attr">dual_port_mask :</span> <span class="string">"1.0.0.0"</span></span><br><span class="line">          <span class="attr">tcp_aging      :</span> <span class="number">1</span></span><br><span class="line">          <span class="attr">udp_aging      :</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">cap_info :</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cap2/dns.pcap</span></span><br><span class="line">       <span class="attr">cps :</span> <span class="number">1.0</span></span><br><span class="line">       <span class="attr">ipg :</span> <span class="number">10000</span></span><br><span class="line">       <span class="attr">rtt :</span> <span class="number">10000</span></span><br><span class="line">       <span class="attr">w   :</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">./t<span class="literal">-rex</span><span class="literal">-64</span> <span class="operator">-f</span> /opt/trex/config/traffic.yaml <span class="literal">-d</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>运行过程中，实时状态显示如下</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="literal">-Per</span> port stats table  <span class="comment">#两张网卡当前的状态</span></span><br><span class="line">      ports |               <span class="number">0</span> |               <span class="number">1</span></span><br><span class="line"> -----------------------------------------------------------------------------------------</span><br><span class="line">   opackets |               <span class="number">2</span> |               <span class="number">2</span> <span class="comment">#当前总发包数</span></span><br><span class="line">     obytes |             <span class="number">154</span> |             <span class="number">186</span> <span class="comment">#当前总发包比特</span></span><br><span class="line">   ipackets |               <span class="number">2</span> |               <span class="number">2</span> <span class="comment">#当前总收包数</span></span><br><span class="line">     ibytes |             <span class="number">186</span> |             <span class="number">154</span> <span class="comment">#当前总收包比特</span></span><br><span class="line">    ierrors |               <span class="number">0</span> |               <span class="number">0</span></span><br><span class="line">    oerrors |               <span class="number">0</span> |               <span class="number">0</span></span><br><span class="line">      Tx Bw |     <span class="number">282.57</span>  bps |     <span class="number">341.28</span>  bps</span><br><span class="line"></span><br><span class="line"><span class="literal">-Global</span> stats enabled</span><br><span class="line"> Cpu Utilization : <span class="number">0.2</span>  %  <span class="number">0.0</span> Gb/core <span class="comment">#CPU占用率</span></span><br><span class="line"> Platform_factor : <span class="number">1.0</span></span><br><span class="line"> Total<span class="literal">-Tx</span>        :     <span class="number">623.85</span>  bps <span class="comment">#实际发包 byte per second</span></span><br><span class="line"> Total<span class="literal">-Rx</span>        :     <span class="number">623.85</span>  bps <span class="comment">#实际收包 byte per second</span></span><br><span class="line"> Total<span class="literal">-PPS</span>       :       <span class="number">0.92</span>  pps <span class="comment">#实际 packet per second</span></span><br><span class="line"> Total<span class="literal">-CPS</span>       :       <span class="number">0.46</span>  cps <span class="comment">#实际 connect per second</span></span><br><span class="line"></span><br><span class="line"> Expected<span class="literal">-PPS</span>    :       <span class="number">2.00</span>  pps <span class="comment">#期望 packet per second</span></span><br><span class="line"> Expected<span class="literal">-CPS</span>    :       <span class="number">1.00</span>  cps <span class="comment">#期望 connect per second</span></span><br><span class="line"> Expected<span class="literal">-BPS</span>    :       <span class="number">1.36</span> Kbps <span class="comment">#期望 byte per second</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#														 Client 数量</span></span><br><span class="line"> Active<span class="literal">-flows</span>    :        <span class="number">0</span>  Clients :      <span class="number">255</span>   Socket<span class="literal">-util</span> : <span class="number">0.0000</span> %</span><br><span class="line"><span class="comment">#														 Server 数量</span></span><br><span class="line"> <span class="built_in">Open-flows</span>      :        <span class="number">2</span>  Servers :      <span class="number">255</span>   Socket :        <span class="number">2</span> Socket/Clients :  <span class="number">0.0</span></span><br><span class="line"> drop<span class="literal">-rate</span>       :       <span class="number">0.00</span>  bps <span class="comment">#丢包率</span></span><br><span class="line"> current time    : <span class="number">3.9</span> sec <span class="comment">#已测试时间</span></span><br><span class="line"> test duration   : <span class="number">6.1</span> sec <span class="comment">#剩余测试时间</span></span><br></pre></td></tr></table></figure>
<p>最终结果</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"> ==================</span><br><span class="line"> interface sum</span><br><span class="line"> ==================</span><br><span class="line">------------------------</span><br><span class="line"> per core stats core id : <span class="number">1</span></span><br><span class="line">------------------------</span><br><span class="line">------------------------</span><br><span class="line"> per core per <span class="keyword">if</span> stats id : <span class="number">1</span></span><br><span class="line">------------------------</span><br><span class="line"> port <span class="number">0</span>, queue id :<span class="number">0</span>  - client</span><br><span class="line"> ----------------------------</span><br><span class="line"> port <span class="number">1</span>, queue id :<span class="number">0</span>  - server</span><br><span class="line"> ----------------------------</span><br><span class="line"> ==================</span><br><span class="line"> generators</span><br><span class="line"> ==================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">normal</span><br><span class="line">-------------</span><br><span class="line"> min_delta  : <span class="number">10</span> usec</span><br><span class="line"> cnt        : <span class="number">0</span></span><br><span class="line"> high_cnt   : <span class="number">0</span></span><br><span class="line"> max_d_time : <span class="number">0</span> usec</span><br><span class="line"> sliding_average    : <span class="number">0</span> usec</span><br><span class="line"> precent    : <span class="literal">-nan</span> %</span><br><span class="line"> histogram</span><br><span class="line"> -----------</span><br><span class="line"> m_total_bytes                           :       <span class="number">1.49</span> Kbytes</span><br><span class="line"> m_total_pkt                             :      <span class="number">18.00</span>  pkt</span><br><span class="line"> m_total_open_flows                      :       <span class="number">9.00</span>  flows</span><br><span class="line"> m_total_pkt                             : <span class="number">18</span></span><br><span class="line"> m_total_open_flows                      : <span class="number">9</span></span><br><span class="line"> m_total_close_flows                     : <span class="number">9</span></span><br><span class="line"> m_total_bytes                           : <span class="number">1530</span></span><br><span class="line"> ---------------</span><br><span class="line">port : <span class="number">0</span></span><br><span class="line">------------</span><br><span class="line"> opackets                                 : <span class="number">9</span></span><br><span class="line"> obytes                                   : <span class="number">693</span></span><br><span class="line"> ipackets                                 : <span class="number">9</span></span><br><span class="line"> ibytes                                   : <span class="number">837</span></span><br><span class="line"> Tx :     <span class="number">290.02</span>  bps</span><br><span class="line">port : <span class="number">1</span></span><br><span class="line">------------</span><br><span class="line"> opackets                                 : <span class="number">9</span></span><br><span class="line"> obytes                                   : <span class="number">837</span></span><br><span class="line"> ipackets                                 : <span class="number">9</span></span><br><span class="line"> ibytes                                   : <span class="number">693</span></span><br><span class="line"> Tx :     <span class="number">350.28</span>  bps</span><br><span class="line"> Cpu Utilization : <span class="number">0.4</span>  %  <span class="number">0.0</span> Gb/core</span><br><span class="line"> Platform_factor : <span class="number">1.0</span></span><br><span class="line"> Total<span class="literal">-Tx</span>        :     <span class="number">640.30</span>  bps</span><br><span class="line"> Total<span class="literal">-Rx</span>        :     <span class="number">640.30</span>  bps</span><br><span class="line"> Total<span class="literal">-PPS</span>       :       <span class="number">0.94</span>  pps</span><br><span class="line"> Total<span class="literal">-CPS</span>       :       <span class="number">0.47</span>  cps</span><br><span class="line"></span><br><span class="line"> Expected<span class="literal">-PPS</span>    :       <span class="number">2.00</span>  pps</span><br><span class="line"> Expected<span class="literal">-CPS</span>    :       <span class="number">1.00</span>  cps</span><br><span class="line"> Expected<span class="literal">-BPS</span>    :       <span class="number">1.36</span> Kbps</span><br><span class="line"></span><br><span class="line"> Active<span class="literal">-flows</span>    :        <span class="number">0</span>  Clients :      <span class="number">255</span>   Socket<span class="literal">-util</span> : <span class="number">0.0000</span> %</span><br><span class="line"> <span class="built_in">Open-flows</span>      :        <span class="number">9</span>  Servers :      <span class="number">255</span>   Socket :        <span class="number">0</span> Socket/Clients :  <span class="number">0.0</span></span><br><span class="line"> drop<span class="literal">-rate</span>       :       <span class="number">0.00</span>  bps</span><br><span class="line"> summary stats</span><br><span class="line"> --------------</span><br><span class="line"> Total<span class="literal">-pkt</span><span class="literal">-drop</span>       : <span class="number">0</span> pkts</span><br><span class="line"> Total<span class="literal">-tx</span><span class="literal">-bytes</span>       : <span class="number">1530</span> bytes</span><br><span class="line"> Total<span class="literal">-tx</span><span class="literal">-sw</span><span class="literal">-bytes</span>    : <span class="number">0</span> bytes</span><br><span class="line"> Total<span class="literal">-rx</span><span class="literal">-bytes</span>       : <span class="number">1530</span> byte</span><br><span class="line"></span><br><span class="line"> Total<span class="literal">-tx</span><span class="literal">-pkt</span>         : <span class="number">18</span> pkts</span><br><span class="line"> Total<span class="literal">-rx</span><span class="literal">-pkt</span>         : <span class="number">18</span> pkts</span><br><span class="line"> Total<span class="literal">-sw</span><span class="literal">-tx</span><span class="literal">-pkt</span>      : <span class="number">0</span> pkts</span><br><span class="line"> Total<span class="literal">-sw</span><span class="literal">-err</span>         : <span class="number">0</span> pkts</span><br><span class="line"> Total ARP sent       : <span class="number">2</span> pkts</span><br><span class="line"> Total ARP received   : <span class="number">1</span> pkts</span><br></pre></td></tr></table></figure>
<h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><h2 id="初始化-EAL-环境失败"><a href="#初始化-EAL-环境失败" class="headerlink" title="初始化 EAL 环境失败"></a>初始化 EAL 环境失败</h2><p>如运行 TRex 遇到下面 EAL 环境报错，则需设置大页</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/opt/trex/v3.<span class="number">05</span><span class="comment"># ./t-rex-64 -f /opt/trex/config/traffic.yaml</span></span><br><span class="line">WARNING: tried to configure <span class="number">2</span> hugepages <span class="keyword">for</span> socket <span class="number">0</span>, but result is: <span class="number">1</span></span><br><span class="line">The ports are bound/configured.</span><br><span class="line">Starting  TRex v3.<span class="number">04</span> please wait  ...</span><br><span class="line">EAL: FATAL: Cannot get hugepage information.</span><br><span class="line">EAL: Cannot get hugepage information.</span><br><span class="line"> You might need to run ./trex<span class="literal">-cfg</span>  once</span><br><span class="line">EAL: Error - exiting with code: <span class="number">1</span></span><br><span class="line">  Cause: Invalid EAL arguments</span><br></pre></td></tr></table></figure>
<p>设置 1024 个 2048kB 大页，即写入 1024 到 hugepages-2048kB 下的 nr_hugepages 文件（初始为 0）</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/opt/trex/v3.<span class="number">05</span><span class="comment"># echo 1024 | tee /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages</span></span><br><span class="line"><span class="number">1024</span></span><br></pre></td></tr></table></figure>
<p>重新运行，即可正常</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://trex-tgn.cisco.com" target="_blank" rel="noopener">https://trex-tgn.cisco.com</a></p>
<p><a href="https://blog.csdn.net/shaoyunzhe/article/details/132344878" target="_blank" rel="noopener">https://blog.csdn.net/shaoyunzhe/article/details/132344878</a></p>
<p><a href="https://www.youtube.com/watch?v=ginboH5cCyA" target="_blank" rel="noopener">https://www.youtube.com/watch?v=ginboH5cCyA</a></p>
]]></content>
      <tags>
        <tag>DPDK</tag>
        <tag>TRex</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode调用Mac摄像头</title>
    <url>/2020/03/31/Xcode%E8%B0%83%E7%94%A8Mac%E6%91%84%E5%83%8F%E5%A4%B4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;Xcode中OpenCV C++调用Mac摄像头。由于在macOS 10.14中加入了隐私管理，直接调用摄像头会出现报错<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OpenCV: not authorized to capture video (status 0), requesting... OpenCV: camera failed to properly initialize!</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;所以涉及摄像头这类隐私问题的项目必须添加<code>Info.plist</code>，在这注册摄像头权限。</p>
<a id="more"></a>
<h1 id="注册摄像头权限"><a href="#注册摄像头权限" class="headerlink" title="注册摄像头权限"></a>注册摄像头权限</h1><p>&emsp;&emsp;Photo Booth作为Mac原生的调用摄像头的app，天生带有设置权限的<code>Info.plist</code>，我们只需要将Photo Booth的<code>Info.plist</code>稍作修改，便可应用于我们的程序中。</p>
<p>&emsp;&emsp;当然，首先我们得<a href="https://gy23333.github.io/2020/01/16/Xcode%E4%B8%8A%E9%85%8D%E7%BD%AEOpenCV%E5%92%8CC-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">在Xcode里配置OpenCV</a>。</p>
<p>1、在<code>/System/Applications/Photo Booth.app</code>中右击“显示包文件”，找到其中的<code>/System/Applications/Photo Booth.app/Contents/Info.plist</code>，将这个<code>Info.plist</code>拷贝用于修改。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/XcodeCamera_显示包内容.png" style="zoom: 50%;" /></p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/XcodeCamera_Info-position.png" style="zoom: 50%;" /></p>
<p>2、修改<code>Info.plist</code></p>
<p>&emsp;&emsp;将原本的<code>Info.plist</code>进行下列修改。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/XcodeCamera_Info-proto.png" style="zoom: 50%;" /></p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/XcodeCamera_Info-after.png" style="zoom: 67%;" /></p>
<p>3、将<code>Info.plist</code>移入Xcode项目中</p>
<p>&emsp;&emsp;在Xcode项目的Product文件中右击里面的项目“Show In Folder”，将修改后的<code>Info.plist</code>添加到该文件夹中。</p>
<p>&emsp;&emsp;摄像头注册配置完成。</p>
<h1 id="OpenCV-C-调用摄像头"><a href="#OpenCV-C-调用摄像头" class="headerlink" title="OpenCV C++ 调用摄像头"></a>OpenCV C++ 调用摄像头</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//读取视频或摄像头</span></span><br><span class="line">    <span class="function">VideoCapture <span class="title">capture</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        Mat frame;</span><br><span class="line">        capture &gt;&gt; frame;</span><br><span class="line">        imshow(<span class="string">"读取视频"</span>, frame);</span><br><span class="line">        waitKey(<span class="number">30</span>); <span class="comment">//延时30</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Xcode</tag>
        <tag>OpenCV</tag>
        <tag>Mac</tag>
        <tag>摄像头权限</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC与Go</title>
    <url>/2023/09/20/gRPC%E4%B8%8EGo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>基于 go 的 gRPC 简介与实现</p>
<a id="more"></a>
<h1 id="gRPC-简介"><a href="#gRPC-简介" class="headerlink" title="gRPC 简介"></a>gRPC 简介</h1><p><img src="https://grpc.io/img/landing-2.svg" alt=""></p>
<p>gRPC 使用 Protocol Buffer 作为其接口定义语言，使得 gRPC 客户端可以跨机器、跨语言调用 gRPC 服务器的方法。</p>
<ul>
<li><p>Protocol Buffer 定义接口的输入参数和返回类型</p>
</li>
<li><p>gRPC 服务端：实现接口方法，并运行 gRPC Server</p>
</li>
<li><p>gRPC 客户端：调用 gRPC Stub （相当于 gRPC Server 在客户端的代理，拥有与 Server 实现的接口方法）的接口</p>
</li>
</ul>
<h1 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h1><p>Mac 安装 go gRPC 所需环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install protobuf protoc-gen-go protoc-gen-go-grpc</span><br></pre></td></tr></table></figure>
<h1 id="一个简单的-gRPC"><a href="#一个简单的-gRPC" class="headerlink" title="一个简单的 gRPC"></a>一个简单的 gRPC</h1><p>实现客户端向服务端查询用户的信息</p>
<h2 id="Protocol-Buffer"><a href="#Protocol-Buffer" class="headerlink" title="Protocol Buffer"></a>Protocol Buffer</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://grpc.io/docs/languages/go/quickstart/" target="_blank" rel="noopener">gRPC 官方文档</a></li>
<li><a href="http://www.topgoer.com/微服务/gRPC.html" target="_blank" rel="noopener">Go-gRPC 使用教程</a></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>hough变换</title>
    <url>/2019/12/20/hough%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>​    hough变换主要用于找线，当然也可以扩展为找圆或者其他形状。</p>
<p><img src="https://i.loli.net/2020/01/17/3g8XPIn5KNO4dZT.jpg" alt="road.jpg" style="zoom:18%;" /></p>
<p><img src="https://i.loli.net/2020/01/17/2YX7I6Od9UlGKcr.jpg" alt="result.jpg" style="zoom: 18%;" /></p>
<a id="more"></a>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>在Canny算法提取出边缘的基础上，</p>
<ol>
<li><p>将原图像空间转到参数空间；</p>
</li>
<li><p>在参数空间 <em>(u,v)</em> 内建立两维数组 <em>A( u,v )</em> ;</p>
</li>
<li><p>在开始时将数组置零；</p>
</li>
<li><p>对图像空间的每一个待检测点 <em>(xi, yi)</em> ，令 <em>u</em> 取遍所有可能的取值，并计算对应的<em>v</em>；</p>
<p>​                                        <strong>v = - xi * u + yi</strong></p>
</li>
<li><p>对计算得到的 <em>(u,v)</em> ，对 <em>A(u,v)</em> 中相应单元进行累加:</p>
<p>​                                        <strong>A(u, v) = A(u, v) + 1</strong></p>
</li>
<li><p>根据 A(u,v)的值，确定有多少点是共线的， 同时可以知道线条的参数(u,v)。</p>
<p>​                                        <strong>y = u x + v</strong></p>
</li>
</ol>
<h1 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _USE_MATH_DEFINES</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_LINES 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_LINEPOINTS 30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Hough变换(找到最长的NUM_LINES条直线)</span></span><br><span class="line"><span class="comment"> img为输入的二值边缘图像，lines为Hough变换提取出的直线</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">houghTrans_max</span><span class="params">(Mat img, <span class="built_in">vector</span>&lt;Vec2f&gt; &amp;lines)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numangle = <span class="number">360</span>;</span><br><span class="line">    <span class="keyword">int</span> numr = <span class="keyword">int</span>(<span class="built_in">sqrt</span>(<span class="built_in">pow</span>(img.rows, <span class="number">2</span>) + <span class="built_in">pow</span>(img.cols, <span class="number">2</span>)));</span><br><span class="line">    <span class="keyword">int</span> numpoint[numangle][numr];</span><br><span class="line">    <span class="keyword">int</span> numline = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// numpoint置0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numangle; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; numr; j++) &#123;</span><br><span class="line">            numpoint[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环遍历每个点，如果为边缘点则进行处理（遍历每个角度ang，算出相应的r）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; img.rows; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; img.cols; i++) &#123;</span><br><span class="line">            <span class="comment">// 只取边缘点</span></span><br><span class="line">            <span class="keyword">if</span> (img.ptr&lt;uchar&gt;(j)[i] == <span class="number">255</span>) &#123;</span><br><span class="line">                <span class="comment">// 遍历每个角度ang，算出相应的r</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; numangle/<span class="number">2</span>; n++) &#123;</span><br><span class="line">                    <span class="keyword">double</span> ang = <span class="keyword">double</span>(n*M_PI/<span class="number">180</span>);</span><br><span class="line">                    <span class="keyword">int</span> r = <span class="keyword">int</span>(i*<span class="built_in">cos</span>(ang) + j*<span class="built_in">sin</span>(ang));</span><br><span class="line">                    <span class="keyword">if</span>(r &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">int</span> n1 = n+<span class="number">180</span>;</span><br><span class="line">                        <span class="keyword">int</span> r1 = -r;</span><br><span class="line">                        numpoint[n1][r1] ++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       numpoint[n][r] ++; <span class="comment">//记录该角度半径下的点数</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> minmax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxNum[NUM_LINES];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_LINES; i++) &#123;</span><br><span class="line">        maxNum[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">float</span> lines_f[NUM_LINES][<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 遍历角度半径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numangle; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; numr; j++) &#123;</span><br><span class="line">            <span class="comment">// 如该角度、半径下点数大于门限10，且进行非极大值抑制，则记录线</span></span><br><span class="line">            <span class="keyword">if</span> (numpoint[i][j] &gt; MIN_LINEPOINTS &amp;&amp; (numpoint[i][j] &gt; minmax || numline &lt; NUM_LINES)) &#123;</span><br><span class="line">                <span class="comment">// 未满四条线时</span></span><br><span class="line">                <span class="keyword">if</span> (numline &lt; NUM_LINES) &#123;</span><br><span class="line">                    maxNum[numline] = numpoint[i][j];</span><br><span class="line">                    lines_f[numline][<span class="number">0</span>] = <span class="keyword">float</span>(j);</span><br><span class="line">                    lines_f[numline][<span class="number">1</span>] = <span class="keyword">float</span>(i*M_PI/<span class="number">180</span>);</span><br><span class="line">                    minmax = maxNum[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; numline+<span class="number">1</span>; m++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (maxNum[m] &lt; minmax) &#123;</span><br><span class="line">                            minmax = maxNum[m];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 满四条线时</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; NUM_LINES; m++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (maxNum[m] == minmax) &#123;</span><br><span class="line">                            lines_f[m][<span class="number">0</span>] = <span class="keyword">float</span>(j);</span><br><span class="line">                            lines_f[m][<span class="number">1</span>] = <span class="keyword">float</span>(i*M_PI/<span class="number">180</span>);</span><br><span class="line">                            maxNum[m] = numpoint[i][j];</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    minmax = maxNum[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; NUM_LINES; m++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (maxNum[m] &lt; minmax) &#123;</span><br><span class="line">                            minmax = maxNum[m];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                numline++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (numline &gt; NUM_LINES) &#123;</span><br><span class="line">        numline = NUM_LINES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numline; i++) &#123;</span><br><span class="line">        Vec2f l;</span><br><span class="line">        l[<span class="number">0</span>] = lines_f[i][<span class="number">0</span>];</span><br><span class="line">        l[<span class="number">1</span>] = lines_f[i][<span class="number">1</span>];</span><br><span class="line">        lines.push_back(l);</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Hough变换</span></span><br><span class="line"><span class="comment"> img为输入的二值边缘图像，lines为Hough变换提取出的直线，threshold是共线的点数的阈值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">houghTrans</span><span class="params">(Mat img, <span class="built_in">vector</span>&lt;Vec2f&gt; &amp;lines, <span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numangle = <span class="number">360</span>;</span><br><span class="line">    <span class="keyword">int</span> numr = <span class="keyword">int</span>(<span class="built_in">sqrt</span>(<span class="built_in">pow</span>(img.rows, <span class="number">2</span>) + <span class="built_in">pow</span>(img.cols, <span class="number">2</span>)));</span><br><span class="line">    <span class="keyword">int</span> numpoint[numangle][numr];</span><br><span class="line">    <span class="keyword">int</span> numline = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// numpoint置0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numangle; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; numr; j++) &#123;</span><br><span class="line">            numpoint[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环遍历每个点，如果为边缘点则进行处理（遍历每个角度ang，算出相应的r）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; img.rows; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; img.cols; i++) &#123;</span><br><span class="line">            <span class="comment">// 只取边缘点</span></span><br><span class="line">            <span class="keyword">if</span> (img.ptr&lt;uchar&gt;(j)[i] == <span class="number">255</span>) &#123;</span><br><span class="line">                <span class="comment">// 遍历每个角度ang，算出相应的r</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; numangle/<span class="number">2</span>; n++) &#123;</span><br><span class="line">                    <span class="keyword">double</span> ang = <span class="keyword">double</span>(n*M_PI/<span class="number">180</span>);</span><br><span class="line">                    <span class="keyword">int</span> r = <span class="keyword">int</span>(i*<span class="built_in">cos</span>(ang) + j*<span class="built_in">sin</span>(ang));</span><br><span class="line">                    <span class="keyword">if</span>(r &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">int</span> n1 = n+<span class="number">180</span>;</span><br><span class="line">                        <span class="keyword">int</span> r1 = -r;</span><br><span class="line">                        numpoint[n1][r1] ++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       numpoint[n][r] ++; <span class="comment">//记录该角度半径下的点数</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历角度半径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numangle; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; numr; j++) &#123;</span><br><span class="line">            <span class="comment">// 如该角度、半径下点数大于门限，且进行非极大值抑制，则记录线</span></span><br><span class="line">            <span class="keyword">if</span> (numpoint[i][j] &gt; threshold) &#123;</span><br><span class="line">                Vec2f l;</span><br><span class="line">                l[<span class="number">0</span>] = <span class="keyword">float</span>(j);</span><br><span class="line">                l[<span class="number">1</span>] = <span class="keyword">float</span>(i*M_PI/<span class="number">180</span>);</span><br><span class="line">                lines.push_back(l);</span><br><span class="line">                numline ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 在图像上画线</span></span><br><span class="line"><span class="comment"> img为输入图像，result为画完线的输出图像，lines为需要画的线</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawLines</span><span class="params">(Mat &amp;img, Mat &amp;result, <span class="built_in">vector</span>&lt;Vec2f&gt; &amp;lines)</span></span>&#123;</span><br><span class="line">    cvtColor(img, result, COLOR_GRAY2BGR); <span class="comment">//将IMREAD_GRAYSCALE转化为COLOR_GRAY2BGR格式，以便显示线</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; lines.<span class="built_in">size</span>(); i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">float</span> rho = lines[i][<span class="number">0</span>], theta = lines[i][<span class="number">1</span>];</span><br><span class="line">        Point pt1, pt2;</span><br><span class="line">        <span class="keyword">double</span> a = <span class="built_in">cos</span>(theta), b = <span class="built_in">sin</span>(theta);</span><br><span class="line">        <span class="keyword">if</span> (rho/b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pt1.y = <span class="number">0</span>;</span><br><span class="line">            pt1.x = cvRound(rho/a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pt1.x = <span class="number">0</span>;</span><br><span class="line">            pt1.y = cvRound(rho/b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((-(a/b)*<span class="keyword">float</span>(img.cols<span class="number">-1</span>)+rho/b) &gt;= img.rows) &#123;</span><br><span class="line">            pt2.y = img.rows<span class="number">-1</span>;</span><br><span class="line">            pt2.x = cvRound(-(b/a)*<span class="keyword">float</span>(img.rows<span class="number">-1</span>) + rho/a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pt2.x = img.cols<span class="number">-1</span>;</span><br><span class="line">            pt2.y = cvRound(-(a/b)*<span class="keyword">float</span>(img.cols<span class="number">-1</span>) + rho/b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">line</span>( result, pt1, pt2, Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">1</span>, LINE_AA);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mat img, edge, result;</span><br><span class="line">    img = imread(<span class="string">"road.jpg"</span>, IMREAD_GRAYSCALE); <span class="comment">//从文件中加载灰度图像</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取图片失败，则停止</span></span><br><span class="line">    <span class="keyword">if</span> (img.empty()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"读取图像文件失败"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Canny(img, edge, <span class="number">100</span>, <span class="number">400</span>); <span class="comment">// canny变换</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;Vec2f&gt; lines;</span><br><span class="line"><span class="comment">//  int numline = houghTrans_max(edge, lines); // Hough变换(找到最长的NUM_LINES条直线)</span></span><br><span class="line"><span class="comment">//  HoughLines(edge, lines, 1, CV_PI/180, 150, 0, 0 ); // OpenCV的hough变换</span></span><br><span class="line">    houghTrans(edge, lines, <span class="number">400</span>);</span><br><span class="line">    </span><br><span class="line">    drawLines(img, result, lines);<span class="comment">// 画线</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 图像显示</span></span><br><span class="line">    imshow(<span class="string">"img"</span>, img);</span><br><span class="line">    imshow(<span class="string">"canny"</span>,edge);<span class="comment">// 图像显示</span></span><br><span class="line">    imshow(<span class="string">"hough"</span>, result);</span><br><span class="line">    waitKey();</span><br><span class="line">    imwrite(<span class="string">"result.jpg"</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>原图像：</p>
<p><img src="https://i.loli.net/2020/01/17/3g8XPIn5KNO4dZT.jpg" alt="road.jpg"></p>
<p>hough变化后的图像（找到直线用红线标出）：</p>
<p><img src="https://i.loli.net/2020/01/17/2YX7I6Od9UlGKcr.jpg" alt="result.jpg"></p>
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>OpenCV</tag>
        <tag>图像处理</tag>
        <tag>hough</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab GUI入门</title>
    <url>/2020/01/08/matlab-GUI%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>​    Matlab GUI为图形用户界面，可以理解为相当于做一个软件，将输入输出函数操作通过交互界面表现出来，下面简单讲述一些Matlab GUI入门知识。</p>
<a id="more"></a>
<h1 id="创建新的GUI界面"><a href="#创建新的GUI界面" class="headerlink" title="创建新的GUI界面"></a>创建新的GUI界面</h1><p>​    GUI系统包含两种文件，一种是.fig文件，用于设计页面，另一种是.m文件，用来存放控件操作。</p>
<h2 id="创建-fig文件"><a href="#创建-fig文件" class="headerlink" title="创建.fig文件"></a>创建.fig文件</h2><ol>
<li><p>打开Matlab，在命令行窗口中输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">guide</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/01/08/NA8QGvdIXoH6f9q.png" alt="命令行窗口中输入GUI"></p>
</li>
<li><p>回车，弹出GUIDE快速入门弹窗；</p>
<p><img src="https://i.loli.net/2020/01/08/MxiXZS38gl4Rj1H.png" style="zoom: 50%;" /></p>
</li>
<li><p>选中默认的 Blank GUI (Default) ，点击确定新建GUI，自动生成新的.fig页面文件；</p>
<p><img src="https://i.loli.net/2020/01/08/PZcp1OA4zEndsqr.png" alt=""></p>
</li>
<li><p>完成GUI的.fig文件的新建。</p>
<h2 id="创建-fig文件-1"><a href="#创建-fig文件-1" class="headerlink" title="创建.fig文件"></a>创建.fig文件</h2><p>​    保存.fig文件时，会自动生成相对应的.m的文件。</p>
</li>
</ol>
<p>   ​    现在，一个GUI界面已经搭建完成，你可以在.fig文件里增加修改控件、设计页面，在.m文件里编写逻辑代码。</p>
<h1 id="fig的页面设计"><a href="#fig的页面设计" class="headerlink" title=".fig的页面设计"></a>.fig的页面设计</h1><h2 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h2><p>   ​    左侧的控件栏里面直接可通过拖拽放入控件，下面简单介绍一下课设里几种常用的控件。</p>
<p>   <img src="https://i.loli.net/2020/01/08/9I4OvxFEXa58Zpi.png" style="zoom: 50%;" /></p>
<h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><p>   <img src="https://i.loli.net/2020/01/08/g8qOlNs9fSXVixe.png" style="zoom:50%;" />    双击拖拽出来的按钮，可进入按钮的检查器，在检查器里设置按钮的属性。</p>
<p>   <img src="https://i.loli.net/2020/01/08/8RWnOp9Ej3x5acZ.png" style="zoom: 33%;" /></p>
<p>   ​    检查器中比较重要的几个属性：</p>
<ul>
<li>| Tag          | 控件的名称（不重名），.m通过Tag来唯一寻找该控件，建议将需调用的控件换成有意义的名字，方便调用。 |<br>| —————— | —————————————————————————————— |<br>| String       | 控件里面的文字                                               |<br>| FontSize     | 控件里面的文字的字体大小                                     |<br>| Visible      | 控件初始是否可见                                             |<br>| <strong>Callback</strong> | 调用函数（如是按钮的话，则点击按钮就会调用该函数），<strong>双击中间的书写按钮matlab会自动跳转到相应的.m中的调用函数的位置</strong>，方便书写 |</li>
</ul>
<h3 id="可编辑文本"><a href="#可编辑文本" class="headerlink" title="可编辑文本"></a>可编辑文本</h3><p><img src="https://i.loli.net/2020/01/08/WU2iYajrpITE8cK.png" style="zoom:50%;" />可编辑文本，<strong>可通过交互界面来进行编辑</strong>，当然也可在检查器中String里直接设置其初始值，常用于<strong>参数输入</strong>。</p>
<h3 id="静态文本"><a href="#静态文本" class="headerlink" title="静态文本"></a>静态文本</h3><p><img src="https://i.loli.net/2020/01/08/wsrGmgAjLbYhEtk.png" style="zoom:50%;" />静态文本，<strong>不可通过交互界面来进行编辑</strong>，可设置String初始文本，也可通过.m修改，用于<strong>描述文字和输出</strong>。</p>
<h3 id="坐标区"><a href="#坐标区" class="headerlink" title="坐标区"></a>坐标区</h3><p><img src="https://i.loli.net/2020/01/08/klGwxZiDnfa7Kou.png" style="zoom:50%;" />坐标区，用于画图（动画、坐标图等）。</p>
<h3 id="面板"><a href="#面板" class="headerlink" title="面板"></a>面板</h3><p><img src="https://i.loli.net/2020/01/08/6vIciuo9e387OyY.png" style="zoom:50%;" />面板，可将各控件组合成一个集合，方便移动，显示更清晰。</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>​    介绍两个我觉得用得到的。</p>
<h3 id="对齐对象"><a href="#对齐对象" class="headerlink" title="对齐对象"></a>对齐对象</h3><p><img src="https://i.loli.net/2020/01/08/jneLEPHMBTRQk8s.png" alt=""></p>
<p>​    用于对齐控件，使页面整齐美观。</p>
<p><img src="https://i.loli.net/2020/01/08/UcTon8SJIWreNYQ.png" style="zoom:50%;" /></p>
<p>​    例如，随意拖入几个文本，选中全部，设置好横纵对齐分布格式，点击应用。</p>
<p><img src="https://i.loli.net/2020/01/08/L3lE4JMuDjQKFoO.png" style="zoom: 33%;" /></p>
<p><img src="https://i.loli.net/2020/01/08/DOC9TpkP3NvfFbj.png" style="zoom: 33%;" /></p>
<p>​    瞬间就整齐了。</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>​    可方便地查看页面显示。</p>
<p><img src="https://i.loli.net/2020/01/08/S5jN4MUP8LmZXnC.png" alt=""></p>
<h1 id="m的文件编写"><a href="#m的文件编写" class="headerlink" title=".m的文件编写"></a>.m的文件编写</h1><h2 id="查看修改控件属性"><a href="#查看修改控件属性" class="headerlink" title="查看修改控件属性"></a>查看修改控件属性</h2><p>​    应用广泛，比如检测输入框输入的内容和输出到输出的静态文本框。</p>
<p>检测输入框输入的内容：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = str2num(get(handles.Tagname, <span class="string">'string'</span>)); <span class="comment">% 从Tag属性为Tagname的String属性中获取x的string格式，再转为num（即在Tagname中输入的x）</span></span><br></pre></td></tr></table></figure>
<p>输出到输出的静态文本框：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">set(handles.Tagname, <span class="string">'string'</span>, num2str(y)); <span class="comment">% 将参数y先从num转为string，再设置到Tag属性为Tagname的String属性中（即在Tagname中显示y）</span></span><br></pre></td></tr></table></figure>
<h2 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">h = gcf;	<span class="comment">% 本页面（不需关闭本页面此句省略）</span></span><br><span class="line">pagename; <span class="comment">% 打开名字为pagename的页面</span></span><br><span class="line">close(h); <span class="comment">%	关闭本页面（不需关闭本页面此句省略）</span></span><br></pre></td></tr></table></figure>
<h3 id="页面之间传参"><a href="#页面之间传参" class="headerlink" title="页面之间传参"></a>页面之间传参</h3><p>​    既然有跳转，那就免不了传参，最简单的方法就是设置全局变量（适用于小系统）。</p>
<p>​    在用到该全局变量的函数开头都声明该全局变量即可。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">global</span> x</span><br></pre></td></tr></table></figure>
<h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><p>​    例如绘制一个三角函数</p>
<script type="math/tex; mode=display">
y = sinx</script><p>先在界面放置好axes控件，这里命名为axes1；</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">X = <span class="number">0</span>:<span class="number">0.01</span>:<span class="built_in">pi</span>; <span class="comment">% 设置x的范围(起始值：采样间隔：终止值)</span></span><br><span class="line">Y = <span class="built_in">sin</span>(X); <span class="comment">% 设置x-y的对应函数</span></span><br><span class="line">axes(handles.axes1); <span class="comment">% 选则坐标区（axes）axes1</span></span><br><span class="line"><span class="built_in">plot</span>(X, Y, <span class="string">'b'</span>); <span class="comment">% 绘制X-Y（X轴变量，Y轴变量，点的颜色）</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>SIFT算子</title>
    <url>/2020/04/22/SIFT%E7%AE%97%E5%AD%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;<strong>尺度不变特征转换</strong>(<strong>Scale-invariant feature transform</strong> 或 <strong>SIFT</strong>)是一种机器视觉的算法用来侦测与描述影像中的局部性特征，它在空间尺度中寻找极值点，并提取出其位置、尺度、旋转不变数，融特征点和描述于一体。</p>
<a id="more"></a>
<h1 id="SIFT算子——算法"><a href="#SIFT算子——算法" class="headerlink" title="SIFT算子——算法"></a>SIFT算子——算法</h1><h2 id="尺度空间极值检测"><a href="#尺度空间极值检测" class="headerlink" title="尺度空间极值检测"></a>尺度空间极值检测</h2><p>&emsp;&emsp;图像在不同的尺度下用高斯滤波器进行卷积，然后利用连续高斯模糊化图像差异来找出关键点。</p>
<h3 id="高斯金字塔构建"><a href="#高斯金字塔构建" class="headerlink" title="高斯金字塔构建"></a>高斯金字塔构建</h3><p>&emsp;&emsp;图像的尺度空间被定义为一个函数 $L(x,y,\sigma)$，它是由可变尺度高斯函数$G(x,y,\sigma)$与输入图像$I(x,y)$的卷积产生的。</p>
<script type="math/tex; mode=display">
L(x,y,\sigma)=G(x,y,\sigma)*I(x,y)</script><script type="math/tex; mode=display">
G(x,y,\sigma)=\frac1{2\pi \sigma^2}e^{-\frac{x^2+y^2}{2\sigma ^2}}</script><p>$\sigma$是尺度坐标(尺度变化因子)，$\sigma$大小决定图像的平滑程度，$\sigma$值越大图像模糊得越严重。大尺度对应图像的概貌特征，小尺度对应图像的细节特征。一般根据$3\sigma$原则，高斯核矩阵的大小设为$(6\sigma +1)\times (6\sigma +1)$。</p>
<p>&emsp;&emsp;SIFT算子中的高斯金字塔由多个组（Octave）组成，而每个组（Octave）由多层（Interval）组成。</p>
<p>&emsp;&emsp;每组图像的第一层由上一组的第一层<strong>高斯金字塔降采样</strong>而得，每组的下一层由上一层<strong>高斯滤波</strong>而得。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/SIFT_Pyramid1.png" style="zoom:33%;" /></p>
<p>&emsp;&emsp;先按<a href="https://gy23333.github.io/2020/04/16/图像金字塔/">高斯金字塔</a>将原图像化为多组（Octave），后一组的尺寸是前一组的$\frac 12$。每组再由第一层进行高斯滤波，同组的图像尺寸相同。</p>
<p>&emsp;&emsp;在降采样时，高斯金字塔中一组(Octive)的底层图像是由前一组图像的倒数第3张图像隔点采样得到。</p>
<div class="note info">
            <p>&emsp;&emsp;金字塔组数（Octave）可由原始图像和塔顶图像的大小之比算得。</p><script type="math/tex; mode=display">Octave = \log_2 \frac {min(width_0,height_0)}{min(width,height)}</script><p>式中，$width_0、height_0$分别为原始图像的宽高，$width、height$为塔顶图像的宽高。</p>
          </div>
<p>&emsp;&emsp;每组分为$S$个尺度间隔（做$S$次高斯滤波），相邻两个尺度的$\sigma$之比为：</p>
<script type="math/tex; mode=display">
k=2^{\frac 1S}</script><p>则每一组包含$1$，$2^{\frac 1S}$，$2^{\frac 2S}$，…，2，一共$(S+1)$幅图像（即$(S+1)$层）。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/SIFT_Pyramid2.jpg" style="zoom: 65%;" /></p>
<div class="note info">
            <p>&emsp;&emsp;尺度参数$\sigma$的取值与金字塔的组数和层数相关。设第一组第一层的尺度参数取值为$\sigma (0,0) = \sigma _0$，则第$m$组第$n$层的$\sigma$取值为</p><script type="math/tex; mode=display">\sigma(0,0)=\sigma_0,\quad\sigma(o,s)=2^{o}\times k^{s}\times \sigma_0 = 2^{o}\times 2^{\frac sS}\times \sigma_0=2^{o+\frac sS}\times \sigma_0</script>
          </div>
<h3 id="高斯差分金字塔（DoG金字塔）"><a href="#高斯差分金字塔（DoG金字塔）" class="headerlink" title="高斯差分金字塔（DoG金字塔）"></a>高斯差分金字塔（DoG金字塔）</h3><p>&emsp;&emsp;DoG金字塔计算简单，提供了LoG算子良好的近似，LoG算子的极值相较于Hessian、Harris等算子，能提供更稳定的图像特征，且具有尺度不变性。</p>
<p>&emsp;&emsp;高斯差分图像由高斯金字塔中同一组(Octave)内相邻层(Interval)的图像作差得到。</p>
<script type="math/tex; mode=display">
D(x,y,\sigma)=L(x,y,k\sigma)-L(x,y,\sigma)</script><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/SIFT_DoG.png" style="zoom: 33%;" /></p>
<p>&emsp;&emsp;高斯金字塔一级$S$个图像，将得到DoG金字塔一级$(S-1)$个图像。</p>
<h3 id="空间极值点检测"><a href="#空间极值点检测" class="headerlink" title="空间极值点检测"></a>空间极值点检测</h3><p>&emsp;&emsp;对DoG金字塔中的每个像素，在<strong>三维领域</strong>内判断是否是<strong>极值点</strong>（最大值/最小值）。如果是极值点，则该点暂定为图像在该尺度下的一个特征点。</p>
<p><strong>三维领域</strong>：中间检测点与其同尺度的8个邻域像素点以及上下相邻两层对应的$9\times 2$个像素点一共$3\times 9-1=26$个点作比较。</p>
<p><img src="https://i.loli.net/2020/04/23/hVMXou7GcbmJE2j.png" alt="SIFT_DoG1.png" style="zoom: 50%;" /></p>
<p>&emsp;&emsp;该步的极值点检测可以确定极值点的位置（像素级）和尺度，极值点的大小反映了极值处的对比度（反差）。</p>
<p>&emsp;&emsp;为了每组（Octave）得到$S$个尺度的极值结果，需要DoG金字塔每组$S+2$个图像，需要高斯金字塔每组$S+3$个图像。</p>
<h2 id="关键点定位"><a href="#关键点定位" class="headerlink" title="关键点定位"></a>关键点定位</h2><h3 id="亚像素（子像素）精确定位"><a href="#亚像素（子像素）精确定位" class="headerlink" title="亚像素（子像素）精确定位"></a>亚像素（子像素）精确定位</h3><p>&emsp;&emsp;在DoG尺度空间检测到的极值点是离散的，通过三元二次函数拟合来精确确定关键点的位置和尺度，达到亚像素精度。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/SIFT_location.png" style="zoom: 33%;" /></p>
<p>&emsp;&emsp;将原点移到极值点处，并将高斯差分在该极值点处展开，保留一阶项及二阶项，得到：</p>
<script type="math/tex; mode=display">
D(X)=D+\frac {\partial D^T}{\partial X}+\frac 12 X^T\frac {\partial ^2 D}{\partial X^2}X</script><p>其中，$X=(x,y,\sigma )^T$</p>
<p>&emsp;&emsp;令$D’(X)=0$，得极值点的偏移量</p>
<script type="math/tex; mode=display">
\hat X = -(\frac {\partial^2 D}{\partial X^2})^{-1}\frac {\partial D}{\partial X}</script><p>如此得到亚像素精度的极值点$\hat X$。</p>
<p>&emsp;&emsp;利用$\hat X$得到新的高斯差分值$D(\hat X)$</p>
<script type="math/tex; mode=display">
D(\hat X)=D+\frac 12 \frac {\partial D^T}{\partial X}\hat X</script><p>设置<strong>对比度阈值</strong>$T$，当$|D(\hat X)|&lt;T$时，去除该对比度低的不稳定极值点$\hat X$。</p>
<h3 id="去除边缘点"><a href="#去除边缘点" class="headerlink" title="去除边缘点"></a>去除边缘点</h3><p>&emsp;&emsp;由于DoG算子对边缘点很敏感，在边缘处也有很大的响应值，需要剔除不稳定的边缘响应点。</p>
<p>&emsp;&emsp;在极值点处，利用$D(X)$计算Hessian矩阵</p>
<script type="math/tex; mode=display">
H=
\begin{bmatrix}
D_{xx}&D_{xy}\\
D_{yx}&D_{yy}
\end{bmatrix}</script><p>&emsp;&emsp;$D(X)$的主曲率与$H$的特征值成正比，在边缘梯度方向比较大，对应一个大的特征值$\alpha$；在沿着边缘的方向上比较小，对应一个小的特征值$\beta$。（两个特征值的之比为$r = \alpha/\beta$）</p>
<p>两特征值的和等于$H$的迹$Tr(H)$</p>
<script type="math/tex; mode=display">
Tr(H)=D_{xx}+D_{yy}=\alpha + \beta</script><p>两特征值的积等于$H$的行列式$det(H)$</p>
<script type="math/tex; mode=display">
det(H)=D_{xx}D_{yy}-D_{xy}D_{yx}</script><p>则有</p>
<script type="math/tex; mode=display">
\frac {Tr^2(H)}{det(H)}=\frac {(\alpha + \beta)^2}{\alpha \beta}=\frac {(r+1)^2}{r}</script><p>当两特征值相等，即$r=1$时，$\frac {(r+1)^2}{r}$最小。$r$越大，$\frac {(r+1)^2}{r}$越大。</p>
<p>&emsp;&emsp;边缘点对应的特征值之比$r$比其他的点大，所以设置一个关于$r$的阈值$T_r$，当$\frac {Tr^2(H)}{det(H)} &gt; \frac {(T_r+1)^2}{T_r}$时，判断该极值点为边缘点，去除该点。</p>
<h2 id="获取关键点主方向"><a href="#获取关键点主方向" class="headerlink" title="获取关键点主方向"></a>获取关键点主方向</h2><p>&emsp;&emsp;为了使特征描述子具有旋转不变性，需要利用关键点邻域像素的梯度方向分布特性为每个关键点指定方向参数。</p>
<p>&emsp;&emsp;根据关键点的尺度，在高斯金字塔对应图像的关键点位置处的局部区域计算<strong>梯度方向直方图</strong>，计算每个点的梯度幅值和方向。（一般取大小为$3\sigma$的领域）</p>
<p>梯度幅值$m$：</p>
<script type="math/tex; mode=display">
m(x,y)=\sqrt{[L(x+1,y)-L(x-1,y)]^2+[L(x,y+1)-L(x,y-1)]^2}</script><p>梯度方向$\theta$：</p>
<script type="math/tex; mode=display">
\theta (x,y)=\tan^{-1}\frac {L(x,y+1)-L(x,y-1)}{L(x+1,y)-L(x-1,y)}</script><p>&emsp;&emsp;将$[0\circ, 360\circ]$分为多个柱，梯度幅值加到对应的梯度方向的柱上，选出直方图的峰值为该关键点的主方向。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/SIFT_direction1.png" style="zoom:45%;" /></p>
<h2 id="关键点描述"><a href="#关键点描述" class="headerlink" title="关键点描述"></a>关键点描述</h2><p>&emsp;&emsp;到上述步骤已经获得了关键点的位置、尺度以及方向。关键点的描述利用关键点及其周围像素，计算块内梯度直方图，生成特征向量，用于描述每个关键点。</p>
<h3 id="确定用于计算关键点描述的局部区域"><a href="#确定用于计算关键点描述的局部区域" class="headerlink" title="确定用于计算关键点描述的局部区域"></a>确定用于计算关键点描述的局部区域</h3><p>&emsp;&emsp;描述子梯度方向直方图由关键点所在尺度的模糊图像计算产生，局部区域的半径$radius$：（$\sigma_{oct}$为关键点所在组的组内尺度）</p>
<script type="math/tex; mode=display">
radius = \frac {3\sigma_{oct}\times \sqrt2 \times (d+1)}{2},\quad d = 4</script><p>&emsp;&emsp;除上面的方法以外，还可以直接使用直径$diameter$：（$\sigma 为关键点所在尺度$）</p>
<script type="math/tex; mode=display">
diameter = 6\sigma +1</script><h3 id="根据关键点主方向变换坐标系"><a href="#根据关键点主方向变换坐标系" class="headerlink" title="根据关键点主方向变换坐标系"></a>根据关键点主方向变换坐标系</h3><p>&emsp;&emsp;将坐标轴旋转至关键点主方向，以确保旋转不变性。旋转后采样点的新坐标为</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
x'\\
y'
\end{bmatrix}
=
\begin{bmatrix}
\cos \theta&-\sin \theta\\
\sin \theta&\cos \theta
\end{bmatrix}
\begin{bmatrix}
x\\
y
\end{bmatrix}
,\quad
 x,y \in [-radius,radius]</script><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/SIFT1.png" style="zoom: 60%;" /></p>
<h3 id="计算关键点描述"><a href="#计算关键点描述" class="headerlink" title="计算关键点描述"></a>计算关键点描述</h3><p>&emsp;&emsp;在局部区域内对每个像素点求其梯度幅值和方向，生成方向直方图。</p>
<p>&emsp;&emsp;梯度幅值高斯（$\sigma$为局部区域大小的一半）加权：离关键点越近，对关键点描述的作用越大。</p>
<p>&emsp;&emsp;基于像素位置和梯度方向的三线性插值：将梯度方向和位置分解再加权。避免梯度方向直方图在分块边界和梯度方向量化的边界处的突然变化。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/SIFT_direction.png" style="zoom:45%;" /></p>
<h3 id="归一化关键点描述"><a href="#归一化关键点描述" class="headerlink" title="归一化关键点描述"></a>归一化关键点描述</h3><p>&emsp;&emsp;向量归一化：克服光照的影响，主要是增益的影响。</p>
<p>&emsp;&emsp;方向直方图每个方向上梯度幅值限制在一定门限值以下（门限一般取0.2，像素灰度值在0~1范围内）：克服相机饱和、光照对3D表面不同方位影响不同等非线性光照情形。</p>
<h1 id="SIFT算子——应用"><a href="#SIFT算子——应用" class="headerlink" title="SIFT算子——应用"></a>SIFT算子——应用</h1><ul>
<li>关键点匹配</li>
<li>场景匹配</li>
<li>全景拼接</li>
<li>图像检索</li>
<li>笔迹鉴定</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.cs.ubc.ca/~lowe/papers/ijcv04.pdf" target="_blank" rel="noopener">Paper: Distinctive Image Features from Scale-Invariant Keypoints</a></li>
<li><a href="https://senitco.github.io/2017/06/24/image-feature-sift/" target="_blank" rel="noopener">图像特征之SIFT特征匹配</a></li>
<li><a href="https://blog.csdn.net/zddblog/article/details/7521424" target="_blank" rel="noopener">SIFT算法详解</a></li>
<li><a href="https://blog.csdn.net/abcjennifer/article/details/7639681" target="_blank" rel="noopener">SIFT特征提取分析</a></li>
<li><a href="https://www.jianshu.com/p/03449c6b42c4" target="_blank" rel="noopener">SIFT特征提取</a></li>
<li><a href="https://blog.csdn.net/dcrmg/article/details/52561656" target="_blank" rel="noopener">Sift中尺度空间、高斯金字塔、差分金字塔（DOG金字塔）、图像金字塔</a></li>
</ol>
]]></content>
      <categories>
        <category>Computer Vision</category>
      </categories>
      <tags>
        <tag>特征描述</tag>
        <tag>SIFT算子</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能概述</title>
    <url>/2020/07/07/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>《人工智能及其应用》第一章绪论笔记总结。</p>
<a id="more"></a>
<h1 id="人工智能的定义与发展"><a href="#人工智能的定义与发展" class="headerlink" title="人工智能的定义与发展"></a>人工智能的定义与发展</h1><h2 id="人工智能的定义"><a href="#人工智能的定义" class="headerlink" title="人工智能的定义"></a>人工智能的定义</h2><p>&emsp;&emsp;人工智能的几种定义：</p>
<ul>
<li><strong>智能</strong><ul>
<li>人的智能是人类理解和学习事物的能力，或者说，智能是思考和理解的能力而不是本能做事的能力。</li>
<li>智能是一种应用知识处理环境的能力或由目标准则衡量的抽象思考能力。</li>
</ul>
</li>
<li><strong>智能机器</strong><ul>
<li>一种能够呈现出人类智能行为的机器，而这种智能行为是人类用大脑思考问题或创造思想。</li>
<li>是一种能够在不确定环境中执行各种拟人任务达到预期目标的机器。</li>
</ul>
</li>
<li><strong>人工智能（学科）</strong></li>
</ul>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>systemd</title>
    <url>/2024/10/05/systemd/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>systemd 是 Linux 的系统和服务管理器。作为系统启动的第一个进程，初始化系统并且管理其他用户服务。</p>
<a id="more"></a>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>systemd 提供了一套完整的系统启动和管理的解决方案，其中的 <code>d</code> 为守护进程（daemon）的缩写，即系统的守护进程。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/bg2016030703.png" alt="systemd架构图"></p>
<p>查看 systemd 简介</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">man systemd</span><br></pre></td></tr></table></figure>
<p>systemd 作为系统的第一个进程，PID = 1，其余所有进程都是 systemd 的子进程。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># pstree -p</span></span><br><span class="line">systemd(<span class="number">1</span>)─┬─ModemManager(<span class="number">855</span>)─┬─&#123;ModemManager&#125;(<span class="number">887</span>)</span><br><span class="line">           │                   └─&#123;ModemManager&#125;(<span class="number">894</span>)</span><br><span class="line">           ├─NetworkManager(<span class="number">777</span>)─┬─&#123;NetworkManager&#125;(<span class="number">854</span>)</span><br><span class="line">           │                     └─&#123;NetworkManager&#125;(<span class="number">859</span>)</span><br><span class="line">           ├─VGAuthService(<span class="number">747</span>)</span><br><span class="line">           ├─accounts<span class="literal">-daemon</span>(<span class="number">766</span>)─┬─&#123;accounts<span class="literal">-daemon</span>&#125;(<span class="number">778</span>)</span><br><span class="line">           │                      └─&#123;accounts<span class="literal">-daemon</span>&#125;(<span class="number">811</span>)</span><br><span class="line">           ├─acpid(<span class="number">767</span>)</span><br><span class="line">           ├─avahi<span class="literal">-daemon</span>(<span class="number">770</span>)───avahi<span class="literal">-daemon</span>(<span class="number">840</span>)</span><br><span class="line">           ├─bluetoothd(<span class="number">771</span>)</span><br><span class="line">           ├─colord(<span class="number">1484</span>)─┬─&#123;colord&#125;(<span class="number">1486</span>)</span><br><span class="line">           │              └─&#123;colord&#125;(<span class="number">1488</span>)</span><br><span class="line">           ├─cron(<span class="number">773</span>)</span><br><span class="line">        .....</span><br></pre></td></tr></table></figure>
<h1 id="Unit"><a href="#Unit" class="headerlink" title="Unit"></a>Unit</h1><p>systemd 可以管理所有系统资源，unit 为 systemd 的基本管理单元，用于描述系统服务、资源、设备和其他对象，根据不同资源分为了 12 种 Unit。</p>
<ul>
<li>Service unit：系统服务</li>
<li>Target unit：多个 Unit 构成的一个组</li>
<li>Device Unit：硬件设备</li>
<li>Mount Unit：文件系统的挂载点</li>
<li>Automount Unit：自动挂载点</li>
<li>Path Unit：文件或路径</li>
<li>Scope Unit：不是由 Systemd 启动的外部进程</li>
<li>Slice Unit：进程组</li>
<li>Snapshot Unit：Systemd 快照，可以切回某个快照</li>
<li>Socket Unit：进程间通信的 socket</li>
<li>Swap Unit：swap 文件</li>
<li>Timer Unit：定时器</li>
</ul>
<p>可通过 <code>man systemd.service</code> 查看各种 Unit 的简介。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>每个 Unit 需设置对应类型的配置文件。Unit 配置分为三个区块：Unit、Service\Timer\Socket、Install</p>
<h3 id="Unit-区块"><a href="#Unit-区块" class="headerlink" title="Unit 区块"></a>Unit 区块</h3><p>Unit 的元数据，定义了 unit 的基本信息、依赖关系和启动顺序。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=服务或单元的描述</span><br><span class="line"><span class="attr">Documentation</span>=man:your-man-page(<span class="number">1</span>)  <span class="comment"># 可选，文档链接</span></span><br><span class="line"><span class="attr">Requires</span>=其他-unit.service  <span class="comment"># 可选，定义强依赖</span></span><br><span class="line"><span class="attr">Wants</span>=其他-unit.service  <span class="comment"># 可选，定义弱依赖</span></span><br><span class="line"><span class="attr">After</span>=network.target  <span class="comment"># 可选，指定启动顺序</span></span><br><span class="line"><span class="attr">Before</span>=其他-unit.service  <span class="comment"># 可选，指定启动顺序</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>Description</code>：简短描述</li>
<li><code>Documentation</code>：文档地址，可以是手册页或 URL</li>
</ul>
<p><strong>依赖关系</strong></p>
<p>例如：unit-A Requires/BindsTo/Wants/PartOf=unit-B.service</p>
<ul>
<li><code>Requires</code>：<ul>
<li>强依赖</li>
<li>unit-A 启动时，自动启动被依赖 unit-B，如果被依赖 unit-B 启动失败，则该 unit-A 也会启动失败</li>
</ul>
</li>
<li><code>BindsTo</code>：<ul>
<li>强依赖</li>
<li>unit-A 启动时，自动启动被依赖 unit-B，如果被依赖 unit-B 启动失败，则该 unit-A 也会启动失败</li>
<li>unit-B 停止或者失败时，依赖 unit-B 的 unit-A 也会自动停止 </li>
</ul>
</li>
<li><code>Wants</code>：<ul>
<li>弱依赖</li>
<li>unit-A 启动时，自动启动被依赖 unit-B，但被依赖 unit-B 启动失败，也不会一些该 unit-A 启动</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>特性</th>
<th><code>Requires</code></th>
<th><code>BindsTo</code></th>
<th><code>Wants</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>启动行为</td>
<td>必须成功启动被依赖的 unit</td>
<td>必须成功启动被依赖的 unit</td>
<td>建议启动被依赖的 unit</td>
</tr>
<tr>
<td>停止行为</td>
<td>不会自动停止依赖它的 unit</td>
<td>自动停止依赖它的 unit</td>
<td>不会自动停止依赖它的 unit</td>
</tr>
<tr>
<td>依赖关系类型</td>
<td>单向强依赖</td>
<td>双向强依赖</td>
<td>弱依赖</td>
</tr>
<tr>
<td>适用场景</td>
<td>功能密切相关但生命周期不必一致的服务</td>
<td>需要同时运行并在同一生命周期内运行的服务</td>
<td>可能相互关联但非必需的服务</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>Conflicts</code>：互斥关系，unit-A 和 unit-B 不能同时运行，当 unit-A 启动时，会自动停止 unit-B，反之亦然</li>
<li><code>PartOf</code>：unit-A 是目标服务 unit-B 的一部分，当目标服务 unit-B 停止或被重启时，作为其一部分的 unit-A 也会停止或重启</li>
</ul>
<p><strong>启动顺序</strong></p>
<p>例如：unit-A Before/After=unit-B.service</p>
<ul>
<li><code>Before</code>：当前 unit A 应该在指定的 unit B 之前启动（A -&gt; B）</li>
<li><code>After</code>：当前 unit A 应该在指定的 unit B 之后启动（B -&gt; A）</li>
</ul>
<p>顺序配置<code>Before</code>、<code>After</code> 只是设置一起启动时的顺序，A 服务启动时并不会自动启动 B 服务，如需设置自启动，需搭配依赖关系使用。</p>
<p><strong>其他关系</strong></p>
<ul>
<li><code>Condition...</code>：检查服务启动时的条件，如果条件不满足，服务将不会被启动，但不会导致启动失败<ul>
<li><code>ConditionPathExists=</code>：检查指定的文件或路径是否存在。如果路径存在，服务将启动</li>
<li><code>ConditionPathExistsGlob=</code>：使用通配符检查路径是否匹配</li>
<li><code>ConditionPathIsDirectory=</code>：检查指定路径是否是一个目录</li>
<li><code>ConditionPathIsSymbolicLink=</code>：检查指定路径是否是一个符号链接</li>
<li><code>ConditionKernelCommandLine=</code>：检查内核命令行参数是否包含指定的字符串</li>
<li><code>ConditionVirtualization=</code>：检查当前系统是否运行在虚拟化环境中（如 KVM、LXC 等）</li>
<li><code>ConditionHost=</code>：检查主机名是否与指定值匹配</li>
</ul>
</li>
<li><code>Assert...</code>：对服务启动的条件进行强制检查。与 <code>Condition</code> 不同，如果指定的条件未满足，服务将不会启动，且系统会报告错误<ul>
<li><code>AssertPathExists=</code>：检查指定路径是否存在</li>
<li><code>AssertPathIsDirectory=</code>：检查指定路径是否是目录</li>
<li><code>AssertPathIsSymbolicLink=</code>：检查指定路径是否是符号链接</li>
<li><code>AssertKernelCommandLine=</code>：检查内核命令行参数</li>
<li><code>AssertVirtualization=</code>：检查当前系统是否在虚拟化环境中</li>
</ul>
</li>
</ul>
<h3 id="类型区块"><a href="#类型区块" class="headerlink" title="类型区块"></a>类型区块</h3><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p><code>systemd.service</code> 是用于定义和管理系统服务的单位类型。</p>
<p>配置文件以 <code>.service</code> 结尾，主要用于描述如何启动、停止和管理服务。</p>
<p><code>.service</code> 配置中，通过 [Service] 区块定义服务的启动和运行参数。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=notify</span><br><span class="line"><span class="attr">EnvironmentFile</span>=-/etc/default/ssh</span><br><span class="line"><span class="attr">ExecStartPre</span>=/usr/sbin/sshd -t</span><br><span class="line"><span class="attr">ExecStart</span>=/usr/sbin/sshd -D <span class="variable">$SSHD_OPTS</span></span><br><span class="line"><span class="attr">ExecReload</span>=/usr/sbin/sshd -t</span><br><span class="line"><span class="attr">ExecReload</span>=/bin/kill -HUP <span class="variable">$MAINPID</span></span><br><span class="line"><span class="attr">KillMode</span>=process</span><br><span class="line"><span class="attr">Restart</span>=<span class="literal">on</span>-failure</span><br><span class="line"><span class="attr">RestartPreventExitStatus</span>=<span class="number">255</span></span><br><span class="line"><span class="attr">RuntimeDirectory</span>=sshd</span><br><span class="line"><span class="attr">RuntimeDirectoryMode</span>=<span class="number">0755</span></span><br></pre></td></tr></table></figure>
<p><strong>启动类型</strong></p>
<ul>
<li><code>Type</code>：配置服务如何通知systemd服务启动完成<ul>
<li><code>simple</code>（默认值）：systemd 调用完 <code>ExecStart</code> 后即认为服务启动成功，即使 <code>ExecStart</code> 运行失败，服务也启动成功</li>
<li><code>notify</code>：启动时，服务通过 <code>sd_notify()</code> 发送一个 “READY=1” 信号，systemd 收到这个信号后才认为服务启动成功，再启动之后的 unit</li>
<li><code>dbus</code>：需设置 <code>BusName=</code>（如设置，自动为 dbus 类型），当 systemd 确认 <code>BusName=</code> 的 dbus 存在后，则认为服务启动成功</li>
<li>等等</li>
</ul>
</li>
</ul>
<p><strong>启动命令</strong></p>
<ul>
<li><p><code>EnvironmentFile</code>：启动时会加载这个配置的环境变量文件</p>
</li>
<li><p><code>ExecStartPre</code>：启动服务之前执行的命令</p>
<ul>
<li><p>如果 <code>ExecStartPre</code> 执行失败，则服务启动失败，不会执行 <code>ExecStart</code></p>
</li>
<li><p>如果希望 <code>ExecStartPre</code> 执行失败也能继续执行 <code>ExecStart</code>，需在 <code>ExecStartPre</code> 加前缀 <code>-</code></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">ExecStartPre</span>=-/usr/bin/check_dependencies</span><br></pre></td></tr></table></figure>
</li>
<li><p>支持多个 <code>ExecStartPre</code>，按顺序执行</p>
</li>
</ul>
</li>
<li><p><code>ExecStart</code>（必选）：启动服务执行的命令</p>
</li>
<li><p><code>ExecStartPost</code>：启动服务成功之后执行的命令</p>
<ul>
<li>如果 <code>Type</code> 规定的启动没成功，则不会执行 <code>ExecStartPost</code></li>
</ul>
</li>
</ul>
<p><strong>终止类型</strong></p>
<ul>
<li><code>KillMode</code>：停止服务时如何处理进程<ul>
<li><code>control-group</code>（默认值）：停止服务时，所有属于该服务 cgroup 的所有进程都会被杀死</li>
<li><code>process</code>：停止服务时，只杀主进程，主进程产生的子进程不会被杀死</li>
<li><code>mixed</code>：停止服务时，向主进程发送 SIGTERM 信号，接着向子进程发送 SIGKILL 信号</li>
<li><code>none</code>：没有进程会被杀掉，只是执行服务的 <code>ExecStop</code> 命令</li>
</ul>
</li>
</ul>
<blockquote>
<p>杀进程过程：</p>
<ol>
<li>向进程发送<code>KillSignal=</code> 信号（默认为 <code>SIGTERM</code>）</li>
<li>等待进程被杀死</li>
<li>若等候 <code>TimeoutStopSec=</code> 时间（默认 90s）后，进程仍然未被杀死，向进程发送 <code>FinalKillSignal=</code> 信号（默认为 <code>SIGKILL</code>）强制杀死进程</li>
</ol>
</blockquote>
<p><strong>终止命令</strong></p>
<ul>
<li><code>ExecStop</code>字段：停止服务时执行的命令</li>
<li><code>ExecStopPost</code>字段：停止服务之后执行的命令</li>
</ul>
<p><strong>重启类型</strong></p>
<p>有时候，服务需要保持运行状态，如有意外奔溃，能自动拉起，可通过下面配置设置自拉起</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Restart&#x3D;always</span><br><span class="line">RestartSec&#x3D;5</span><br><span class="line">StartLimitInterval&#x3D;0</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Restart</code>：重启机制，什么情况下会自动触发重启服务（systemctl stop/restart 触发的停止服务，不会被这里设置的重启机制拉起）<ul>
<li>no（默认值）：退出后不会重启</li>
<li>always：所有情况触发自动重启</li>
<li>on-success：只有正常退出时触发自动重启</li>
<li>on-failure：异常退出时触发自动重启</li>
<li>on-abnormal：只有被信号终止和超时，才会重启</li>
<li>on-abort：只有在收到没有捕捉到的信号终止时，才会重启</li>
<li>on-watchdog：超时退出，才会重启</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>退出原因</th>
<th>no</th>
<th>always</th>
<th>on-success</th>
<th>on-failure</th>
<th>on-abnormal</th>
<th>on-abort</th>
<th>on-watchdog</th>
</tr>
</thead>
<tbody>
<tr>
<td>systemctl stop</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>正常退出</td>
<td></td>
<td>restart</td>
<td>restart</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>退出码不为“0”</td>
<td></td>
<td>restart</td>
<td></td>
<td>restart</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>进程被强制杀死</td>
<td></td>
<td>restart</td>
<td></td>
<td>restart</td>
<td>restart</td>
<td>restart</td>
<td></td>
</tr>
<tr>
<td>systemd操作超时</td>
<td></td>
<td>restart</td>
<td></td>
<td>restart</td>
<td>restart</td>
<td></td>
<td></td>
</tr>
<tr>
<td>看门狗超时</td>
<td></td>
<td>restart</td>
<td></td>
<td>restart</td>
<td>restart</td>
<td></td>
<td>restart</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<ul>
<li>正常退出：退出码为”0”， 或者进程收到 <code>SIGHUP</code>, <code>SIGINT</code>, <code>SIGTERM</code>, <code>SIGPIPE</code> 信号之一，并且退出码符合 <code>SuccessExitStatus=</code> 的设置</li>
<li>异常退出：包括退出码不为“0”、进程被强制杀死、systemd操作超时、看门狗超时</li>
</ul>
</blockquote>
<ul>
<li><code>RestartSec</code>：配合 <code>Restart</code> 使用，重新启动服务之前的睡眠时间，设置如异常退出后，等待多少秒再次启动，默认 100ms</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                     |----RestartSec------|</span><br><span class="line">---------|-----------|--------------------|------------|----------</span><br><span class="line"> running    stopping    stopped             starting     running</span><br></pre></td></tr></table></figure>
<ul>
<li><code>StartLimitInterval</code>、<code>StartLimitBurst</code>：重启限制次数，在 <code>StartLimitBurst=</code> 时间内尝试重启超过 <code>StartLimitInterval=</code> 次则不再重启，默认为 10s 内 5 次，如需无限制，则设置 <code>StartLimitInterval=0</code></li>
</ul>
<p><strong>重启命令</strong></p>
<ul>
<li><code>ExecReload</code>字段：重启服务时执行的命令</li>
</ul>
<h3 id="Install-区块"><a href="#Install-区块" class="headerlink" title="Install 区块"></a>Install 区块</h3><p>定义服务单元的安装和启用选项，指定如何将服务单元与目标（如启动目标或其他服务）关联。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>WantedBy</code>：定义服务应该被哪些目标“需要”，这意味着在这些目标启动时，该服务也会被自动启动</p>
<ul>
<li><p>示例说明服务所在 target 是 multi-user.target，这个设置很通用且重要</p>
</li>
<li><p>在 enable 这个服务后，在 <code>/etc/systemd/system/multi-user.target.wants/</code> 的指定目录中创建了一个指向 <code>/usr/lib/systemd/system/XXX.service</code> 的符号链接</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># systemctl enable nginx</span></span><br><span class="line">Created symlink /etc/systemd/system/multi<span class="literal">-user</span>.target.wants/nginx.service → /usr/lib/systemd/system/nginx.service.</span><br></pre></td></tr></table></figure>
</li>
<li><p>相当于为 <code>multi-user.target</code> 添加了 <code>Wants=nginx</code> 配置</p>
</li>
<li><p>当系统启动时, <code>multi-user.target</code> 启动，<code>nginx.service</code> 单元也会被启动</p>
</li>
</ul>
</li>
<li><p><code>RequiredBy</code>：类似于 <code>WantedBy</code>，但表示更强的依赖关系，如果目标启动失败，相关服务也不会启动</p>
</li>
<li><p><code>Alias</code>：当前 Unit 的别名</p>
</li>
<li><p><code>Also</code>：当前 Unit 启用（enable）或禁用（disable）时，会被同时（enable）或禁用（disable）的其他 Unit</p>
</li>
</ul>
<h2 id="配置路径"><a href="#配置路径" class="headerlink" title="配置路径"></a>配置路径</h2><p>配置文件存放在下面地址：</p>
<ul>
<li>系统级目录：<code>/lib/systemd/system/</code><ul>
<li>Linux 系统提供的默认 unit 配置文件的存放位置</li>
</ul>
</li>
<li>用户级目录：<code>~/.config/systemd/user/</code><ul>
<li>用户级的 unit 配置文件，允许普通用户定义和管理自己的服务和任务。</li>
</ul>
</li>
<li>本地配置目录：<code>/etc/systemd/system/</code><ul>
<li>本地的 unit 配置文件，用户可以在这里创建或修改 unit 文件。</li>
</ul>
</li>
</ul>
<p>优先级顺序：</p>
<ol>
<li><code>/etc/systemd/system/</code>（本地配置目录，最高优先级）</li>
<li><code>/run/systemd/system/</code>（临时配置，通常在运行时创建）</li>
<li><code>/lib/systemd/system/</code>（默认系统提供的配置）</li>
</ol>
<p>优先级从高到低，如在高低优先级的目录下有同名 unit，则采用高优先级中的配置。</p>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p>systemd 由一组系统命令组成，用来控制系统的方方面面。</p>
<h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h2><p>参考链接：<a href="https://manpages.ubuntu.com/manpages/focal/zh_CN/man1/systemctl.1.html" target="_blank" rel="noopener">manpages</a>、<code>man systemctl</code></p>
<p><code>systemctl</code> 是 systemd 的主命令，用于控制 systemd 系统与服务。</p>
<ul>
<li>命令格式：<code>systemctl [OPTIONS...] COMMAND [UNIT...]</code></li>
</ul>
<h3 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出 systemd 所有单位</span></span><br><span class="line">systemctl list<span class="literal">-units</span></span><br><span class="line"><span class="comment"># 通过 --type= 筛选出 unit 类型</span></span><br><span class="line">systemctl list<span class="literal">-units</span> -<span class="literal">-type</span>=service</span><br><span class="line"><span class="comment"># 通过 --state= 筛选出 unit 类型</span></span><br><span class="line">systemctl list<span class="literal">-units</span> -<span class="literal">-state</span>=running</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出 systemd 所有单元和状态</span></span><br><span class="line">systemctl list<span class="literal">-unit</span><span class="literal">-files</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出已加载的套接字(socket)单元</span></span><br><span class="line">systemctl list<span class="literal">-sockets</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出已加载的定时器(timer)单元</span></span><br><span class="line">systemctl list<span class="literal">-timers</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载服务配置</span></span><br><span class="line">systemctl daemon<span class="literal">-reload</span></span><br></pre></td></tr></table></figure>
<h3 id="单-Unit-命令"><a href="#单-Unit-命令" class="headerlink" title="单 Unit 命令"></a>单 Unit 命令</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看服务状态</span></span><br><span class="line">systemctl status [<span class="type">SERVICE</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">systemctl start [<span class="type">SERVICE</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止服务</span></span><br><span class="line">systemctl stop [<span class="type">SERVICE</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">systemctl restart [<span class="type">SERVICE</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自启动服务</span></span><br><span class="line">systemctl enable [<span class="type">SERVICE</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机不自启动服务</span></span><br><span class="line">systemctl disable [<span class="type">SERVICE</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示服务信息</span></span><br><span class="line">systemctl show [<span class="type">SERVICE</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读服务配置文件，等同于 cat 配置文件地址</span></span><br><span class="line">systemctl cat [<span class="type">SERVICE</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑服务配置文件，相比直接 vim，编辑后可自动检查格式</span></span><br><span class="line">systemctl edit [<span class="type">SERVICE</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定 unit 的依赖关系</span></span><br><span class="line">systemctl list<span class="literal">-dependencies</span> [<span class="type">UNIT</span>]</span><br></pre></td></tr></table></figure>
<h2 id="journalctl"><a href="#journalctl" class="headerlink" title="journalctl"></a>journalctl</h2><p>参考链接：<a href="https://manpages.ubuntu.com/manpages/oracular/zh_CN/man1/journalctl.1.html" target="_blank" rel="noopener">manpages</a>、<code>man journalctl</code></p>
<p><code>journalctl</code> 用来查看 systemd 日志，包括系统日志还有各 unit 日志。</p>
<ul>
<li>服务：systemd-journald.service</li>
<li>命令格式：<code>journalctl [OPTIONS...] [MATCHES...]</code></li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有日志（默认情况下 ，只保存本次启动的日志）</span></span><br><span class="line">journalctl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示尾部指定行数的日志</span></span><br><span class="line">journalctl <span class="literal">-n</span> <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时滚动显示最新日志</span></span><br><span class="line">journalctl <span class="operator">-f</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内核日志（不显示应用日志）</span></span><br><span class="line">journalctl <span class="literal">-k</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统本次启动的日志</span></span><br><span class="line">journalctl <span class="literal">-b</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看上一次启动的日志</span></span><br><span class="line">journalctl <span class="literal">-b</span> <span class="literal">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定时间的日志</span></span><br><span class="line">journalctl -<span class="literal">-since</span>=<span class="string">"2012-10-30 18:17:16"</span></span><br><span class="line">journalctl -<span class="literal">-since</span> <span class="string">"20 min ago"</span></span><br><span class="line">journalctl -<span class="literal">-since</span> yesterday</span><br><span class="line">journalctl -<span class="literal">-since</span> <span class="string">"2015-01-10"</span> -<span class="literal">-until</span> <span class="string">"2015-01-11 03:00"</span></span><br><span class="line">journalctl -<span class="literal">-since</span> <span class="number">09</span>:<span class="number">00</span> -<span class="literal">-until</span> <span class="string">"1 hour ago"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定服务的日志</span></span><br><span class="line">journalctl /usr/lib/systemd/systemd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个 Unit 的日志</span></span><br><span class="line">journalctl <span class="literal">-u</span> nginx.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并显示多个 Unit 的日志</span></span><br><span class="line">journalctl <span class="literal">-u</span> nginx.service <span class="literal">-u</span> php<span class="literal">-fpm</span>.service -<span class="literal">-since</span> today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定进程的日志</span></span><br><span class="line">journalctl _PID=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个路径的脚本的日志</span></span><br><span class="line">journalctl /usr/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定用户的日志</span></span><br><span class="line">journalctl _UID=<span class="number">33</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定优先级（及其以上级别）的日志，共有8级</span></span><br><span class="line"><span class="comment"># 0: emerg</span></span><br><span class="line"><span class="comment"># 1: alert</span></span><br><span class="line"><span class="comment"># 2: crit</span></span><br><span class="line"><span class="comment"># 3: err</span></span><br><span class="line"><span class="comment"># 4: warning</span></span><br><span class="line"><span class="comment"># 5: notice</span></span><br><span class="line"><span class="comment"># 6: info</span></span><br><span class="line"><span class="comment"># 7: debug</span></span><br><span class="line">journalctl <span class="literal">-p</span> err <span class="literal">-b</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志默认分页输出，--no-pager 改为正常的标准输出</span></span><br><span class="line">journalctl -<span class="literal">-no</span><span class="literal">-pager</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 JSON 格式（单行）输出</span></span><br><span class="line">journalctl <span class="literal">-b</span> <span class="literal">-u</span> nginx.service <span class="literal">-o</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 JSON 格式（多行）输出，可读性更好</span></span><br><span class="line">journalctl <span class="literal">-b</span> <span class="literal">-u</span> nginx.service <span class="literal">-o</span> json<span class="literal">-pretty</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示日志占据的硬盘空间</span></span><br><span class="line">journalctl -<span class="literal">-disk</span><span class="literal">-usage</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志文件占据的最大空间</span></span><br><span class="line">journalctl -<span class="literal">-vacuum</span><span class="literal">-size</span>=<span class="number">1</span>G</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志文件保存多久</span></span><br><span class="line">journalctl -<span class="literal">-vacuum</span><span class="literal">-time</span>=<span class="number">1</span>years</span><br></pre></td></tr></table></figure>
<h2 id="loginctl"><a href="#loginctl" class="headerlink" title="loginctl"></a>loginctl</h2><p>参考链接：<a href="https://manpages.ubuntu.com/manpages/focal/zh_CN/man1/loginctl.1.html" target="_blank" rel="noopener">manpages</a>、<code>man loginctl</code></p>
<p><code>loginctl</code>命令用来控制 systemd 登录管理器（systemd-logind.service）。</p>
<ul>
<li>服务：systemd-logind.service</li>
<li>命令格式：<code>loginctl [OPTIONS...] {COMMAND} [NAME...]</code></li>
</ul>
<p>COMMAND 分为三种类型：用户、会话和席位</p>
<blockquote>
<h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p>用户是操作系统中进行交互和操作的实体。在Linux中，每个用户都有一个唯一的用户名和用户ID（UID）。用户可以是普通用户、超级用户（root）等，拥有不同的权限。</p>
<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>会话是用户与系统之间的交互过程。当用户登录到Linux系统时，会创建一个会话。会话包含用户的环境设置、运行的程序、打开的文件等。一个用户可以同时拥有多个会话，例如在不同的终端或远程登录时。</p>
<h3 id="席位"><a href="#席位" class="headerlink" title="席位"></a>席位</h3><p>席位（TTY或终端）是用户与系统之间交互的接口。在Linux中，每个物理或虚拟终端都被称为一个席位。用户可以通过这些席位输入命令并接收输出。现代Linux系统通常支持多个席位，例如通过虚拟终端（tty）或图形界面（X Window System）。</p>
</blockquote>
<ul>
<li><p><strong>用户命令</strong></p>
<ul>
<li><p>列出当前登录用户 <code>list-users</code></p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># loginctl list-users</span></span><br><span class="line"> UID USER</span><br><span class="line">   <span class="number">0</span> root</span><br><span class="line"><span class="number">1000</span> guoyi</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> users listed.</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示用户状态<code>user-status [USER...]</code></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># loginctl user-status root</span></span><br><span class="line">root (<span class="number">0</span>)</span><br><span class="line">           Since: Sat <span class="number">2024</span><span class="literal">-10</span><span class="literal">-05</span> <span class="number">01</span>:<span class="number">40</span>:<span class="number">47</span> PDT; <span class="number">9</span>h ago</span><br><span class="line">           State: active</span><br><span class="line">        Sessions: <span class="number">321</span> *<span class="number">304</span></span><br><span class="line">          Linger: no</span><br><span class="line">            Unit: user<span class="literal">-0</span>.slice</span><br><span class="line">                  ├─session<span class="literal">-304</span>.scope</span><br><span class="line">                  │ ├─<span class="number">57001</span> sshd: root@pts/<span class="number">1</span></span><br><span class="line">                  │ ├─<span class="number">57094</span> <span class="literal">-bash</span></span><br><span class="line">                  │ ├─<span class="number">58718</span> loginctl user<span class="literal">-status</span> root</span><br><span class="line">                  │ └─<span class="number">58719</span> pager</span><br><span class="line">                  ├─session<span class="literal">-321</span>.scope</span><br><span class="line">                  │ ├─<span class="number">58486</span> sshd: root@pts/<span class="number">2</span></span><br><span class="line">                  │ └─<span class="number">58572</span> <span class="literal">-bash</span></span><br><span class="line">                  └─user@<span class="number">0</span>.service</span><br><span class="line">                    └─init.scope</span><br><span class="line">                      ├─<span class="number">57004</span> /lib/systemd/systemd -<span class="literal">-user</span></span><br><span class="line">                      └─<span class="number">57005</span> (sd<span class="literal">-pam</span>)</span><br><span class="line"></span><br><span class="line">Oct <span class="number">05</span> <span class="number">01</span>:<span class="number">40</span>:<span class="number">48</span> ubuntu systemd[<span class="number">57004</span>]: Condition check resulted <span class="keyword">in</span> Sound System being sk&gt;</span><br><span class="line">Oct <span class="number">05</span> <span class="number">01</span>:<span class="number">40</span>:<span class="number">48</span> ubuntu systemd[<span class="number">57004</span>]: Listening on REST API socket <span class="keyword">for</span> snapd user sessi&gt;</span><br><span class="line">Oct <span class="number">05</span> <span class="number">01</span>:<span class="number">40</span>:<span class="number">48</span> ubuntu systemd[<span class="number">57004</span>]: Listening on D<span class="literal">-Bus</span> User Message Bus Socket.</span><br><span class="line">Oct <span class="number">05</span> <span class="number">01</span>:<span class="number">40</span>:<span class="number">48</span> ubuntu systemd[<span class="number">57004</span>]: Reached target Sockets.</span><br><span class="line">Oct <span class="number">05</span> <span class="number">01</span>:<span class="number">40</span>:<span class="number">48</span> ubuntu systemd[<span class="number">57004</span>]: Reached target Basic System.</span><br><span class="line">Oct <span class="number">05</span> <span class="number">01</span>:<span class="number">40</span>:<span class="number">48</span> ubuntu systemd[<span class="number">57004</span>]: Condition check resulted <span class="keyword">in</span> Sound Service being s</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示用户各属性<code>show-user [USER...]</code>，可以用 <code>--all</code> 选项查看缺省空置，使用 <code>--property=</code> 查看特定属性</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># loginctl show-user root</span></span><br><span class="line">UID=<span class="number">0</span></span><br><span class="line">GID=<span class="number">0</span></span><br><span class="line">Name=root</span><br><span class="line">Timestamp=Sat <span class="number">2024</span><span class="literal">-10</span><span class="literal">-05</span> <span class="number">01</span>:<span class="number">40</span>:<span class="number">47</span> PDT</span><br><span class="line">TimestampMonotonic=<span class="number">574471117888</span></span><br><span class="line">RuntimePath=/run/user/<span class="number">0</span></span><br><span class="line">Service=user@<span class="number">0</span>.service</span><br><span class="line">Slice=user<span class="literal">-0</span>.slice</span><br><span class="line">Display=<span class="number">304</span></span><br><span class="line">State=active</span><br><span class="line">Sessions=<span class="number">321</span> <span class="number">304</span></span><br><span class="line">IdleHint=no</span><br><span class="line">IdleSinceHint=<span class="number">0</span></span><br><span class="line">IdleSinceHintMonotonic=<span class="number">0</span></span><br><span class="line">Linger=no</span><br></pre></td></tr></table></figure>
</li>
<li><p>等等</p>
</li>
</ul>
</li>
<li><p><strong>会话命令</strong></p>
<ul>
<li><p>列出当前所有会话 <code>list-sessions</code></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># loginctl list-sessions</span></span><br><span class="line">SESSION  UID USER  SEAT  TTY</span><br><span class="line">      <span class="number">2</span> <span class="number">1000</span> guoyi seat0 tty2</span><br><span class="line">    <span class="number">304</span>    <span class="number">0</span> root</span><br><span class="line">    <span class="number">321</span>    <span class="number">0</span> root</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> sessions listed.</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示简洁的会话状态信息<code>session-status [ID...]</code></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># loginctl session-status 304</span></span><br><span class="line"><span class="number">304</span> - root (<span class="number">0</span>)</span><br><span class="line">           Since: Sat <span class="number">2024</span><span class="literal">-10</span><span class="literal">-05</span> <span class="number">01</span>:<span class="number">40</span>:<span class="number">47</span> PDT; <span class="number">9</span>h ago</span><br><span class="line">          Leader: <span class="number">57001</span> (sshd)</span><br><span class="line">          Remote: <span class="number">192.168</span>.<span class="number">45.1</span></span><br><span class="line">         Service: sshd; type tty; <span class="class"><span class="keyword">class</span> <span class="title">user</span></span></span><br><span class="line"><span class="class">           <span class="title">State</span>: <span class="title">active</span></span></span><br><span class="line"><span class="class">            <span class="title">Unit</span>: <span class="title">session</span>-304.<span class="title">scope</span></span></span><br><span class="line"><span class="class">                  ├─57001 <span class="title">sshd</span>: <span class="title">root</span>@<span class="title">pts</span>/1</span></span><br><span class="line"><span class="class">                  ├─57094 -<span class="title">bash</span></span></span><br><span class="line"><span class="class">                  ├─58744 <span class="title">loginctl</span> <span class="title">session</span>-<span class="title">status</span> 304</span></span><br><span class="line"><span class="class">                  └─58745 <span class="title">pager</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Oct</span> 05 01:40:48 <span class="title">ubuntu</span> <span class="title">systemd</span>[1]: <span class="title">Started</span> <span class="title">Session</span> 304 <span class="title">of</span> <span class="title">user</span> <span class="title">root</span>.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>显示会话的各项属性值<code>show-session [ID...]</code></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># loginctl show-session 321</span></span><br><span class="line">Id=<span class="number">321</span></span><br><span class="line">User=<span class="number">0</span></span><br><span class="line">Name=root</span><br><span class="line">Timestamp=Sat <span class="number">2024</span><span class="literal">-10</span><span class="literal">-05</span> <span class="number">10</span>:<span class="number">31</span>:<span class="number">06</span> PDT</span><br><span class="line">TimestampMonotonic=<span class="number">606290337700</span></span><br><span class="line">VTNr=<span class="number">0</span></span><br><span class="line">Remote=yes</span><br><span class="line">RemoteHost=<span class="number">192.168</span>.<span class="number">45.1</span></span><br><span class="line">Service=sshd</span><br><span class="line">Scope=session<span class="literal">-321</span>.scope</span><br><span class="line">Leader=<span class="number">58486</span></span><br><span class="line">Audit=<span class="number">321</span></span><br><span class="line">Type=tty</span><br><span class="line"><span class="class"><span class="keyword">Class</span>=<span class="title">user</span></span></span><br><span class="line"><span class="class"><span class="title">Active</span>=<span class="title">yes</span></span></span><br><span class="line"><span class="class"><span class="title">State</span>=<span class="title">active</span></span></span><br><span class="line"><span class="class"><span class="title">IdleHint</span>=<span class="title">no</span></span></span><br><span class="line"><span class="class"><span class="title">IdleSinceHint</span>=0</span></span><br><span class="line"><span class="class"><span class="title">IdleSinceHintMonotonic</span>=0</span></span><br><span class="line"><span class="class"><span class="title">LockedHint</span>=<span class="title">no</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>等等</p>
</li>
</ul>
</li>
<li><p><strong>席位命令</strong></p>
<ul>
<li><p>显示所有可用席位<code>list-seats</code></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># loginctl list-seats</span></span><br><span class="line">SEAT</span><br><span class="line">seat0</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> seats listed.</span><br></pre></td></tr></table></figure>
</li>
<li><p>等等</p>
</li>
</ul>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://systemd.io" target="_blank" rel="noopener">官方文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>systemd</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>命令行执行hexo d后，出现错误ERROR Deployer not found: git</title>
    <url>/2019/12/16/%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%A7%E8%A1%8Chexo-d%E5%90%8E%EF%BC%8C%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AFERROR-Deployer-not-found-git/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>命令行执行hexo d后，出现错误ERROR Deployer not found: git</p>
<p><img src="https://res.cloudinary.com/dh7ramrlh/image/upload/v1576576407/gy/img6_d6qnm6.png" style="zoom:50%;" /></p>
<a id="more"></a>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>命令行在hexo的根目录位置执行 <code>npm install --save hexo-deployer-git</code></p>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title>图像的傅立叶变换</title>
    <url>/2020/04/17/%E5%9B%BE%E5%83%8F%E7%9A%84%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;空域上的图像利于人眼分析，但是对于计算机来说分析困难，所以在很多情况下（比如滤波），需要在频域对图像进行处理。傅立叶变换把信号拆分成不同频率sin的组合，即可将空域的图像化到频域。</p>
<a id="more"></a>
<h1 id="傅立叶变换"><a href="#傅立叶变换" class="headerlink" title="傅立叶变换"></a>傅立叶变换</h1><h2 id="一维傅立叶变换"><a href="#一维傅立叶变换" class="headerlink" title="一维傅立叶变换"></a>一维傅立叶变换</h2><p>&emsp;&emsp;一维傅立叶变换，即任何信号都可以拆分成 $A\sin (wx+\varPhi )$ 的组合。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/7/72/Fourier_transform_time_and_frequency_domains_%28small%29.gif" alt=""></p>
<p><strong>连续的傅立叶变换</strong></p>
<script type="math/tex; mode=display">
H(w)=\int_{-\infty}^{\infty}h(x)e^{-jwx}dx</script><p><strong>离散的傅立叶变换（DFT）</strong></p>
<script type="math/tex; mode=display">
H(k)=\frac 1N\sum\limits_{x=0}^{N-1}h(x)e^{-j\frac{2\pi kx}{N}}\ ,\quad k= -N/2..N/2</script><p><strong>快速傅立叶变换（FFT）时间复杂度</strong>：$N\log N$</p>
<p>&emsp;&emsp;对于每个频率w来说，都有一个$A\sin (wx+\varPhi )$，其中</p>
<p><strong>幅值</strong>（R为H(w)的实部，I为H(w)的虚部）构成频谱图</p>
<script type="math/tex; mode=display">
A=\pm\sqrt{R(w)^2+I(w)^2}</script><p><strong>相位</strong>（R为H(w)的实部，I为H(w)的虚部）构成相位图</p>
<script type="math/tex; mode=display">
\varPhi = \arctan\frac {I(w)}{R(w)}</script><h2 id="二维傅立叶变换"><a href="#二维傅立叶变换" class="headerlink" title="二维傅立叶变换"></a>二维傅立叶变换</h2><p>&emsp;&emsp;图像的傅立叶变换是二维的傅立叶变换。</p>
<p><strong>二维的连续傅立叶变换</strong></p>
<script type="math/tex; mode=display">
F(u,v)=\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}f(x,y)e^{-j(ux+vy)}dxdy</script><p><strong>二维离散的傅立叶变换</strong>（对于$M\times N$的图像）</p>
<script type="math/tex; mode=display">
F(u,v)=\sum\limits_{x=0}^{M-1}\sum\limits_{y=0}^{N-1}f(x,y)e^{-j2\pi (\frac{ux}{M}+\frac{vy}{N})}\ ,\quad u = 0,1,2,···,M-1\ , \quad v = 0,1,2,···,N-1</script><p>&emsp;&emsp;如此图像从$(x,y)$的空域矩阵，变成了$(u,v)$的频域矩阵。（频域矩阵的大小与原空间域矩阵大小相同）</p>
<p><strong>幅值</strong>（R为H(u,v)的实部，I为H(u,v)的虚部）</p>
<script type="math/tex; mode=display">
A=\pm\sqrt{R(u,v)^2+I(u,v)^2}</script><p><strong>相位</strong>（R为H(u,v)的实部，I为H(u,v)的虚部）</p>
<script type="math/tex; mode=display">
\varPhi = \arctan\frac {I(u,v)}{R(u,v)}</script><div class="note info">
            <p>一维傅立叶变换的三角函数系是$sin(wx)$、$cos(wx)$以及常数$1$，二维傅立叶变换的三角函数系是$sin(ux+vy)$、$cos(ux+vy)$和常数$1$。</p>
          </div>
<h1 id="频谱图"><a href="#频谱图" class="headerlink" title="频谱图"></a>频谱图</h1><h2 id="频谱图生成"><a href="#频谱图生成" class="headerlink" title="频谱图生成"></a>频谱图生成</h2><p>图像频谱图生成Matlab代码如下</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">img = imread(<span class="string">'Lenna.jpg'</span>);</span><br><span class="line">img = rgb2gray(img);</span><br><span class="line">img = double(img);</span><br><span class="line">f1 = fft2(img); <span class="comment">% 二维快速傅里叶变换 </span></span><br><span class="line">f2 = fftshift(f1); <span class="comment">% FFT频谱平移</span></span><br><span class="line">magnitude1 = <span class="built_in">log</span>(<span class="number">1</span>+<span class="built_in">abs</span>(f1)); <span class="comment">% （未中心化）频谱对数变换（由于幅度值范围很大，所以要取对数处理）</span></span><br><span class="line">magnitude2 = <span class="built_in">log</span>(<span class="number">1</span>+<span class="built_in">abs</span>(f2)); <span class="comment">% （中心化）</span></span><br><span class="line">imshow(magnitude2,[]),title(<span class="string">'频谱图'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="二维傅里叶变换"><a href="#二维傅里叶变换" class="headerlink" title="二维傅里叶变换"></a>二维傅里叶变换</h3><p>&emsp;&emsp;首先需将图像进行二维傅里叶变换，得到未中心化的频谱图。此时频谱图中间区域是高频，而四个角则是DC低频分量。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/DFT1.jpg" style="zoom:75%;" /></p>
<h3 id="频谱的中心化"><a href="#频谱的中心化" class="headerlink" title="频谱的中心化"></a>频谱的中心化</h3><p>&emsp;&emsp;DFT具有周期性，且频谱图关于原点对称。</p>
<p>&emsp;&emsp;在原图像乘以系数$(-1)^{x+y}$，再进行傅立叶变换，可以得到中心化的频谱图（中间低频、四周高频）。相当于对未中心化的频谱图的四个象限进行对调：1 &lt;—&gt; 3、2 &lt;—&gt; 4</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/DFT_center.png" style="zoom:80%;" /></p>
<p>频谱图进行中心化</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/DFT2.jpg" style="zoom:75%;" /></p>
<p>如此得到最终的频谱图</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/DFT3.jpg" style="zoom:75%;" /></p>
<h2 id="频率分布"><a href="#频率分布" class="headerlink" title="频率分布"></a>频率分布</h2><p>&emsp;&emsp;经过频谱居中后的频谱中，中间最亮的点是最低频率，属于直流分量（DC分量）。越往边外走，频率越高。所以，频谱图中的四个角和X,Y轴的尽头都是高频。</p>
<p>&emsp;&emsp;频谱图的亮度表示对应频率的幅度的大小。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/DFT4.png" style="zoom: 40%;" /></p>
<h2 id="平移和旋转"><a href="#平移和旋转" class="headerlink" title="平移和旋转"></a>平移和旋转</h2><ul>
<li>原图像平移，频谱图不变；</li>
<li>原图像旋转，频谱随着原图像旋转相同的角度。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/DFT5.jpg" style="zoom:75%;" /></p>
<p>Matlab代码</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Isize = <span class="number">512</span>;</span><br><span class="line">Rwidth = <span class="number">50</span>;</span><br><span class="line">Rlength = <span class="number">3</span>*Rwidth;</span><br><span class="line"> </span><br><span class="line">Irect = <span class="built_in">zeros</span>(Isize);</span><br><span class="line">Irect(<span class="built_in">floor</span>((Isize - Rlength)/<span class="number">2</span>) + <span class="number">1</span>:<span class="built_in">floor</span>((Isize - Rlength)/<span class="number">2</span>) + Rlength,...</span><br><span class="line">     (<span class="built_in">floor</span>(Isize - Rwidth)/<span class="number">2</span>) + <span class="number">1</span>:<span class="built_in">floor</span>((Isize - Rwidth)/<span class="number">2</span>) + Rwidth) = <span class="number">1</span>;</span><br><span class="line">Idft = fft2(Irect);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>),imshow(Irect),title(<span class="string">'原图'</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>),imshow(<span class="built_in">log</span>(<span class="built_in">abs</span>(fftshift(Idft))+<span class="number">1</span>),[]),title(<span class="string">'原图的频谱图'</span>);</span><br><span class="line"> </span><br><span class="line">Irect = <span class="built_in">zeros</span>(Isize);</span><br><span class="line">Irect(<span class="built_in">floor</span>((Isize - Rlength)/<span class="number">2</span>) + <span class="number">150</span> + <span class="number">1</span>:<span class="built_in">floor</span>((Isize - Rlength)/<span class="number">2</span>) + <span class="number">150</span> + Rlength,...</span><br><span class="line">     (<span class="built_in">floor</span>(Isize - Rwidth)/<span class="number">2</span>) + <span class="number">1</span> + <span class="number">200</span>:<span class="built_in">floor</span>((Isize - Rwidth)/<span class="number">2</span>) + Rwidth + <span class="number">200</span>) = <span class="number">1</span>;</span><br><span class="line">Idft = fft2(Irect);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>),imshow(Irect),title(<span class="string">'平移'</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>),imshow(<span class="built_in">log</span>(<span class="built_in">abs</span>(fftshift(Idft))+<span class="number">1</span>),[]),title(<span class="string">'平移后的频谱图'</span>);</span><br><span class="line"></span><br><span class="line">Irect = <span class="built_in">zeros</span>(Isize);</span><br><span class="line">Irect(<span class="built_in">floor</span>((Isize - Rlength)/<span class="number">2</span>) + <span class="number">1</span>:<span class="built_in">floor</span>((Isize - Rlength)/<span class="number">2</span>) + Rlength,...</span><br><span class="line">     (<span class="built_in">floor</span>(Isize - Rwidth)/<span class="number">2</span>) + <span class="number">1</span>:<span class="built_in">floor</span>((Isize - Rwidth)/<span class="number">2</span>) + Rwidth) = <span class="number">1</span>;</span><br><span class="line">Irot = imrotate(Irect, <span class="number">45</span>, <span class="string">'crop'</span>, <span class="string">'bilinear'</span>);</span><br><span class="line">Idft = fft2(Irot);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>),imshow(Irot),title(<span class="string">'旋转'</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>),imshow(<span class="built_in">log</span>(<span class="built_in">abs</span>(fftshift(Idft))+<span class="number">1</span>),[]),title(<span class="string">'旋转后的频谱图'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="方向性"><a href="#方向性" class="headerlink" title="方向性"></a>方向性</h2><p>&emsp;&emsp;在二维傅里叶变换中，空间域中横向的周期变化会反应在频谱图中的Y轴上，而空间域中纵向的周期变化会反应在频谱图中的X轴上。空间域中东南方向的周期变化会反应在频谱图中的东北方向，反之亦然。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/DFT6.jpg" style="zoom: 40%;" /></p>
<p>Matlab代码</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Isize = <span class="number">512</span>;</span><br><span class="line"></span><br><span class="line">Irect = <span class="built_in">zeros</span>(Isize);</span><br><span class="line">Irect(<span class="built_in">floor</span>(Isize/<span class="number">2</span>)+<span class="number">1</span>:Isize, <span class="number">1</span>:Isize) = <span class="number">0.1</span>;</span><br><span class="line">Irect(<span class="number">1</span>:<span class="built_in">floor</span>(Isize/<span class="number">2</span>), <span class="number">1</span>:Isize) = <span class="number">1</span>;</span><br><span class="line">Idft = fft2(Irect);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>),imshow(Irect);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>),imshow(<span class="built_in">log</span>(<span class="built_in">abs</span>(fftshift(Idft))+<span class="number">1</span>),[]);</span><br><span class="line"></span><br><span class="line">Irect = <span class="built_in">zeros</span>(Isize);</span><br><span class="line">Irect(<span class="number">1</span>:Isize, <span class="built_in">floor</span>(Isize/<span class="number">2</span>)+<span class="number">1</span>:Isize) = <span class="number">0.1</span>;</span><br><span class="line">Irect(<span class="number">1</span>:Isize, <span class="number">1</span>:<span class="built_in">floor</span>(Isize/<span class="number">2</span>)) = <span class="number">1</span>;</span><br><span class="line">Idft = fft2(Irect);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),imshow(Irect);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>),imshow(<span class="built_in">log</span>(<span class="built_in">abs</span>(fftshift(Idft))+<span class="number">1</span>),[]);</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/daduzimama/article/details/80109139" target="_blank" rel="noopener">图像的傅里叶变换的频谱特征 一（周期性，能量分布，fftshift，交错性）</a></li>
<li><a href="https://blog.csdn.net/daduzimama/article/details/80394596?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1" target="_blank" rel="noopener">图像的傅里叶变换的频谱特征 三（平移，旋转，相位的重要性）</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2" target="_blank" rel="noopener">WiKi 傅立叶变换</a></li>
<li><a href="https://imlogm.github.io/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/image-fft/" target="_blank" rel="noopener">二维图像的傅立叶变换</a></li>
</ol>
]]></content>
      <categories>
        <category>Computer Vision</category>
      </categories>
      <tags>
        <tag>傅立叶变换</tag>
      </tags>
  </entry>
  <entry>
    <title>匈牙利算法</title>
    <url>/2023/01/07/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2023/01/08/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>动态规划（dynamic programming）算法是解决多阶段决策过程最优化问题的一种常用方法，利用动态规划，可以解决很多贪婪算法或分治算活不能解决的。</p>
<p>最核心的思想，就在于拆分子问题，记住过往，减少重复计算。</p>
<a id="more"></a>
<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>一个典型的动态规划问题：</p>
<blockquote>
<p>求序列 <code>nums = [1,5,2,4,3]</code>的最长递增子序列长度。</p>
<p>直观可以看出最长递增子序列有<code>[1,2,4]</code>或<code>[1,2,3]</code>，长度为3。</p>
</blockquote>
<h2 id="暴力枚举-暴力搜索"><a href="#暴力枚举-暴力搜索" class="headerlink" title="暴力枚举/暴力搜索"></a>暴力枚举/暴力搜索</h2><p>首先容易想到的就是暴力枚举/暴力搜索方法。</p>
<p>先利用<strong>递归</strong>分别计算从每个位置出发的子序列，然后取其中长度的最大值。</p>
<p>序列<code>nums = [1,5,2,4,3]</code>，如果从<code>1</code>出发，到<code>5</code>、<code>2</code>、<code>4</code>、<code>3</code>都是递增的，则可得下式（设<em>f(x)</em>为从x出发的最长递增子序列长度）</p>
<script type="math/tex; mode=display">
f(1) = max\{f(5),f(2),f(4),f(3)\}+1</script><p>由此可递归求得，从<code>1</code>出发最长递增子序列长度。</p>
<pre class="mermaid">graph TD
    A((1))
    B((5))
    C((2))
    D((4))
    E((3))
    F((4))
    G((3))


    A-->B;
    A-->C;
    A-->D;
    A-->E;
    C-->F;
    C-->G;</pre>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算从序号i开始的最长递增子序列长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">L</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> max_len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &gt; nums[i]) &#123;</span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len, L(nums, j) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算序列的最长递增子序列长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length_of_LIS</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max_len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        max_len = <span class="built_in">max</span>(max_len, L(nums, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; length_of_LIS(nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：</p>
<p>每个子序列都需要遍历一次，判断是否是递增序列，时间复杂度为$O(2^n)$，每个子序列至多遍历n次，总时间复杂度为$O(n*2^n)$。</p>
<p>时间复杂度为指数级别的算法，以下针对这个问题进行优化。</p>
<h2 id="记忆化搜索-剪枝"><a href="#记忆化搜索-剪枝" class="headerlink" title="记忆化搜索/剪枝"></a>记忆化搜索/剪枝</h2><p>暴力枚举中存在大量重复计算问题，如下图中在<code>2</code>的子树中遍历了<code>4</code>，后面又遍历了一次<code>4</code>，重复计算了两次。</p>
<p>所以可以用一个哈希表记录已计算的“从i开始的最长子序列长度”，用空间换取时间上的缩短。</p>
<pre class="mermaid">graph TD
    A((1))
    B((5))
    C((2))
    D((4))
    E((3))
    F((4))
    G((3))


    A-->B;
    A-->C;
    A-->D;
    A-->E;
    C-->F;
    C-->G;</pre>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用map记录已计算过的 L(i)</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; memo;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算从序号i开始的最长递增子序列长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">L</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果memo中存在 L(i)，则直接返回记录值</span></span><br><span class="line">    <span class="keyword">if</span> (memo.count(i)) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (i == nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> max_len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &gt; nums[i]) &#123;</span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len, L(nums, j) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    memo[i] = max_len; <span class="comment">//添加新记录</span></span><br><span class="line">    <span class="keyword">return</span> max_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算序列的最长递增子序列长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length_of_LIS</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max_len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        max_len = <span class="built_in">max</span>(max_len, L(nums, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; length_of_LIS(nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迭代-非递归的实现"><a href="#迭代-非递归的实现" class="headerlink" title="迭代/非递归的实现"></a>迭代/非递归的实现</h2><p>将上面的方法归纳成非递归的形式。</p>
<p>序列 <code>nums = [1,5,2,4,3]</code></p>
<script type="math/tex; mode=display">
\begin{aligned}
L(0) &= max\{L(1),L(2),L(3),L(4)\}+1 \\
L(1) &= max\{\cancel{L(2)},\cancel{L(3)},\cancel{L(4)}\}+1\\
L(2) &= max\{L(3),L(4)\}+1\\
L(3) &= max\{\cancel{L(4)}\}+1\\
L(4) &= 1
\end{aligned}</script><p>可以看出，只要从后往前依次计算，就可以通过迭代方法计算出所有的$L(i)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算序列的最长递增子序列长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length_of_LIS</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">L</span><span class="params">(nums.<span class="built_in">size</span>(), <span class="number">1</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从倒数第二个开始，从后往前计算L(i)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; L.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[i]) &#123;</span><br><span class="line">                L[i] = <span class="built_in">max</span>(L[i], L[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回L(i)中的最大值</span></span><br><span class="line">    <span class="keyword">int</span> max_length = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l : L) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; max_length) &#123;</span><br><span class="line">            max_length = l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; length_of_LIS(nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度为$O(n^2)$，相比暴力搜索的$O(n*2^n)$，时间大大降低。</p>
<h1 id="动态规划的基本思想和基本概念"><a href="#动态规划的基本思想和基本概念" class="headerlink" title="动态规划的基本思想和基本概念"></a>动态规划的基本思想和基本概念</h1><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><ul>
<li>将待求解的问题分解成若干个子问题，层层分解，直到问题可以直接解决</li>
<li>对于重复出现的子问题，只在第一次遇到的时候进行求解，并将结果保存起来，下次遇到时直接引用答案</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>阶段：把问题分为具有一定次序的若干阶段，即第n个子问题就是第n个阶段。</li>
<li>状态：每个阶段开始时所处的状态，即在求第n个阶段的解时，已求得的第n-1个阶段的解，就是当前的状态。</li>
<li>决策：目前已知第n-1个阶段的状态，可以通过决策，确定下一个阶段的状态</li>
<li>状态转移方程：从第n-1个阶段的状态到第n个阶段的状态的方程</li>
</ul>
<h1 id="动态规划例题"><a href="#动态规划例题" class="headerlink" title="动态规划例题"></a>动态规划例题</h1><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p>求字符串中最长的回文子串，回文子串即左右对称的串，如ABBA、ABCBA。</p>
<h3 id="分析步骤"><a href="#分析步骤" class="headerlink" title="分析步骤"></a>分析步骤</h3><ul>
<li><p>分解问题</p>
<p>  判断某字符串是否为回文串，可以分解为两个子问题：</p>
<ul>
<li><p>去掉头尾两个字符后，剩下的字符串为回文串</p>
</li>
<li><p>头尾两个字符相同</p>
<p>如果满足以上条件，则该字符串为回文串。</p>
</li>
</ul>
</li>
<li><p>初始化</p>
<p>  拆解到最后，如果只剩一个字符，则一定是回文串；如果剩两个字符，两字符相同是回文串。</p>
</li>
<li><p>状态转移方程</p>
<p>  设 $dp[i][j]$ 表示从$i$到$j$的子串是否是回文串。</p>
<script type="math/tex; mode=display">
  dp[i][j]
  =\left\{
      \begin{array}{ll}
          1 & i=j \\
          s[i]==s[j]?1:0 & j-i=1 \\
          s[i]==s[j] \&\& dp[i+1][j-1] & j-i>1
      \end{array}\right.</script></li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>采用迭代的形式，在计算长串的 $dp[i][j]$ 前，必须要已知 $dp[i+1][j-1]$ ，即要保证左下角的状态已求，所以遍历顺序如下，遍历列优先的上三角。</p>
<script type="math/tex; mode=display">
\begin{pmatrix}
1 & 2 & 4 &7\\
* & 3 & 5 &8\\
* & * & 6 &9\\
* & * & * &10\\
\end{pmatrix}</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length_of_LPS</span> <span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(str.length(), <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(str.length(), <span class="literal">false</span>))</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> max_length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dp[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= j; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j - i == <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = str[i] == str[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = (str[i] == str[j]) &amp;&amp; dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; max_length) &#123;</span><br><span class="line">                max_length = j - i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; length_of_LPS(str) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h2><p>一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<ul>
<li><p><code>.</code> 匹配任意单个字符</p>
</li>
<li><p><code>*</code> 匹配零个或多个前面的那一个元素</p>
</li>
</ul>
<p>所谓匹配，是要涵盖整个字符串 <code>s</code> 的，而不是部分字符串。</p>
<p>示例一</p>
<blockquote>
<p>输入：<br>s = “aa”<br>p = “a*”<br>输出：<br>true</p>
<p>解释：因为 <code>*</code> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。</p>
</blockquote>
<p>示例二</p>
<blockquote>
<p>输入：<br>s = “ab”<br>p = “.*”<br>输出：<br>true</p>
<p>解释：<code>.*</code> 表示可匹配零个或多个（<code>*</code>）任意字符（<code>.</code>）。</p>
</blockquote>
<p>提示：</p>
<ul>
<li>1 &lt;= s.length &lt;= 20</li>
<li>1 &lt;= p.length &lt;= 30</li>
<li>s 只包含从 a-z 的小写字母。</li>
<li>p 只包含从 a-z 的小写字母，以及字符 . 和 *。</li>
<li>保证每次出现字符 * 时，前面都匹配到有效的字符</li>
</ul>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>关键在于处理<code>&#39;*&#39;</code>问题，<code>&#39;*&#39;</code>需要搭配前面的一个字符使用。如，</p>
<ul>
<li><p><code>&#39;a*&#39;</code>可以表示0～N个<code>&#39;a&#39;</code>，即<code>&quot;&quot;</code>、<code>&quot;a&quot;</code>、<code>&quot;aa&quot;</code>、<code>&quot;aaa&quot;</code>等</p>
</li>
<li><p><code>&#39;.*&#39;</code>可以表示0～N个<code>&#39;.&#39;</code>，即可以表示任意字符串</p>
</li>
</ul>
<h3 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a>状态定义</h3><p>定义 $dp[i][j]$ 表示<code>s</code>的前<code>i</code>个字符和<code>p</code>的前<code>j</code>个字符是否匹配。</p>
<h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><ul>
<li><p>如 $p[j]$ 为小写字母</p>
<p>  $s[0,i]$ 和 $p[0,j]$ 的匹配问题，可以分解为两个子问题，即 $s[0,i-1]$ 和 $p[0,j-1]$ 匹配，且 $s[i]$ 和 $p[j]$ 相同</p>
<script type="math/tex; mode=display">
  dp[i][j] = dp[i-1][j-1] \& s[i]=p[j]</script></li>
<li><p>如 $p[j]$ 为<code>&#39;.&#39;</code></p>
<p>  只要$s[0,i-1]$ 和 $p[0,j-1]$ 匹配，则$s[0,i]$ 和 $p[0,j]$ 也一定匹配</p>
<script type="math/tex; mode=display">
  dp[i][j] = dp[i-1][j-1]</script></li>
<li><p>如 $p[j]$ 为<code>&#39;*&#39;</code></p>
<p>  需要与前一个字符 $p[j-1]$ 一起计算，可对 $p[j-1]$ 匹配 $k$ 次，如<code>&quot;a*&quot;</code>，</p>
<ul>
<li><p>匹配 $0$ 次 </p>
<p>  <code>s = &quot;bc&quot;</code> <code>p = &quot;bca*&quot;</code></p>
<p>  <code>&quot;a*&quot;</code>匹配 $0$ 次，即<code>&quot;a*&quot;</code>相当于<code>&quot;&quot;</code>，<code>p = &quot;bca*&quot;</code> 化为 <code>&quot;bc&quot;</code></p>
<script type="math/tex; mode=display">
  dp[i][j] = dp[i][j-2]</script></li>
<li><p>匹配 $1$ 次 </p>
<p>  <code>s = &quot;bca&quot;</code> <code>p = &quot;bca*&quot;</code></p>
<p>  <code>&quot;a*&quot;</code>匹配 $1$ 次，即<code>&quot;a*&quot;</code>相当于<code>&quot;a&quot;</code></p>
<p>  如匹配，则$s[0,i]$一个字符为<code>a</code>，且$s[0,i]$去除掉 $1$ 个<code>a</code>后、$p[0,j]$去除掉 <code>&quot;a*&quot;</code>后，查看是否匹配</p>
<script type="math/tex; mode=display">
  dp[i][j] = dp[i-1][j-2] \& s[i] = p[j-1]</script></li>
<li><p>匹配 $k$ 次 </p>
<p>  $s[0,i]$ 和 $p[0,j]$ 的匹配问题，可以分解为</p>
<ul>
<li><p>$s[0,i]$的后 $k$ 个是否都为<code>a</code></p>
</li>
<li><p>$s[0,i]$去除掉 $k$ 个<code>a</code>后、$p[0,j]$去除掉 <code>&quot;a*&quot;</code>后，查看是否匹配</p>
<script type="math/tex; mode=display">
\begin{aligned}
&dp[i][j] = dp[i-k][j-2] \\
\& \\
&s[i-k+1] = s[i-k+2] = ... = s[i] = p[j-1]
\end{aligned}</script></li>
</ul>
<p>即 $p[j]$ 为<code>&#39;*&#39;</code>时，转移矩阵只要匹配 $0、1…k$ 次有一个成立，则$s[0,i]$ 和 $p[0,j]$ 匹配</p>
<script type="math/tex; mode=display">
\begin{aligned}
dp[i][j] = & dp[i][j-2] （匹配0次） \\
or\ & dp[i-1][j-2] \& s[i] = p[j-1] （匹配1次）\\
... \\
or\ & dp[i-k][j-2] \& s[i-k+1,..., i] = p[j-1] （匹配k次）
\end{aligned}</script></li>
<li><p>匹配 $0$ 次，即 <code>s = &quot;bc&quot;</code> <code>p = &quot;bca*&quot;</code></p>
<script type="math/tex; mode=display">
  dp[i][j] = dp[i][j-2]</script></li>
<li><p>匹配 $k$ 次</p>
<p>  需要有一个前提，即 $s[i]$ 等于 $p[j-1]$ </p>
<p>   <code>s = &quot;bcaa&quot;</code> <code>p = &quot;bca*&quot;</code>，如果 $s$ 去掉一个<code>a</code>也匹配，即<code>&quot;bca&quot;</code> <code>&quot;bca*&quot;</code>匹配，则$s[0,i]$ 和 $p[0,j]$ 匹配（如 $p[j-1]=’.’$ ，也相当于 $s[i]=p[j-1]$ 成立）</p>
<script type="math/tex; mode=display">
  dp[i][j] = dp[i-1][j] \& s[i]=p[j-1]</script></li>
</ul>
</li>
</ul>
<p><strong>总状态转移矩阵</strong></p>
<script type="math/tex; mode=display">
dp[i][j]
=\left\{
    \begin{array}{ll}
        dp[i-1][j-1]\ \&\ s[i]=p[j] &p[j]\in[a,z]\\
        dp[i-1][j-1] &  p[j] = \ .\\
        dp[i][j-2]\ or\ \{dp[i-1][j]\ \&\ (s[i]=p[j-1] \ ||\ p[j-1]='.' \}&  p[j] = \ *
    \end{array}\right.</script><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>$s$ 的长度为 m，$p$ 的长度为 n，需要考虑空串的匹配问题，所以状态大小设置为$dp[m+1][n+1]$</p>
<p>要求 $dp[i][j]$ 需先有左上角的 $dp[i-1][j-1]$ 、$dp[i][j-2]$ 、$dp[i-1][j]$ ，所以初始化应先求出左边和上边，即$dp[…][0]$ 、$dp[0][…]$</p>
<ul>
<li><p>两个空串必然匹配，所以 $dp[0][0] = true$</p>
</li>
<li><p>空串<code>p = &quot;&quot;</code>和任意非空<code>s</code>不匹配，即 $dp[1…n][0] = false$</p>
</li>
<li><p>空串<code>s = &quot;&quot;</code>和奇数长度的<code>p</code>不可能匹配，和偶数长度的<code>p</code>可能匹配，如<code>p = &quot;a*b*c*&quot;</code>，所以当 $p[j] = ‘*’$ 时，$dp[0][j] = dp[0][j-2]$ </p>
</li>
</ul>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>(), m = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//默认实现了dp[1...n][0]的初始化</span></span><br><span class="line">        <span class="comment">//dp[0][1...m]的初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= m &amp;&amp; p[j<span class="number">-1</span>] == <span class="string">'*'</span>; j += <span class="number">2</span>) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p[j<span class="number">-1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-2</span>] || ((s[i<span class="number">-1</span>] == p[j<span class="number">-2</span>] || p[j<span class="number">-2</span>] == <span class="string">'.'</span>) &amp;&amp; dp[i<span class="number">-1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="称砝码"><a href="#称砝码" class="headerlink" title="称砝码"></a>称砝码</h2><p>现有n种砝码，重量互不相等，分别为 m1,m2,m3…mn ，每种砝码对应的数量为 x1,x2,x3…xn，问能称出多少种不同的重量。（注：称重重量包括 0）</p>
<ul>
<li><p>输入描述：</p>
<p>  对于每组测试数据：</p>
<p>  第一行：n —- 砝码的种数(范围[1,10])</p>
<p>  第二行：m1 m2 m3 … mn —- 每种砝码的重量(范围[1,2000])</p>
<p>  第三行：x1 x2 x3 …. xn —- 每种砝码对应的数量(范围[1,10])</p>
</li>
<li><p>输出描述：</p>
<p>  利用给定的砝码可以称出的不同的重量数</p>
</li>
</ul>
<p>示例一</p>
<blockquote>
<p>输入：<br>2<br>1 2<br>2 1<br>输出：<br>5 </p>
</blockquote>
<p>示例二</p>
<blockquote>
<p>输入：<br>3<br>10 191 103<br>6 6 5<br>输出：<br>254 </p>
</blockquote>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; memo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">different_sum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (memo.count(v)) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        n += v[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (v[i][<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        s.insert(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i][<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; t = v;</span><br><span class="line">            t[i][<span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j : different_sum(t)) &#123;</span><br><span class="line">                s.insert(j);</span><br><span class="line">                s.insert(j + v[i][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memo[v] = s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">v</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>*n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; v[i][<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= n) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; v[i-n][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; different_sum(v).<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">v</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>*n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; v[i][<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= n) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; v[i-n][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    s.insert(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i][<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i][<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s_copy = s;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j : s_copy) &#123;</span><br><span class="line">                    s.insert(j + v[i][<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                s.insert(v[i][<span class="number">0</span>]);</span><br><span class="line">                v[i][<span class="number">1</span>] --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i][<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序（云开发）</title>
    <url>/2020/02/03/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BA%91%E5%BC%80%E5%8F%91%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>​    微信小程序+云开发的入门讲解。</p>
<a id="more"></a>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="搭建云开发环境"><a href="#搭建云开发环境" class="headerlink" title="搭建云开发环境"></a>搭建云开发环境</h2><ol>
<li><p>新建一个文件夹</p>
</li>
<li><p>在微信开发者工具中新建一个小程序，注册AppID，选择云开发</p>
</li>
<li><p>点击云开发按钮，开通云开发</p>
</li>
<li><p>创建资源环境，并在<code>miniprogram/app.js</code>中配置环境</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//app.js</span></span><br><span class="line">App(&#123;</span><br><span class="line">  onLaunch: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!wx.cloud) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">'请使用 2.2.3 或以上的基础库以使用云能力'</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      wx.cloud.init(&#123;</span><br><span class="line">        <span class="comment">// env 参数说明：</span></span><br><span class="line">        <span class="comment">//   env 参数决定接下来小程序发起的云开发调用（wx.cloud.xxx）会默认请求到哪个云环境的资源</span></span><br><span class="line">        <span class="comment">//   此处请填入环境 ID, 环境 ID 可打开云控制台查看</span></span><br><span class="line">        <span class="comment">//   如不填则使用默认环境（第一个创建的环境）</span></span><br><span class="line">        env: <span class="string">'test-6ga7apra89fe93e5'</span>,</span><br><span class="line">        traceUser: <span class="literal">true</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.globalData = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>云开发环境搭建完成，后续可根据指引浏览小程序。</p>
</li>
</ol>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>云开发小程序一经搭建，就提供一个基础框架。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── cloudfunctions				&#x2F;&#x2F;云函数根目录</span><br><span class="line">│   ├── callback</span><br><span class="line">│   ├── echo</span><br><span class="line">│   ├── login</span><br><span class="line">│   └── openapi</span><br><span class="line">│</span><br><span class="line">├── miniprogram					&#x2F;&#x2F;小程序根目录</span><br><span class="line">│   ├── components					&#x2F;&#x2F;自定义组件目录</span><br><span class="line">│   ├── images						&#x2F;&#x2F;图片目录</span><br><span class="line">│   ├── pages						&#x2F;&#x2F;页面目录</span><br><span class="line">│   ├── style						&#x2F;&#x2F;样式目录</span><br><span class="line">│</span><br><span class="line">│   ├── app.js						&#x2F;&#x2F;小程序逻辑</span><br><span class="line">│   ├── app.json					&#x2F;&#x2F;小程序公共配置</span><br><span class="line">│   ├── app.wxss					&#x2F;&#x2F;小程序公共样式表</span><br><span class="line">│   └── sitemap.json				&#x2F;&#x2F;sitemap配置</span><br><span class="line">│ </span><br><span class="line">└── project.config.json</span><br></pre></td></tr></table></figure>
<h1 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h1><p>用户登录主要是要获取用户的<code>userInfo</code>和<code>openid</code>，流程如下</p>
<div id="flowchart-0" class="flow-chart"></div>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line"></span><br><span class="line">  data: &#123;</span><br><span class="line">    userInfo: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  onLoad() &#123;</span><br><span class="line">    <span class="comment">// 获取本地缓存的userInfo</span></span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      userInfo: wx.getStorageSync(<span class="string">'userInfo'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 授权登录</span></span><br><span class="line">  <span class="comment">// 1.getUserProfile获取userInfo</span></span><br><span class="line">  <span class="comment">// 2.获取userInfo成功，再通过云函数getOpenid获取openid，将openid添加进userInfo中</span></span><br><span class="line">  <span class="comment">// 3.将userInfo加入本地缓存</span></span><br><span class="line">  login()&#123;</span><br><span class="line">    <span class="comment">// 1.获取userInfo</span></span><br><span class="line">    wx.getUserProfile(&#123;</span><br><span class="line">      desc: <span class="string">'用于完善用户资料'</span>, <span class="comment">// 声明获取用户个人信息后的用途，后续会展示在弹窗中，请谨慎填写</span></span><br><span class="line">      success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">          userInfo: res.userInfo</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 2.获取OpenID</span></span><br><span class="line">        wx.cloud.callFunction(&#123;</span><br><span class="line">          name: <span class="string">"getOpenid"</span>,</span><br><span class="line">          success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.data.userInfo.openid = res.result.openid</span><br><span class="line">            <span class="comment">// 3.加入本地缓存</span></span><br><span class="line">            wx.setStorageSync(<span class="string">'userInfo'</span>, <span class="keyword">this</span>.data.userInfo)</span><br><span class="line">          &#125;,</span><br><span class="line">          fail: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">              userInfo: &#123;&#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"获取OpenID登录失败"</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 登出</span></span><br><span class="line">  logout()&#123;</span><br><span class="line">    <span class="comment">// 清空用户信息缓存</span></span><br><span class="line">    wx.removeStorageSync(<span class="string">'userInfo'</span>)</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      userInfo: <span class="literal">null</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: start
op1=>operation: 未登录状态
op2=>operation: 点击授权登录
cond1=>condition: 获取userInfo
(getUserProfile函数)
op3=>operation: 拒绝授权
(未获得userInfo)
op4=>operation: 同意授权
(获得userInfo)
cond2=>condition: 获取openid
(getOpenid云函数)
op5=>operation: openid获取失败
op6=>operation: 清空userInfo
op7=>operation: openid获取成功
op8=>operation: 将userInfo和openid加入本地缓存
op9=>operation: 登录成功
e=>end: end

st->op1->op2->cond1
cond1(no)->op3(right)->op1
cond1(yes)->op4->cond2
cond2(no)->op5->op6(right)->op1
cond2(yes)->op7->op8->op9->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>微信小程序</tag>
        <tag>云开发</tag>
      </tags>
  </entry>
  <entry>
    <title>图像金字塔</title>
    <url>/2020/04/16/%E5%9B%BE%E5%83%8F%E9%87%91%E5%AD%97%E5%A1%94/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>&emsp;&emsp;金字塔是一种图像多尺度信号表示法，其中信号或图像要经过反复的平滑和二次采样。通过对原始图像进行多尺度像素采样的方式，生成N个不同分辨率的图像。把具有最高级别分辨率的图像放在底部，以金字塔形状排列。</p>
<a id="more"></a>
<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>问题：假设要进行人脸识别，但是人脸与摄像头之间距离忽远忽近，单一分辨率的识别算法无法识别所有距离下的人脸特征。</p>
<p>&emsp;&emsp;图像金字塔是一种以多分辨率来解释图像的结构，通过对原始图像进行多尺度像素采样的方式，生成N个不同分辨率的图像。<br>&emsp;&emsp;把具有最高级别分辨率的图像放在底部，以金字塔形状排列，往上是一系列像素（尺寸）逐渐降低的图像，一直到金字塔的顶部只包含一个像素点的图像，这就构成了传统意义上的图像金字塔。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/43/Image_pyramid.svg/600px-Image_pyramid.svg.png" style="zoom: 67%;" /></p>
<p>两种采样方式：</p>
<ul>
<li>升采样：分辨率逐渐升高，图像变大</li>
<li>降采样：分辨率逐渐下降，图像变小</li>
</ul>
<h1 id="降采样"><a href="#降采样" class="headerlink" title="降采样"></a>降采样</h1><p>&emsp;&emsp;降采样使图像分辨率逐渐下降的同时要保证不出现错误（失真）。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/DownSampling.png" style="zoom:30%;" /></p>
<h2 id="奈奎斯特采样定理"><a href="#奈奎斯特采样定理" class="headerlink" title="奈奎斯特采样定理"></a>奈奎斯特采样定理</h2><p>&emsp;&emsp;为了不失真地恢复模拟信号，采样频率应该大于模拟信号频谱中最高频率的2倍。</p>
<script type="math/tex; mode=display">
F_s \geq 2F_{max}</script><p><strong>混叠</strong></p>
<p>&emsp;&emsp;如果不能满足上述采样条件，采样后信号的频率就会重叠，即高于采样频率一半的频率成分将被重建成低于采样频率一半的信号。这种频谱的重叠导致的失真称为<strong>混叠</strong>，而重建出来的信号称为原信号的混叠替身，因为这两个信号有同样的样本值。</p>
<p>&emsp;&emsp;下图对正弦信号的采样未符合奈奎斯特采样定理，恢复模拟信号时失真。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/f/f6/Aliasing-plot.png" alt=""></p>
<p>&emsp;&emsp;如果原信号中包含的最高频率成分$F_{max} &gt; \frac{F_s}{2}$ ，则在离散信号谱中相应周期的谱会出现重叠，最终恢复的模拟信号失真。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Pyramid_Aliasing1.png" style="zoom: 42%;" /></p>
<p>&emsp;&emsp;反之，如果$F_{max} &lt; \frac{F_s}{2}$ ，即采样频率大于分析信号中最高频谱成分的2倍，则采样后离散信号频谱中不会出现频率混叠。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Pyramid_Aliasing2.png" style="zoom: 50%;" /></p>
<p>&emsp;&emsp;一个频率正好是采样频率一半的弦波信号，通常会混叠成另一相同频率的波弦信号，但它的相位和幅度改变了。以下两种措施可避免混叠的发生：</p>
<ol>
<li><strong>提高采样频率</strong>，使之达到最高信号频率的两倍以上；</li>
<li>引入<strong>低通滤波器</strong></li>
</ol>
<p>&emsp;&emsp;高斯金字塔即是引入了<strong>高斯滤波器</strong>作为低通滤波器，从而抑制高频分量，避免混叠导致降采样后的图像失真。</p>
<p>&emsp;&emsp;下图中，上行是未滤波的采样，可以看出后期出现了失真；下行是经过高斯滤波的下采样，后期虽然有数据损失，但是未发生失真。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Pyramid_Aliasing3.png" style="zoom: 40%;" /></p>
<h1 id="高斯金字塔"><a href="#高斯金字塔" class="headerlink" title="高斯金字塔"></a>高斯金字塔</h1><p>&emsp;&emsp;高斯金字塔是通过高斯平滑和亚采样获得<strong>下采样</strong>图像。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Pyramid_Gauss1.png" alt=""></p>
<h2 id="降采样-1"><a href="#降采样-1" class="headerlink" title="降采样"></a>降采样</h2><p>&emsp;&emsp;为了获取层级为$G_{i+1}$的金字塔图像，采用如下方法:</p>
<ol>
<li>对图像$G_i$进行高斯内核卷积</li>
<li>将所有偶数行和列去除</li>
</ol>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Pyramid_Gauss2.png" style="zoom: 25%;" /></p>
<p>得到的图像即为$G_{i+1}$的图像，显而易见，结果图像只有原图像素点数的四分之一。通过对输入图像$G_i$(原始图像)不停迭代以上步骤就会得到整个金字塔。同时，向下取样会逐渐丢失图像的信息。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Pyramid_Gauss3.png" style="zoom:67%;" /></p>
<h2 id="升采样"><a href="#升采样" class="headerlink" title="升采样"></a>升采样</h2><p>&emsp;&emsp;如果想放大图像，则需要通过向上取样操作得到，具体做法如下：</p>
<ol>
<li>将图像在每个方向扩大为原来的两倍，新增的行和列以0填充</li>
<li>使用先前同样的内核(乘以4)与放大后的图像卷积，获得 “新增像素”的近似值</li>
</ol>
<p>（或者用双线性插值：先行求均值插入，再列求均值插入）</p>
<p>得到的图像即为放大后的图像，但是与原来的图像相比比较模糊，因为在缩放的过程中已经丢失了一些信息，如果想在缩小和放大整个过程中减少信息的丢失，这些数据形成了拉普拉斯金字塔。</p>
<p>&emsp;&emsp;下面两图分别是Lenna原图和经过高斯金字塔降采样再升采样后的图像，可以看出处理后的图像丢失了部分信息，所以升采样并不完全是降采样的逆。</p>
<p><img src="https://i.loli.net/2020/04/22/nYSLKVvMImch715.jpg" alt="Lenna.jpg"></p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Lenna_guass_pyramid.png" style="zoom:62%;" /></p>
<h2 id="高斯金字塔C-代码"><a href="#高斯金字塔C-代码" class="headerlink" title="高斯金字塔C++代码"></a>高斯金字塔C++代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/imgproc.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/imgcodecs.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/highgui.hpp"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n Zoom In-Out demo \n "</span></span><br><span class="line">            <span class="string">"------------------  \n"</span></span><br><span class="line">            <span class="string">" * [i] -&gt; Zoom in   \n"</span></span><br><span class="line">            <span class="string">" * [o] -&gt; Zoom out  \n"</span></span><br><span class="line">            <span class="string">" * [ESC] -&gt; Close program \n"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* filename = argc &gt;=<span class="number">2</span> ? argv[<span class="number">1</span>] : <span class="string">"/Users/yogo/Downloads/CV/高斯金字塔/Gaussian pyramid/Gaussian pyramid/Lenna.png"</span>;</span><br><span class="line">    <span class="comment">// Loads an image</span></span><br><span class="line">    Mat src = imread( samples::findFile( filename ) );</span><br><span class="line">    <span class="comment">// Check if image is loaded fine</span></span><br><span class="line">    <span class="keyword">if</span>(src.empty())&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" Error opening image\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" Program Arguments: [image_name -- default chicky_512.png] \n"</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        imwrite(<span class="string">"result3.png"</span>, src);</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span>( c == <span class="number">27</span> )</span><br><span class="line">        &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( c == <span class="string">'i'</span> )</span><br><span class="line">        &#123; pyrUp( src, src, Size( src.cols*<span class="number">2</span>, src.rows*<span class="number">2</span> ) );</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">"** Zoom In: Image x 2 \n"</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( c == <span class="string">'o'</span> )</span><br><span class="line">        &#123; pyrDown( src, src, Size( src.cols/<span class="number">2</span>, src.rows/<span class="number">2</span> ) );</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">"** Zoom Out: Image / 2 \n"</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><h3 id="滤波模版大小问题"><a href="#滤波模版大小问题" class="headerlink" title="滤波模版大小问题"></a>滤波模版大小问题</h3><p>&emsp;&emsp;按高斯分布，理论上需要一个无限大的卷积核。但实际上，仅需要取均值周围3倍标准差内的值（高斯核单边大小为3σ），以外部分直接去掉即可。</p>
<p>&emsp;&emsp;如果模版取得太小，边界后出现高频振荡。</p>
<h3 id="图像边缘问题"><a href="#图像边缘问题" class="headerlink" title="图像边缘问题"></a>图像边缘问题</h3><p>&emsp;&emsp;图像的边缘做卷积时，需要在边缘点周围填充值。</p>
<ul>
<li>clip filter（black）：填0</li>
<li>wrap around：图像周期出现，即把图像平移到边缘</li>
<li>copy edge：边缘复制</li>
<li>reflect across edge：镜像反转</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Pyramid_edge.png" style="zoom:50%;" /></p>
<h1 id="拉普拉斯金字塔"><a href="#拉普拉斯金字塔" class="headerlink" title="拉普拉斯金字塔"></a>拉普拉斯金字塔</h1><p>&emsp;&emsp;拉普拉斯金字塔每一层的图像为同一层高斯金字塔的图像减去上一层的图像进行上采样并高斯模糊的结果。</p>
<script type="math/tex; mode=display">
L_i = G_i-UP(G_{i+1})*g_{5\times 5}</script><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Pyramid_Laplacian.png" style="zoom:67%;" /></p>
<p>&emsp;&emsp;拉普拉斯金字塔即是高斯金字塔每层丢掉的高频部分。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Pyramid_Laplacian2.png" style="zoom: 50%;" /></p>
<h1 id="小波金字塔"><a href="#小波金字塔" class="headerlink" title="小波金字塔"></a>小波金字塔</h1><p>&emsp;&emsp;二维离散小波分解将二维图像分解为多尺度表达， 原图像可以由多尺度小波系数精确重建。</p>
<p>&emsp;&emsp;频域告诉我们场景里有什么东西，空域告诉在什么位置。高频往往对应的是边缘，所以相对于图像的低频成分来说，图像的高频成分的空间定位需求很高，不应该损失空间表达能力。对于低频的部分则要求频域的分辨能力更强。即，<strong>高频要求空域上的高分辨率，低频要求频域上的高分辨率。</strong></p>
<p>&emsp;&emsp;在傅立叶变换上无法做到对高低频不同的分辨能力，而小波分解可以做到。</p>
<h2 id="小波变换"><a href="#小波变换" class="headerlink" title="小波变换"></a>小波变换</h2><p>&emsp;&emsp;小波变换是线性的。</p>
<script type="math/tex; mode=display">
\vec F = U \vec f</script><h3 id="哈尔变换"><a href="#哈尔变换" class="headerlink" title="哈尔变换"></a>哈尔变换</h3><p>&emsp;&emsp;哈尔变换是一种最简单又可以反应出时变频谱（time-variant spectrum）的表示方法。其观念与傅里叶变换相近。傅里叶变换的原理是利用正弦波与余弦波来对信号进行调变；而哈尔变换则是利用哈尔函数来对信号进行调变。哈尔函数也含有正弦函数系和余弦函数系所拥有的正交性，也就是说不同的哈尔函数是互相正交的，其内积为零。</p>
<p>&emsp;&emsp;将信号分解成低频和高频。以$N=2$为例，第一行是做均值，分出低频；第二行是做差值，分出高频。低频部分可以继续分解。（N取决于信号的维数，加权需要归一化）</p>
<script type="math/tex; mode=display">
N=2\ ,\quad 
U=
\begin{bmatrix}
1&1\\
1&-1
\end{bmatrix}
\\
N=4\ ,\quad 
U=
\begin{bmatrix}
1&1&1&1\\
1&1&-1&-1\\
1&-1&0&0\\
0&0&1&-1\\
\end{bmatrix}
\\
.
\\
.
\\
.</script><p>&emsp;&emsp;下面$N=8$的小波，前2行为低频部分（第2行为低频的高频部分），第3、4行为次高频部分，后4行为高频部分。</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
\frac18&\frac18&\frac18&\frac18&\frac18&\frac18&\frac18&\frac18\\
\frac18&\frac18&\frac18&\frac18&-\frac18&-\frac18&-\frac18&-\frac18\\
\frac14&\frac14&-\frac14&-\frac14&0&0&0&0\\
0&0&0&0&\frac14&\frac14&-\frac14&-\frac14\\
\frac12&-\frac12&0&0&0&0&0&0\\
0&0&\frac12&-\frac12&0&0&0&0\\
0&0&0&0&\frac12&-\frac12&0&0\\
0&0&0&0&0&0&\frac12&-\frac12\\
\end{bmatrix}</script><p>哈尔变换特点：</p>
<ol>
<li>不需要乘法（只有相加或加减），容易实现</li>
<li>输入与输出个数相同</li>
</ol>
<div class="note warning">
            <p>对$(64,2,3,61,60,6,7,57)$做Haar小波变换</p><script type="math/tex; mode=display">\begin{bmatrix}\frac18&\frac18&\frac18&\frac18&\frac18&\frac18&\frac18&\frac18\\\frac18&\frac18&\frac18&\frac18&-\frac18&-\frac18&-\frac18&-\frac18\\\frac14&\frac14&-\frac14&-\frac14&0&0&0&0\\0&0&0&0&\frac14&\frac14&-\frac14&-\frac14\\\frac12&-\frac12&0&0&0&0&0&0\\0&0&\frac12&-\frac12&0&0&0&0\\0&0&0&0&\frac12&-\frac12&0&0\\0&0&0&0&0&0&\frac12&-\frac12\\\end{bmatrix}\begin{bmatrix}64\\2\\3\\61\\60\\6\\7\\57\\\end{bmatrix}=\begin{bmatrix}32.5\\0\\0.5\\0.5\\31\\-29\\27\\-25\\\end{bmatrix}</script>
          </div>
<h2 id="哈尔变换-降采样"><a href="#哈尔变换-降采样" class="headerlink" title="哈尔变换+降采样"></a>哈尔变换+降采样</h2><p>例如：一个一维的图像$[2,4,6,8,10,12,14,16]$</p>
<p>求均值（低频）：相邻两个取均值，得$[3,7,11,15]$。这个新的图像分辨率就成了原来的一半(8/2=4)。</p>
<p>求差值（高频）：上面的均值我们存储了图像的整体信息。但是很多细节信息我们丢掉了，所以我们同时要记录图像的细节信息，这样在重构时能够恢复图像的全部信息。下面是求第m个差值的公式：</p>
<script type="math/tex; mode=display">
b_m=\frac {a_{2m}−a_{2m+1}}2</script><p>&emsp;&emsp;经过计算我们得到了结果$[-1,-1,-1,-1]$。这个新的分辨率也成了原来的一半(8/2=4)。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Pyramid_Haar1.png" style="zoom:33%;" /></p>
<h2 id="哈尔小波金字塔"><a href="#哈尔小波金字塔" class="headerlink" title="哈尔小波金字塔"></a>哈尔小波金字塔</h2><p>&emsp;&emsp;小波金字塔，先将图像分为高频和低频，其中的低频成分继续分解。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Pyramid_Haar2.png" style="zoom:50%;" /></p>
<p>每一步分解：先水平分解成高频、低频；</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Pyramid_Haar4.png" style="zoom:30%;" /></p>
<p>在将水平方向的分解的结果继续分解，得到四幅图——水平高垂直高、水平高垂直低、水平低垂直高、水平低垂直低</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Pyramid_Haar5.png" style="zoom:30%;" /></p>
<p>下一步分解：将水平低垂直低的图重复上述分解，即得到小波金字塔。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Pyramid_Haar3.png" style="zoom: 50%;" /></p>
<p>每次分解都是降采样，并且可以用原始图像大小空间表达出全部小波分解结果。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Pyramid_Haar6.png" style="zoom: 50%;" /></p>
<h2 id="小波的优缺点"><a href="#小波的优缺点" class="headerlink" title="小波的优缺点"></a>小波的优缺点</h2><ul>
<li><p>小波的优点</p>
<ul>
<li>不是过完备的，即可以用原始图像大小空间表达出全部小波分解结果。</li>
<li>适合图像压缩，系数比较稀疏</li>
<li>可分层的运算，比较快速</li>
</ul>
</li>
<li><p>小波的缺点</p>
<ul>
<li><p>子带</p>
<p>只做了水平垂直方向，其他方向不理想</p>
</li>
<li><p>空间分配不合理</p>
<p>空域上小的移动，会导致小波分解的系数产生大的差异</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Pyramid_Haar7.png" style="zoom: 50%;" /></p>
</li>
</ul>
</li>
</ul>
<h1 id="可控方向的金字塔"><a href="#可控方向的金字塔" class="headerlink" title="可控方向的金字塔"></a>可控方向的金字塔</h1><p>&emsp;&emsp;设计不同方向的滤波器，将图像分解成不同的滤波结果，这些滤波结果又可以继续抽样划分。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Pyramid_Steerable1.png" style="zoom: 33%;" /></p>
<ul>
<li>可控方向的金字塔的优点<ul>
<li>子带划分时可以做方向的细分</li>
<li>子带的稳定性好，不会产生突变</li>
<li>可以根据需要选择滤波器组</li>
</ul>
</li>
<li>可控方向的金字塔的缺点<ul>
<li>过完备</li>
<li>需要各向同性的滤波器进行补充</li>
</ul>
</li>
</ul>
<h1 id="图像金字塔的作用"><a href="#图像金字塔的作用" class="headerlink" title="图像金字塔的作用"></a>图像金字塔的作用</h1><ul>
<li><p>多尺度</p>
<p>在有不同大小的图像分析时，算法不变，通过金字塔改变尺度</p>
</li>
<li><p>去噪</p>
</li>
<li><p>纹理分析</p>
</li>
<li><p>目标识别</p>
</li>
<li><p>图像拼接</p>
</li>
<li><p>图像融合</p>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://shartoo.github.io/2019/02/24/image-pramid/" target="_blank" rel="noopener">图像中的各种金字塔</a></li>
<li><a href="https://blog.csdn.net/xiamentingtao/article/details/78596240" target="_blank" rel="noopener">图像金字塔总结</a></li>
<li><a href="https://www.uio.no/studier/emner/matnat/its/UNIK4690/v16/forelesninger/lecture_2_3_blending.pdf" target="_blank" rel="noopener">图像金字塔的算法构建图示</a></li>
<li><a href="https://www.cnblogs.com/zhuifeng-mayi/p/9565656.html" target="_blank" rel="noopener">高斯金字塔、拉普拉斯金字塔</a></li>
<li><a href="http://gr.xjtu.edu.cn/c/document_library/get_file?folderId=1826595&amp;name=DLFE-34601.pdf" target="_blank" rel="noopener">图像多分尺度处理技术</a></li>
<li><a href="https://docs.opencv.org/3.4/d4/d1f/tutorial_pyramids.html" target="_blank" rel="noopener">opencv 官方文档</a></li>
<li><a href="https://en.wikipedia.org/wiki/Pyramid_(image_processing" target="_blank" rel="noopener">WiKi百科：金字塔（图像处理）</a>)</li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%99%8D%E9%87%87%E6%A0%B7" target="_blank" rel="noopener">WiKi百科：降采样</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%87%87%E6%A0%B7%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">WiKi百科：采样定理</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%93%88%E7%88%BE%E5%B0%8F%E6%B3%A2%E8%BD%89%E6%8F%9B" target="_blank" rel="noopener">WiKi百科：哈尔小波变换</a></li>
</ol>
]]></content>
      <categories>
        <category>Computer Vision</category>
      </categories>
      <tags>
        <tag>高斯金字塔</tag>
        <tag>拉普拉斯金字塔</tag>
        <tag>小波金字塔</tag>
      </tags>
  </entry>
  <entry>
    <title>一致性哈希算法</title>
    <url>/2024/11/07/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>一致性哈希，Consistent Hashing，用于分布式系统的负载均衡，解决了传统哈希算法的节点扩缩容问题。</p>
<a id="more"></a>
<h1 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h1><p>在分布式系统中，集群由多台服务器组成，数据采用分布式缓存，期望将数据尽量均匀地分配缓存到各个服务器，每个服务器上有着不同的缓存，以分担压力。请求数据时，再到相应的服务器获取缓存。这部分工作由负载均衡层 LB 来完成。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20241107021347734.png" alt="image-20241107021347734" style="zoom:50%;" /></p>
<p>分布式系统应满足下面要求：</p>
<ul>
<li>对于同一个数据的请求落在相同的服务器上</li>
<li>数据分配尽量均匀</li>
<li>当服务器数量增减时，尽量减小原有数据分配变化</li>
</ul>
<h1 id="传统哈希算法"><a href="#传统哈希算法" class="headerlink" title="传统哈希算法"></a>传统哈希算法</h1><h2 id="传统哈希算法-1"><a href="#传统哈希算法-1" class="headerlink" title="传统哈希算法"></a>传统哈希算法</h2><p>哈希算法采用取模运算，基于下面的公式，将 hash 值对机器数量取余，将数据的 key 映射到节点。</p>
<script type="math/tex; mode=display">
hash(key) \% size</script><p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20241107131915573.png" alt="image-20241107131915573" style="zoom:50%;" /></p>
<h2 id="扩缩容问题"><a href="#扩缩容问题" class="headerlink" title="扩缩容问题"></a>扩缩容问题</h2><p>服务器集群会因为业务量变化需求而扩缩容，增加或减少节点数，此时映射关系发生大量变化，缓存失效，需要进行数据迁移，以保证请求正常。数据迁移规模 <code>O(M)</code>，迁移成本极大，导致服务器瞬时压力巨大。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20241107132455997.png" alt="image-20241107132455997" style="zoom:50%;" /></p>
<h1 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h1><h2 id="哈希环"><a href="#哈希环" class="headerlink" title="哈希环"></a>哈希环</h2><p>一致性哈希算法引入哈希环解决了扩缩容导致过多数据迁移问题。</p>
<p>一致性哈希算法同样采用了取模的方式，但与传统哈希不同，取模值固定为 $2^{32}$</p>
<script type="math/tex; mode=display">
hash(key) \% 2^{32}</script><p>可以把取模结果当做一个圆环，由 $2^{32}$ 个点组成，先将服务器取模映射到哈希环上，再将数据同样取模映射到环上，选择顺时针找到的第一个服务器存入。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20241107134652765.png" alt="image-20241107134652765" style="zoom:50%;" /></p>
<p>此时添加一个节点，仅有少量的数据需要重新分配映射，大部分位置分配保持不变。</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/image-20241107135232078.png" alt="image-20241107135232078" style="zoom:50%;" /></p>
<h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p>如果采用节点直接映射，可能存在节点分布不均匀问题，也就是 hash 偏斜。大部分的缓存落在少数几台服务器上，如果该台服务器发生故障，会导致瞬时大量数据迁移。</p>
<p><img src="/Users/guoyi/Library/Application Support/typora-user-images/image-20241113013903066.png" alt="image-20241113013903066" style="zoom:60%;" /></p>
<p>为了解决 hash 偏斜问题，引入虚拟节点。</p>
<p>将每个服务器映射为多个虚拟节点，数量足够多，以保证均匀分布。数据映射时先找到虚拟节点，再对应到相应的真实节点。</p>
<p><img src="/Users/guoyi/Library/Application Support/typora-user-images/image-20241113015419128.png" alt="image-20241113015419128" style="zoom:50%;" /></p>
<h1 id="Go-实现一致性哈希"><a href="#Go-实现一致性哈希" class="headerlink" title="Go 实现一致性哈希"></a>Go 实现一致性哈希</h1>]]></content>
      <tags>
        <tag>Load Balancing</tag>
      </tags>
  </entry>
  <entry>
    <title>基于区域的图像分割——区域分裂与合并</title>
    <url>/2020/01/19/%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E2%80%94%E2%80%94%E5%8C%BA%E5%9F%9F%E5%88%86%E8%A3%82%E4%B8%8E%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>​    分裂与合并是一种区域分割方式，将图像划分成不相交的区域，以某一检测准则从四叉树数据结构的任一层开始，对区域进行分裂或合并。并逐步改善区域划分的性能，直到最后将图像分成数量最小的均匀区域为止。</p>
<p><img src="https://i.loli.net/2020/01/19/zHZh7fe1OIcmqD3.jpg" alt="img.jpg" style="zoom:40%;" /></p>
<p><img src="https://i.loli.net/2020/01/20/PUAhMeZjsBI6v8m.jpg" alt="result.jpg" style="zoom: 40%;" /></p>
<a id="more"></a>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>定义用于同质性的标准；</li>
<li>将图像分成相等大小的区域；</li>
<li>计算每个区域的同质性；</li>
<li>如果区域同质，则将其与邻居合并；</li>
<li>重复该过程，直到所有区域均通过均一性测试。</li>
</ol>
<p><img src="https://i.loli.net/2020/01/19/n41MloiBH5GSwCv.png" alt="image.png" style="zoom:60%;" /></p>
<h2 id="同质性"><a href="#同质性" class="headerlink" title="同质性"></a>同质性</h2><p>​    可有多种同质性的定义方式，比如：</p>
<ul>
<li><p>方差-灰度方差</p>
<p><img src="https://i.loli.net/2020/01/19/7QIG4fa95iB2oH8.png" alt="image.png"></p>
<p>当区域方差小于指定值时，则该区域符合同质性。</p>
</li>
</ul>
<h1 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> row; <span class="comment">//起始行</span></span><br><span class="line">    <span class="keyword">int</span> col; <span class="comment">//起始列</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span>; <span class="comment">//高度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">width</span>; <span class="comment">//宽度</span></span><br><span class="line">&#125;; <span class="comment">//区域</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 计算区域的灰度方差</span></span><br><span class="line"><span class="comment"> img为原图像，blocks为区域集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">variance</span><span class="params">(Mat img, <span class="built_in">vector</span>&lt;Block&gt; blocks)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 求得区域方差</span></span><br><span class="line">    <span class="keyword">double</span> ave_I = <span class="number">0</span>; <span class="comment">//区域平均灰度值</span></span><br><span class="line">    <span class="keyword">int</span> aero = <span class="number">0</span>; <span class="comment">//区域集面积</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; blocks.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> nrow = blocks[i].row; nrow &lt; blocks[i].row+blocks[i].<span class="built_in">height</span>; nrow++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> ncol = blocks[i].col; ncol &lt; blocks[i].col+blocks[i].<span class="built_in">width</span>; ncol++) &#123;</span><br><span class="line">                ave_I += img.ptr&lt;uchar&gt;(nrow)[ncol];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        aero += blocks[i].<span class="built_in">height</span> * blocks[i].<span class="built_in">width</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ave_I /= <span class="keyword">double</span>(aero);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> v = <span class="number">0</span>; <span class="comment">//区域灰度方差</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; blocks.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> nrow = blocks[i].row; nrow &lt; blocks[i].row+blocks[i].<span class="built_in">height</span>; nrow++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> ncol = blocks[i].col; ncol &lt; blocks[i].col+blocks[i].<span class="built_in">width</span>; ncol++) &#123;</span><br><span class="line">                v += (img.ptr&lt;uchar&gt;(nrow)[ncol] - ave_I)*(img.ptr&lt;uchar&gt;(nrow)[ncol] - ave_I);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v /= <span class="keyword">double</span>(aero - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 画线</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawLines</span><span class="params">(Mat &amp;img, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Block&gt;&gt; homo_blocks)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; homo_blocks.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        Mat linePic = Mat::zeros(img.<span class="built_in">size</span>(), CV_8UC1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; homo_blocks[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="comment">// 上下边缘</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> ncol = homo_blocks[i][j].col; ncol &lt; homo_blocks[i][j].col+homo_blocks[i][j].<span class="built_in">width</span>; ncol++) &#123;</span><br><span class="line">                <span class="comment">// 上边缘</span></span><br><span class="line">                <span class="keyword">int</span> I = linePic.ptr&lt;uchar&gt;(homo_blocks[i][j].row)[ncol];</span><br><span class="line">                <span class="keyword">if</span> (I == <span class="number">0</span>) &#123; <span class="comment">//如果为黑，还未划线</span></span><br><span class="line">                    linePic.ptr&lt;uchar&gt;(homo_blocks[i][j].row)[ncol] = <span class="number">255</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (I == <span class="number">255</span>) &#123; <span class="comment">//已划线则去掉线</span></span><br><span class="line">                    linePic.ptr&lt;uchar&gt;(homo_blocks[i][j].row)[ncol] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 下边缘</span></span><br><span class="line">                I = linePic.ptr&lt;uchar&gt;(homo_blocks[i][j].row+homo_blocks[i][j].<span class="built_in">height</span>)[ncol];</span><br><span class="line">                <span class="keyword">if</span> (I == <span class="number">0</span>) &#123; <span class="comment">//如果为黑，还未划线</span></span><br><span class="line">                    linePic.ptr&lt;uchar&gt;(homo_blocks[i][j].row+homo_blocks[i][j].<span class="built_in">height</span>)[ncol] = <span class="number">255</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (I == <span class="number">255</span>) &#123; <span class="comment">//已划线则去掉线</span></span><br><span class="line">                    linePic.ptr&lt;uchar&gt;(homo_blocks[i][j].row+homo_blocks[i][j].<span class="built_in">height</span>)[ncol] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 左右边缘</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> nrow = homo_blocks[i][j].row; nrow &lt; homo_blocks[i][j].row+homo_blocks[i][j].<span class="built_in">height</span>; nrow++) &#123;</span><br><span class="line">                <span class="comment">// 左边缘</span></span><br><span class="line">                <span class="keyword">int</span> I = linePic.ptr&lt;uchar&gt;(nrow)[homo_blocks[i][j].col];</span><br><span class="line">                <span class="keyword">if</span> (I == <span class="number">0</span>) &#123; <span class="comment">//如果为黑，还未划线</span></span><br><span class="line">                    linePic.ptr&lt;uchar&gt;(nrow)[homo_blocks[i][j].col] = <span class="number">255</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (I == <span class="number">255</span>) &#123; <span class="comment">//已划线则去掉线</span></span><br><span class="line">                    linePic.ptr&lt;uchar&gt;(nrow)[homo_blocks[i][j].col] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 右边缘</span></span><br><span class="line">                I = linePic.ptr&lt;uchar&gt;(nrow)[homo_blocks[i][j].col+homo_blocks[i][j].<span class="built_in">width</span>];</span><br><span class="line">                <span class="keyword">if</span> (I == <span class="number">0</span>) &#123; <span class="comment">//如果为黑，还未划线</span></span><br><span class="line">                    linePic.ptr&lt;uchar&gt;(nrow)[homo_blocks[i][j].col+homo_blocks[i][j].<span class="built_in">width</span>] = <span class="number">255</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (I == <span class="number">255</span>) &#123; <span class="comment">//已划线则去掉线</span></span><br><span class="line">                    linePic.ptr&lt;uchar&gt;(nrow)[homo_blocks[i][j].col+homo_blocks[i][j].<span class="built_in">width</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> nrow = <span class="number">0</span>; nrow &lt; img.rows; nrow++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> ncol = <span class="number">0</span>; ncol &lt; img.cols; ncol++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (linePic.ptr&lt;uchar&gt;(nrow)[ncol] == <span class="number">255</span>) &#123;</span><br><span class="line">                    img.ptr&lt;uchar&gt;(nrow)[ncol] = <span class="number">255</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 区域分裂与合并</span></span><br><span class="line"><span class="comment"> img为原图像，result为处理后的图像，threshold为方差阈值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splitMerge</span> <span class="params">(Mat img, Mat &amp;result, <span class="keyword">double</span> threshold)</span></span>&#123;</span><br><span class="line">    Block init_block = &#123;</span><br><span class="line">        .row = <span class="number">0</span>,</span><br><span class="line">        .col = <span class="number">0</span>,</span><br><span class="line">        .<span class="built_in">height</span> = img.rows,</span><br><span class="line">        .<span class="built_in">width</span> = img.cols</span><br><span class="line">    &#125;; <span class="comment">//初始区域</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Block&gt; blocks; <span class="comment">//不符合同质性区域集</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Block&gt;&gt; homo_blocks; <span class="comment">//符合同质性的区域集</span></span><br><span class="line">    </span><br><span class="line">    blocks.push_back(init_block); <span class="comment">//将初始区域压入不符合同质性区域集</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分裂与合并的迭代</span></span><br><span class="line">    <span class="keyword">while</span> (!blocks.empty()) &#123;</span><br><span class="line">        <span class="comment">// 取出一个不符合同质性的区域</span></span><br><span class="line">        Block current_block = blocks.back();</span><br><span class="line">        blocks.pop_back();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 面积为8以上可分</span></span><br><span class="line">        <span class="keyword">if</span> (current_block.<span class="built_in">height</span> * current_block.<span class="built_in">width</span> &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">            Block child_blocks[<span class="number">4</span>] = &#123;</span><br><span class="line">                &#123;.row = current_block.row, .col = current_block.col, .<span class="built_in">height</span> = (current_block.<span class="built_in">height</span>+<span class="number">1</span>)/<span class="number">2</span>, .<span class="built_in">width</span> = (current_block.<span class="built_in">width</span>+<span class="number">1</span>)/<span class="number">2</span>&#125;,</span><br><span class="line">                &#123;.row = current_block.row, .col = current_block.col+(current_block.<span class="built_in">width</span>+<span class="number">1</span>)/<span class="number">2</span>, .<span class="built_in">height</span> = (current_block.<span class="built_in">height</span>+<span class="number">1</span>)/<span class="number">2</span>, .<span class="built_in">width</span> = current_block.<span class="built_in">width</span>-(current_block.<span class="built_in">width</span>+<span class="number">1</span>)/<span class="number">2</span>&#125;,</span><br><span class="line">                &#123;.row = current_block.row+(current_block.<span class="built_in">height</span>+<span class="number">1</span>)/<span class="number">2</span>, .col = current_block.col, .<span class="built_in">height</span> = current_block.<span class="built_in">height</span>-(current_block.<span class="built_in">height</span>+<span class="number">1</span>)/<span class="number">2</span>, .<span class="built_in">width</span> = (current_block.<span class="built_in">width</span>+<span class="number">1</span>)/<span class="number">2</span>&#125;,</span><br><span class="line">                &#123;.row = current_block.row+(current_block.<span class="built_in">height</span>+<span class="number">1</span>)/<span class="number">2</span>, .col = current_block.col+(current_block.<span class="built_in">width</span>+<span class="number">1</span>)/<span class="number">2</span>, .<span class="built_in">height</span> = current_block.<span class="built_in">height</span>-(current_block.<span class="built_in">height</span>+<span class="number">1</span>)/<span class="number">2</span>, .<span class="built_in">width</span> = current_block.<span class="built_in">width</span>-(current_block.<span class="built_in">width</span>+<span class="number">1</span>)/<span class="number">2</span>&#125;</span><br><span class="line">            &#125;; <span class="comment">//区域分裂成四块子区域</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 判断子区域是否具有同质性</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;Block&gt; c_block = &#123;child_blocks[i]&#125;;</span><br><span class="line">                <span class="keyword">if</span> (variance(img, c_block) &lt;= threshold) &#123; <span class="comment">//如果具有同质性（方差小于阈值），进行合并</span></span><br><span class="line">                    <span class="comment">// 如果符合同质性的区域集为空</span></span><br><span class="line">                    <span class="keyword">if</span> (homo_blocks.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                        homo_blocks.push_back(c_block); <span class="comment">//将该子区域压入符合同质性的区域集</span></span><br><span class="line">                    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// 遍历符合同质性的区域集</span></span><br><span class="line">                        <span class="keyword">int</span> n;</span><br><span class="line">                        <span class="keyword">double</span> min_v = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">int</span> min_n = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; homo_blocks.<span class="built_in">size</span>(); n++) &#123;</span><br><span class="line">                            <span class="built_in">vector</span>&lt;Block&gt; bk = homo_blocks[n];</span><br><span class="line">                            bk.push_back(child_blocks[i]);</span><br><span class="line">                            <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                                min_v = variance(img, bk);</span><br><span class="line">                            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                                <span class="keyword">if</span> (variance(img, bk) &lt; min_v) &#123;</span><br><span class="line">                                    min_v = variance(img, bk);</span><br><span class="line">                                    min_n = n;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 需合并，修改添加入区域</span></span><br><span class="line">                        <span class="keyword">if</span> (min_v &lt;= threshold) &#123;</span><br><span class="line">                            <span class="built_in">vector</span>&lt;Block&gt; bk = homo_blocks[min_n];</span><br><span class="line">                            bk.push_back(child_blocks[i]);</span><br><span class="line">                            homo_blocks[min_n] = bk;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">//不需合并，直接加入该区域</span></span><br><span class="line">                            homo_blocks.push_back(c_block);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">//如果不具有同质性</span></span><br><span class="line">                    blocks.push_back(child_blocks[i]); <span class="comment">//压入不符合同质性区域集</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    drawLines(result, homo_blocks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mat img,result;</span><br><span class="line">    img = imread(<span class="string">"img.jpg"</span>, IMREAD_GRAYSCALE); <span class="comment">//获取原图的灰度图像</span></span><br><span class="line">    <span class="comment">// 读取图片失败，则停止</span></span><br><span class="line">    <span class="keyword">if</span> (img.empty()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"读取图像文件失败"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result = img.clone();</span><br><span class="line">    <span class="keyword">double</span> threshold = <span class="number">200</span>; <span class="comment">//方差阈值</span></span><br><span class="line">    splitMerge(img, result, threshold); <span class="comment">//区域分裂与合并</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 图像显示</span></span><br><span class="line">    imshow(<span class="string">"img"</span>,img);</span><br><span class="line">    imshow(<span class="string">"result"</span>,result);</span><br><span class="line">    imwrite(<span class="string">"result.jpg"</span>, result);</span><br><span class="line">    waitKey(); <span class="comment">//等待键值输入</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>原图像：</p>
<p><img src="https://i.loli.net/2020/01/19/zHZh7fe1OIcmqD3.jpg" alt="img.jpg"></p>
<p>​    该图片由<a href="https://pixabay.com/zh/users/HOerwin56-2108907/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4387401" target="_blank" rel="noopener">HOerwin56</a>在<a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4387401" target="_blank" rel="noopener">Pixabay</a>上发布</p>
<p>处理后的图像：</p>
<p><img src="https://i.loli.net/2020/01/20/PUAhMeZjsBI6v8m.jpg" alt="result.jpg"></p>
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>OpenCV</tag>
        <tag>图像处理</tag>
        <tag>区域分割</tag>
        <tag>区域分裂与合并</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/2023/08/01/git/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Git 常用命令以及使用场景</p>
<a id="more"></a>
<h1 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h1><ol>
<li><p>初始化新仓</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go init</span><br></pre></td></tr></table></figure>
<p> 此时里面的所有文件都是“未跟踪”状态</p>
<p> <img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/%E6%88%AA%E5%B1%8F2023-08-01%2004.24.26.png" alt=""></p>
</li>
<li><p>将文件添加到暂存区</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add &lt;name&gt;</span><br></pre></td></tr></table></figure>
<p> <img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/%E6%88%AA%E5%B1%8F2023-08-01%2004.29.39.png" alt=""></p>
</li>
<li><p>提交</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;message&quot;</span><br></pre></td></tr></table></figure>
<p> <img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/%E6%88%AA%E5%B1%8F2023-08-01%2004.34.50.png" alt=""></p>
</li>
</ol>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="查看-git-配置"><a href="#查看-git-配置" class="headerlink" title="查看 git 配置"></a>查看 git 配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>
<h2 id="创建新仓库"><a href="#创建新仓库" class="headerlink" title="创建新仓库"></a>创建新仓库</h2><p>初始化新仓</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go init</span><br></pre></td></tr></table></figure>
<p>此时会在目录下新增一个 <code>.git</code> 隐藏目录，用于跟踪管理版本库</p>
<h2 id="克隆已有项目"><a href="#克隆已有项目" class="headerlink" title="克隆已有项目"></a>克隆已有项目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone &lt;HTTP or SSH&gt;</span><br></pre></td></tr></table></figure>
<h2 id="添加修改"><a href="#添加修改" class="headerlink" title="添加修改"></a>添加修改</h2><p>将修改过的文件修改为缓存状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add &lt;name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="取消缓存状态"><a href="#取消缓存状态" class="headerlink" title="取消缓存状态"></a>取消缓存状态</h2><p>通过 <code>add</code> 设置的缓存状态，可以通过 <code>reset</code> 取消</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset HEAD &lt;name&gt;</span><br></pre></td></tr></table></figure>
<h1 id="git-clone-速度慢"><a href="#git-clone-速度慢" class="headerlink" title="git clone 速度慢"></a>git clone 速度慢</h1><p>添加 git 的域名映射</p>
<ol>
<li><p>查询 ip</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(base) ➜  ~ nslookup github.global.ssl.fastly.Net</span><br><span class="line">Server:		192.168.1.1</span><br><span class="line">Address:	192.168.1.1#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:	github.global.ssl.fastly.Net</span><br><span class="line">Address: 173.252.88.67</span><br><span class="line"></span><br><span class="line">(base) ➜  ~ nslookup github.com</span><br><span class="line">Server:		192.168.1.1</span><br><span class="line">Address:	192.168.1.1#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:	github.com</span><br><span class="line">Address: 20.205.243.166</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>/etc/hosts</code> 添加域名映射</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20.205.243.166  github.com</span><br><span class="line">173.252.88.67 github.global.ssl.fastly.Net</span><br></pre></td></tr></table></figure>
</li>
<li><p>刷新 DNS 缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo killall -HUP mDNSResponder</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>基于区域的图像分割——区域生长</title>
    <url>/2020/01/18/%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E2%80%94%E2%80%94%E5%8C%BA%E5%9F%9F%E7%94%9F%E9%95%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>​    区域生长是一种基于区域的分割方式，从初始种子点出发，检查相邻像素点，判断是否需要加入该区域。</p>
<p><img src="https://i.loli.net/2020/01/18/vlGqrPXBI6RDMSb.jpg" alt="mountains.jpg" style="zoom: 15%;" /><img src="https://i.loli.net/2020/01/18/ZWH2fCianE9MtYx.jpg" alt="result.jpg" style="zoom:15%;" /></p>
<a id="more"></a>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>​    令 <em>f(x, y)</em> 表示一个输入图像阵列；<em>S(x, y)</em> 表示一个种子阵列，阵列中种子点位置处为1，其他位置处为0；<em>Q</em> 表示在每个位置 <em>(x, y)</em> 处所用的属性。假设阵列 <em>f</em> 和 <em>S</em> 的尺寸相同。基于8连接的一个基本区域生长算法说明如下：</p>
<ol>
<li>在 <em>S(x, y)</em> 中寻找所有连通分量，并把每个连通分量腐蚀成一个像素；把找到的所有这种像素标记为1，把 <em>S</em> 中的所有其他像素标记为0；</li>
<li>在坐标对 <em>(x, y)</em> 处形成图像 <em>fQ</em>：如果输入图像在该坐标处满足给定的属性 <em>Q</em>，则令 <em>fQ(x, y) = 1</em>，否则令 <em>fQ(x, y) = 0</em>；</li>
<li>令 <em>g</em> 是这样形成的图像：即把 <em>fQ</em> 中为8连通种子点的所有1值点，添加到 <em>S</em> 中的每个种子点；</li>
<li>用不同的区域标记标记出 <em>g</em> 中的每个连通分量。这就是由区域生长得到的分割图像。</li>
</ol>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p><img src="https://i.loli.net/2020/01/18/blSYLwiBoqhRsVF.jpg" alt=""></p>
<h1 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 区域生长</span></span><br><span class="line"><span class="comment"> img为原图像，result为经区域生长后的图像，seed为初始种子点，threshold为阈值</span></span><br><span class="line"><span class="comment"> 输入种子点超出范围返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">regionGrowing</span><span class="params">(Mat img, Mat &amp;result, Point2i seed, <span class="keyword">int</span> threshold)</span></span>&#123;</span><br><span class="line">    result = Mat::zeros(img.<span class="built_in">size</span>(), CV_8UC1); <span class="comment">//背景全部设置为黑</span></span><br><span class="line"><span class="comment">//    输入种子点超出范围返回false</span></span><br><span class="line">    <span class="keyword">if</span> (seed.x &lt; <span class="number">0</span> || seed.y &lt; <span class="number">0</span> || seed.y &gt; img.rows<span class="number">-1</span> || seed.x &gt; img.cols<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;Point2i&gt; seeds; <span class="comment">//种子点集</span></span><br><span class="line">    seeds.push_back(seed); <span class="comment">//压入初始种子点</span></span><br><span class="line">    result.ptr&lt;uchar&gt;(seed.y)[seed.x] = <span class="number">255</span>; <span class="comment">//种子点设置为白</span></span><br><span class="line">    <span class="keyword">int</span> growDirections[<span class="number">8</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">0</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">1</span>&#125;&#125;; <span class="comment">//生长方向</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//    开始生长</span></span><br><span class="line">    <span class="keyword">while</span> (!seeds.empty()) &#123;</span><br><span class="line">        <span class="comment">// 取出一个种子点作为现在循环的初始种子点</span></span><br><span class="line">        Point2i seed_current = seeds.back();</span><br><span class="line">        seeds.pop_back();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历各生长方向的邻点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            Point2i neighborPoint = &#123;seed_current.x + growDirections[i][<span class="number">0</span>], seed_current.y + growDirections[i][<span class="number">1</span>]&#125;; <span class="comment">//邻点</span></span><br><span class="line">            <span class="keyword">if</span> (neighborPoint.x &lt; <span class="number">0</span> || neighborPoint.y &lt; <span class="number">0</span> || neighborPoint.x &gt; img.cols<span class="number">-1</span> || neighborPoint.y &gt; img.rows<span class="number">-1</span>) &#123; <span class="comment">//邻点超出范围</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((result.ptr&lt;uchar&gt;(neighborPoint.y)[neighborPoint.x] == <span class="number">0</span>) &amp;&amp; <span class="built_in">abs</span>(img.ptr&lt;uchar&gt;(neighborPoint.y)[neighborPoint.x] - img.ptr&lt;uchar&gt;(seed.y)[seed.x]) &lt; threshold) &#123;</span><br><span class="line">                <span class="comment">// 设置为种子点</span></span><br><span class="line">                result.ptr&lt;uchar&gt;(neighborPoint.y)[neighborPoint.x] = <span class="number">255</span>; <span class="comment">//设置为白色</span></span><br><span class="line">                seeds.push_back(neighborPoint); <span class="comment">//压入种子集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mat img, result;</span><br><span class="line">    img = imread(<span class="string">"mountains.jpg"</span>, IMREAD_GRAYSCALE); <span class="comment">//从文件中加载灰度图像</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    读取图片失败，则停止</span></span><br><span class="line">    <span class="keyword">if</span> (img.empty()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"读取图像文件失败"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    输入初始种子点</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Select a point as seed from ["</span> &lt;&lt; img.rows<span class="number">-1</span> &lt;&lt; <span class="string">", "</span> &lt;&lt; img.cols<span class="number">-1</span> &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> seed_row, seed_col;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"row"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; seed_row;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"col"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; seed_col;</span><br><span class="line">    Point2i seed;</span><br><span class="line">    seed.x = seed_col;</span><br><span class="line">    seed.y = seed_row;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    区域生长</span></span><br><span class="line">    <span class="keyword">int</span> threshold = <span class="number">50</span>;</span><br><span class="line">    regionGrowing(img, result, seed, threshold); <span class="comment">//区域生长</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//    图像显示</span></span><br><span class="line">    imshow(<span class="string">"img"</span>,img);</span><br><span class="line">    imshow(<span class="string">"result"</span>,result);</span><br><span class="line">    imwrite(<span class="string">"result.jpg"</span>, result);</span><br><span class="line">    waitKey(); <span class="comment">//等待键值输入</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>原图像：</p>
<p><img src="https://i.loli.net/2020/01/18/vlGqrPXBI6RDMSb.jpg" alt="mountains.jpg"></p>
<p>经区域生长后的图像（取原种子点为（0, 0））：</p>
<p><img src="https://i.loli.net/2020/01/18/ZWH2fCianE9MtYx.jpg" alt="result.jpg" /></p>
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>OpenCV</tag>
        <tag>图像处理</tag>
        <tag>区域分割</tag>
        <tag>区域生长</tag>
      </tags>
  </entry>
  <entry>
    <title>日语语法</title>
    <url>/2024/04/14/%E6%97%A5%E8%AF%AD%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>XXX</p>
<a id="more"></a>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>A　は　B　です</p>
<p>A　は　B　では　ありません</p>
<p>じゃ　ありません</p>
<p>A　は　B　ですか</p>
<p>A　の　B</p>
<p>場所　に　何　が　ありなす</p>
<p>場所　に　誰　が　います</p>
<p>何　は　場所　に　あります</p>
<p>誰　は　場所　に　います</p>
<p>場所　に　何　も　ありません</p>
<p>場所　に　誰　も　いません</p>
<p>場所　へ　行きます</p>
<p>場所「時間」　から、場所「時間」　まで</p>
<p>車　で　行きます</p>
<h2 id="何を-动词"><a href="#何を-动词" class="headerlink" title="何を　动词"></a>何を　动词</h2><p>动作对象 + を</p>
<ul>
<li>ご飯<strong>を</strong>食べる</li>
</ul>
<h2 id="場所で-动词"><a href="#場所で-动词" class="headerlink" title="場所で　动词"></a>場所で　动词</h2><p>在某地做某事</p>
<ul>
<li>図書館で勉強する</li>
</ul>
<h2 id="Aか-B"><a href="#Aか-B" class="headerlink" title="Aか　B"></a>Aか　B</h2><p>A 或 B</p>
<ul>
<li>休みは土曜日か月曜日です</li>
</ul>
<h2 id="手段-原料で-动词"><a href="#手段-原料で-动词" class="headerlink" title="手段/原料で　动词"></a>手段/原料で　动词</h2><ul>
<li>日本語で手紙を書きます</li>
</ul>
<h2 id="誰に-何を-あげます"><a href="#誰に-何を-あげます" class="headerlink" title="誰に　何を　あげます"></a>誰に　何を　あげます</h2><p>给某人</p>
<ul>
<li>森さんにお土産をあげました</li>
</ul>
<h2 id="誰に・から-何を-もらいます"><a href="#誰に・から-何を-もらいます" class="headerlink" title="誰に・から　何を　もらいます"></a>誰に・から　何を　もらいます</h2><p>从某人那里得倒</p>
<ul>
<li>森さんにお土産をもらいました</li>
<li>森さんからお土産をもらいました</li>
</ul>
<h2 id="誰に-会います"><a href="#誰に-会います" class="headerlink" title="誰に　会います"></a>誰に　会います</h2><p>见谁</p>
<ul>
<li>森さんに駅で会いました</li>
</ul>
<h2 id="何が-好きです"><a href="#何が-好きです" class="headerlink" title="何が　好きです"></a>何が　好きです</h2><ul>
<li><p>情感的对象后面加 が</p>
<ul>
<li>好き、嫌い、怖い</li>
<li>森さんは映画が好きです</li>
</ul>
</li>
<li><p>能力的对象后面加 が</p>
<ul>
<li>分かります、できます、苦手です、上手です</li>
<li>森さんは料理が苦手です</li>
</ul>
</li>
</ul>
<h2 id="名や-名（など）"><a href="#名や-名（など）" class="headerlink" title="名や　名（など）"></a>名や　名（など）</h2><p>比如什么、什么</p>
<ul>
<li>森さんはビールーやお茶などが好きです</li>
</ul>
<h1 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>一类动词（五段动词）</p>
<ol>
<li><p>う段非る</p>
<ul>
<li>書く（かく）、探す（さがす）、勝つ（かつ）</li>
</ul>
</li>
<li><p>あ段+る、う段+る、お段+る</p>
<ul>
<li>困る（こまる）、怒る（おこる）、やる</li>
</ul>
</li>
<li><p>特例</p>
<ul>
<li>切る（きる）、帰る（かえる）、走る（はしる）</li>
</ul>
</li>
</ol>
<p>二类动词</p>
<ol>
<li>い段+る<ul>
<li>起きる（おきる）</li>
</ul>
</li>
<li>え段+る<ul>
<li>食べる（たべる）</li>
</ul>
</li>
</ol>
<p>三类动词</p>
<ol>
<li>来る（くる）</li>
<li>名　＋　する<ul>
<li>勉強する</li>
</ul>
</li>
</ol>
<h2 id="动词变形（ます型）"><a href="#动词变形（ます型）" class="headerlink" title="动词变形（ます型）"></a>动词变形（ます型）</h2><p>一类</p>
<p>う段　=&gt;　い段 + ます</p>
<ul>
<li>書く　＝＞　書きます</li>
<li>困る　＝＞　困ります</li>
<li>切る　＝＞　切ります</li>
</ul>
<p>二类</p>
<p>る　＝＞　ます</p>
<ul>
<li>起きる　＝＞　起きます</li>
<li>食べる　＝＞　食べます</li>
</ul>
<p>三类</p>
<p>来る　＝＞　きます</p>
<p>する　＝＞　します</p>
<ul>
<li>勉強する　＝＞　勉強します</li>
</ul>
<h2 id="时态以及肯否定"><a href="#时态以及肯否定" class="headerlink" title="时态以及肯否定"></a>时态以及肯否定</h2><p>一般现在：ます</p>
<p>一般现在（否）：ません</p>
<p>过去：ました</p>
<p>过去（否）：ませんでした</p>
<h1 id="形容词"><a href="#形容词" class="headerlink" title="形容词"></a>形容词</h1><h2 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h2><p>一类形容词</p>
<ol>
<li>い　结尾</li>
<li>汉字　＋　い<ul>
<li>寒い、暖かい</li>
</ul>
</li>
</ol>
<p>二类形容词</p>
<ol>
<li>汉字<ul>
<li>綺麗（きれい）</li>
</ul>
</li>
</ol>
<h2 id="时态"><a href="#时态" class="headerlink" title="时态"></a>时态</h2><h3 id="一类"><a href="#一类" class="headerlink" title="一类"></a>一类</h3><p>现在肯定：XX　い</p>
<ul>
<li>今日は暑いです</li>
</ul>
<p>现在否定：い　→　くない　或　XX　く　ありません</p>
<ul>
<li>今日は暑くないです</li>
<li>今日は暑くありません</li>
</ul>
<p>过去肯定：い　→　かった</p>
<ul>
<li>昨日は暑かったです</li>
</ul>
<p>过去否定：い　→　くなかった　或　く　ありませんでした</p>
<ul>
<li>昨日は暑くなかったです</li>
</ul>
<p>一类形容词　名词</p>
<h3 id="二类"><a href="#二类" class="headerlink" title="二类"></a>二类</h3><p>现在肯定：二类形容词　＋　です</p>
<p>过去肯定：二类形容词　＋　でした</p>
<p>否定：二类形容词　＋　ではありません</p>
<p>过去否定：二类形容词　＋　ではありませんでした</p>
<p>二类形容词　な　名词</p>
]]></content>
  </entry>
  <entry>
    <title>大津二值化法</title>
    <url>/2020/01/18/%E5%A4%A7%E6%B4%A5%E4%BA%8C%E5%80%BC%E5%8C%96%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>​    大津法（Otsu算法，おおつ）用来自动对图像进行二值化，即将图像的两类分开。要计算将两类分开的最佳阈值，即要使两类的类内方差最小。由于两类平方距离恒定，所以类内方差最小即是求类间方差最大时的阈值为最佳阈值。</p>
<p><img src="https://i.loli.net/2020/01/18/P1J6Caybjuv7HQs.png" alt="image.png" style="zoom: 60%;" /></p>
<p><img src="https://i.loli.net/2020/01/18/2hvMQawHr5u3OiP.jpg" alt="result.jpg" style="zoom:60%;" /></p>
<a id="more"></a>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ol>
<li><p>计算得原图的灰度直方图和概率直方图</p>
<p>​    设图像像素为 <em>N</em>，灰度范围为 <em>[0, L-1]</em>，对应灰度级 <em>i</em> 的像素为 <em>ni</em>，概率为：</p>
<p><img src="https://i.loli.net/2020/01/18/ukiQnv16RA9fwhJ.png" alt=""></p>
</li>
<li><p>遍历所有可能阈值 t ，找到类间方差最大是的两个对应的阈值（有一个最大则取一个，两个最大取平均）</p>
<p>类概率：</p>
<p><img src="https://i.loli.net/2020/01/18/rZMCzkKURx4JNBc.png" alt=""></p>
<p><img src="https://i.loli.net/2020/01/18/LIuFPTcKsMpjEm1.png" alt=""></p>
<p>类均值：</p>
<p><img src="https://i.loli.net/2020/01/18/Oi7jx3lAesLZ9vN.png" alt=""></p>
<p><img src="https://i.loli.net/2020/01/18/aW21HAmIpibxPyd.png" alt=""></p>
</li>
</ol>
<p>   类间方差：</p>
<p>   <img src="https://i.loli.net/2020/01/18/bBYL5wMJrVqznmj.png" alt=""></p>
<ol>
<li>最佳阈值=<img src="https://i.loli.net/2020/01/18/bKAZIRuL3xvMn6Q.png" alt="image.png"></li>
</ol>
<h1 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 获取灰度概率直方图</span></span><br><span class="line"><span class="comment"> img为原图像，histogram为灰度概率直方图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getHistogram</span><span class="params">(Mat &amp;img, <span class="keyword">double</span> *histogram)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> H[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nrow = <span class="number">0</span>; nrow &lt; img.rows; nrow++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ncol = <span class="number">0</span>; ncol &lt; img.cols; ncol++) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = img.ptr&lt;uchar&gt;(nrow)[ncol];</span><br><span class="line">            H[h] ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> N = img.rows * img.cols; <span class="comment">//总像素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">255</span>; i++) &#123;</span><br><span class="line">        histogram[i] = <span class="keyword">double</span>(H[i]) / <span class="keyword">double</span>(N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 大津法获取最佳阈值</span></span><br><span class="line"><span class="comment"> histogram为灰度概率直方图，threshold为最佳阈值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Otsu</span><span class="params">(<span class="keyword">double</span> *histogram, <span class="keyword">double</span> &amp;threshold)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> w1 = <span class="number">0.0</span>, w2 = <span class="number">1.0</span>; <span class="comment">//类概率w1,w2</span></span><br><span class="line">    <span class="keyword">double</span> u1, u2; <span class="comment">//类均值u1,u2</span></span><br><span class="line">    <span class="keyword">double</span> <span class="built_in">max</span> = <span class="number">0.0</span>; <span class="comment">//最大类间方差</span></span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">255</span>; i++) &#123;</span><br><span class="line">        sum += i * histogram[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> sum1 = <span class="number">0.0</span>, sum2 = sum;</span><br><span class="line">    <span class="keyword">double</span> threshold1 = <span class="number">0.0</span>, threshold2 = <span class="number">0.0</span>; <span class="comment">//有一个最大则取一个，两个最大取平均</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//    遍历所有可能阈值 t ，找到类间方差最大是的两个对应的阈值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= <span class="number">255</span>; t++) &#123;</span><br><span class="line">        w1 += histogram[t];</span><br><span class="line">        w2 = <span class="number">1</span> - w1;</span><br><span class="line">        <span class="keyword">if</span> (w1 == <span class="number">0</span>) &#123; <span class="comment">//还没出现点时不会是阈值</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (w2 == <span class="number">0</span>)&#123; <span class="comment">//后面没点时已获得最佳阈值</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum1 += t * histogram[t];</span><br><span class="line">        sum2 = sum - sum1;</span><br><span class="line">        u1 = sum1 / w1;</span><br><span class="line">        u2 = sum2 / w2;</span><br><span class="line">        <span class="keyword">double</span> v = w1 * w2 * (u1 - u2) * (u1 - u2); <span class="comment">//类间方差</span></span><br><span class="line">        <span class="keyword">if</span> (v &gt;= <span class="built_in">max</span>) &#123;</span><br><span class="line">            threshold1 = t; <span class="comment">//大于等于，等于时，有两个最大</span></span><br><span class="line">            <span class="keyword">if</span> (v &gt; <span class="built_in">max</span>) &#123;</span><br><span class="line">                threshold2 = t; <span class="comment">//大于时，有唯一最大，threshold1、threshold2统一</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">max</span> = v; <span class="comment">//替换max</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = (threshold1 + threshold2) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 获得大津法二值化后的图像</span></span><br><span class="line"><span class="comment"> img为原图像，result为大津法二值化后的图像，threshold为最佳阈值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getOtsuImg</span><span class="params">(Mat img, Mat &amp;result, <span class="keyword">double</span> threshold)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nrow = <span class="number">0</span>; nrow &lt;= img.rows; nrow++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ncol = <span class="number">0</span>; ncol &lt;= img.cols; ncol++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (img.ptr&lt;uchar&gt;(nrow)[ncol] &lt;= threshold) &#123;</span><br><span class="line">                result.ptr&lt;uchar&gt;(nrow)[ncol] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result.ptr&lt;uchar&gt;(nrow)[ncol] = <span class="number">255</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mat img,result;</span><br><span class="line">    img = imread(<span class="string">"Otsu.png"</span>, IMREAD_GRAYSCALE); <span class="comment">//获取原图的灰度图像</span></span><br><span class="line">    <span class="comment">// 读取图片失败，则停止</span></span><br><span class="line">    <span class="keyword">if</span> (img.empty()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"读取图像文件失败"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    获取灰度概率直方图</span></span><br><span class="line">    <span class="keyword">double</span> histogram[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//灰度概率直方图</span></span><br><span class="line">    getHistogram(img, histogram); <span class="comment">//获取灰度概率直方图</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//    获取最佳阈值</span></span><br><span class="line">    <span class="keyword">double</span> threshold = <span class="number">0</span>; <span class="comment">//最佳阈值</span></span><br><span class="line">    Otsu(histogram, threshold); <span class="comment">//获取最佳阈值</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//    获得大津法二值化后的图像</span></span><br><span class="line">    result = img.clone();</span><br><span class="line">    getOtsuImg(img, result, threshold);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 图像显示</span></span><br><span class="line">    imshow(<span class="string">"img"</span>, img);</span><br><span class="line">    imshow(<span class="string">"Otsu"</span>, result);</span><br><span class="line">    waitKey();</span><br><span class="line">    imwrite(<span class="string">"result.jpg"</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>原图像：</p>
<p><img src="https://i.loli.net/2020/01/18/P1J6Caybjuv7HQs.png" alt="image.png"></p>
<p>大津法二值化后得到的图像：</p>
<p><img src="https://i.loli.net/2020/01/18/2hvMQawHr5u3OiP.jpg" alt="result.jpg"></p>
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>OpenCV</tag>
        <tag>图像处理</tag>
        <tag>大津法</tag>
      </tags>
  </entry>
  <entry>
    <title>Neovim</title>
    <url>/2023/10/12/Neovim/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>vim</p>
<a id="more"></a>
<h1 id="Neovim-安装"><a href="#Neovim-安装" class="headerlink" title="Neovim 安装"></a>Neovim 安装</h1><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>对于 Ubuntu，安装更新版本的 Neovim</p>
<ol>
<li><p>添加源</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:neovim-ppa&#x2F;unstable</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新源</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 Neovim</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install neovim</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>安装后输入 <code>nvim</code> 即可进入</p>
<p>如果依旧想要输入 <code>vim</code> 进入，可使用链接替换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alias vim&#x3D;&#39;nvim&#39;</span><br></pre></td></tr></table></figure>
<h2 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h2><p>对于 mac，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install neovim</span><br></pre></td></tr></table></figure>
<p>在 <code>~/.bash_profile</code> 中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alias vim&#x3D;&#39;nvim&#39;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure>
<h1 id="Vim-模式"><a href="#Vim-模式" class="headerlink" title="Vim 模式"></a>Vim 模式</h1><h2 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h2><p>打开 Vim 直接进入的就是普通模式，主要用于浏览文件、执行复制粘贴删除等的操作</p>
<h2 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h2><p>普通模式下输入 <code>i</code> 进入输入模式，输入 <code>Esc</code> 退出输入模式回到普通模式</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>普通模式下输入 <code>:</code> 进入命令模式</p>
<h2 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h2><p>普通模式下输入 <code>v</code> 进入可视模式，用于选中</p>
<h1 id="普通模式-1"><a href="#普通模式-1" class="headerlink" title="普通模式"></a>普通模式</h1><h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><p>可以使用方向键进行移动，但更多地使用 <code>hjkl</code> 移动光标</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">指令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>h</code></td>
<td style="text-align:center">左移</td>
</tr>
<tr>
<td style="text-align:center"><code>j</code></td>
<td style="text-align:center">下移</td>
</tr>
<tr>
<td style="text-align:center"><code>k</code></td>
<td style="text-align:center">上移</td>
</tr>
<tr>
<td style="text-align:center"><code>l</code></td>
<td style="text-align:center">右移</td>
</tr>
<tr>
<td style="text-align:center"><code>4h</code></td>
<td style="text-align:center">左移4格</td>
</tr>
<tr>
<td style="text-align:center"><code>w</code> (word)</td>
<td style="text-align:center">跳转到下一个单词的开头</td>
</tr>
<tr>
<td style="text-align:center"><code>b</code> (beginning)</td>
<td style="text-align:center">跳转到前一个单词的开头</td>
</tr>
<tr>
<td style="text-align:center"><code>gg</code></td>
<td style="text-align:center">跳转到文件开头</td>
</tr>
<tr>
<td style="text-align:center"><code>G</code></td>
<td style="text-align:center">跳转到文件结尾</td>
</tr>
<tr>
<td style="text-align:center"><code>Ctrl</code>+<code>u</code> (PgUp)</td>
<td style="text-align:center">向上翻页</td>
</tr>
<tr>
<td style="text-align:center"><code>Ctrl</code>+<code>d</code> (PgDown)</td>
<td style="text-align:center">向下翻页</td>
</tr>
<tr>
<td style="text-align:center"><code>fr</code> (find r)</td>
<td style="text-align:center">移动到下一个 <code>r</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h2><p>复制键 <code>y</code> (yank)，粘贴键 <code>p</code> (paste)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">指令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>yaw</code> (yank all word)</td>
<td style="text-align:center">复制整个单词</td>
</tr>
<tr>
<td style="text-align:center"><code>y4j</code></td>
<td style="text-align:center">复制本行以及下4行（一共5行）</td>
</tr>
<tr>
<td style="text-align:center"><code>yfr</code></td>
<td style="text-align:center">复制到 <code>r</code> 为止的内容（包括 <code>r</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>p</code></td>
<td style="text-align:center">粘贴</td>
</tr>
</tbody>
</table>
</div>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除键 <code>d</code> (delete)，操作与复制同理</p>
<h2 id="改变"><a href="#改变" class="headerlink" title="改变"></a>改变</h2><p>改变键 <code>c</code> (change)，操作与复制同理，删除选中内容并进入输入模式</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">指令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>/</code></td>
<td style="text-align:center">从上往下查找</td>
</tr>
<tr>
<td style="text-align:center"><code>?</code></td>
<td style="text-align:center">从下往上查找</td>
</tr>
<tr>
<td style="text-align:center"><code>n</code></td>
<td style="text-align:center">下一个</td>
</tr>
<tr>
<td style="text-align:center"><code>N</code></td>
<td style="text-align:center">上一个</td>
</tr>
</tbody>
</table>
</div>
<h1 id="命令模式-1"><a href="#命令模式-1" class="headerlink" title="命令模式"></a>命令模式</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>:h &lt;plugin name&gt;</code></td>
<td style="text-align:center">查看插件说明书</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p>窗口</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">指令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>:b&lt;N&gt;</code></td>
<td style="text-align:center">跳到第 N 个 Tab</td>
</tr>
<tr>
<td style="text-align:center"><code>:b &lt;file name&gt;</code></td>
<td style="text-align:center">跳到相应文件名的 Tab</td>
</tr>
<tr>
<td style="text-align:center"><code>:bn</code></td>
<td style="text-align:center">跳到上一个的 Tab</td>
</tr>
<tr>
<td style="text-align:center"><code>:bp</code></td>
<td style="text-align:center">跳到下一个的 Tab</td>
</tr>
</tbody>
</table>
</div>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">指令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&lt;Ctrl-w&gt; + h/j/k/l</code></td>
<td style="text-align:center">切换聚焦窗口</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;Ctrl-w&gt; + w</code></td>
<td style="text-align:center">切换聚焦到下一个窗口</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>新建 nvim 的配置文件夹 <code>~/.config/nvim</code> ，结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── init.vim                              入口文件，这里负责加载所有lua文件夹里的文件</span><br><span class="line">└── lua                                   所有 lua 配置文件</span><br><span class="line">    ├── basic.lua                         Neovim 的基础配置</span><br><span class="line">    ├── keybindings.lua                   快捷键配置</span><br><span class="line">    ├── lsp                               内置 LSP  (Language Server Protocol) 配置</span><br><span class="line">    │   ├── diagnostic_signs.lua</span><br><span class="line">    │   ├── language_servers.lua</span><br><span class="line">    │   └── nvim-cmp-config.lua</span><br><span class="line">    ├── plugin-config                     各个插件配置在这个文件夹</span><br><span class="line">    │   ├── bufferline.lua</span><br><span class="line">    │   ├── comment.lua</span><br><span class="line">    │   ├── nvim-autopairs.lua</span><br><span class="line">    │   ├── nvim-colorizer.lua</span><br><span class="line">    │   ├── nvim-tree.lua</span><br><span class="line">    │   ├── nvim-treesitter.lua</span><br><span class="line">    │   ├── rust-tools.lua</span><br><span class="line">    │   ├── surround.lua</span><br><span class="line">    │   ├── telescope.lua</span><br><span class="line">    │   └── which-key.lua</span><br><span class="line">    └── plugins.lua                       插件安装管理</span><br></pre></td></tr></table></figure>
<p>nvim 在下次启动时会自动查看其中的内容进行更新，当然也可以在编辑后直接使用 <code>:so</code> 命令当重新载入。</p>
<p>以 <code>~/.config/nvim/init.lua</code> 作为入口，lua 文件夹放置不同的模块</p>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>使用插件管理器 <a href="https://github.com/folke/lazy.nvim" target="_blank" rel="noopener">lazy.vim</a> 进行插件管理</p>
<h2 id="安装-lazyvim"><a href="#安装-lazyvim" class="headerlink" title="安装 lazyvim"></a>安装 lazyvim</h2><ul>
<li><p>新建 <code>lua/lazynvim-init.lua</code></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> lazypath = vim.fn.stdpath(<span class="string">"data"</span>) .. <span class="string">"/lazy/lazy.nvim"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> vim.loop.fs_stat(lazypath) <span class="keyword">then</span></span><br><span class="line">  vim.fn.system(&#123;</span><br><span class="line">    <span class="string">"git"</span>,</span><br><span class="line">    <span class="string">"clone"</span>,</span><br><span class="line">    <span class="string">"--filter=blob:none"</span>,</span><br><span class="line">    <span class="string">"https://github.com/folke/lazy.nvim.git"</span>,</span><br><span class="line">    <span class="string">"--branch=stable"</span>, <span class="comment">-- latest stable release</span></span><br><span class="line">    lazypath,</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">vim.opt.rtp:prepend(lazypath)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">"lazy"</span>).setup(&#123;&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>init.lua</code> 中</p>
 <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"lazynvim-init"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>如此后，便可输入 <code>:Lazy</code> 打开</p>
<p><img src="https://gy-pic.oss-cn-hangzhou.aliyuncs.com/%E6%88%AA%E5%B1%8F2023-10-24%2000.47.43.png" alt=""></p>
</li>
</ul>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p> 以安装 nvim-tree 为例</p>
<ul>
<li><p>在 <code>lua</code> 文件夹下新建 <code>plugins</code> 目录</p>
</li>
<li><p>在 <code>lazynvim-init.lua</code> 中的 <code>setup</code> 中将 <code>plugins</code> 目录添加为参数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"lazy"</span>).setup(<span class="string">"plugins"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>lua/plugins</code> 下添加文件 <code>plugin-nvim-tree.lua</code></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"nvim-tree/nvim-tree.lua"</span>,</span><br><span class="line">        version = <span class="string">"*"</span>,</span><br><span class="line">        dependencies = &#123;<span class="string">"nvim-tree/nvim-web-devicons"</span>&#125;,</span><br><span class="line">        <span class="built_in">config</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">            <span class="built_in">require</span>(<span class="string">"nvim-tree"</span>).setup &#123;&#125;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>&quot;nvim-tree/nvim-tree.lua&quot;</code>：插件在 github 上的短 url</p>
</li>
<li><p><code>version</code>：下载的版本，<code>*</code> 表示自动更新最新版本</p>
</li>
<li><p><code>dependencies = {&quot;nvim-tree/nvim-web-devicons&quot;}</code>：依赖插件</p>
</li>
<li><p><code>config = ... ...</code>：当插件启动加载以后，则会执行该 config 的代码</p>
</li>
</ul>
</li>
<li><p>重新打开 vim 即可自动加载插件</p>
</li>
</ul>
<h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><h3 id="主题插件-TokyoNight"><a href="#主题插件-TokyoNight" class="headerlink" title="主题插件 TokyoNight"></a>主题插件 <a href="https://github.com/folke/tokyonight.nvim" target="_blank" rel="noopener">TokyoNight</a></h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"folke/tokyonight.nvim"</span>,</span><br><span class="line">        version = <span class="string">"*"</span>,</span><br><span class="line">        <span class="built_in">config</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">            <span class="built_in">require</span>(<span class="string">"tokyonight"</span>).setup &#123;&#125;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件树插件-nvim-tree"><a href="#文件树插件-nvim-tree" class="headerlink" title="文件树插件 nvim-tree"></a>文件树插件 <a href="https://github.com/nvim-tree/nvim-tree.lua" target="_blank" rel="noopener">nvim-tree</a></h3><ul>
<li><p>下载 nerd fornt 字体</p>
<p><strong>Linux</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -c https:&#x2F;&#x2F;github.com&#x2F;ryanoasis&#x2F;nerd-fonts&#x2F;releases&#x2F;download&#x2F;v3.0.2&#x2F;DejaVuSansMono.zip</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo unzip DejaVuSansMono.zip -d &#x2F;usr&#x2F;share&#x2F;fonts&#x2F;DejaVuSansMono</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;share&#x2F;fonts&#x2F;SourceCodePro</span><br><span class="line">sudo mkfontscale # 生成核心字体信息</span><br><span class="line">sudo mkfontdir # 生成字体文件夹</span><br><span class="line">sudo fc-cache -fv # 刷新系统字体缓存</span><br></pre></td></tr></table></figure>
<p><strong>Mac</strong></p>
<p><a href="https://joit.info/essay/a5f51f2cbbb240d7a992d481fc09f7e0" target="_blank" rel="noopener">https://joit.info/essay/a5f51f2cbbb240d7a992d481fc09f7e0</a></p>
<p>下载字体后在配置里配置 Terminal 字体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew tap homebrew&#x2F;cask-fonts</span><br><span class="line">brew install --cask font-hack-nerd-font</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"nvim-tree/nvim-tree.lua"</span>,</span><br><span class="line">        version = <span class="string">"*"</span>,</span><br><span class="line">        dependencies = &#123;<span class="string">"nvim-tree/nvim-web-devicons"</span>&#125;,</span><br><span class="line">        <span class="built_in">config</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">            <span class="built_in">require</span>(<span class="string">"nvim-tree"</span>).setup &#123;&#125;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关命令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">指令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>g?</code></td>
<td style="text-align:center">查看帮助</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;C-k&gt;</code></td>
<td style="text-align:center">查看信息</td>
</tr>
<tr>
<td style="text-align:center"><code>r</code></td>
<td style="text-align:center">重命名</td>
</tr>
<tr>
<td style="text-align:center"><code>o</code></td>
<td style="text-align:center">开文件</td>
</tr>
<tr>
<td style="text-align:center"><code>a</code></td>
<td style="text-align:center">创建新文件</td>
</tr>
<tr>
<td style="text-align:center"><code>d</code></td>
<td style="text-align:center">删除文件</td>
</tr>
<tr>
<td style="text-align:center"><code>c</code></td>
<td style="text-align:center">复制文件</td>
</tr>
<tr>
<td style="text-align:center"><code>p</code></td>
<td style="text-align:center">粘贴文件</td>
</tr>
<tr>
<td style="text-align:center"><code>x</code></td>
<td style="text-align:center">剪切文件</td>
</tr>
<tr>
<td style="text-align:center"><code>J</code></td>
<td style="text-align:center">跳到顶部的文件/文件夹</td>
</tr>
<tr>
<td style="text-align:center"><code>K</code></td>
<td style="text-align:center">跳到底部的文件/文件夹</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;</code> / <code>&gt;</code></td>
<td style="text-align:center">跳到上一个/下一个兄弟文件/文件夹</td>
</tr>
<tr>
<td style="text-align:center"><code>y</code></td>
<td style="text-align:center">复制文件名</td>
</tr>
<tr>
<td style="text-align:center"><code>Y</code></td>
<td style="text-align:center">复制相对地址</td>
</tr>
<tr>
<td style="text-align:center"><code>gy</code></td>
<td style="text-align:center">复制绝对地址</td>
</tr>
</tbody>
</table>
</div>
<h3 id="状态栏插件-lualine-nvim"><a href="#状态栏插件-lualine-nvim" class="headerlink" title="状态栏插件 lualine.nvim"></a>状态栏插件 <a href="https://github.com/nvim-lualine/lualine.nvim" target="_blank" rel="noopener">lualine.nvim</a></h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"nvim-lualine/lualine.nvim"</span>,</span><br><span class="line">        version = <span class="string">"*"</span>,</span><br><span class="line">        <span class="built_in">config</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">            <span class="built_in">require</span>(<span class="string">"lualine"</span>).setup &#123;&#125;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="页插件-bufferline-nvim"><a href="#页插件-bufferline-nvim" class="headerlink" title="页插件 bufferline.nvim"></a>页插件 <a href="https://github.com/akinsho/bufferline.nvim" target="_blank" rel="noopener">bufferline.nvim</a></h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"akinsho/bufferline.nvim"</span>,</span><br><span class="line">        version = <span class="string">"*"</span>,</span><br><span class="line">        <span class="built_in">config</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">            vim.opt.termguicolors = <span class="literal">true</span></span><br><span class="line">						<span class="built_in">require</span>(<span class="string">"bufferline"</span>).setup&#123;&#125;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/571617696" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/571617696</a></li>
<li><a href="https://github.com/folke/lazy.nvim" target="_blank" rel="noopener">lazy.vim官网</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/638379995" target="_blank" rel="noopener">lazy-nvim插件管理器基础入门</a></li>
<li><a href="https://www.bilibili.com/video/BV1Td4y1578E/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f5f8e6e01c0d525ef6934da8b95c76ce" target="_blank" rel="noopener">【全程讲解】Neovim从零配置成属于你的个人编辑器</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2023/02/12/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>排序算法总结</p>
<a id="more"></a>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>可根据<a href="https://visualgo.net/zh" target="_blank" rel="noopener">数据结构和算法动态可视化</a>网站，更加形象地学习。</p>
<h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>每次将一个待排序的记录插入到已排序好的序列中。</p>
<blockquote>
<p>(49) <strong>38</strong> 65 97 76 13 27 <u>49</u><br>(38 49) <strong>65</strong> 97 76 13 27 <u>49</u><br>(38 49 65) <strong>97</strong> 76 13 27 <u>49</u><br>(38 49 65 97) <strong>76</strong> 13 27 <u>49</u><br>(38 49 65 76 97) <strong>13</strong> 27 <u>49</u><br>(13 38 49 65 76 97) <strong>27</strong> <u>49</u><br>(13 27 38 49 65 76 97) <strong><u>49</u></strong><br>(13 27 38 49 <u>49</u> 65 76 97)</p>
<p>()表示已排好序的部分</p>
</blockquote>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Insertion</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt; &amp;nums)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Insertion&lt;T&gt;::sort(<span class="built_in">vector</span>&lt;T&gt; &amp;nums) &#123;</span><br><span class="line">    <span class="comment">//每次选一个未排序的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">//从后往前，依次检查前面已排序好的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; nums[j+<span class="number">1</span>]; j--) &#123;</span><br><span class="line">            <span class="comment">//与待排序的元素对比，如果逆序，则交换</span></span><br><span class="line">            swap(nums[j], nums[j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><ul>
<li><p>空间复杂度： $O(1)$</p>
</li>
<li><p>时间复杂度</p>
<ul>
<li><p>最好时间复杂度（全部有序）：$O(n)$</p>
<p>  共 $n-1$ 趟，每趟只需比对一次关键字，不用移动元素。</p>
</li>
<li><p>最坏时间复杂度（全部逆序）：$O(n^2)$</p>
<p>  共 $n-1$ 趟，每趟（如第 $i$ 趟）对比 $i$ 次，移动 $i$ 次。</p>
</li>
<li><p>平均时间复杂度：$O(n^2)$</p>
</li>
</ul>
</li>
<li><p>稳定性</p>
<p>  稳定。每次插入元素都是从前往后比较移动，所以不会出现相同元素相对位置变化。</p>
</li>
</ul>
<ul>
<li>适用性：顺序表和链表</li>
</ul>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h2 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h2><p>希尔排序是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。</p>
<ul>
<li><p>每轮把记录按下标的一定增量分组 $L[i, i+d, i+2d,…,i+kd]$ ，对每组直接插入排序；</p>
</li>
<li><p>逐渐减少增量，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
</li>
</ul>
<blockquote>
<p><strong>49</strong> 38 65 13 <strong>76</strong> <u>13</u> 27 57 （d = 4）<br><strong>49</strong> <u>13</u> <strong>27</strong> 13 <strong>76</strong> 38 <strong>65</strong> 57 （d = 2）<br><strong>27 <u>13</u> 49 13 65 38 76 57</strong> （d = 1）<br><u>13</u> 13 27 38 49 57 65 76</p>
</blockquote>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shell</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt; &amp;nums)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Shell&lt;T&gt;::sort(<span class="built_in">vector</span>&lt;T&gt; &amp;nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> N = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//增量d初始为N/2，每次减一半，直到为1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = N/<span class="number">2</span>; d &gt;= <span class="number">1</span>; d /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//增量为d的直接插入排序</span></span><br><span class="line">        <span class="comment">//[0,d-1]在所属子表中已排序好，从d开始，选一个未排序的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = d; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="comment">//[..., i-2d, i-d]已排好序</span></span><br><span class="line">            <span class="comment">//从后往前，依次检测前面已排序好的元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i-d; j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; nums[j+d]; j -= d) &#123;</span><br><span class="line">                <span class="comment">//与待排序的元素对比，如果逆序，则交换</span></span><br><span class="line">                swap(nums[j], nums[j+d]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h2><ul>
<li><p>空间复杂度： $O(1)$</p>
</li>
<li><p>时间复杂度</p>
<ul>
<li><p>最坏时间复杂度 $O(n^2)$</p>
</li>
<li><p>最好时间复杂度（全部有序）：$O(n)$</p>
</li>
<li><p>当n在某个特定范围时，可达 $O(n^{1.3})$</p>
</li>
</ul>
</li>
<li><p>稳定性</p>
<p>  不稳定。如果两相同元素划分到不同子表，可能会改变相对位置。</p>
</li>
<li><p>适用性：顺序表</p>
</li>
</ul>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h2><ul>
<li><p>每趟从前往后（或从后往前）两两相邻元素比较，如逆序，则交换</p>
</li>
<li><p>每趟可冒泡出最大的元素到最后</p>
</li>
</ul>
<blockquote>
<p>(1)<br><strong>49 38</strong> 65 97 76 13 27 <u>49</u><br>38 <strong>49 65</strong> 97 76 13 27 <u>49</u><br>38 49 <strong>65 97</strong> 76 13 27 <u>49</u><br>38 49 65 <strong>97 76</strong> 13 27 <u>49</u><br>38 49 65 76 <strong>97 13</strong> 27 <u>49</u><br>38 49 65 76 13 <strong>97 27</strong> <u>49</u><br>38 49 65 76 13 27 <strong>97 <u>49</u></strong><br>38 49 65 76 13 27 <u>49</u> (97)</p>
<p>(2)<br><strong>38 49</strong> 65 76 13 27 <u>49</u> (97)<br>38 <strong>49 65</strong> 76 13 27 <u>49</u> (97)<br>…<br>38 49 65 13 27 <u>49</u> (76 97)</p>
<p>……</p>
<p>(n-1)<br>(13 27 38 49 <u>49</u> 65 76 97)</p>
</blockquote>
<h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bubble</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt; &amp;nums)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Bubble&lt;T&gt;::sort(<span class="built_in">vector</span>&lt;T&gt; &amp;nums) &#123;</span><br><span class="line">    <span class="comment">//冒泡N-1趟</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>()<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>; <span class="comment">//表示发生过交换</span></span><br><span class="line">        <span class="comment">//第i趟冒泡范围[0,N-i-1]，后i个已经排序好</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>()-i<span class="number">-1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">//逆序，则交换</span></span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                swap(nums[j], nums[j+<span class="number">1</span>]);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如该趟未发生交换，则已全部有序，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能分析-2"><a href="#性能分析-2" class="headerlink" title="性能分析"></a>性能分析</h2><ul>
<li><p>空间复杂度： $O(1)$</p>
</li>
<li><p>时间复杂度</p>
<ul>
<li><p>最好时间复杂度（全部有序）：$O(n)$</p>
<p>  只需冒泡一趟，比较 $n$ 次，交换 $0$ 次，时间复杂度为$O(n)$</p>
</li>
<li><p>最坏时间复杂度（全部逆序）： $O(n^2)$</p>
<ul>
<li><p>共冒泡 $n-1$ 趟</p>
</li>
<li><p>第 $i$ 趟，比较 $n-i-1$ 次，交换 $n-i-1$ 次</p>
</li>
<li><p>比较次数 = 交换次数 = $(n-1)+(n-2)+…+1 =n(n-1)/2$</p>
</li>
<li><p>时间复杂度 $O(n^2)$</p>
</li>
</ul>
</li>
<li><p>平均时间复杂度： $O(n^2)$</p>
</li>
</ul>
</li>
<li><p>稳定性</p>
<p>  稳定。只在相邻逆序时交换，不改变相同元素的相对位置。</p>
</li>
<li><p>适用性：顺序表和链表</p>
</li>
</ul>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h2><p>每趟排序确定一个元素 $x$ 的最终位置，将数据分为$<x$ 和 $>x$ 两个部分。再对这两个部分递归进行排序。</p>
<p>(1)：确定49的位置，与49比较，左边部分小于49，右边部分大于49</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>49</th>
<th>38</th>
<th>65</th>
<th style="text-align:left">97</th>
<th style="text-align:left">76</th>
<th style="text-align:left">13</th>
<th style="text-align:left">27</th>
<th style="text-align:left"><u>49</u></th>
</tr>
</thead>
<tbody>
<tr>
<td>49</td>
<td></td>
<td></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td></td>
<td>38</td>
<td>65</td>
<td style="text-align:left">97</td>
<td style="text-align:left">76</td>
<td style="text-align:left">13</td>
<td style="text-align:left">27</td>
<td style="text-align:left"><strong><u>49</u></strong></td>
</tr>
<tr>
<td>low</td>
<td></td>
<td></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">high</td>
</tr>
<tr>
<td>49</td>
<td></td>
<td></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td></td>
<td>38</td>
<td>65</td>
<td style="text-align:left">97</td>
<td style="text-align:left">76</td>
<td style="text-align:left">13</td>
<td style="text-align:left"><strong>27</strong></td>
<td style="text-align:left"><u>49</u></td>
</tr>
<tr>
<td>low</td>
<td></td>
<td></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">high</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">49</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td><strong>27</strong></td>
<td>38</td>
<td>65</td>
<td style="text-align:left">97</td>
<td style="text-align:left">76</td>
<td style="text-align:left">13</td>
<td style="text-align:left"></td>
<td style="text-align:left"><u>49</u></td>
</tr>
<tr>
<td>low</td>
<td></td>
<td></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">high</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">49</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>27</td>
<td><strong>38</strong></td>
<td>65</td>
<td style="text-align:left">97</td>
<td style="text-align:left">76</td>
<td style="text-align:left">13</td>
<td style="text-align:left"></td>
<td style="text-align:left"><u>49</u></td>
</tr>
<tr>
<td></td>
<td>low</td>
<td></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">high</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">49</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>27</td>
<td>38</td>
<td><strong>65</strong></td>
<td style="text-align:left">97</td>
<td style="text-align:left">76</td>
<td style="text-align:left">13</td>
<td style="text-align:left"></td>
<td style="text-align:left"><u>49</u></td>
</tr>
<tr>
<td></td>
<td></td>
<td>low</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">high</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td></td>
<td></td>
<td>49</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>27</td>
<td>38</td>
<td></td>
<td style="text-align:left">97</td>
<td style="text-align:left">76</td>
<td style="text-align:left">13</td>
<td style="text-align:left"><strong>65</strong></td>
<td style="text-align:left"><u>49</u></td>
</tr>
<tr>
<td></td>
<td></td>
<td>low</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">high</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td></td>
<td></td>
<td>49</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>27</td>
<td>38</td>
<td></td>
<td style="text-align:left">97</td>
<td style="text-align:left">76</td>
<td style="text-align:left"><strong>13</strong></td>
<td style="text-align:left">65</td>
<td style="text-align:left"><u>49</u></td>
</tr>
<tr>
<td></td>
<td></td>
<td>low</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">high</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">49</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>27</td>
<td>38</td>
<td><strong>13</strong></td>
<td style="text-align:left">97</td>
<td style="text-align:left">76</td>
<td style="text-align:left"></td>
<td style="text-align:left">65</td>
<td style="text-align:left"><u>49</u></td>
</tr>
<tr>
<td></td>
<td></td>
<td>low</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">high</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">49</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>27</td>
<td>38</td>
<td>13</td>
<td style="text-align:left"><strong>97</strong></td>
<td style="text-align:left">76</td>
<td style="text-align:left"></td>
<td style="text-align:left">65</td>
<td style="text-align:left"><u>49</u></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">low</td>
<td style="text-align:left"></td>
<td style="text-align:left">high</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">49</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>27</td>
<td>38</td>
<td>13</td>
<td style="text-align:left"></td>
<td style="text-align:left">76</td>
<td style="text-align:left"><strong>97</strong></td>
<td style="text-align:left">65</td>
<td style="text-align:left"><u>49</u></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">low</td>
<td style="text-align:left"></td>
<td style="text-align:left">high</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">49</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>27</td>
<td>38</td>
<td>13</td>
<td style="text-align:left"></td>
<td style="text-align:left"><strong>76</strong></td>
<td style="text-align:left">97</td>
<td style="text-align:left">65</td>
<td style="text-align:left"><u>49</u></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">low</td>
<td style="text-align:left">high</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">49</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>27</td>
<td>38</td>
<td>13</td>
<td style="text-align:left"></td>
<td style="text-align:left">76</td>
<td style="text-align:left">97</td>
<td style="text-align:left">65</td>
<td style="text-align:left"><u>49</u></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td style="text-align:left">l=h</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>27</td>
<td>38</td>
<td>13</td>
<td style="text-align:left"><strong>49</strong></td>
<td style="text-align:left">76</td>
<td style="text-align:left">97</td>
<td style="text-align:left">65</td>
<td style="text-align:left"><u>49</u></td>
</tr>
<tr>
<td></td>
<td></td>
<td>&lt;49</td>
<td style="text-align:left">l=h</td>
<td style="text-align:left">&gt;49</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
<p>再分别对左右两边 $[27, 38, 13]$ 、 $[76, 97, 65, 49]$ 进行递归排序。</p>
<h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quick</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt; &amp;nums)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Quick&lt;T&gt;::sort(<span class="built_in">vector</span>&lt;T&gt; &amp;nums) &#123;</span><br><span class="line">    sort(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对[low, high]部分排序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Quick&lt;T&gt;::sort(<span class="built_in">vector</span>&lt;T&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high) &#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt;= high) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//跳出递归</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pivot_pos = partition(nums, low, high); <span class="comment">//切分</span></span><br><span class="line">    sort(nums, low, pivot_pos<span class="number">-1</span>); <span class="comment">//排序左边部分</span></span><br><span class="line">    sort(nums, pivot_pos+<span class="number">1</span>, high); <span class="comment">//排序右边部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序划分</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> Quick&lt;T&gt;::partition(<span class="built_in">vector</span>&lt;T&gt; &amp;nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high) &#123;</span><br><span class="line">    T pivot = nums[low]; <span class="comment">//第一个元素为枢轴</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//low和high比较交换，直到 low &gt;= high</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">//high左移，直到第一个小于pivot的出现</span></span><br><span class="line">        <span class="keyword">while</span> (nums[high] &gt;= pivot &amp;&amp; low &lt; high) &#123;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = nums[high]; <span class="comment">//小于pivot的high与low交换</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//low右移，直到第一个大于pivot的出现</span></span><br><span class="line">        <span class="keyword">while</span> (nums[low] &lt;= pivot &amp;&amp; low &lt; high) &#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[high] = nums[low]; <span class="comment">//大于pivot的low与high交换</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//pivot填入中间位置</span></span><br><span class="line">    nums[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能分析-3"><a href="#性能分析-3" class="headerlink" title="性能分析"></a>性能分析</h2><ul>
<li><p>空间复杂度</p>
<p>  需要调用递归栈，相当于分别用n个枢轴建立一个二叉树，空间复杂度即为递归层数，也就是二叉树高度。</p>
<ul>
<li><p>最好空间复杂度：$O(log_2n)$</p>
<p>  枢轴划分均匀，二叉树为完全二叉树，高度为 $log_2n$</p>
</li>
<li><p>最坏时间复杂度 $O(n)$</p>
<p>  枢轴划分极不均匀，如每个都划分成只有大于pivot或小于pivot，二叉树每个节点的度都为1，高度为 $n$</p>
</li>
</ul>
</li>
<li><p>时间复杂度</p>
<p>  时间复杂度为 $O(n*递归层数)$</p>
<ul>
<li><p>最好时间复杂度（划分均匀）：$O(nlog_2N)$</p>
</li>
<li><p>最坏时间复杂度（划分极不均匀）： $O(n^2)$</p>
</li>
<li><p>平均时间复杂度： $O(nlog_2N)$</p>
</li>
</ul>
</li>
<li><p>稳定性</p>
<p>  不稳定。交换时，可能把相对位置更后的元素交换到更前的位置。</p>
<p>  | 49 | 38 | 65 | 16 | 76 | 13 | 57 | <u>16</u> |<br>  |——|——|——|:—-|:—-|:—-|:—-|:—————|<br>  | 49 |    |    |    |    |    |    |           |<br>  |    | 38 | 65 | <strong>16</strong> | 76 | 13 | 27 |<strong><u>16</u></strong>|<br>  | low|    |    |    |    |    |    | high      |<br>  |    |    |    |    |    |    |    |     49      |<br>  | <strong><u>16</u></strong> | 38 | 65 | <strong>16</strong> | 76 | 13 | 27 |  |<br>  | low|    |    |    |    |    |     | high      | </p>
</li>
<li><p>适用性：顺序表</p>
</li>
</ul>
<h1 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h1><h2 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h2><p>最简单的一种排序方法。每次找到最小的那个元素，和第一个元素交换。</p>
<blockquote>
<p>49 38 65 97 76 <strong>13</strong> 27 <u>49</u><br>(13) 38 65 97 76 49 <strong>27</strong> <u>49</u><br>(13 27) 65 97 76 49 <strong>38</strong> <u>49</u><br>(13 27 38) 97 76 <strong>49</strong> 65 <u>49</u><br>(13 27 38 49) 76 97 65 <strong><u>49</u></strong><br>(13 27 38 49 <u>49</u>) 97 <strong>65</strong> 76<br>(13 27 38 49 <u>49</u> 65) 97 <strong>76</strong><br>(13 27 38 49 <u>49</u> 65 76) <strong>97</strong><br>(13 27 38 49 <u>49</u> 65 76 97)</p>
</blockquote>
<h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单选择排序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Selection</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt; &amp;nums)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Selection&lt;T&gt;::sort(<span class="built_in">vector</span>&lt;T&gt; &amp;nums) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>()<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min_pos = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[min_pos]) &#123;</span><br><span class="line">                min_pos = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[i], nums[min_pos]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能分析-4"><a href="#性能分析-4" class="headerlink" title="性能分析"></a>性能分析</h2><ul>
<li><p>空间复杂度：$O(1)$</p>
</li>
<li><p>时间复杂度：$O(n^2)$</p>
<p>  无论是有序、无序、乱序，都需要 $n-1$ 趟选出最小值，第i趟选最小值都需要对比 $n-i$ 次。即 $(n-1)+(n-2)+…+1 = n(n-1)/2$</p>
</li>
<li><p>稳定性</p>
<p>  不稳定。交换时，可能把相对位置更前的元素换到后面去。</p>
<blockquote>
<p>2 <u>2</u> <strong>1</strong><br>1 <strong><u>2</u></strong> 2<br>1 <u>2</u> 2</p>
</blockquote>
</li>
<li><p>适用性：顺序表和链表</p>
</li>
</ul>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="算法思想-5"><a href="#算法思想-5" class="headerlink" title="算法思想"></a>算法思想</h2><p>先建立大根堆/小根堆，再基于大根堆/小根堆进行排序。</p>
<h3 id="二叉树的顺序存储"><a href="#二叉树的顺序存储" class="headerlink" title="二叉树的顺序存储"></a>二叉树的顺序存储</h3><p>完全二叉树可以顺序存储为序列，如下面序列和完全二叉树的对应</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>t[0]</th>
<th>t[1]</th>
<th>t[2]</th>
<th>t[3]</th>
<th style="text-align:left">t[4]</th>
<th style="text-align:left">t[5]</th>
<th style="text-align:left">t[6]</th>
<th style="text-align:left">t[7]</th>
<th style="text-align:left">t[8]</th>
<th style="text-align:left">t[9]</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>1</td>
<td>2</td>
<td>3</td>
<td style="text-align:left">4</td>
<td style="text-align:left">5</td>
<td style="text-align:left">6</td>
<td style="text-align:left">7</td>
<td style="text-align:left">8</td>
<td style="text-align:left">9</td>
</tr>
</tbody>
</table>
</div>
<pre class="mermaid">graph TD
    A((1))
    B((2))
    C((3))
    D((4))
    E((5))
    F((6))
    G((7))
    H((8))
    I((9))

    A---B;
    A---C;
    B---D;
    B---E;
    C---F;
    C---G;
    D---H;
    D---I;</pre>

<p>对于共有 $n$ 个结点完全二叉树，序号为 $i$ 结点</p>
<ul>
<li><p>$i$ 的左孩子： $2i$</p>
</li>
<li><p>$i$ 的右孩子： $2i+1$</p>
</li>
<li><p>$i$ 的父结点： $\lfloor i/2 \rfloor$</p>
</li>
<li><p>$i$ 所在层次： $\lfloor log_2(n+1) \rfloor$</p>
</li>
<li><p>$i$ 是否有左孩子： $2i \le n?$</p>
</li>
<li><p>$i$ 是否有右孩子： $2i+1 \le n?$</p>
</li>
<li><p>$i$ 是否是叶子结点： $i \ge \lfloor n/2 \rfloor?$</p>
</li>
</ul>
<h3 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h3><p>堆分为大根堆/小根堆，即更大的为根/更小的为根</p>
<ul>
<li><p>大根堆：根 &gt;= 左、右</p>
<p>  |   | 87 | 45 | 78 | 32 | 17 | 65 | 53 | 9 |<br>  |—-|—-|—-|—-|:—|:—|:—|:—|:—|  </p>
</li>
</ul>
<pre><code>&lt;pre class=&quot;mermaid&quot;&gt;    graph TD
    A((87))
    B((45))
    C((78))
    D((32))
    E((17))
    F((65))
    G((53))
    H((9))

    A---B;
    A---C;
    B---D;
    B---E;
    C---F;
    C---G;
    D---H;&lt;/pre&gt;
</code></pre><ul>
<li><p>小根堆：根 &lt;= 左、右</p>
<p>  |   | 9 | 45 | 17 | 65 | 53 | 32 | 87 | 78 |<br>  |—-|—-|—-|—-|:—|:—|:—|:—|:—|  </p>
</li>
</ul>
<pre><code>&lt;pre class=&quot;mermaid&quot;&gt;    graph TD
    A((9))
    B((45))
    C((17))
    D((65))
    E((53))
    F((32))
    G((87))
    H((78))

    A---B;
    A---C;
    B---D;
    B---E;
    C---F;
    C---G;
    D---H;&lt;/pre&gt;
</code></pre><h3 id="堆的建立"><a href="#堆的建立" class="headerlink" title="堆的建立"></a>堆的建立</h3><p>以大根堆为例，</p>
<p>把所有的非叶子结点检查一遍，如果不满足大根堆要求，则进行调整。</p>
<h3 id="基于堆进行排序"><a href="#基于堆进行排序" class="headerlink" title="基于堆进行排序"></a>基于堆进行排序</h3><h2 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h2><h2 id="性能分析-5"><a href="#性能分析-5" class="headerlink" title="性能分析"></a>性能分析</h2><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="算法思想-6"><a href="#算法思想-6" class="headerlink" title="算法思想"></a>算法思想</h2><h2 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h2><h2 id="性能分析-6"><a href="#性能分析-6" class="headerlink" title="性能分析"></a>性能分析</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://visualgo.net/zh" target="_blank" rel="noopener">数据结构和算法动态可视化</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>栈的应用——表达式求值</title>
    <url>/2023/01/18/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>利用栈对表达式进行求解</p>
<a id="more"></a>
<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>输入一个表达式（用字符串表示），求这个表达式的值。</p>
<p>保证字符串中的有效字符包括【<code>0</code>-<code>9</code>】、<code>+</code>、<code>-</code>、 <code>*</code>、<code>/</code> 、<code>(</code>、 <code>)</code>、<code>[</code>、<code>]</code>、<code>{</code> 、<code>}</code>，且表达式一定合法。</p>
<ul>
<li><p>输入描述：</p>
<p>  输入一个算术表达式</p>
</li>
<li><p>输出描述：</p>
<p>  得到计算结果</p>
</li>
</ul>
<p>示例一</p>
<blockquote>
<p>输入：<br>$3+2<em>{1+2</em>[-4/(8-6)+7]}$<br>输出：<br>25</p>
</blockquote>
<p>示例二</p>
<blockquote>
<p>输入：<br>$5-3+9<em>6</em>(6-10-2)$<br>输出：<br>-322</p>
</blockquote>
<h1 id="中缀表达式的计算"><a href="#中缀表达式的计算" class="headerlink" title="中缀表达式的计算"></a>中缀表达式的计算</h1><p>将中缀转后缀、后缀表达式的计算两个步骤合并。</p>
<ul>
<li><p>初始化两个栈，操作数栈和运算符栈</p>
</li>
<li><p>从左到右扫描中缀表达式，</p>
<ul>
<li><p>当扫描到操作数时，将操作数压入操作数栈</p>
</li>
<li><p>当扫描到运算符时，</p>
<ul>
<li><p>如果是界限符，</p>
<ul>
<li><p>遇到左括号’(‘、’[‘、’{‘，压入运算符栈</p>
</li>
<li><p>遇到右括号’)’、’]’、’}’，依次弹出栈内的运算符，直到弹出左括号时结束</p>
</li>
</ul>
</li>
<li><p>如果是其他运算符，</p>
<ul>
<li><p>依次弹出优先级大于等于当前运算符的所有运算符，直到遇到左括号或栈空</p>
</li>
<li><p>当前运算符入栈</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>扫描完全部字符后，依次将剩下的运算符全部弹出</p>
</li>
<li><p>每弹出一个运算符，就要弹出两个操作数，先弹出的为右操作数，后弹出的为左操作数，计算$[左操作数 \ 运算符\ 右操作数]$，将结果压入操作数栈</p>
</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出一个运算符和两个操作数，计算后的结果压入操作数栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_count_push</span> <span class="params">(<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;&amp; v_num, <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt;&amp; v_sign)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//运算符出栈</span></span><br><span class="line">    <span class="keyword">char</span> sign = v_sign.top();</span><br><span class="line">    v_sign.pop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作数出栈，先弹出的为右操作数，后弹出的为左操作数</span></span><br><span class="line">    <span class="keyword">int</span> num1 = v_num.top(); <span class="comment">//右操作数</span></span><br><span class="line">    v_num.pop();</span><br><span class="line">    <span class="keyword">int</span> num2 = v_num.top(); <span class="comment">//左操作数</span></span><br><span class="line">    v_num.pop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算【左操作数 运算符 右操作数】</span></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">switch</span> (sign) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">            res = num2 + num1;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">            res = num2 - num1;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">            res = num2 * num1;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">            res = num2 / num1;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结果压入操作数栈</span></span><br><span class="line">    v_num.push(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断运算符优先级，乘除为2，加减为1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">priority</span> <span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'*'</span> || c == <span class="string">'/'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算中缀表达式</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_expression</span> <span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; v_num; <span class="comment">//操作数栈</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; v_sign; <span class="comment">//运算符栈</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果开始或左括号后直接跟“-”号，则补0（即-4变0-4）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; str[i] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            str = <span class="string">"0"</span> + str;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">'-'</span> &amp;&amp; (str[i - <span class="number">1</span>] == <span class="string">'('</span> || str[i - <span class="number">1</span>] == <span class="string">'['</span> ||</span><br><span class="line">                                     str[i - <span class="number">1</span>] == <span class="string">'&#123;'</span>)) &#123;</span><br><span class="line">            str.insert(i, <span class="string">"0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从左到右扫描中缀表达式</span></span><br><span class="line">    <span class="keyword">bool</span> flag =</span><br><span class="line">        <span class="literal">false</span>; <span class="comment">//前一位为符号位为false，为数位为true（用于计算多位数）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : str) &#123;</span><br><span class="line">        <span class="comment">//当扫描到操作数时，将操作数压入操作数栈</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">            <span class="comment">//前一位为符号位，则直接压入本位</span></span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                v_num.push(c - <span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//前一位为数位，则将上一个数出栈，乘10，再加上本位</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> num = v_num.top() * <span class="number">10</span> + (c - <span class="string">'0'</span>);</span><br><span class="line">                v_num.pop();</span><br><span class="line">                v_num.push(num); <span class="comment">//新数入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当扫描到运算符时</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当扫描到左括号时，压入运算符栈</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span> || c == <span class="string">'['</span> || c == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">                v_sign.push(c);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当扫描到右括号时，依次弹出栈内的运算符，直到弹出左括号时结束</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">')'</span> || c == <span class="string">']'</span> || c == <span class="string">'&#125;'</span>) &#123;</span><br><span class="line">                <span class="comment">//当栈顶不是左括号时，继续弹出运算符计算</span></span><br><span class="line">                <span class="keyword">while</span> (v_sign.top() != <span class="string">'('</span> &amp;&amp; v_sign.top() != <span class="string">'['</span> &amp;&amp; v_sign.top() != <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">                    pop_count_push(v_num, v_sign);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//弹出左括号</span></span><br><span class="line">                v_sign.pop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当扫描到其他运算符时</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//遇到左括号或栈空前，一直弹出优先级大于等于当前的运算符</span></span><br><span class="line">                <span class="keyword">while</span> (!v_sign.empty()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v_sign.top() == <span class="string">'('</span> || v_sign.top() == <span class="string">'['</span> || v_sign.top() == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//栈顶运算符的优先级大于等于当前的运算符，则弹出运算符计算</span></span><br><span class="line">                    <span class="keyword">if</span> (priority(v_sign.top()) &gt;= priority(c)) &#123;</span><br><span class="line">                        pop_count_push(v_num, v_sign);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">//否则结束弹出</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当前运算符入栈</span></span><br><span class="line">                v_sign.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将剩下的运算符全部弹出</span></span><br><span class="line">    <span class="keyword">while</span> (!v_sign.empty()) &#123;</span><br><span class="line">        pop_count_push(v_num, v_sign);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = v_num.top();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count_expression(str) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>表达式求值</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>某不科学的C课设入门（华科自动化C课设）</title>
    <url>/2019/12/17/%E6%9F%90%E4%B8%8D%E7%A7%91%E5%AD%A6%E7%9A%84C%E8%AF%BE%E8%AE%BE%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>一些关于华科自动化C课设的经验总结，之前在课设群里发过pdf版的，现整理到博客上，如有问题可在下面进行评论。</p>
<a id="more"></a>
<h2 id="入门建议"><a href="#入门建议" class="headerlink" title="入门建议"></a>入门建议</h2><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><p>C课设的大部分需要的知识都已经在自动化大一下学期的C语言课程上学习过了，这里主要就谈一些需要自学的知识，建议大家在暑假期间学习一下。</p>
<ul>
<li><p><strong>建立打开工程</strong></p>
<p>跑一跑学长学姐的代码，看看大致是一个怎样的内容。学会如何在bc上建立一个工程。（详细过程请参考《Borland C++建立工程菜鸟教程》）</p>
</li>
<li><p><strong>选择画图的模式，学习基本的画图方法</strong></p>
<p>两种模式可供选择——VGA和SVGA</p>
<p>|          | <strong>优点</strong>                                                     | <strong>缺点</strong>                                                     |<br>| ———— | —————————————————————————————— | —————————————————————————————— |<br>| <strong>VGA</strong>  | 具有众多的画图函数（例如画圆、画方框等），画图显示速度快（基本一跳转画图就完成） | 分辨率低，可选择的颜色少，不能贴图                           |<br>| <strong>SVGA</strong> | 分辨率高，可选颜色多，可贴图                                 | 需要基于画点自己写画图函数，画图显示慢（页面显示时可以明显地看出画图的过程） |</p>
<p><strong>建议</strong>：不要求较为复杂的页面的课题选择VGA模式，因为画图比较方便而且显示效果比较好；如果需要画较为复杂的页面和图形，或者必须得贴图的课题选择SVGA模式。</p>
<p><strong>提醒</strong>：贴图须谨慎，非必要不贴图。每年的情况可能不同，打听一下今年的贴图的要求。</p>
<p>VGA画图函数可以参考《C高级实用程序设计（王士元）》中的章节。</p>
</li>
<li><p><strong>鼠标的使用</strong></p>
</li>
<li><p>重点是找到一个好用的鼠标，然后学会如何使用。（当然如果愿意自己写一个也是可以的，这样会理解的更透彻一些）</p>
<p><em>注意：不要用系统鼠标！！！</em></p>
<p> 系统鼠标是DOS下面自带的一个鼠标，在我们的电脑的bc跑的时候可以很好地显示，但是在验收用XP系统跑的时候，系统鼠标是无法显示出来的。</p>
<p>如何区分是否是系统鼠标？</p>
<p>看有没有画鼠标的图形，如果该鼠标文件里面没有任何画图的过程直接调出鼠标的形状即为系统鼠标。</p>
</li>
<li><p><strong>汉字显示</strong></p>
<p>与鼠标相同，只要找一个汉字库加入工程，然后学会使用就行。</p>
<p>有些用Notepad++编写的同学会发现汉字乱码的情况，这是因为在编写的最初没有设置为简体汉字，Notepad++默认编码为UTF-8编码，在每次编写c文件前需要手动设为中文简体。</p>
<p><img src="https://res.cloudinary.com/dh7ramrlh/image/upload/v1576576517/gy/cks1_ae9qus.jpg" style="zoom: 15%;" /></p>
</li>
<li><p><strong>文件操作</strong></p>
<p>需要自学文件的读取和写入的操作。由于不连网，所以课设中信息一般都是储存在文件中， 这时候的文件相当于课设系统的数据库。文件建议以二进制形式存储，这样读写的速度会更快。</p>
</li>
</ul>
<h3 id="其他建议"><a href="#其他建议" class="headerlink" title="其他建议"></a>其他建议</h3><ol>
<li>组内配合。C课设毕竟是个合作项目，很多人一开始忽视了搭档之间配合的重要性，最后一个人完成了大部分的工作，其实这样不仅会让你身心俱疲，而且也可能无法取得更高的分数（老师并不知道真正工作分配量，而且就算知道，不能和搭档较好的合作这个问题也会成为你的一个扣分项）。不建议组三人队，三人队对于课设来说人太多了些，但是已经组好了三人队也没关系，把功能多做一些，分摊到每个人的工作量不能小于二人队。</li>
<li>多找老师。找老师主要是两个方面：一是和老师讨论一下项目的总体规划（最好找出这道题的老师），不要让你的项目功能和老师想的偏差太大，可能的话多给几个老师看一下你的程序。二是找老师帮助debug，如果有bug一直都该不好，尽早找老师或者学长学姐问，不要拖。</li>
<li>仿照市面上已有的电脑版软件设计。课设最好的效果就是让人看起来像一个真实的软件。</li>
<li>尽早开始做。C课设至少要一到两个月的工作量，一般中期验收在10月中旬，终期验收在11月初或者中旬，所以建议最晚在9月中旬要开始工作，当然越早开始肯定是越好的啦。</li>
<li>验收前一周一定要去科技楼的电脑上跑一下程序，科技楼有一种银白色的主机是最后验收时跑的主机，（判断是否是最后验收时跑的方式的方法：工程在XP系统上直接运行，不需要打开BC），这种跑法可能会和你在自己电脑上或者科技楼非XP系统的电脑上跑得有很大的不同，所以一定要提前至少一周的时间去科技楼跑一下你的程序。最后有闲余的时间的话可以把程序里的warning全部消掉一下。</li>
<li>中期和终期报告尽量多写一些。中期验收会看报告页数，页数不够的会被打回去重写。</li>
<li>每个函数的行数不要过多。不要把一个页面所有的代码都堆在一个函数里，这样很可能让你带上重复代码来凑代码量的嫌疑，把带有功能的代码块提出成函数，这样也方便重复调用。</li>
<li>多功能性和稳定性。不一定要追求十分复杂的算法，重要的是扩展功能，特别是较为简单的题就得放开思路，使你的系统功能更加的丰富。</li>
</ol>
<h2 id="跑往届代码"><a href="#跑往届代码" class="headerlink" title="跑往届代码"></a>跑往届代码</h2><p>《Borland C++建立工程菜鸟教程》中很详细地讲述了如何建立工程的问题，所以这里就只是简述一下怎么打开已有的工程（这里就用我们组的工程进行演示，文件夹名为stock）。</p>
<p>第一步：把代码放到BC的DISK_C文件夹下。</p>
<p><img src="https://res.cloudinary.com/dh7ramrlh/image/upload/v1576576585/gy/cks2_vtbuw9.png" style="zoom:40%;" /></p>
<p>第二步：打开BC，在 File &gt; Change Directory 里找到相应文件。</p>
<p><img src="https://res.cloudinary.com/dh7ramrlh/image/upload/v1576576622/gy/cks3_yqusyj.jpg" style="zoom:75%;" /></p>
<p>第三步：在 Project &gt; Open Project File 中找到 .prj 文件，打开。</p>
<p><img src="https://res.cloudinary.com/dh7ramrlh/image/upload/v1576576802/gy/cks4_mae1qb.jpg" style="zoom:75%;" /></p>
<p> 第四步：设置Directories</p>
<p>在Options &gt; Directories中的第一行是头文件的地址，除了BC自带的头文件库外，还得添加自己程序的头文件所在地址。</p>
<p><img src="https://res.cloudinary.com/dh7ramrlh/image/upload/v1576576839/gy/cks5_sezizh.png" style="zoom: 40%;" /></p>
<p><img src="https://res.cloudinary.com/dh7ramrlh/image/upload/v1576576872/gy/cks6_blyehy.jpg" style="zoom:75%;" /></p>
<p>第五步：上述几步都设置好了后就可以编译了</p>
<p>​         Compile &gt; Build all</p>
<p><img src="https://res.cloudinary.com/dh7ramrlh/image/upload/v1576576916/gy/cks7_nhlxc2.jpg" style="zoom:75%;" /></p>
<p>编译没有error，就可以跑了（Run &gt; Run）</p>
<p><img src="https://res.cloudinary.com/dh7ramrlh/image/upload/v1576576954/gy/cks8_tydpvv.jpg" style="zoom:75%;" /></p>
<p><img src="https://res.cloudinary.com/dh7ramrlh/image/upload/v1576576990/gy/cks9_qt7pz1.jpg" style="zoom:75%;" /></p>
<p><img src="https://res.cloudinary.com/dh7ramrlh/image/upload/v1576577029/gy/cks10_kwiqgf.jpg" style="zoom:75%;" /></p>
<p> 之后就自己去玩啦。。。。。</p>
<h2 id="如何搭建项目框架"><a href="#如何搭建项目框架" class="headerlink" title="如何搭建项目框架"></a>如何搭建项目框架</h2><p>接下来我会演示我们组当时建立整个项目的框架，如何建工程《Borland C++建立工程菜鸟教程》中有讲，这里不在赘述。</p>
<h3 id="Notepad-的使用"><a href="#Notepad-的使用" class="headerlink" title="Notepad++的使用"></a>Notepad++的使用</h3><p>建议使用第三方编译器来打代码（如Notepad++）</p>
<p>Notepad++可在官网直接免费下载</p>
<p><img src="https://res.cloudinary.com/dh7ramrlh/image/upload/v1576577065/gy/cks11_cgpuko.jpg" style="zoom:75%;" /></p>
<p>用Notepad++新建一个文件后，一定要记得进行两个设置，一个是汉字（前面提过），一个是C语言。</p>
<p><img src="https://res.cloudinary.com/dh7ramrlh/image/upload/v1576577092/gy/cks12_enrz0y.jpg" alt="编码>编码字符集>中文>GB2312(Simplified)" style="zoom: 25%;" /></p>
<p><img src="https://res.cloudinary.com/dh7ramrlh/image/upload/v1576577155/gy/cks13_dlvq8m.jpg" alt="语言&gt;C&gt;C"></p>
<h3 id="项目框架的搭建"><a href="#项目框架的搭建" class="headerlink" title="项目框架的搭建"></a>项目框架的搭建</h3><p>事例项目test 将放在文件夹中一起提供给大家。</p>
<p>文件夹中需要编写的只有.c 和 .h文件，其余为自动生成和库。</p>
<h4 id="主函数的编写"><a href="#主函数的编写" class="headerlink" title="主函数的编写"></a>主函数的编写</h4><p>主函数 main.c 主要由初始化部分和页面跳转部分组成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"main.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/***********各种初始化*****************/</span></span><br><span class="line">	<span class="comment">/*设定初始页面</span></span><br><span class="line"><span class="comment">	调试的时候可以改变page的初始设定，直接跳转到需要调试的页面</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">int</span> page = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//VGA画图的初始化</span></span><br><span class="line">    <span class="keyword">int</span> graphdriver = VGA;</span><br><span class="line">    <span class="keyword">int</span>	graphmode = VGAHI;</span><br><span class="line">    initgraph(&amp;graphdriver, &amp;graphmode, <span class="string">"BGI"</span>);</span><br><span class="line">	<span class="comment">//鼠标的初始化</span></span><br><span class="line">	mouseinit();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	*********页面跳转循环***********</span></span><br><span class="line"><span class="comment">	每一个页面对应一个page值，</span></span><br><span class="line"><span class="comment">	在各个页面的程序中，每一次有需要跳转页面的时候，就改变page值，且回到主程序</span></span><br><span class="line"><span class="comment">	在主程序的循环中，通过page值的改变，跳转到相应页面</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">switch</span>(page)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:<span class="comment">//页面1（初始页面）</span></span><br><span class="line">			    page = p1();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">				</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//页面2</span></span><br><span class="line">			    page = p2();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">				</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//退出程序</span></span><br><span class="line">				closegraph();<span class="comment">//关闭画图</span></span><br><span class="line">			    <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//退出程序</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>页面跳转依赖while循环和switch case的结合，之后新开页面直接增加case就可以。</p>
<h4 id="页面函数的编写"><a href="#页面函数的编写" class="headerlink" title="页面函数的编写"></a>页面函数的编写</h4><p>页面函数主要是页面绘制和鼠标或者其他控制功能和页面跳转的两个部分。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"page1.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因为需要返回page值，所以页面的函数需是int型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">p1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> page = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//防止鼠标在跳转页面时留痕</span></span><br><span class="line">	clrmous(MouseX,MouseY);</span><br><span class="line">	<span class="built_in">delay</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	page1_screen();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*循环，不停地监测异动，当异动导致page值改变，跳转页面*/</span></span><br><span class="line">	<span class="keyword">while</span>(page == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//获取鼠标的位置和状态</span></span><br><span class="line">		mou_pos(&amp;MouseX,&amp;MouseY,&amp;<span class="built_in">press</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//点击跳转页面框，跳转到页面2界面</span></span><br><span class="line">		<span class="keyword">if</span>(mouse_press(<span class="number">180</span>, <span class="number">170</span>, <span class="number">180</span>+<span class="number">280</span>, <span class="number">170</span>+<span class="number">60</span>) == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			page = <span class="number">1</span>;<span class="comment">//返回1到主函数的页面跳转循环</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//点击退出程序框</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(mouse_press(<span class="number">180</span>, <span class="number">170</span>+<span class="number">60</span>+<span class="number">40</span>, <span class="number">180</span>+<span class="number">280</span>, <span class="number">170</span>+<span class="number">60</span>+<span class="number">40</span>+<span class="number">60</span>) == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			page = <span class="number">2</span>;<span class="comment">//返回2到主函数的页面跳转循环</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制页面1界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">page1_screen</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cleardevice();<span class="comment">//把以前的页面清屏</span></span><br><span class="line">	</span><br><span class="line">	setbkcolor(BLACK);<span class="comment">//背景色设置</span></span><br><span class="line">	</span><br><span class="line">	setfillstyle(SOLID_FILL, BLUE);<span class="comment">//设定蓝色框</span></span><br><span class="line">	bar(<span class="number">180</span>, <span class="number">170</span>, <span class="number">180</span>+<span class="number">280</span>, <span class="number">170</span>+<span class="number">60</span>);<span class="comment">//跳转页面</span></span><br><span class="line">	setfillstyle(SOLID_FILL, RED);<span class="comment">//设定红色框</span></span><br><span class="line">	bar(<span class="number">180</span>, <span class="number">170</span>+<span class="number">60</span>+<span class="number">40</span>, <span class="number">180</span>+<span class="number">280</span>, <span class="number">170</span>+<span class="number">60</span>+<span class="number">40</span>+<span class="number">60</span>);<span class="comment">//退出程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>页面1有两个框，点击蓝框跳转到页面2，点击红框退出程序。</p>
<p>页面2与页面1编写结构相同，只有一个红色的退出框。</p>
<p><img src="https://res.cloudinary.com/dh7ramrlh/image/upload/v1576577257/gy/cks14_hlp79y.jpg" alt="页面1" style="zoom:75%;" /></p>
<p><img src="https://res.cloudinary.com/dh7ramrlh/image/upload/v1576577276/gy/cks15_ezfwi0.jpg" alt="页面2" style="zoom:75%;" /></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"common.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"page2.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">////因为需要返回page值，所以页面的函数需是int型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">p2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> page = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//防止鼠标在跳转页面时留痕</span></span><br><span class="line">	clrmous(MouseX,MouseY);</span><br><span class="line">	<span class="built_in">delay</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	page2_screen();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*循环，不停地监测异动，当异动导致page值改变，跳转页面*/</span></span><br><span class="line">	<span class="keyword">while</span>(page == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//获取鼠标的位置和状态</span></span><br><span class="line">		mou_pos(&amp;MouseX,&amp;MouseY,&amp;<span class="built_in">press</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//点击退出程序框</span></span><br><span class="line">		<span class="keyword">if</span>(mouse_press(<span class="number">180</span>, <span class="number">200</span>, <span class="number">180</span>+<span class="number">280</span>, <span class="number">200</span>+<span class="number">60</span>) == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			page = <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> page;<span class="comment">//返回2到主函数的页面跳转循环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制页面2界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">page2_screen</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cleardevice();<span class="comment">//把以前的页面清屏</span></span><br><span class="line">	</span><br><span class="line">	setbkcolor(BLACK);<span class="comment">//背景色设置</span></span><br><span class="line">	</span><br><span class="line">	setfillstyle(SOLID_FILL, RED);<span class="comment">//设定红色框</span></span><br><span class="line">	bar(<span class="number">180</span>, <span class="number">200</span>, <span class="number">180</span>+<span class="number">280</span>, <span class="number">200</span>+<span class="number">60</span>);<span class="comment">//退出程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="头文件的编写"><a href="#头文件的编写" class="headerlink" title="头文件的编写"></a>头文件的编写</h4><p>头文件的编写有多种形式，这里写的只是我们当时用的那种，其他编写形式也是可以的。</p>
<p>从上面的.c文件中可以看出，我们的每一个.c都调用了两个头文件。</p>
<p>一个是同样的common.h，一个是与其文件名相同的 .h文件。</p>
<p>test的common.h如下图所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _COMMON_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _COMMON_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;dos.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"mouse.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>我们用common.h装了所有需要用到的库文件和鼠标头文件，每次有新调用的库文件就加进去，这样每个.c文件都只要调用common.h，不需要再重新写调用的库文件。</p>
<p>另一种是与文件名相同的 .h文件，以main.h为例。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MAIN_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MAIN_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"page1.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"page2.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>与文件名相同的 .h文件包含两个部分，第一部分是其调用的位于其他文件的函数的头文件，如main中调用了p1()和p2()分别位于page1.h和page2.h；第二部分是该.c文件中所有的函数。</p>
<p>这样我们就搭建了一个有两个页面的简单工程。</p>
<p>最后祝学弟学妹们“0 warning, 0 error.”，之后的路就要靠学弟学妹们自己去探索，老妈子学姐就不再废话啦。</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>华科自动化</tag>
        <tag>C语言课程设计</tag>
        <tag>BorlandC</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编学习笔记</title>
    <url>/2019/12/20/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>汇编学习</p>
<a id="more"></a>
<h1 id="如何在Mac上运行汇编程序"><a href="#如何在Mac上运行汇编程序" class="headerlink" title="如何在Mac上运行汇编程序"></a>如何在Mac上运行汇编程序</h1><h2 id="安装nasm"><a href="#安装nasm" class="headerlink" title="安装nasm"></a>安装nasm</h2><p>在命令行中安装nasm</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install nasm</span><br></pre></td></tr></table></figure>
<p>Mac中虽自带nasm，但版本太老，需重新安装。</p>
<h2 id="新建asm文件"><a href="#新建asm文件" class="headerlink" title="新建asm文件"></a>新建asm文件</h2><p>下面名为 HelloWorld.asm 文件运行可输出hello world!</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msg: db &quot;hello world!&quot;, 0x0a</span><br><span class="line">len: equ $-msg</span><br><span class="line">   </span><br><span class="line">SECTION .text</span><br><span class="line">global _main</span><br><span class="line">   </span><br><span class="line">kernel:</span><br><span class="line">     syscall</span><br><span class="line">     ret</span><br><span class="line">  </span><br><span class="line">_main:</span><br><span class="line">     mov rax,0x2000004</span><br><span class="line">     mov rdi,1</span><br><span class="line">     mov rsi,msg</span><br><span class="line">     mov rdx,len</span><br><span class="line">     call kernel</span><br><span class="line">   </span><br><span class="line">     mov rax,0x2000001</span><br><span class="line">     mov rdi,0</span><br><span class="line">     call kernel</span><br></pre></td></tr></table></figure>
<h2 id="在命令行中运行"><a href="#在命令行中运行" class="headerlink" title="在命令行中运行"></a>在命令行中运行</h2><ul>
<li>根据HelloWorld.asm生成相应的输出文件HelloWorld.o</li>
</ul>
<p>-o outfile    write output to an outfile</p>
<p>-f format     select an output format（指定编译环境）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nasm -f macho64 -o HelloWorld.o HelloWorld.asm</span><br></pre></td></tr></table></figure>
<ul>
<li>生成输出文件HelloWorld（格式：Unix可执行文件）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ld HelloWorld.o -o HelloWorld -macosx_version_min 10.13 -lSystem -no_pie</span><br></pre></td></tr></table></figure>
<ul>
<li>运行HelloWorld文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;HelloWorld</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/12/20/fBoJwRNQp2vZ3xA.png" alt=""></p>
<p>运行成功</p>
<p>此时可看到文件夹中有三种文件（.asm、.o、Unix可执行文件）</p>
<p><img src="https://i.loli.net/2019/12/20/6MdfgvErVatNjUo.png" style="zoom: 67%;" /></p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>直方图均衡化</title>
    <url>/2020/01/15/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>​    直方图均衡化是通过对原图像在像素个数多的灰度级进行展宽，对像素个数少的灰度级进行缩减，使原图像的灰度直方图修正为均匀分布的直方图。</p>
<p><img src="https://i.loli.net/2020/01/16/Sv9pntb6Qay1c2Z.jpg" style="zoom: 33%;" /><img src="https://i.loli.net/2020/01/16/HqY6SxcMLaFrB3U.jpg" style="zoom: 33%;" /></p>
<a id="more"></a>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="由原图像得灰度直方图"><a href="#由原图像得灰度直方图" class="headerlink" title="由原图像得灰度直方图"></a>由原图像得灰度直方图</h2><p>​    计每一个像素值的点的个数。</p>
<p>例如：原图像</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>1</strong></th>
<th><strong>3</strong></th>
<th><strong>9</strong></th>
<th><strong>9</strong></th>
<th><strong>8</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>2</strong></td>
<td><strong>1</strong></td>
<td><strong>3</strong></td>
<td><strong>7</strong></td>
<td><strong>3</strong></td>
</tr>
<tr>
<td><strong>3</strong></td>
<td><strong>6</strong></td>
<td><strong>0</strong></td>
<td><strong>6</strong></td>
<td><strong>4</strong></td>
</tr>
<tr>
<td><strong>6</strong></td>
<td><strong>8</strong></td>
<td><strong>2</strong></td>
<td><strong>0</strong></td>
<td><strong>5</strong></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><strong>9</strong></td>
<td><strong>2</strong></td>
<td><strong>6</strong></td>
<td><strong>0</strong></td>
</tr>
</tbody>
</table>
</div>
<p>灰度直方图</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>灰度级</th>
<th>像素点个数H</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td><strong>3</strong></td>
</tr>
<tr>
<td><strong>1</strong></td>
<td><strong>2</strong></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><strong>4</strong></td>
</tr>
<tr>
<td><strong>3</strong></td>
<td><strong>4</strong></td>
</tr>
<tr>
<td><strong>4</strong></td>
<td><strong>1</strong></td>
</tr>
<tr>
<td><strong>5</strong></td>
<td><strong>1</strong></td>
</tr>
<tr>
<td><strong>6</strong></td>
<td><strong>4</strong></td>
</tr>
<tr>
<td><strong>7</strong></td>
<td><strong>1</strong></td>
</tr>
<tr>
<td><strong>8</strong></td>
<td><strong>2</strong></td>
</tr>
<tr>
<td><strong>9</strong></td>
<td><strong>3</strong></td>
</tr>
</tbody>
</table>
</div>
<h2 id="由灰度直方图得灰度级像素百分比"><a href="#由灰度直方图得灰度级像素百分比" class="headerlink" title="由灰度直方图得灰度级像素百分比"></a>由灰度直方图得灰度级像素百分比</h2><p>​    灰度直方图中的像素点个数 / 总像素点个数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>灰度级</th>
<th>灰度级像素百分比HR</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td><strong>0.12</strong></td>
</tr>
<tr>
<td><strong>1</strong></td>
<td><strong>0.08</strong></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><strong>0.16</strong></td>
</tr>
<tr>
<td><strong>3</strong></td>
<td><strong>0.16</strong></td>
</tr>
<tr>
<td><strong>4</strong></td>
<td><strong>0.04</strong></td>
</tr>
<tr>
<td><strong>5</strong></td>
<td><strong>0.04</strong></td>
</tr>
<tr>
<td><strong>6</strong></td>
<td><strong>0.16</strong></td>
</tr>
<tr>
<td><strong>7</strong></td>
<td><strong>0.04</strong></td>
</tr>
<tr>
<td><strong>8</strong></td>
<td><strong>0.08</strong></td>
</tr>
<tr>
<td><strong>9</strong></td>
<td><strong>0.12</strong></td>
</tr>
</tbody>
</table>
</div>
<h2 id="计算各灰度级的累积分布"><a href="#计算各灰度级的累积分布" class="headerlink" title="计算各灰度级的累积分布"></a>计算各灰度级的累积分布</h2><p><img src="https://i.loli.net/2020/01/16/ntvmADKixyB7r5C.png" style="zoom: 50%;" /></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>灰度级</th>
<th>累积分布HS</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td><strong>0.12</strong></td>
</tr>
<tr>
<td><strong>1</strong></td>
<td><strong>0.20</strong></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><strong>0.36</strong></td>
</tr>
<tr>
<td><strong>3</strong></td>
<td><strong>0.52</strong></td>
</tr>
<tr>
<td><strong>4</strong></td>
<td><strong>0.56</strong></td>
</tr>
<tr>
<td><strong>5</strong></td>
<td><strong>0.60</strong></td>
</tr>
<tr>
<td><strong>6</strong></td>
<td><strong>0.76</strong></td>
</tr>
<tr>
<td><strong>7</strong></td>
<td><strong>0.80</strong></td>
</tr>
<tr>
<td><strong>8</strong></td>
<td><strong>0.88</strong></td>
</tr>
<tr>
<td><strong>9</strong></td>
<td><strong>1.00</strong></td>
</tr>
</tbody>
</table>
</div>
<h2 id="求出新图像的灰度值"><a href="#求出新图像的灰度值" class="headerlink" title="求出新图像的灰度值"></a>求出新图像的灰度值</h2><p><img src="https://i.loli.net/2020/01/16/Xgf4cGaTAyIwhQi.png" alt="image-20200116210709241" style="zoom:80%;" /></p>
<p>​    即乘以灰度级个数后再四舍五入。</p>
<h1 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直方图均衡化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">histogram_equalization</span><span class="params">(Mat &amp;img, Mat &amp;result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> H[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">255</span>; i++) &#123;</span><br><span class="line">        H[i] = <span class="number">0</span>; <span class="comment">// 灰度直方图</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    由原图像得灰度直方图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nrow = <span class="number">0</span>; nrow &lt; img.rows; nrow++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ncol = <span class="number">0</span>; ncol &lt; img.cols; ncol++) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = img.ptr&lt;uchar&gt;(nrow)[ncol];</span><br><span class="line">            H[h] ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    由灰度直方图得灰度级像素百分比</span></span><br><span class="line">    <span class="keyword">int</span> NR = img.rows * img.cols; <span class="comment">// 总像素点个数</span></span><br><span class="line">    <span class="keyword">double</span> HR[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">255</span>; i++) &#123;</span><br><span class="line">        HR[i] = <span class="number">0.0</span>; <span class="comment">// 灰度直方图</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">255</span>; i++) &#123;</span><br><span class="line">        HR[i] = <span class="keyword">double</span>(H[i])/<span class="keyword">double</span>(NR); <span class="comment">// 灰度级像素百分比</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    计算各灰度级的累积分布，并求出新图像的灰度值</span></span><br><span class="line">    <span class="keyword">double</span> HS[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">255</span>; i++) &#123;</span><br><span class="line">        HS[i] = <span class="number">0.0</span>; <span class="comment">// 各灰度级的累积分布</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">255</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            HS[i] += HR[j];</span><br><span class="line">        &#125;</span><br><span class="line">        H[i] = round(HS[i] * <span class="number">255</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    获得新图像</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nrow = <span class="number">0</span>; nrow &lt; img.rows; nrow++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ncol = <span class="number">0</span>; ncol &lt; img.cols; ncol++) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = img.ptr&lt;uchar&gt;(nrow)[ncol];</span><br><span class="line">            result.ptr&lt;uchar&gt;(nrow)[ncol] = H[h];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mat img = imread(<span class="string">"Unequalized.jpg"</span>, IMREAD_GRAYSCALE);</span><br><span class="line">    Mat result = img.clone();</span><br><span class="line">    histogram_equalization(img, result);</span><br><span class="line">    imshow(<span class="string">"img"</span>,img);</span><br><span class="line">    imshow(<span class="string">"Histogram Equalization"</span>,result);</span><br><span class="line">    imwrite(<span class="string">"result.jpg"</span>, result);</span><br><span class="line">    waitKey();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原图像：</p>
<p><img src="https://i.loli.net/2020/01/16/Sv9pntb6Qay1c2Z.jpg" style="zoom:50%;" /></p>
<p>经直方图均衡化后的图像：</p>
<p><img src="https://i.loli.net/2020/01/16/HqY6SxcMLaFrB3U.jpg" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>OpenCV</tag>
        <tag>图像处理</tag>
        <tag>直方图均衡化</tag>
      </tags>
  </entry>
  <entry>
    <title>有序搜索——八数码问题</title>
    <url>/2020/06/13/%E6%9C%89%E5%BA%8F%E6%90%9C%E7%B4%A2%E2%80%94%E2%80%94%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>有序搜索（ordered search）又称最佳优先搜索，设计估价函数选择最有希望的节点最为下一个要扩展的节点。</p>
<a id="more"></a>
<h1 id="有序搜索算法"><a href="#有序搜索算法" class="headerlink" title="有序搜索算法"></a>有序搜索算法</h1><ol>
<li>把起始节点S放到OPEN表中，计算$f(S)$并把其值与节点$S$联系起来。</li>
<li>如果OPEN是个空表，则失败退出，无解。</li>
<li>从OPEN表中选择一个$f$值最小的节点$i$。如果有几个节点合格，当其中有一个为目标节点时，则选择此目标节点，否则就选择其中任一个节点作为节点。</li>
<li>把节点$i$从OPEN表中移出，并把它放入 CLOSED的扩展节点表中。</li>
<li>如果$i$是一个目标节点，则成功退出，求得一个解。</li>
<li>扩展节点$i$，生成其全部后继节点。对于$i$的每一个后继节点$j$：<ol>
<li>计算$f(j)$。</li>
<li>如果$j$既不在OPEN表中，又不在 CLOSED表中，则用估价函数$f$把它添OPEN表。从$j$加一指向其父节点$i$的指针，以便一旦找到目标节点时记住一个解答路径。</li>
<li>如果$j$已在OPEN表或 CLOSED表中，比较刚刚对$j$计算过的$f$值和前面计算过的该节点在表中的$f$值。如果新的$f$值较小，则<ol>
<li>以此新值取代旧值。</li>
<li>从$j$指向$i$，而不是指向它的父节点。</li>
<li>如果节点$j$在 CLOSED表中，则把它移回OPEN表</li>
</ol>
</li>
</ol>
</li>
<li>转向（2），即GOTO（2）。</li>
</ol>
<p>&emsp;&emsp;其中，最为重要的就是估价函数的设计。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/orderedSearch.png" alt=""></p>
<h1 id="八数码问题"><a href="#八数码问题" class="headerlink" title="八数码问题"></a>八数码问题</h1><p>&emsp;&emsp;八数码问题由8个编有1到8并放在$3 \times 3$方格棋盘上的可走动的棋子组成。棋盘上总有一个格是空的，以便让空格周围的棋子走进空格，即移动空格。将棋盘状态由初始状态变换成目标状态。</p>
<p>&emsp;&emsp;比如有下面左图的初始状态转为下面右图的目标状态。</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
        2 & 8 & 3 \\
        1 & 6 & 4 \\
        7 & 0 & 5
\end{bmatrix}
\quad \quad -> \quad \quad
\begin{bmatrix}
        1 & 2 & 3 \\
        8 & 0 & 4 \\
        7 & 6 & 5
\end{bmatrix}</script><h1 id="利用有序搜索求解八数码"><a href="#利用有序搜索求解八数码" class="headerlink" title="利用有序搜索求解八数码"></a>利用有序搜索求解八数码</h1><ol>
<li><p>利用逆转棋子数来判断目标状态是否可达</p>
<p>如初始状态和目标状态的逆转棋子数同奇偶，则目标状态可达；否则，目标状态不可达。</p>
<div class="note info">
            <p>   &emsp;&emsp;逆转棋子数：将棋盘转为一维数组，从该数组中取出一对数，如前面的数大于后面的数，则为一个逆序。棋盘的逆转棋子数则为该棋盘逆序的总数。</p><p>   &emsp;&emsp;如棋盘</p><script type="math/tex; mode=display">    \begin{bmatrix}        2 & 8 & 3 \\        1 & 6 & 4 \\    7 & 0 & 5\end{bmatrix}\quad \quad -> \quad \quad    \begin{bmatrix}        2 & 8 & 3 & 1 & 6 & 4 & 7 & 5    \end{bmatrix}</script><p>   该棋盘的逆转棋子数为 $1+6+1+0+3+2+1+0 = 14$</p>
          </div>
</li>
<li><p>代入有序搜索算法</p>
<figure class="highlight matlab"><figcaption><span>main.m</span></figcaption><table><tr><td class="code"><pre><span class="line">clear;</span><br><span class="line">clc;</span><br><span class="line"></span><br><span class="line">h_select = <span class="number">2</span>;</span><br><span class="line">S = [<span class="number">2</span>,<span class="number">8</span>,<span class="number">3</span>; <span class="number">1</span> <span class="number">6</span> <span class="number">4</span>; <span class="number">7</span>,<span class="number">0</span>,<span class="number">5</span>]; <span class="comment">%起始节点</span></span><br><span class="line">G = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>; <span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>; <span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>]; <span class="comment">%目标节点</span></span><br><span class="line"></span><br><span class="line">reachFlag = <span class="built_in">true</span>;</span><br><span class="line"><span class="comment">% 需逆转数目同奇偶才可达</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">mod</span>(H3(S),<span class="number">2</span>) ~= <span class="built_in">mod</span>(H3(G),<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">"Fail"</span>);</span><br><span class="line">    reachFlag = <span class="built_in">false</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">OPEN = initOPEN(S,G, h_select); <span class="comment">%初始化OPEN表</span></span><br><span class="line">CLOSED = &#123;&#125;; <span class="comment">%初始化CLOSED为空表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> reachFlag</span><br><span class="line">    <span class="comment">% OPEN表为空，则失败，跳出循环</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isempty</span>(OPEN)</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">"Fail"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 对OPEN表中的节点排序筛出f最小节点Node，并将Node从OPEN中删除</span></span><br><span class="line">    [Node, OPEN] = removeMinf(OPEN); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 将Node加入CLOSED表</span></span><br><span class="line">    CLOSED&#123;<span class="number">1</span>, <span class="built_in">length</span>(CLOSED)+<span class="number">1</span>&#125; = Node;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">'第'</span>,num2str(<span class="built_in">length</span>(CLOSED)),<span class="string">'步， '</span>,...</span><br><span class="line">    <span class="string">'第'</span>,num2str(CLOSED&#123;<span class="number">1</span>,<span class="built_in">length</span>(CLOSED)&#125;.depth),<span class="string">'层， '</span>,...</span><br><span class="line">    <span class="string">'总代价'</span>,num2str(CLOSED&#123;<span class="number">1</span>,<span class="built_in">length</span>(CLOSED)&#125;.f)]);</span><br><span class="line">    <span class="built_in">disp</span>(CLOSED&#123;<span class="number">1</span>,<span class="built_in">length</span>(CLOSED)&#125;.state);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 如果Node节点为目标结点，则成功，退出</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isequal</span>(Node.state,G)</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">"Success"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 扩展节点</span></span><br><span class="line">    [OPEN, CLOSED] = expand(Node, G, OPEN, CLOSED, h_select);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展节点</p>
<p>扩展i，得后继节点j，计算f(j)，提供返回的指针，利用f(j)对OPEN表重新排序，调整亲子关系及指针。</p>
<figure class="highlight matlab"><figcaption><span>expand.m</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[OPEN, CLOSED]</span> = <span class="title">expand</span><span class="params">(Node, G, OPEN, CLOSED, h_select)</span></span></span><br><span class="line"><span class="comment">%expand 扩展结点</span></span><br><span class="line"><span class="comment">%   Node为当前节点，G为目标节点，OPEN为OPEN表，CLOSED为CLOSED表</span></span><br><span class="line"><span class="comment">%   OPEN为扩展后的OPEN表，CLOSED为扩展后的CLOSED表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 生成后继节点</span></span><br><span class="line">neighbor_states = [];</span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line">[m,n] = <span class="built_in">find</span>(Node.state==<span class="number">0</span>); <span class="comment">%找到节点的0位置</span></span><br><span class="line">[r, c] = <span class="built_in">size</span>(Node.state);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 空格向左的后继节点</span></span><br><span class="line"><span class="keyword">if</span> n ~= <span class="number">1</span></span><br><span class="line">    len = len+<span class="number">1</span>;</span><br><span class="line">    neighbor_states(:,:,len) = moveLeft(Node.state);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 空格向右的后继节点</span></span><br><span class="line"><span class="keyword">if</span> n ~= c</span><br><span class="line">    len = len+<span class="number">1</span>;</span><br><span class="line">    neighbor_states(:,:,len) = moveRight(Node.state);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 空格向上的后继节点</span></span><br><span class="line"><span class="keyword">if</span> m ~= <span class="number">1</span></span><br><span class="line">    len = len+<span class="number">1</span>;</span><br><span class="line">    neighbor_states(:,:,len) = moveUp(Node.state);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 空格向下的后继节点</span></span><br><span class="line"><span class="keyword">if</span> m ~= r</span><br><span class="line">    len = len+<span class="number">1</span>;</span><br><span class="line">    neighbor_states(:,:,len) = moveDown(Node.state);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 对每个后继节点</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(neighbor_states,<span class="number">3</span>)</span><br><span class="line">    neighborNode.state = neighbor_states(:,:,<span class="built_in">i</span>); <span class="comment">%节点状态</span></span><br><span class="line">    neighborNode.parent = <span class="built_in">length</span>(CLOSED); <span class="comment">%父节点</span></span><br><span class="line">    <span class="comment">% 计算f</span></span><br><span class="line">    neighborNode.depth = Node.depth+<span class="number">1</span>; <span class="comment">%节点深度</span></span><br><span class="line">    <span class="keyword">switch</span> h_select</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> </span><br><span class="line">    		<span class="comment">%估计函数1:取一格局与目的格局相比，其位置不符的棋子数目。</span></span><br><span class="line">        neighborNode.h = H1(neighborNode.state, G); </span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span></span><br><span class="line">    		<span class="comment">%估价函数2：各棋子移到目的位置所需移动距离的总和。</span></span><br><span class="line">        neighborNode.h = H2(neighborNode.state, G); </span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span></span><br><span class="line">    		<span class="comment">%估价函数3：对每一对逆转棋子乘以一个倍数。</span></span><br><span class="line">        neighborNode.h = H3(neighborNode.state); </span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span></span><br><span class="line">    		<span class="comment">%估价函数4：将位置不符棋子数目的总和与3倍棋子逆转数目相加。</span></span><br><span class="line">        neighborNode.h = H1(neighborNode.state, G) ...</span><br><span class="line">        + H3(neighborNode.state); </span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span></span><br><span class="line">    		<span class="comment">%估价函数5：各棋子与目的位置欧式距离平方的总和。</span></span><br><span class="line">        neighborNode.h = H5(neighborNode.state, G);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    neighborNode.f = neighborNode.depth + neighborNode.h;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 添加节点</span></span><br><span class="line">    [OPEN, CLOSED] = addNode(neighborNode, OPEN, CLOSED);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>估价函数</p>
<ul>
<li><p>估价函数1</p>
<p>取一格局与目的格局相比，其位置不符的棋子数目。</p>
<figure class="highlight matlab"><figcaption><span>H1.m</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrongNum</span> = <span class="title">H1</span><span class="params">(N, G)</span></span></span><br><span class="line"><span class="comment">%H1 估价函数1 计算节点N相对于目标棋局错放的棋子个数</span></span><br><span class="line"><span class="comment">%   N为当前节点，G为目标节点</span></span><br><span class="line"><span class="comment">%   WrongNum为错放的棋子个数</span></span><br><span class="line"></span><br><span class="line">[r, c] = <span class="built_in">size</span>(N);</span><br><span class="line">wrongNum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">% 计算节点N相对于目标棋局错放的棋子个数</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:r</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:c</span><br><span class="line">        <span class="comment">% 错放棋子且0位不算在错放个数内</span></span><br><span class="line">        <span class="keyword">if</span> N(<span class="built_in">i</span>,<span class="built_in">j</span>) &amp;&amp; N(<span class="built_in">i</span>,<span class="built_in">j</span>)~=G(<span class="built_in">i</span>,<span class="built_in">j</span>)</span><br><span class="line">            wrongNum = wrongNum+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>估价函数2</p>
<p>各棋子移到目的位置所需移动距离的总和。</p>
<figure class="highlight matlab"><figcaption><span>H2.m</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span> = <span class="title">H2</span><span class="params">(N, G)</span></span></span><br><span class="line"><span class="comment">%H2 估价函数2 各棋子移到目的位置所需移动距离的总和</span></span><br><span class="line"><span class="comment">%   N为当前节点，G为目标节点</span></span><br><span class="line"><span class="comment">%   h为所需移动距离的总和</span></span><br><span class="line">h = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">8</span></span><br><span class="line">    [a,b] = <span class="built_in">find</span>(N==<span class="built_in">i</span>);</span><br><span class="line">    [c,d] = <span class="built_in">find</span>(G==<span class="built_in">i</span>);</span><br><span class="line">    h = h + <span class="built_in">abs</span>(c-a) + <span class="built_in">abs</span>(d-b);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>估价函数3</p>
<p>对每一对逆转棋子乘以一个倍数，这里为$\times 3$。</p>
<figure class="highlight matlab"><figcaption><span>H3.m</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span> = <span class="title">H3</span><span class="params">(N)</span></span></span><br><span class="line"><span class="comment">%H3 估价函数3 对每一对逆转棋子乘以一个倍数。</span></span><br><span class="line"><span class="comment">%   N为当前节点</span></span><br><span class="line"><span class="comment">%   h为3倍逆转棋子数</span></span><br><span class="line">h = <span class="number">0</span>;</span><br><span class="line">N1 = [N(<span class="number">1</span>,:),N(<span class="number">2</span>,:),N(<span class="number">3</span>,:)];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">9</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="built_in">i</span>+<span class="number">1</span>:<span class="number">9</span></span><br><span class="line">        <span class="keyword">if</span> N1(<span class="built_in">i</span>) &gt; N1(<span class="built_in">j</span>) &amp;&amp; N1(<span class="built_in">i</span>)~=<span class="number">0</span> &amp;&amp; N1(<span class="built_in">j</span>)~=<span class="number">0</span></span><br><span class="line">            h = h+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">h = h*<span class="number">3</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>估价函数4</p>
<p>将位置不符棋子数目的总和与3倍棋子逆转数目相加。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%估价函数4：将位置不符棋子数目的总和与3倍棋子逆转数目相加。</span></span><br><span class="line">neighborNode.h = H1(neighborNode.state, G) + H3(neighborNode.state);</span><br></pre></td></tr></table></figure>
</li>
<li><p>估价函数5（自己设计）</p>
<p>各棋子与目的位置欧式距离平方的总和。</p>
<figure class="highlight matlab"><figcaption><span>H5.m</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span> = <span class="title">H5</span><span class="params">(N, G)</span></span></span><br><span class="line"><span class="comment">%H5 估价函数5 欧式距离的平方的总和</span></span><br><span class="line"><span class="comment">%   N为当前节点，G为目标节点</span></span><br><span class="line"><span class="comment">%   h为欧式距离的平方的总和</span></span><br><span class="line">h = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">8</span></span><br><span class="line">    [a,b] = <span class="built_in">find</span>(N==<span class="built_in">i</span>);</span><br><span class="line">    [c,d] = <span class="built_in">find</span>(G==<span class="built_in">i</span>);</span><br><span class="line">    h = h + (c-a)^<span class="number">2</span> + (d-b)^<span class="number">2</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>&emsp;&emsp;利用有序搜索解例题（左图为初始状态，右图为目标状态）</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
        2 & 8 & 3 \\
        1 & 6 & 4 \\
        7 & 0 & 5
\end{bmatrix}
\quad \quad -> \quad \quad
\begin{bmatrix}
        1 & 2 & 3 \\
        8 & 0 & 4 \\
        7 & 6 & 5
\end{bmatrix}</script><ol>
<li><p>估价函数1</p>
<p>取一格局与目的格局相比，其位置不符的棋子数目。</p>
<p>利用估价函数1运行，搜索成功一共经历7个扩展节点。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/h1.jpg" /></p>
</li>
<li><p>估价函数2</p>
<p>各棋子移到目的位置所需移动距离的总和。</p>
<p>利用估价函数2运行，搜索成功一共经历6个扩展节点。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/h2.jpg" /></p>
</li>
<li><p>估价函数3</p>
<p>对每一对逆转棋子乘以一个倍数，这里为$\times 3$。</p>
<p>利用估价函数3运行，搜索成功一共经历8个扩展节点。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/h3.jpg" /></p>
</li>
<li><p>估价函数4</p>
<p>将位置不符棋子数目的总和与3倍棋子逆转数目相加。</p>
<p>利用估价函数4运行，搜索成功一共经历6个扩展节点。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/h4.jpg" /></p>
</li>
<li><p>估价函数5</p>
<p>各棋子与目的位置欧式距离平方的总和。</p>
<p>利用估价函数5运行，搜索成功一共经历6个扩展节点。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/h5.jpg" /></p>
</li>
</ol>
<p>&emsp;&emsp;对于该八数码例题，估价函数2、4、5扩展节点最少，即估价函数2、4、5的搜索效率最高。</p>
<h1 id="Matlab-GUI"><a href="#Matlab-GUI" class="headerlink" title="Matlab GUI"></a>Matlab GUI</h1><p>&emsp;&emsp;从<code>mainPage.m</code>开始运行，可打开八数码GUI页面。（其中初始节点和目标节点可编辑）</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/eightGUI.png" alt=""></p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>有序搜索</tag>
        <tag>八数码问题</tag>
      </tags>
  </entry>
  <entry>
    <title>深度优先搜索（DFS）算法</title>
    <url>/2023/01/14/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88DFS%EF%BC%89%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>图的深度优先搜索（DFS）类似于树的先序遍历，尽可能“深”地搜索一个图。</p>
<a id="more"></a>
<h1 id="DFS-算法"><a href="#DFS-算法" class="headerlink" title="DFS 算法"></a>DFS 算法</h1><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>首先访问某一起始顶点v，再由v出发，访问与v邻接且未访问过的顶点w，在以w为起始顶点出发，访问与w邻接且未访问过的顶点……</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(Graph G, <span class="keyword">int</span> v)</span> </span>&#123; <span class="comment">//从顶点v出发，深度优先遍历图G</span></span><br><span class="line">    visit(v); <span class="comment">//访问v</span></span><br><span class="line">    visited[v] = <span class="literal">true</span>; <span class="comment">//标记v已访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//依次对v的所有未访问过的邻接顶点深度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span> (w = FirstNeighbor(G, v); w &gt;= <span class="number">0</span>; w = NextNeighbor(G, v, w)) &#123; <span class="comment">//遍历邻接顶点</span></span><br><span class="line">        <span class="keyword">if</span> (!visited[w]) &#123; <span class="comment">//未访问过</span></span><br><span class="line">            DFS(G, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下图为例，采用深度优先搜索，且以字母顺序优先，遍历顺序如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
a -> b -> c &-> e \\
       -> d &-> f \\
            &-> g
\end{aligned}</script><pre class="mermaid">graph LR
    a((a))
    b((b))
    c((c))
    d((d))
    e((e))
    f((f))
    g((g))

    a --- b & c
    b --- c & d
    c --- e
    d --- f & g</pre>

<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><ul>
<li><p>空间复杂度</p>
<p>  DPS利用递归，需要一个以每个顶点为起点的DFS函数递归工作栈，空间复杂度为 $O(|V|)$</p>
<p>  （$|V|$ 表示顶点的个数）</p>
</li>
<li><p>时间复杂度</p>
<p>  遍历图实际上是对每一个顶点查找其邻接点的过程，时间复杂度取决于图的存储结构。</p>
<ul>
<li><p>邻接矩阵</p>
<p>  查找每个顶点的邻接点的时间为 $O(|V|)$，总时间复杂度 $O(|V^2|)$</p>
</li>
<li><p>邻接表</p>
<p>  查找所有顶点的邻接点的时间为 $O(|E|)$，（即有多少条边，查找多少次邻接点），访问顶点所需时间为 $O(|V|)$，总时间复杂度 $O(|V|+|E|)$</p>
</li>
</ul>
</li>
</ul>
<h1 id="DFS-例题"><a href="#DFS-例题" class="headerlink" title="DFS 例题"></a>DFS 例题</h1><h2 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>定义一个二维数组 N*M ，如 5 × 5 数组下所示：</p>
<script type="math/tex; mode=display">
maze[5][5] = \begin{pmatrix} 0, 1, 0, 0, 0,\\
0, 1, 1, 1, 0,\\
0, 0, 0, 0, 0,\\
0, 1, 1, 1, 0,\\
0, 0, 0, 1, 0,\\
\end{pmatrix}</script><p>它表示一个迷宫，其中的$1$表示墙壁，$0$表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的路线。入口点为$[0,0]$，既第一格是可以走的路。</p>
<p>数据范围：$2\leq n,m \leq 10$，输入的内容只包含 $0、1$</p>
<ul>
<li><p>输入描述：</p>
<p>  输入两个整数，分别表示二维数组的行数，列数。再输入相应的数组，其中的1表示墙壁，0表示可以走的路。数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。</p>
</li>
<li><p>输出描述：</p>
<p>  左上角到右下角的最短路径</p>
</li>
</ul>
<p>示例一</p>
<blockquote>
<p>输入：<br>5 5<br>0 1 0 0 0<br>0 1 1 1 0<br>0 0 0 0 0<br>0 1 1 1 0<br>0 0 0 1 0<br>输出：<br>(0,0)<br>(1,0)<br>(2,0)<br>(2,1)<br>(2,2)<br>(2,3)<br>(2,4)<br>(3,4)<br>(4,4)</p>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>从迷宫左上角的起点开始，对迷宫进行深度优先遍历，把$1$当作已访问过的点，$0$当作未访问过的点。先尽量“深”地遍历未访问的点，若周围的点都被访问过，则则证明此路不通，回溯到上一个还有未访问的邻接点的点，重新开始深度优先遍历。</p>
<p>对于深度优先遍历的当前点，</p>
<ul>
<li><p>如果该点未访问过，（如果是回溯到该点，则已访问过，不需要进行这两步）</p>
<ul>
<li><p>将该点加入临时路径，该点标记为已访问</p>
</li>
<li><p>如果该点为终点，则当前路径为最终路径</p>
</li>
</ul>
</li>
<li><p>如果存在未访问过的邻接点，则按（下、右、上、左）的优先顺序，访问邻接点，即对该邻接点进行递归的深度优先遍历</p>
</li>
<li><p>如果邻接点都已访问，则进行回溯</p>
<ul>
<li><p>重新修改该点为未访问，将该点弹出临时路径</p>
</li>
<li><p>（利用递归自动实现）通过函数栈回到上一个点的遍历访问，查看剩下的优先顺序的邻接点是否未访问，如不存在未访问的，则继续向上一个点回溯，直到回溯到的点还剩有未访问的邻接点，重新开始深度遍历</p>
</li>
</ul>
</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; final_path; <span class="comment">//最终路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先搜索，maze为迷宫地图，(n, m)为迷宫矩阵的行、列数，(i, j)为当前访问点，tmp_path为当前路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;maze, <span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; &amp;tmp_path)</span> </span>&#123;</span><br><span class="line">    tmp_path.push_back(&#123;i, j&#125;); <span class="comment">//将该点加入临时路径</span></span><br><span class="line">    maze[i][j] = <span class="number">1</span>; <span class="comment">//将该点标记为已访问</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (i == n<span class="number">-1</span> &amp;&amp; j == m<span class="number">-1</span>) &#123; <span class="comment">//如果该点为终点</span></span><br><span class="line">        final_path = tmp_path; <span class="comment">//当前路径为最终路径</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (i+<span class="number">1</span> &lt; n &amp;&amp; maze[i+<span class="number">1</span>][j] == <span class="number">0</span>) &#123; <span class="comment">//如有下邻接点且未访问过</span></span><br><span class="line">        DFS(maze, n, m, i+<span class="number">1</span>, j, tmp_path); <span class="comment">//深度优先遍历下邻接点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j+<span class="number">1</span> &lt; m &amp;&amp; maze[i][j+<span class="number">1</span>] == <span class="number">0</span>) &#123; <span class="comment">//如有右邻接点且未访问过</span></span><br><span class="line">        DFS(maze, n, m, i, j+<span class="number">1</span>, tmp_path); <span class="comment">//深度优先遍历右邻接点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; maze[i<span class="number">-1</span>][j] == <span class="number">0</span>) &#123; <span class="comment">//如有上邻接点且未访问过</span></span><br><span class="line">        DFS(maze, n, m, i<span class="number">-1</span>, j, tmp_path); <span class="comment">//深度优先遍历上邻接点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j<span class="number">-1</span> &gt;= <span class="number">0</span> &amp;&amp; maze[i][j<span class="number">-1</span>] == <span class="number">0</span>) &#123; <span class="comment">//如有左邻接点且未访问过</span></span><br><span class="line">        DFS(maze, n, m, i, j<span class="number">-1</span>, tmp_path); <span class="comment">//深度优先遍历左邻接点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果邻接点都已访问，则进行回溯</span></span><br><span class="line">    maze[i][j] = <span class="number">0</span>;</span><br><span class="line">    tmp_path.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="comment">//矩阵长宽</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">maze</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>))</span></span>; <span class="comment">//迷宫地图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; maze[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; tmp_path;</span><br><span class="line">        DFS(maze, n, m, <span class="number">0</span>, <span class="number">0</span>, tmp_path); <span class="comment">//深度优先搜索得迷宫解</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">point</span> : final_path) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; <span class="built_in">point</span>.first &lt;&lt; <span class="string">","</span> &lt;&lt; <span class="built_in">point</span>.second &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数独游戏"><a href="#数独游戏" class="headerlink" title="数独游戏"></a>数独游戏</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>玩家需要根据9X9盘面上的已知数字，推算出所有剩余空格的数字，并且满足每一行、每一列、每一个3X3粗线宫内的数字均含1-9，并且不重复。</p>
<p>例如：(0代表空缺位)</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20210517/423483716_1621235429962/E29A36714F128D3B9B3E2DA1D8D357D7" alt=""></p>
<p><img src="https://uploadfiles.nowcoder.com/images/20210517/423483716_1621235449608/9D09933CEBE1C910F3FC7B5638CDC516" alt=""></p>
<p>数据范围：输入一个 9*9 的矩阵</p>
<ul>
<li><p>输入描述：</p>
<p>  包含已知数字的9X9盘面数组（空缺位以数字0表示）</p>
</li>
<li><p>输出描述：</p>
<p>  完整的9X9盘面数组</p>
</li>
</ul>
<p>示例一</p>
<blockquote>
<p>输入：<br>0 9 2 4 8 1 7 6 3<br>4 1 3 7 6 2 9 8 5<br>8 6 7 3 5 9 4 1 2<br>6 2 4 1 9 5 3 7 8<br>7 5 9 8 4 3 1 2 6<br>1 3 8 6 2 7 5 9 4<br>2 7 1 5 3 8 6 4 9<br>3 8 6 9 1 4 2 5 7<br>0 4 5 2 7 6 8 3 1<br>输出：<br>5 9 2 4 8 1 7 6 3<br>4 1 3 7 6 2 9 8 5<br>8 6 7 3 5 9 4 1 2<br>6 2 4 1 9 5 3 7 8<br>7 5 9 8 4 3 1 2 6<br>1 3 8 6 2 7 5 9 4<br>2 7 1 5 3 8 6 4 9<br>3 8 6 9 1 4 2 5 7<br>9 4 5 2 7 6 8 3 1</p>
</blockquote>
<p>示例二</p>
<blockquote>
<p>输入：<br>0 0 8 7 1 9 2 4 5<br>9 0 5 2 3 4 0 8 6<br>0 7 4 8 0 6 1 0 3<br>7 0 3 0 9 2 0 0 0<br>5 0 0 0 0 0 0 0 0<br>8 6 1 4 0 3 5 2 9<br>4 0 0 0 2 0 0 0 8<br>0 0 0 0 0 0 0 7 0<br>1 0 7 0 6 8 0 5 0<br>输出：<br>6 3 8 7 1 9 2 4 5<br>9 1 5 2 3 4 7 8 6<br>2 7 4 8 5 6 1 9 3<br>7 4 3 5 9 2 8 6 1<br>5 9 2 6 8 1 4 3 7<br>8 6 1 4 7 3 5 2 9<br>4 5 6 3 2 7 9 1 8<br>3 8 9 1 4 5 6 7 2<br>1 2 7 9 6 8 3 5 4</p>
</blockquote>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>深度优先遍历所有的空缺位，对于每个空缺位，</p>
<ul>
<li>找出目前该空缺位所有可能的取值</li>
<li>如果存在可能的取值<ul>
<li>将可能的取值之一填入</li>
<li>如果当前为最后一个空缺点，且有可能的取值，则求得最终结果</li>
<li>深度优先搜索下一个空缺位</li>
</ul>
</li>
<li>如果不存在可能的取值<ul>
<li>该位恢复成空缺位</li>
<li>回溯回上一个空缺位，换一个可能的取值</li>
</ul>
</li>
</ul>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; blank; <span class="comment">//空缺位</span></span><br><span class="line"><span class="keyword">int</span> final_mp[<span class="number">9</span>][<span class="number">9</span>]; <span class="comment">//最终矩阵</span></span><br><span class="line"><span class="keyword">bool</span> final_flag = <span class="literal">false</span>; <span class="comment">//已求得最终矩阵标志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//找到该点可能的取值</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">find_possible_num</span> <span class="params">(<span class="keyword">int</span> mp[][<span class="number">9</span>], pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag[<span class="number">9</span>] = &#123;<span class="literal">false</span>&#125;; <span class="comment">//相应行、列、3X3粗线宫内出现过的数字为true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> row = p.first, col = p.second; <span class="comment">//p所在行、列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//检验所在行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j) &#123;</span><br><span class="line">        <span class="comment">//如果不是空缺位，且该数字没有出现过</span></span><br><span class="line">        <span class="keyword">if</span> (j != col &amp;&amp; mp[row][j] != <span class="number">0</span> &amp;&amp; !flag[mp[row][j] - <span class="number">1</span>]) &#123;</span><br><span class="line">            flag[mp[row][j] - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检验所在列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">//如果不是空缺位，且该数字没有出现过</span></span><br><span class="line">        <span class="keyword">if</span> (i != row &amp;&amp; mp[i][col] != <span class="number">0</span> &amp;&amp; !flag[mp[i][col] - <span class="number">1</span>]) &#123;</span><br><span class="line">            flag[mp[i][col] - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检验所在3X3粗线宫</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (row/<span class="number">3</span>)*<span class="number">3</span>; i &lt; (row/<span class="number">3</span>)*<span class="number">3</span> + <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = (col/<span class="number">3</span>)*<span class="number">3</span>; j &lt; (col/<span class="number">3</span>)*<span class="number">3</span> + <span class="number">3</span>; ++j) &#123;</span><br><span class="line">            <span class="comment">//如果不是空缺位，且该数字没有出现过</span></span><br><span class="line">            <span class="keyword">if</span> (!(i == row &amp;&amp; j == col) &amp;&amp; mp[i][j] != <span class="number">0</span> &amp;&amp; !flag[mp[i][j] - <span class="number">1</span>]) &#123;</span><br><span class="line">                flag[mp[i][j] - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; possible_num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag[i]) &#123;</span><br><span class="line">            possible_num.push_back(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> possible_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先搜索，mp为目前数独表，n_blank为当前求的空缺位序号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(<span class="keyword">int</span> mp[][<span class="number">9</span>], <span class="keyword">int</span> &amp;n_blank)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; possible_num = find_possible_num(mp, blank[n_blank]);</span><br><span class="line">    <span class="keyword">int</span> row = blank[n_blank].first, col = blank[n_blank].second; <span class="comment">//空缺位所在行、列</span></span><br><span class="line">    <span class="keyword">bool</span> f = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (row &gt;= <span class="number">7</span> &amp;&amp; !f) &#123;</span><br><span class="line">        f = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//依次递归填入可能的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : possible_num) &#123;</span><br><span class="line">        mp[row][col] = num; <span class="comment">//将可能的值填入该空缺位</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果是最后一个空缺位，结束递归遍历</span></span><br><span class="line">        <span class="keyword">if</span> (n_blank == blank.<span class="built_in">size</span>()<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">//将当前矩阵复制到最终矩阵上</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j) &#123;</span><br><span class="line">                    final_mp[i][j] = mp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            final_flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        DFS(mp, ++n_blank); <span class="comment">//向下一个空缺位深度优先搜索</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (final_flag) &#123; <span class="comment">//如已求得最终矩阵，则跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果可能的值都不成立，则进行回溯</span></span><br><span class="line">    mp[row][col] = <span class="number">0</span>; <span class="comment">//恢复空缺位</span></span><br><span class="line">    n_blank--; <span class="comment">//回到上一个空缺位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mp[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; mp[i][j];</span><br><span class="line">            <span class="keyword">if</span> (mp[i][j] == <span class="number">0</span>) &#123; <span class="comment">//0表示空缺位</span></span><br><span class="line">                blank.push_back(&#123;i, j&#125;); <span class="comment">//将空缺位压入blank中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n_blank = <span class="number">0</span>; <span class="comment">//从0号空缺位开始深度优先遍历</span></span><br><span class="line">    DFS(mp, n_blank);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; final_mp[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>深度优先搜索（DFS）</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2023/02/10/%E6%A0%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>栈相关</p>
<a id="more"></a>
<h1 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h1><h2 id="用数组实现栈（顺序栈）"><a href="#用数组实现栈（顺序栈）" class="headerlink" title="用数组实现栈（顺序栈）"></a>用数组实现栈（顺序栈）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Stack.hpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> Stack_hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Stack_hpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    T *data; <span class="comment">//成员数组</span></span><br><span class="line">    <span class="keyword">int</span> top; <span class="comment">//栈顶指针，当前栈顶元素的位置</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>; <span class="comment">//栈中元素的最大个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stack();</span><br><span class="line">    ~Stack();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">()</span></span>; <span class="comment">//判断栈空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_full</span><span class="params">()</span></span>; <span class="comment">//判断栈满</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T &amp;elem)</span></span>; <span class="comment">//入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">//出栈</span></span><br><span class="line">    <span class="function">T <span class="title">get_top</span><span class="params">()</span></span>; <span class="comment">//访问栈顶元素</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈初始化</span></span><br><span class="line"><span class="comment">//初始栈空，栈顶指针指向-1，初始空间为10</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Stack&lt;T&gt;::Stack() : top(<span class="number">-1</span>), <span class="built_in">size</span>(<span class="number">10</span>) &#123;</span><br><span class="line">    data = <span class="keyword">new</span> T[<span class="built_in">size</span>]; <span class="comment">//申请一个初始为10的空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁栈</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Stack&lt;T&gt;::~Stack() &#123;</span><br><span class="line">    <span class="keyword">delete</span> [] data;</span><br><span class="line">    data = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> Stack&lt;T&gt;::is_empty() &#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈满</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> Stack&lt;T&gt;::is_full() &#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="built_in">size</span><span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Stack&lt;T&gt;::push(<span class="keyword">const</span> T &amp;elem) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_full()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> out_of_range(<span class="string">"Stack&lt;&gt;::push(): 栈满"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        data[++top] = elem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Stack&lt;T&gt;::pop() &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_empty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> out_of_range(<span class="string">"Stack&lt;&gt;::pop(): 栈空"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问栈顶元素</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T Stack&lt;T&gt;::get_top() &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_empty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> out_of_range(<span class="string">"Stack&lt;&gt;::top(): 栈空"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data[top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="用链表实现栈（链栈）"><a href="#用链表实现栈（链栈）" class="headerlink" title="用链表实现栈（链栈）"></a>用链表实现栈（链栈）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Stack.hpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> Stack_hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Stack_hpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    T data; <span class="comment">//数据域</span></span><br><span class="line">    node *next; <span class="comment">//指针域</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链栈</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    node&lt;T&gt; *top; <span class="comment">//栈顶指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stack();</span><br><span class="line">    ~Stack();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">()</span></span>; <span class="comment">//判断栈空</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T &amp;elem)</span></span>; <span class="comment">//入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">//出栈</span></span><br><span class="line">    <span class="function">T <span class="title">get_top</span><span class="params">()</span></span>; <span class="comment">//访问栈顶元素</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈初始化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Stack&lt;T&gt;::Stack() &#123;</span><br><span class="line">    top = <span class="literal">nullptr</span>; <span class="comment">//初始为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁栈</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Stack&lt;T&gt;::~Stack() &#123;</span><br><span class="line">    node&lt;T&gt; *ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (!is_empty()) &#123;</span><br><span class="line">        ptr = top-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> top;</span><br><span class="line">        top = ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> Stack&lt;T&gt;::is_empty() &#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Stack&lt;T&gt;::push(<span class="keyword">const</span> T &amp;elem) &#123;</span><br><span class="line">    node&lt;T&gt; *ptr = <span class="keyword">new</span> node&lt;T&gt;;</span><br><span class="line">    ptr-&gt;data = elem;</span><br><span class="line">    ptr-&gt;next = top;</span><br><span class="line">    top = ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Stack&lt;T&gt;::pop() &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_empty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> out_of_range(<span class="string">"Stack&lt;&gt;::pop(): 栈空"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node&lt;T&gt; *ptr = top-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> top;</span><br><span class="line">        top = ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问栈顶元素</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T Stack&lt;T&gt;::get_top() &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_empty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> out_of_range(<span class="string">"Stack&lt;&gt;::top(): 栈空"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h1 id="stack（栈）"><a href="#stack（栈）" class="headerlink" title="stack（栈）"></a>stack（栈）</h1><h2 id="函数方法"><a href="#函数方法" class="headerlink" title="函数方法"></a>函数方法</h2><div class="table-container">
<table>
<thead>
<tr>
<th>代码</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.push(x)</td>
<td>将x压入栈顶</td>
</tr>
<tr>
<td>s.top()</td>
<td>返回栈顶的元素</td>
</tr>
<tr>
<td>s.pop()</td>
<td>删除栈顶的元素</td>
</tr>
<tr>
<td>s.size()</td>
<td>返回栈中元素的个数</td>
</tr>
<tr>
<td>s.empty()</td>
<td>检查栈是否为空,若为空返回true,否则返回false</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>问题归约——梵塔问题</title>
    <url>/2020/05/11/%E9%97%AE%E9%A2%98%E5%BD%92%E7%BA%A6%E2%80%94%E2%80%94%E6%A2%B5%E5%A1%94%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>问题归约（problem reduction）是一种基于状态空间的问题描述与求解方法。已知问题的描述，通过一系列变换把此问题最终变为一个本原问题集合。</p>
<a id="more"></a>
<h1 id="梵塔问题描述"><a href="#梵塔问题描述" class="headerlink" title="梵塔问题描述"></a>梵塔问题描述</h1><p>&emsp;&emsp;有3根柱子1、2、3柱和N个不同尺寸的圆盘，初始圆盘套在1柱上，盘的尺寸由下到上依次变小。要求将圆盘全部搬到3柱，搬运过程中要遵守下面规定：</p>
<ol>
<li>每次只能移动一个圆盘；</li>
<li>大盘不能叠在小盘上面。</li>
</ol>
<h1 id="求解思路"><a href="#求解思路" class="headerlink" title="求解思路"></a>求解思路</h1><p>&emsp;&emsp;原问题可以拆分成下列子问题。（以4圆盘问题为例，圆盘从小到大分别是A、B、C、D）</p>
<ol>
<li>移动圆盘A、B和C至柱2（3圆盘问题）</li>
<li>移动圆盘D到柱3（单圆盘问题）</li>
<li>移动圆盘A、B和C至柱3（3圆盘问题）</li>
</ol>
<p>如此将4圆盘问题化为两个3圆盘问题和一个单圆盘问题，而3圆盘问题还可继续分解，直到化为单圆盘问题（本原问题）的集合。这便是问题归约。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/hanoi.jpg" style="zoom: 25%;" /></p>
<h1 id="Matlab代码"><a href="#Matlab代码" class="headerlink" title="Matlab代码"></a>Matlab代码</h1><h2 id="调用代码"><a href="#调用代码" class="headerlink" title="调用代码"></a>调用代码</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear; <span class="comment">%清除变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 设置的圆盘个数n</span></span><br><span class="line">n = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">1</span></span><br><span class="line">    fprintf(<span class="string">'圆盘个数需为正整数。\n'</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    HannoiStep = hannoi(n, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>); <span class="comment">% 解梵塔问题</span></span><br><span class="line">    HannoiStep</span><br><span class="line">    clear hannoi <span class="comment">% 清除hannoi文件的变量</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">7</span></span><br><span class="line">       StepAnimation(HannoiStep); <span class="comment">% 动画演示步骤 </span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fprintf(<span class="string">'圆盘太多了，没位置画，圆盘数1～7可以演示。\n'</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><figure class="highlight matlab"><figcaption><span>hannoi.m</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">% n个圆盘，返回步骤矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HannoiStep</span> = <span class="title">hannoi</span><span class="params">(n, A, B, C)</span></span></span><br><span class="line"><span class="comment">% 创建步骤矩阵</span></span><br><span class="line"><span class="keyword">persistent</span> steps;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isempty</span>(steps)</span><br><span class="line">    steps = <span class="built_in">ones</span>(<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 如果是一个圆盘，直接从A移动到C</span></span><br><span class="line"><span class="keyword">if</span> n == <span class="number">1</span></span><br><span class="line">    [r, ~] = <span class="built_in">size</span>(steps);</span><br><span class="line">    step = steps(r,:);</span><br><span class="line">    step(<span class="number">1</span>) = C-<span class="string">'A'</span>+<span class="number">1</span>;</span><br><span class="line">    steps = [steps; step];</span><br><span class="line"><span class="comment">%     fprintf('1 号碟 : %s  ---&gt; %s\n', A, C);</span></span><br><span class="line">    HannoiStep = steps;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">% 否则，先将n-1个圆盘从A经过C移动到B</span></span><br><span class="line">    hannoi(n<span class="number">-1</span>, A, C, B);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 将第n个圆盘从A移动到C</span></span><br><span class="line">    [r, ~] = <span class="built_in">size</span>(steps);</span><br><span class="line">    step = steps(r,:);</span><br><span class="line">    step(n) = C-<span class="string">'A'</span>+<span class="number">1</span>;</span><br><span class="line">    steps = [steps; step];</span><br><span class="line"><span class="comment">%     fprintf('%d 号碟 : %s  ---&gt; %s\n', n, A, C);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 将n-1个圆盘从B经过A移动到C</span></span><br><span class="line">    hannoi(n<span class="number">-1</span>, B, A, C);</span><br><span class="line">    HannoiStep = steps;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="动画代码"><a href="#动画代码" class="headerlink" title="动画代码"></a>动画代码</h2><figure class="highlight matlab"><figcaption><span>StepAnimation.m</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StepAnimation</span><span class="params">(HannoiStep)</span></span></span><br><span class="line">[r,~] = <span class="built_in">size</span>(HannoiStep);</span><br><span class="line"><span class="keyword">for</span> index = <span class="number">1</span> : <span class="number">1</span> : r</span><br><span class="line">    step = HannoiStep(index,:);</span><br><span class="line">    pause_times = <span class="number">1</span>;</span><br><span class="line">    DrawFrame(step)</span><br><span class="line">    pause(pause_times);</span><br><span class="line">    <span class="keyword">if</span> index &lt; r</span><br><span class="line">        clf; <span class="comment">% 清除图形</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DrawFrame</span><span class="params">(step)</span></span></span><br><span class="line">[~,n] = <span class="built_in">size</span>(step); <span class="comment">% n为圆盘数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 初始颜色数组</span></span><br><span class="line">coArray = [</span><br><span class="line">    [<span class="number">0</span> <span class="number">0.4470</span> <span class="number">0.7410</span>];</span><br><span class="line">    [<span class="number">0.8500</span> <span class="number">0.3250</span> <span class="number">0.0980</span>];</span><br><span class="line">    [<span class="number">0.4660</span> <span class="number">0.6740</span> <span class="number">0.1880</span>];</span><br><span class="line">    [<span class="number">0.9290</span> <span class="number">0.6940</span> <span class="number">0.1250</span>];</span><br><span class="line">    [<span class="number">0.3010</span> <span class="number">0.7450</span> <span class="number">0.9330</span>];</span><br><span class="line">    [<span class="number">0.4940</span> <span class="number">0.1840</span> <span class="number">0.5560</span>];</span><br><span class="line">    [<span class="number">0.6350</span> <span class="number">0.0780</span> <span class="number">0.1840</span>];</span><br><span class="line">    ]; </span><br><span class="line"></span><br><span class="line"><span class="comment">% 初始x坐标数组</span></span><br><span class="line">xArray = <span class="built_in">linspace</span>(<span class="number">0.5</span>,<span class="number">1.5</span>,n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">3</span></span><br><span class="line">    subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="built_in">i</span>);</span><br><span class="line">    axis([<span class="number">-1.5</span>,<span class="number">1.5</span>,<span class="number">0</span>,<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">% 绘制柱  </span></span><br><span class="line">    line([<span class="number">0</span> <span class="number">0</span>],[<span class="number">0.5</span> <span class="number">3</span>],<span class="string">'LineWidth'</span>,<span class="number">10</span>,<span class="string">'Color'</span>,[<span class="number">0.3</span> <span class="number">0.3</span> <span class="number">0.3</span>]);</span><br><span class="line">    line([<span class="number">-1.5</span> <span class="number">1.5</span>],[<span class="number">0.5</span> <span class="number">0.5</span>],<span class="string">'LineWidth'</span>,<span class="number">10</span>,<span class="string">'Color'</span>,[<span class="number">0.3</span> <span class="number">0.3</span> <span class="number">0.3</span>]);</span><br><span class="line">    <span class="comment">% 绘制圆盘</span></span><br><span class="line">    <span class="keyword">for</span> index = n : <span class="number">-1</span> : <span class="number">1</span></span><br><span class="line">        <span class="comment">% 如果该圆盘在这根柱上       </span></span><br><span class="line">        <span class="keyword">if</span> step(index) == <span class="built_in">i</span></span><br><span class="line">            Ynum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">j</span> = n : <span class="number">-1</span> : index+<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> step(<span class="built_in">j</span>) == <span class="built_in">i</span></span><br><span class="line">                    Ynum = Ynum+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">% 画圆盘</span></span><br><span class="line">            line([-xArray(index) xArray(index)],[<span class="number">0.7</span>+<span class="number">0.3</span>*Ynum...</span><br><span class="line">                <span class="number">0.7</span>+<span class="number">0.3</span>*Ynum],<span class="string">'LineWidth'</span>,<span class="number">30</span>,<span class="string">'Color'</span>,coArray(index,:));</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    axis off;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><p>&emsp;&emsp;以4圆盘问题为例，运行上述代码，可求解。</p>
<ul>
<li><p>与或图</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/梵塔问题与或图.png" alt=""></p>
</li>
<li><p>步骤</p>
</li>
</ul>
<script type="math/tex; mode=display">
HannoiStep =\begin{bmatrix}
     1\quad     1\quad     1\quad     1\\
     2\quad     1\quad     1\quad     1\\
     2\quad     3\quad     1\quad     1\\
     3\quad     3\quad     1\quad     1\\
     3\quad     3\quad     2\quad     1\\
     1\quad     3\quad     2\quad     1\\
     1\quad     2\quad     2\quad     1\\
     2\quad     2\quad     2\quad     1\\
     2\quad     2\quad     2\quad     3\\
     3\quad     2\quad     2\quad     3\\
     3\quad     1\quad     2\quad     3\\
     1\quad     1\quad     2\quad     3\\
     1\quad     1\quad     3\quad     3\\
     2\quad     1\quad     3\quad     3\\
     2\quad     3\quad     3\quad     3\\
     3\quad     3\quad     3\quad     3\\
     \end{bmatrix}</script><p><img src="https://media2.giphy.com/media/W1eVeuKI0m0th68lCm/200w.gif" style="zoom:150%;" /></p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>问题归约</tag>
        <tag>梵塔问题</tag>
      </tags>
  </entry>
  <entry>
    <title>雾天图像理解算法研究</title>
    <url>/2021/04/04/%E9%9B%BE%E5%A4%A9%E5%9B%BE%E5%83%8F%E7%90%86%E8%A7%A3%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>在自动驾驶的过程中，图像语义分割是其视觉系统中很重要的一环，现有的不少算法在晴天条件下对图像进行处理表现良好，但是一旦出现如雾天等恶劣天气，原有系统对图像的处理效果将大大降低。</p>
<p>本课题旨在通过算法途径，以图像复原为手段，提升图像理解算法在雾天条件下的感知能力，基于大气退化物理模型对雾天图像进行语义分割。</p>
<a id="more"></a>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本毕业设计研究的主要内容是自动驾驶环境下雾天图像的语义分割。作为自动驾驶汽车视觉系统中的重要一环，语义分割的准确度直接影响了自动驾驶汽车的安全性能。现有的语义分割算法在晴朗天气下表现良好，但是在一旦遇到如大雾等不良天气，其分割效果就会大打折扣。为了解决雾天图像的语义分割问题，本次实验利用基于雾天成像物理模型的深度卷积神经网络对雾天图像进行复原，恢复出去雾图像，再在去雾图像上进行语义分割，提高雾天环境下语义分割的准确度。</p>
<p>针对自然条件下难以获得同一场景的无雾/有雾图像对数据的问题，本文选择Cityscapes室外街景晴天图像来合成有雾图像。通过双目视差恢复出原始深度映射，再基于分割进行深度的补全，依照设定的大气散射系数，由深度图像得到相应的传输率图像，再根据雾天大气退化原理合成不同浓度下的有雾图像。该方法合成的有雾图像效果逼真，为后续神经网络的训练提供了大量的无雾/有雾图像对。</p>
<p>针对语义分割受到雾天场景影响的问题，本文提出了一个先图像复原再语义分割的框架。基于雾天大气退化模型，先对传输率进行估计，再生成相应的去雾图像。本文构建了一个深度卷积网络以增大模型的表达能力，同时为了避免网络加深导致的梯度消失问题，引入了残差模块。对网络的去雾效果从视觉指标和定量化指标（PSNR、SSIM）两个维度进行评价，验证了该网络去雾的有效性。</p>
<p>为了进一步验证图像复原工作对语义分割的促进作用，本文将AOD-Net和本文算法模型所得的去雾图像分别输入语义分割网络，与数据集标签进行比较，得到分割的准确度。实验证明，本文提出的去雾网络相比于AOD-Net不仅在图像质量评价指标上有着显著提升，还进一步提升了语义分割的准确度，验证了本文网络对雾天场景语义分割的巨大促进作用。</p>
<p><strong>关键词：</strong>雾天图像的合成；深度卷积网络；单幅图像去雾；雾天图像的语义分割</p>
<h1 id="合成雾图"><a href="#合成雾图" class="headerlink" title="合成雾图"></a>合成雾图</h1><p>参考Semantic Foggy Scene Understanding with Synthetic Data</p>
<h2 id="雾天图像退化模型"><a href="#雾天图像退化模型" class="headerlink" title="雾天图像退化模型"></a>雾天图像退化模型</h2><p>光线在大气中传播的过程中会接触到空气中的颗粒，形成散射，使得原方向上的光线强度衰减，能量发散到其他方向。随着雾的浓度的增大，空气中的颗粒也就愈加密集，光的散射程度也随之增加。</p>
<p>雾天图像退化模型中，光学传感器接收到的光分为两个部分：一是目标物体反射的光，反射光从目标物体传播到光学传感器，途中会受到空气颗粒的散射，导致光强减小；二是周围的环境光，也叫大气光，由大气中其他光源散射至光学传感器。</p>
<p>根据能量守恒定律，目标物体反射光中散射掉的比例应等于大气光散射到光学传感器的比例，由此可以得到以下雾成像机理的线性模型</p>
<script type="math/tex; mode=display">
I(x)=J(x)t(x)+A(1-t(x))</script><p>其中，I(x)为有雾图像，J(x)为晴天图像，t(x)为中间介质透射率（即目标物体反射光中成功到达相机，没有被散射掉的光的比例），A为全局大气光强。有雾图像I(x)可分为衰减模型J(x)t(x)和环境光模型A(1-t(x))。</p>
<h2 id="雾合成"><a href="#雾合成" class="headerlink" title="雾合成"></a>雾合成</h2><p>根据雾成像机制公式</p>
<script type="math/tex; mode=display">
I(x)=R(x)t(x)+L(1-t(x))</script><p>要从晴图R(x)得到雾图I(x)，还需要两个参数——中间透射率t(x)和大气光L。</p>
<h3 id="求中间透射率t-x"><a href="#求中间透射率t-x" class="headerlink" title="求中间透射率t(x)"></a>求中间透射率t(x)</h3><p>数据集通过双目相机对街道进行拍摄，再通过双目匹配算法可以得到以下输入：</p>
<ul>
<li>晴图左通道R</li>
<li>晴图右通道Q</li>
<li>双目相机参数</li>
<li>预估视差D</li>
<li>无视差值D的所有像素点集合</li>
</ul>
<p>计算中间透射率t(x)的步骤：</p>
<ol>
<li>通过视差D计算出大致的深度图d</li>
<li>去噪，完成一个以米为单位的深度图d’</li>
<li>从深度图d’得场景距离图l</li>
<li></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>高斯滤波&amp;均值滤波&amp;中值滤波</title>
    <url>/2020/03/01/%E9%AB%98%E6%96%AF%E6%BB%A4%E6%B3%A2-%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2-%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>​    图像滤波，即在尽量保留图像细节特征的条件下对噪声进行抑制，通过抑制高频段来减少噪音，同时会照成图像一定程度上的模糊，这也叫做平滑或者低通滤波器。</p>
<a id="more"></a>
<h1 id="滤波"><a href="#滤波" class="headerlink" title="滤波"></a>滤波</h1><p>&emsp;&emsp;滤波本来应该是在傅立叶变换的频谱上对图像进行处理，但由于傅立叶的卷积特性</p>
<script type="math/tex; mode=display">
F[g*h]=F[g]F[h]</script><p>滤波后的图像可以由原图像和滤波算子做卷积生成（频域的乘积 =&gt; 空域的卷积）</p>
<script type="math/tex; mode=display">
g*h=F^{-1}[F[g]F[h]]</script><h1 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h1><p>​    高斯滤波器是利用高斯核的一个2维的卷积算子（线性滤波器），对于抑制服从正态分布的噪声非常有效。</p>
<h2 id="高斯分布"><a href="#高斯分布" class="headerlink" title="高斯分布"></a>高斯分布</h2><h3 id="一维高斯分布"><a href="#一维高斯分布" class="headerlink" title="一维高斯分布"></a>一维高斯分布</h3><p><img src="http://imglf3.nosdn0.126.net/img/d2tnT2w1QS9GOGo0emJzcWU4WGxFWDVvMk1PbnpqZi9mUWNHRDBGSHRuODJyTGRzZEllWW53PT0.png?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0" style="zoom: 35%;" /></p>
<p><img src="http://imglf6.nosdn0.126.net/img/d2tnT2w1QS9GOGpDMnJtd2l3RG84OENkOXp2dHhMNVZHbmpoR0htRlhndllRRmdUS3hjUTBnPT0.jpg?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg" style="zoom:80%;" /></p>
<p>&emsp;&emsp;其中，σ描述正态分布资料数据分布的离散程度，σ越大，数据分布越分散，σ越小，数据分布越集中。也称为是正态分布的形状参数，σ越大，曲线越扁平，反之，σ越小，曲线越瘦高。</p>
<h3 id="二维高斯分布"><a href="#二维高斯分布" class="headerlink" title="二维高斯分布"></a>二维高斯分布</h3><p><img src="http://imglf5.nosdn0.126.net/img/d2tnT2w1QS9GOGo0emJzcWU4WGxFUzdzakg3dCtab01xS1VNSmF0bWJDSDFKbDJodTdYc1lRPT0.png?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0" style="zoom:50%;" /></p>
<p><img src="http://imglf3.nosdn0.126.net/img/d2tnT2w1QS9GOGpDMnJtd2l3RG84N3VWK1pBcG4wSmVzNFRDSTNqOEtjWEJFZ3R1SFNjazRBPT0.jpeg?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg" style="zoom:75%;" /></p>
<h3 id="高斯核"><a href="#高斯核" class="headerlink" title="高斯核"></a>高斯核</h3><p>&emsp;&emsp;高斯核主要有两个参数：高斯核的大小、离散程度σ</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">h = fspecial(<span class="string">'gaussian'</span>,hsize,sigma)</span><br></pre></td></tr></table></figure>
<p><strong>高斯核的大小</strong>：按高斯分布，理论上需要一个无限大的卷积核。但实际上，仅需要取均值周围3倍标准差内的值（高斯核单边大小为3σ），以外部分直接去掉即可。（没必要用很大的高斯核）</p>
<p><strong>离散程度σ</strong>：σ越大，数据分布越分散，平滑程度越强，对高频的抑制程度更大。</p>
<p><img src="http://imglf4.nosdn0.126.net/img/d2tnT2w1QS9GOGpDMnJtd2l3RG84N2pacFdiUEJBa3BzVWxkd0FaZHpRYllpMnlIdm91RUtBPT0.png?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0" style="zoom: 60%;" /></p>
<p>&emsp;&emsp;高斯滤波再高斯滤波还是高斯滤波，两个σ的高斯滤波相当于一次$\sqrt{2}\sigma$。</p>
<h2 id="Matlab实现"><a href="#Matlab实现" class="headerlink" title="Matlab实现"></a>Matlab实现</h2><figure class="highlight matlab"><figcaption><span>Gauss</span></figcaption><table><tr><td class="code"><pre><span class="line">img = imread(<span class="string">'Lenna.jpg'</span>);</span><br><span class="line">img = rgb2gray(img);</span><br><span class="line">sigma = <span class="number">1</span>;</span><br><span class="line">gausFilter = fspecial(<span class="string">'gaussian'</span>, [<span class="number">5</span>,<span class="number">5</span>], sigma);</span><br><span class="line">gaus= imfilter(img, gausFilter, <span class="string">'replicate'</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>),imshow(img,[]),title(<span class="string">'原图'</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>),imshow(gausFilter,[]),title(<span class="string">'高斯核'</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>),imshow(gaus,[]),title(<span class="string">'高斯滤波后的图像'</span>);</span><br><span class="line"></span><br><span class="line">F1 = DFT(img);</span><br><span class="line">F2 = DFT(gausFilter);</span><br><span class="line">F3 = DFT(gaus);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>),imshow(F1,[]),title(<span class="string">'原图的频谱图'</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>),imshow(F2,[]),title(<span class="string">'高斯核的频谱图'</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>),imshow(F3,[]),title(<span class="string">'高斯滤波后的频谱图'</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><figcaption><span>Gauss</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span> = <span class="title">DFT</span><span class="params">(img)</span></span></span><br><span class="line"><span class="comment">% 离散傅里叶变换频谱图</span></span><br><span class="line">img_Double = double(img);<span class="comment">% 将灰度图归一化处理</span></span><br><span class="line">F = fft2(img_Double); <span class="comment">% 二维快速傅里叶变换 </span></span><br><span class="line">F = fftshift(F); <span class="comment">% FFT频谱平移</span></span><br><span class="line">F = <span class="built_in">log</span>(<span class="number">1</span>+<span class="built_in">abs</span>(F)); <span class="comment">% 频谱对数变换（由于幅度值范围很大，所以要取对数处理）</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看出图像的高频部分受到了抑制，但并不是完全截断了高频。空域中的高斯到频域中依旧是高斯。</p>
<p>&emsp;&emsp;</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Guass_Filter.jpg" alt=""></p>
<h2 id="openCV实现（openCV提供的函数）"><a href="#openCV实现（openCV提供的函数）" class="headerlink" title="openCV实现（openCV提供的函数）"></a>openCV实现（openCV提供的函数）</h2><h3 id="cv-GaussianBlur"><a href="#cv-GaussianBlur" class="headerlink" title="cv :: GaussianBlur"></a>cv :: GaussianBlur</h3><p>​    openCV自带的高斯滤波器：<a href="http://docs.opencv.org/master/d4/d86/group__imgproc__filter.html#gaabe8c836e97159a9193fb0b11ac52cf1" target="_blank" rel="noopener">cv :: GaussianBlur</a></p>
<ul>
<li>库文件：<code>#include &lt;opencv2/imgproc.hpp&gt;</code></li>
<li>作用：该函数将源图像与指定的高斯内核进行卷积。</li>
<li>调用方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>void cv::GaussianBlur</th>
<th>(</th>
<th><a href="https://docs.opencv.org/master/dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba" target="_blank" rel="noopener">InputArray</a></th>
<th><em>src</em>,</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td><a href="https://docs.opencv.org/master/dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0" target="_blank" rel="noopener">OutputArray</a></td>
<td><em>dst</em>,</td>
</tr>
<tr>
<td></td>
<td></td>
<td><a href="https://docs.opencv.org/master/dc/d84/group__core__basic.html#ga346f563897249351a34549137c8532a0" target="_blank" rel="noopener">Size</a></td>
<td><em>ksize</em>,</td>
</tr>
<tr>
<td></td>
<td></td>
<td>double</td>
<td><em>sigmaX</em>,</td>
</tr>
<tr>
<td></td>
<td></td>
<td>double</td>
<td><em>sigmaY</em> = <code>0</code>,</td>
</tr>
<tr>
<td></td>
<td></td>
<td>int</td>
<td><em>borderType</em> = <a href="https://docs.opencv.org/master/d2/de8/group__core__array.html#gga209f2f4869e304c82d07739337eae7c5afe14c13a4ea8b8e3b3ef399013dbae01" target="_blank" rel="noopener">BORDER_DEFAULT</a></td>
</tr>
<tr>
<td></td>
<td></td>
<td>)</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>参量</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>src</th>
<th>输入图像；图像可以具有任意数量的通道，这些通道可以独立处理，但深度应为CV_8U，CV_16U，CV_16S，CV_32F或CV_64F。</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>dst</strong></td>
<td>输出与src大小和类型相同的图像。</td>
</tr>
<tr>
<td><strong>size</strong></td>
<td>高斯核大小。ksize.width和ksize.height可以不同，但它们都必须为正数和奇数。或者，它们可以为零，然后根据sigma计算得出。</td>
</tr>
<tr>
<td><strong>sigmaX</strong></td>
<td>X方向上的高斯核标准偏差。</td>
</tr>
<tr>
<td><strong>sigmaY</strong></td>
<td>Y方向的高斯核标准差；如果sigmaY为零，则将其设置为等于sigmaX；如果两个sigmas为零，则分别从ksize.width和ksize.height计算得出（有关详细信息，请参见<a href="https://docs.opencv.org/master/d4/d86/group__imgproc__filter.html#gac05a120c1ae92a6060dd0db190a61afa" target="_blank" rel="noopener">getGaussianKernel</a>）；为了完全控制结果，而不管将来可能对所有这些语义进行的修改，建议指定所有ksize，sigmaX和sigmaY。</td>
</tr>
<tr>
<td><strong>borderType</strong></td>
<td>像素外推方法，请参见<a href="https://docs.opencv.org/master/d2/de8/group__core__array.html#ga209f2f4869e304c82d07739337eae7c5" target="_blank" rel="noopener">BorderTypes</a></td>
</tr>
</tbody>
</table>
</div>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mat src = imread(<span class="string">"Lenna.jpg"</span>, IMREAD_GRAYSCALE); <span class="comment">//从文件中加载灰度图像</span></span><br><span class="line">    Mat dst;</span><br><span class="line">    <span class="comment">// 读取图片失败，则停止</span></span><br><span class="line">    <span class="keyword">if</span> (src.empty()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"读取图像文件失败"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 高斯滤波，高斯核大小为5*5</span></span><br><span class="line">    GaussianBlur(src, dst, Size(<span class="number">5</span>,<span class="number">5</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    imshow(<span class="string">"dst"</span>,dst);</span><br><span class="line">    imwrite(<span class="string">"gas_openCV.jpg"</span>, dst);</span><br><span class="line">    waitKey();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="http://imglf3.nosdn0.126.net/img/d2tnT2w1QS9GOGlkb3dEbkVzbEtFckxINERaV0NzZFd1T29Halp0QTQya3hzRGtPUTFCN2xRPT0.jpg?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg" alt=""></p>
<p><img src="http://imglf6.nosdn0.126.net/img/d2tnT2w1QS9GOGlkb3dEbkVzbEtFdDNPdDdmN3h4SExHcmtmYWxTbHhKdFlleUhkb1JiU2hnPT0.jpg?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg" alt=""></p>
<p>原图像和经高斯滤波后图像的傅立叶变换频谱</p>
<p><img src="http://imglf5.nosdn0.126.net/img/d2tnT2w1QS9GOGo0emJzcWU4WGxFWVBZT2RldFFuMitvYmIyMjFnMnV6WllXTG5UaUxRR3pnPT0.png?imageView&thumbnail=500x0&quality=96&stripmeta=0" style="zoom: 50%;" /></p>
<p><img src="http://imglf3.nosdn0.126.net/img/d2tnT2w1QS9GOGo0emJzcWU4WGxFWXo4ZXhLMVo0WEIwdFE0TkZBOVIxcU5YK2hDQW5iQUdRPT0.png?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0" style="zoom:50%;" /></p>
<h2 id="C-实现（函数自己编写）"><a href="#C-实现（函数自己编写）" class="headerlink" title="C++实现（函数自己编写）"></a>C++实现（函数自己编写）</h2><p>​    如利用5*5的高斯核，对图像进行卷积。</p>
<p><img src="http://imglf4.nosdn0.126.net/img/d2tnT2w1QS9GOGpDMnJtd2l3RG84N2pacFdiUEJBa3BzVWxkd0FaZHpRYllpMnlIdm91RUtBPT0.png?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0" style="zoom: 60%;" /></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 利用5*5的高斯核进行高斯滤波</span></span><br><span class="line"><span class="comment"> img 输入原图像</span></span><br><span class="line"><span class="comment"> dst 高斯滤波后的输出图像</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Gaussian_Blur</span><span class="params">(Mat &amp;img, Mat &amp;dst)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Kernel[<span class="number">5</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>,<span class="number">16</span>,<span class="number">26</span>,<span class="number">16</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="number">7</span>,<span class="number">26</span>,<span class="number">41</span>,<span class="number">26</span>, <span class="number">7</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>,<span class="number">16</span>,<span class="number">26</span>,<span class="number">16</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#125;; <span class="comment">//5*5的高斯核</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 与5*5的高斯核做卷积</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nrow = <span class="number">2</span>; nrow &lt; img.rows<span class="number">-2</span>; nrow++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ncol = <span class="number">2</span>; ncol &lt; img.cols<span class="number">-2</span>; ncol++) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">point</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">                    <span class="built_in">point</span> += Kernel[i][j] * img.ptr&lt;uchar&gt;(nrow+i<span class="number">-2</span>)[ncol+j<span class="number">-2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dst.ptr&lt;uchar&gt;(nrow)[ncol] = <span class="built_in">point</span>/<span class="number">273</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mat src = imread(<span class="string">"Lenna.jpg"</span>, IMREAD_GRAYSCALE); <span class="comment">//从文件中加载灰度图像</span></span><br><span class="line">    Mat dst = src.clone();</span><br><span class="line">    <span class="comment">// 读取图片失败，则停止</span></span><br><span class="line">    <span class="keyword">if</span> (src.empty()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"读取图像文件失败"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 高斯滤波，高斯核大小为5*5</span></span><br><span class="line">    GaussianBlur(src, dst, Size(<span class="number">5</span>,<span class="number">5</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    imshow(<span class="string">"dst"</span>,dst);</span><br><span class="line">    imwrite(<span class="string">"gas.jpg"</span>, dst);</span><br><span class="line">    waitKey();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p><img src="http://imglf3.nosdn0.126.net/img/d2tnT2w1QS9GOGlkb3dEbkVzbEtFckxINERaV0NzZFd1T29Halp0QTQya3hzRGtPUTFCN2xRPT0.jpg?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg" alt=""></p>
<p><img src="http://imglf5.nosdn0.126.net/img/d2tnT2w1QS9GOGlkb3dEbkVzbEtFb1dnVnUyQjVoNUFpRSsvZTdzYTd0MmlSR1MxNW9IYUx3PT0.jpg?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg" alt=""></p>
<p>​    该高斯滤波结果与openCV滤波结果基本一致。</p>
<h1 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h1><p>​    均值滤波是空间域线性滤波器，其中所得到的图像中的每个像素具有的值等于其邻近的像素的输入图像中的平均值。它是低通（“模糊”）滤波器的一种形式。</p>
<p><img src="http://imglf5.nosdn0.126.net/img/d2tnT2w1QS9GOGo0emJzcWU4WGxFZXQ5a0dqR1dMTHNKQy9TbEY5UmRrbEozRE41ZVQ3SDR3PT0.png?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0" style="zoom:80%;" /></p>
<h2 id="openCV实现（openCV提供的函数）-1"><a href="#openCV实现（openCV提供的函数）-1" class="headerlink" title="openCV实现（openCV提供的函数）"></a>openCV实现（openCV提供的函数）</h2><h3 id="cv-blur"><a href="#cv-blur" class="headerlink" title="cv::blur"></a>cv::blur</h3><p>​    openCV自带的均值滤波器：<a href="https://docs.opencv.org/master/d4/d86/group__imgproc__filter.html#ga8c45db9afe636703801b0b2e440fce37" target="_blank" rel="noopener">cv::blur</a></p>
<ul>
<li>库文件：<code>#include &lt;opencv2/imgproc.hpp&gt;</code></li>
<li>作用：使用归一化框滤波模糊图像。</li>
<li>调用方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>void cv::blur</th>
<th>(</th>
<th><a href="https://docs.opencv.org/master/dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba" target="_blank" rel="noopener">InputArray</a></th>
<th><em>src</em>,</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td><a href="https://docs.opencv.org/master/dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0" target="_blank" rel="noopener">OutputArray</a></td>
<td><em>dst</em>,</td>
</tr>
<tr>
<td></td>
<td></td>
<td><a href="https://docs.opencv.org/master/dc/d84/group__core__basic.html#ga346f563897249351a34549137c8532a0" target="_blank" rel="noopener">Size</a></td>
<td><em>ksize</em>,</td>
</tr>
<tr>
<td></td>
<td></td>
<td><a href="https://docs.opencv.org/master/dc/d84/group__core__basic.html#ga1e83eafb2d26b3c93f09e8338bcab192" target="_blank" rel="noopener">Point</a></td>
<td><em>anchor</em> = <code>Point(-1,-1)</code>,</td>
</tr>
<tr>
<td></td>
<td></td>
<td>int</td>
<td><em>borderType</em> = <code>BORDER_DEFAULT</code></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>参数</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>src</th>
<th>输入图像；它可以具有任意数量的通道，这些通道可以独立处理，但深度应为CV_8U，CV_16U，CV_16S，CV_32F或CV_64F。</th>
</tr>
</thead>
<tbody>
<tr>
<td>dst</td>
<td>输出与src大小和类型相同的图像。</td>
</tr>
<tr>
<td>大小</td>
<td>内核大小模糊。</td>
</tr>
<tr>
<td>锚</td>
<td>锚点 默认值Point（-1，-1）表示锚点位于内核中心。</td>
</tr>
<tr>
<td>borderType</td>
<td>用于推断图像外部像素的边框模式</td>
</tr>
</tbody>
</table>
</div>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mat src = imread(<span class="string">"Lenna.jpg"</span>, IMREAD_GRAYSCALE); <span class="comment">//从文件中加载灰度图像</span></span><br><span class="line">    Mat dst;</span><br><span class="line">    <span class="comment">// 读取图片失败，则停止</span></span><br><span class="line">    <span class="keyword">if</span> (src.empty()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"读取图像文件失败"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 均值滤波，核大小为5*5</span></span><br><span class="line">    blur(src, dst, Size(<span class="number">5</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    imshow(<span class="string">"dst"</span>,dst);</span><br><span class="line">    imwrite(<span class="string">"box_openCV.jpg"</span>, dst);</span><br><span class="line">    waitKey();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h3><p><img src="http://imglf3.nosdn0.126.net/img/d2tnT2w1QS9GOGlkb3dEbkVzbEtFckxINERaV0NzZFd1T29Halp0QTQya3hzRGtPUTFCN2xRPT0.jpg?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg" alt=""></p>
<p><img src="http://imglf6.nosdn0.126.net/img/d2tnT2w1QS9GOGhWeFp6WVY1UXB3UVVsY2Z4REQzbUdEbzhmbDZDaEkxL0IwTytJU0czNGFRPT0.jpg?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg" alt=""></p>
<p>原图像和经均值滤波后图像的傅立叶变换频谱</p>
<p><img src="http://imglf5.nosdn0.126.net/img/d2tnT2w1QS9GOGo0emJzcWU4WGxFWVBZT2RldFFuMitvYmIyMjFnMnV6WllXTG5UaUxRR3pnPT0.png?imageView&thumbnail=500x0&quality=96&stripmeta=0" style="zoom: 50%;" /></p>
<p><img src="http://imglf3.nosdn0.126.net/img/d2tnT2w1QS9GOGo0emJzcWU4WGxFY0RPVTFQOFlYeXV0Vy9VRmtUY0hqdHhGZWV6NWwrTFlRPT0.png" style="zoom:40%;" /></p>
<h2 id="C-实现（函数自己编写）-1"><a href="#C-实现（函数自己编写）-1" class="headerlink" title="C++实现（函数自己编写）"></a>C++实现（函数自己编写）</h2><p>​    利用5*5的均值滤波器</p>
<p><img src="http://imglf4.nosdn0.126.net/img/d2tnT2w1QS9GOGo0emJzcWU4WGxFYVlrWVpqazZTNkJEK0lXTHBEOWl1OGJsc0twMlFIMDF3PT0.png?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0" style="zoom:50%;" /></p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 利用5*5的均值滤波</span></span><br><span class="line"><span class="comment"> img 输入原图像</span></span><br><span class="line"><span class="comment"> dst 均值滤波后的输出图像</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Blur</span><span class="params">(Mat &amp;img, Mat &amp;dst)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Kernel[<span class="number">5</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#125;; <span class="comment">//5*5的核</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 与5*5的核做卷积</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nrow = <span class="number">2</span>; nrow &lt; img.rows<span class="number">-2</span>; nrow++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ncol = <span class="number">2</span>; ncol &lt; img.cols<span class="number">-2</span>; ncol++) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">point</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">                    <span class="built_in">point</span> += Kernel[i][j] * img.ptr&lt;uchar&gt;(nrow+i<span class="number">-2</span>)[ncol+j<span class="number">-2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dst.ptr&lt;uchar&gt;(nrow)[ncol] = <span class="built_in">point</span>/<span class="number">25</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mat src = imread(<span class="string">"Lenna.jpg"</span>, IMREAD_GRAYSCALE); <span class="comment">//从文件中加载灰度图像</span></span><br><span class="line">    Mat dst = src.clone();</span><br><span class="line">    <span class="comment">// 读取图片失败，则停止</span></span><br><span class="line">    <span class="keyword">if</span> (src.empty()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"读取图像文件失败"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 均值滤波，核大小为5*5</span></span><br><span class="line">    Blur(src, dst);</span><br><span class="line"></span><br><span class="line">    imshow(<span class="string">"dst"</span>,dst);</span><br><span class="line">    imwrite(<span class="string">"box.jpg"</span>, dst);</span><br><span class="line">    waitKey();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h3><p><img src="http://imglf3.nosdn0.126.net/img/d2tnT2w1QS9GOGlkb3dEbkVzbEtFckxINERaV0NzZFd1T29Halp0QTQya3hzRGtPUTFCN2xRPT0.jpg?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg" alt=""></p>
<p><img src="http://imglf3.nosdn0.126.net/img/d2tnT2w1QS9GOGhWeFp6WVY1UXB3WHorVkNDSHlFL3djRjFwdXQxcW5uNXdySkRaTG5meWtnPT0.jpg?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg" alt=""></p>
<h1 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h1><p>​    中值滤波是一种非线性滤波器，利用采集领域的中值的方法，对噪声进行抑制。尤其对于椒盐噪声有用。</p>
<h2 id="openCV实现（openCV提供的函数）-2"><a href="#openCV实现（openCV提供的函数）-2" class="headerlink" title="openCV实现（openCV提供的函数）"></a>openCV实现（openCV提供的函数）</h2><h3 id="cv-medianBlur"><a href="#cv-medianBlur" class="headerlink" title="cv::medianBlur"></a>cv::medianBlur</h3><p>​    openCV自带的均值滤波器：<a href="https://docs.opencv.org/master/d4/d86/group__imgproc__filter.html#ga564869aa33e58769b4469101aac458f9" target="_blank" rel="noopener">cv::medianBlur</a></p>
<ul>
<li>库文件：<code>#include &lt;opencv2/imgproc.hpp&gt;</code></li>
<li>作用：使用中值滤波模糊图像。</li>
<li>调用方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>void cv::medianBlur</th>
<th>(</th>
<th><a href="https://docs.opencv.org/master/dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba" target="_blank" rel="noopener">InputArray</a></th>
<th><em>src</em>,</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td><a href="https://docs.opencv.org/master/dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0" target="_blank" rel="noopener">OutputArray</a></td>
<td><em>dst</em>,</td>
</tr>
<tr>
<td></td>
<td></td>
<td>int</td>
<td><em>ksize</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>参数</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>src</th>
<th>输入1、3或4通道图像; 当ksize为3或5时，图像深度应为CV_8U，CV_16U或CV_32F，对于较大的光圈，只能为CV_8U。</th>
</tr>
</thead>
<tbody>
<tr>
<td>dst</td>
<td>与src具有相同大小和类型的目标数组。</td>
</tr>
<tr>
<td>大小</td>
<td>孔径线性尺寸；它必须是奇数且大于1，例如：3、5、7 …</td>
</tr>
</tbody>
</table>
</div>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mat src = imread(<span class="string">"Lenna.jpg"</span>, IMREAD_GRAYSCALE); <span class="comment">//从文件中加载灰度图像</span></span><br><span class="line">    Mat dst;</span><br><span class="line">    <span class="comment">// 读取图片失败，则停止</span></span><br><span class="line">    <span class="keyword">if</span> (src.empty()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"读取图像文件失败"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中值滤波，领域大小为5*5</span></span><br><span class="line">    medianBlur(src, dst, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    imshow(<span class="string">"dst"</span>,dst);</span><br><span class="line">    imwrite(<span class="string">"median_openCV.jpg"</span>, dst);</span><br><span class="line">    waitKey();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果-4"><a href="#结果-4" class="headerlink" title="结果"></a>结果</h3><p><img src="http://imglf3.nosdn0.126.net/img/d2tnT2w1QS9GOGlkb3dEbkVzbEtFckxINERaV0NzZFd1T29Halp0QTQya3hzRGtPUTFCN2xRPT0.jpg?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg" alt=""></p>
<p><img src="http://imglf6.nosdn0.126.net/img/d2tnT2w1QS9GOGhWeFp6WVY1UXB3ZFh4bVZ1bCtPM3RSOFk1WHEvbUJJaVNBNXRWQWRzdndRPT0.jpg?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg" alt=""></p>
<h2 id="C-实现（函数自己编写）-2"><a href="#C-实现（函数自己编写）-2" class="headerlink" title="C++实现（函数自己编写）"></a>C++实现（函数自己编写）</h2><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 中值滤波</span></span><br><span class="line"><span class="comment"> img 输入原图像</span></span><br><span class="line"><span class="comment"> dst 中值滤波后的输出图像</span></span><br><span class="line"><span class="comment"> ksize 领域大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">median_blur</span><span class="params">(Mat &amp;img, Mat &amp;dst, <span class="keyword">int</span> ksize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nrow = <span class="number">2</span>; nrow &lt; img.rows<span class="number">-2</span>; nrow++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ncol = <span class="number">2</span>; ncol &lt; img.cols<span class="number">-2</span>; ncol++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; points;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ksize; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ksize; j++) &#123;</span><br><span class="line">                    points.push_back(img.ptr&lt;uchar&gt;(nrow+i<span class="number">-2</span>)[ncol+j<span class="number">-2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>()/<span class="number">2</span>+<span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> minIndex = i;</span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                <span class="keyword">for</span> (j = i+<span class="number">1</span>; j &lt; points.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (points[j] &lt; points[i]) &#123;</span><br><span class="line">                        minIndex = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> temp = points[i];</span><br><span class="line">                points[i] = points[minIndex];</span><br><span class="line">                points[minIndex] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            dst.ptr&lt;uchar&gt;(nrow)[ncol] = points[points.<span class="built_in">size</span>()/<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mat src = imread(<span class="string">"Lenna.jpg"</span>, IMREAD_GRAYSCALE); <span class="comment">//从文件中加载灰度图像</span></span><br><span class="line">    Mat dst = src.clone();</span><br><span class="line">    <span class="comment">// 读取图片失败，则停止</span></span><br><span class="line">    <span class="keyword">if</span> (src.empty()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"读取图像文件失败"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中值滤波，领域大小为5*5</span></span><br><span class="line">    median_blur(src, dst, <span class="number">5</span>);</span><br><span class="line">    imshow(<span class="string">"dst"</span>,dst);</span><br><span class="line">    imwrite(<span class="string">"median.jpg"</span>, dst);</span><br><span class="line">    waitKey();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果-5"><a href="#结果-5" class="headerlink" title="结果"></a>结果</h3><p><img src="http://imglf3.nosdn0.126.net/img/d2tnT2w1QS9GOGlkb3dEbkVzbEtFckxINERaV0NzZFd1T29Halp0QTQya3hzRGtPUTFCN2xRPT0.jpg?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg" alt=""></p>
<p><img src="http://imglf5.nosdn0.126.net/img/d2tnT2w1QS9GOGhWeFp6WVY1UXB3U0pteExaa2tENnN5cDd3TXNOOFFKVjhwalB3NW5hdWZBPT0.jpg?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg" alt=""></p>
<h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​    从Lenna图无法看出上面三种滤波太大的区别，但可以明显看出在同样的领域大小下，高斯滤波的模糊化程度小于其余两种。</p>
<p>​    高斯滤波和均值滤波均是线性滤波，而中值滤波为非线性滤波。</p>
<p>​    这三种滤波适合处理的噪声不同，高斯滤波和均值滤波更适宜抑制高斯噪声，尤其是高斯滤波最适合高斯噪声，而中值滤波更适合抑制椒盐噪声。</p>
<h2 id="高斯噪声的抑制程度对比"><a href="#高斯噪声的抑制程度对比" class="headerlink" title="高斯噪声的抑制程度对比"></a>高斯噪声的抑制程度对比</h2><p>​    这是一张加入高斯噪声的图像。</p>
<p><img src="http://imglf3.nosdn0.126.net/img/d2tnT2w1QS9GOGo0emJzcWU4WGxFUlRvWWx1cUJPQitEbk1BZzdscHR1dVRseWlOSVI1OTRRPT0.jpg?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg" style="zoom: 50%;" /></p>
<p>​    下面分别该高斯噪声图像是用5*5的高斯滤波、均值滤波、中值滤波处理后的图像。</p>
<p><img src="http://imglf3.nosdn0.126.net/img/d2tnT2w1QS9GOGo0emJzcWU4WGxFVUdXZTJsRHpiK3p6VTM3dTlSbzUrRG11aWgzSys1MnpnPT0.jpg?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg" style="zoom:50%;" /></p>
<p><img src="http://imglf6.nosdn0.126.net/img/d2tnT2w1QS9GOGo0emJzcWU4WGxFUi9NK1B0dWFWZHd0d01PODhZZG1GTm5ZZnFnbmQ5YXdBPT0.jpg?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg" style="zoom:50%;" /></p>
<p><img src="http://imglf5.nosdn0.126.net/img/d2tnT2w1QS9GOGo0emJzcWU4WGxFYWZKU3hBMDJJS2tyRzQ5VW5QWndYQnM4aXJSZ2x2WnN3PT0.jpg?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg" style="zoom:50%;" /></p>
<h2 id="椒盐噪声的抑制程度对比"><a href="#椒盐噪声的抑制程度对比" class="headerlink" title="椒盐噪声的抑制程度对比"></a>椒盐噪声的抑制程度对比</h2><p>​    这是一张加入椒盐噪声的图像。</p>
<p><img src="http://imglf4.nosdn0.126.net/img/d2tnT2w1QS9GOGo0emJzcWU4WGxFWDhSTjk2akF2bWYvZ0lwTkIwbEZ6OFdsMi9SM0xrZ0dBPT0.png?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0" style="zoom:80%;" /></p>
<p>​    下面分别该椒盐噪声图像是用5*5的高斯滤波、均值滤波、中值滤波处理后的图像。</p>
<p><img src="http://imglf3.nosdn0.126.net/img/d2tnT2w1QS9GOGo0emJzcWU4WGxFUXJDSmt2TWVET08xZVZjb3ZDTXduV1lmR1pHWnlvNXFBPT0.jpg?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg" style="zoom:80%;" /></p>
<p><img src="http://imglf6.nosdn0.126.net/img/d2tnT2w1QS9GOGo0emJzcWU4WGxFUXNlUDc3Q2xZUlAxVEdSRlR2MjJ6VWJCSUZscEFOdGFBPT0.jpg?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg" style="zoom:80%;" /></p>
<p><img src="http://imglf3.nosdn0.126.net/img/d2tnT2w1QS9GOGo0emJzcWU4WGxFZXZ4ZXpibEMwa1d5MXhtOGVDTmRpYmE1cFhDU0VMVGZBPT0.jpg?imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg" style="zoom:80%;" /></p>
]]></content>
      <categories>
        <category>Computer Vision</category>
      </categories>
      <tags>
        <tag>高斯滤波</tag>
        <tag>均值滤波</tag>
        <tag>中值滤波</tag>
      </tags>
  </entry>
  <entry>
    <title>数学形态学运算——腐蚀、膨胀、开运算、闭运算</title>
    <url>/2020/01/20/%E6%95%B0%E5%AD%A6%E5%BD%A2%E6%80%81%E5%AD%A6%E8%BF%90%E7%AE%97%E2%80%94%E2%80%94%E8%85%90%E8%9A%80%E3%80%81%E8%86%A8%E8%83%80%E3%80%81%E5%BC%80%E8%BF%90%E7%AE%97%E3%80%81%E9%97%AD%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>​     数学形态学中的二值形态学最基本的两种运算——腐蚀、膨胀。由这两个算子又可以衍生出开运算和闭运算。开运算为先腐蚀再膨胀，闭运算为先膨胀再腐蚀。</p>
<p><img src="https://i.loli.net/2020/01/22/TMfxzBCK534PhZt.jpg" alt="erosion_dst.jpg" style="zoom:70%;" /></p>
<p><img src="https://i.loli.net/2020/01/23/u8RTH9BgPibLvWp.jpg" alt="dilation_dst.jpg" style="zoom: 85%;" /></p>
<a id="more"></a>
<h1 id="腐蚀"><a href="#腐蚀" class="headerlink" title="腐蚀"></a>腐蚀</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>​    在目标图像中标出那些与结构元素相同的子图像的原点位置的像素。</p>
<p><img src="https://i.loli.net/2020/01/21/ciN4WF8VDw3BJKb.png" alt="image.png"></p>
<p>​    把结构元素B看作一个卷积模版，每当结构元素平移到其原点位置与目标图像A中那些像素值为“1”的位置重合时，就判断被结构元素覆盖的子图像的其它像素的值是否都与结构元素相应位置的像素值相同；只有当其都相同时，就将结果图像中的那个与原点位置对应的像素位置的值置为1，否则置为0。</p>
<p>​    ⚠️注意：当结构元素在目标图像上平移时，结构元素中的任何元素不能超出目标图像的范围。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>原图像：</p>
<p><img src="https://i.loli.net/2020/01/21/uhGrcdfzSPBXTs3.png" alt="原图像" style="zoom: 67%;" /></p>
<p>结构元素：</p>
<p><img src="https://i.loli.net/2020/01/21/FEkiKaGYtN3qbgD.png" alt="结构元素.png" style="zoom:67%;" /></p>
<p>腐蚀运算后的结果图像：</p>
<p><img src="https://i.loli.net/2020/01/21/U3l5SpXhkYsONeG.png" alt="image.png" style="zoom:67%;" /></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Kernel</span>&#123;</span></span><br><span class="line">    Mat B;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">position</span>[<span class="number">2</span>]; <span class="comment">//原点位置</span></span><br><span class="line">&#125;; <span class="comment">//结构元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 生成十字型结构元素</span></span><br><span class="line"><span class="comment"> size为结构元素的行列数，position为原点位置</span></span><br><span class="line"><span class="comment"> 返回生成的结构元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Kernel <span class="title">getCrossKernel</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">size</span>, <span class="keyword">int</span>* <span class="built_in">position</span>)</span></span>&#123;</span><br><span class="line">    Kernel kernel;</span><br><span class="line">    kernel.B = Mat::zeros(<span class="built_in">size</span>[<span class="number">0</span>], <span class="built_in">size</span>[<span class="number">1</span>], CV_8U);</span><br><span class="line">    </span><br><span class="line">    kernel.<span class="built_in">position</span>[<span class="number">0</span>] = <span class="built_in">position</span>[<span class="number">0</span>];</span><br><span class="line">    kernel.<span class="built_in">position</span>[<span class="number">1</span>] = <span class="built_in">position</span>[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nrow = <span class="number">0</span>; nrow &lt; <span class="built_in">size</span>[<span class="number">0</span>]; nrow++) &#123;</span><br><span class="line">        kernel.B.ptr&lt;uchar&gt;(nrow)[kernel.<span class="built_in">position</span>[<span class="number">0</span>]] = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ncol = <span class="number">0</span>; ncol &lt; <span class="built_in">size</span>[<span class="number">1</span>]; ncol++) &#123;</span><br><span class="line">        kernel.B.ptr&lt;uchar&gt;(kernel.<span class="built_in">position</span>[<span class="number">1</span>])[ncol] = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> kernel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 腐蚀</span></span><br><span class="line"><span class="comment"> img为原图像，dst为腐蚀后的图像，kernel为结构元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getErosion</span><span class="params">(Mat img, Mat &amp;dst, Kernel kernel)</span></span>&#123;</span><br><span class="line">    dst = img.clone();</span><br><span class="line">    Mat B = kernel.B;</span><br><span class="line">    <span class="keyword">int</span> r_pos = kernel.<span class="built_in">position</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> c_pos = kernel.<span class="built_in">position</span>[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历查重</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nrow = r_pos; nrow &lt; img.rows-r_pos; nrow++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ncol = c_pos; ncol &lt; img.cols-c_pos; ncol++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> bingo = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (img.ptr&lt;uchar&gt;(nrow)[ncol] == <span class="number">255</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; B.rows; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.cols; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (B.ptr&lt;uchar&gt;(i)[j] == <span class="number">255</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (img.ptr&lt;uchar&gt;(i+nrow-r_pos)[j+ncol-c_pos] != <span class="number">255</span>) &#123;</span><br><span class="line">                                bingo = <span class="literal">false</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!bingo) &#123; <span class="comment">//不符合</span></span><br><span class="line">                dst.ptr&lt;uchar&gt;(nrow)[ncol] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mat img1,erosion_dst; <span class="comment">//图像一和其腐蚀结果</span></span><br><span class="line">    img1 = imread(<span class="string">"img1.png"</span>, IMREAD_GRAYSCALE); <span class="comment">//获取原图的灰度图像</span></span><br><span class="line">    <span class="comment">// 读取图片失败，则停止</span></span><br><span class="line">    <span class="keyword">if</span> (img1.empty()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"读取图像文件失败"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Otsu二值化</span></span><br><span class="line">    Mat img1_twoColor;</span><br><span class="line">    threshold(img1, img1_twoColor, <span class="number">0</span>, <span class="number">255</span>, THRESH_OTSU);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 建立结构元素(中心为原点位置)</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>[<span class="number">2</span>] = &#123;<span class="number">5</span>, <span class="number">5</span>&#125;; <span class="comment">//结构元素的大小</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">position</span>[<span class="number">2</span>] = &#123;<span class="number">2</span>, <span class="number">2</span>&#125;; <span class="comment">//原点位置</span></span><br><span class="line">    Kernel kernel = getCrossKernel(<span class="built_in">size</span>, <span class="built_in">position</span>);</span><br><span class="line">    </span><br><span class="line">    getErosion(img1_twoColor, erosion_dst, kernel); <span class="comment">//腐蚀</span></span><br><span class="line">    </span><br><span class="line">    imshow(<span class="string">"img1"</span>,img1_twoColor);</span><br><span class="line">    imshow(<span class="string">"erosion_dst"</span>, erosion_dst);</span><br><span class="line">    imwrite(<span class="string">"erosion_dst.jpg"</span>, erosion_dst);</span><br><span class="line">    waitKey(); <span class="comment">//等待键值输入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>原图像：</p>
<p><img src="https://i.loli.net/2020/01/22/uebZfV6KS8El1DX.png" alt="img1.png" style="zoom:150%;" /></p>
<p>腐蚀后的图像（十字结构元素）：</p>
<p><img src="https://i.loli.net/2020/01/22/TMfxzBCK534PhZt.jpg" alt="erosion_dst.jpg" style="zoom:150%;" /></p>
<h1 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h1><h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>​    位于某个点的探针(结构元素)是否<em>有</em>探测到物件？</p>
<p><img src="https://i.loli.net/2020/01/22/hvwD16kimTQWAjG.png" alt="image.png"></p>
<p>过程：</p>
<ol>
<li>求结构元素B关于原点的反射集合Bx；</li>
<li>每当结构元素Bx在目标图像A上平移后，结构元素Bx与其覆盖的子图像中至少有一个元素相交时，就将目标图像中与结构元素Bx的原点对应的那个位置的像素为1，否则置为0。</li>
</ol>
<p>⚠️注意：</p>
<ol>
<li>当结构元素中原点位置的值是0时，仍把它看作是0；而不再把它看作是1。</li>
<li>当结构元素在目标图像上平移时，允许结构中的非原点像素超出目标图像范围。</li>
</ol>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><ul>
<li>结构元素原点为1时，</li>
</ul>
<p>​    原图像：</p>
<p><img src="https://i.loli.net/2020/01/23/5kNeIaSqHERKzZ8.png" alt="image.png" style="zoom:67%;" /></p>
<p>​    结构元素：</p>
<p><img src="https://i.loli.net/2020/01/23/U9KjTLXRgrzNp1V.png" alt="image.png" style="zoom: 67%;" /></p>
<p>​    结构元素的反射：</p>
<p><img src="https://i.loli.net/2020/01/23/qTVWv5BQ17ubxps.png" alt="image.png" style="zoom:67%;" /></p>
<p>​    膨胀运算后的结果图像：</p>
<p><img src="https://i.loli.net/2020/01/23/wrcmlgnZFP4TbSM.png" alt="image.png" style="zoom:67%;" /></p>
<ul>
<li>结构元素原点为0时，</li>
</ul>
<p>​    原图像：</p>
<p><img src="https://i.loli.net/2020/01/23/uXEYVCIlwGofcj8.png" alt="image.png" style="zoom:67%;" /></p>
<p>​    结构元素：</p>
<p><img src="https://i.loli.net/2020/01/23/gZsrSIhiLYKJlQT.png" alt="image.png" style="zoom:67%;" /></p>
<p>​    结构元素的反射：</p>
<p><img src="https://i.loli.net/2020/01/23/WMFdOPXijhNtcsQ.png" alt="image.png" style="zoom:67%;" /></p>
<p>​    膨胀运算后的结果图像：</p>
<p><img src="https://i.loli.net/2020/01/23/GQkz7RW6YjbOIlF.png" alt="image.png" style="zoom:67%;" /></p>
<p>​    </p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Kernel</span>&#123;</span></span><br><span class="line">    Mat B;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">position</span>[<span class="number">2</span>]; <span class="comment">//原点位置</span></span><br><span class="line">&#125;; <span class="comment">//结构元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 生成矩形结构元素</span></span><br><span class="line"><span class="comment"> size为结构元素的大小，position为原点位置</span></span><br><span class="line"><span class="comment"> 返回生成的结构元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Kernel <span class="title">getRectKernel</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">size</span>, <span class="keyword">int</span>* <span class="built_in">position</span>)</span> </span>&#123;</span><br><span class="line">    Kernel kernel;</span><br><span class="line">    kernel.B = Mat::ones(<span class="built_in">size</span>[<span class="number">0</span>], <span class="built_in">size</span>[<span class="number">1</span>], CV_8U);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nrow = <span class="number">0</span>; nrow &lt; kernel.B.rows; nrow++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ncol = <span class="number">0</span>; ncol &lt; kernel.B.cols; ncol++) &#123;</span><br><span class="line">            kernel.B.ptr&lt;uchar&gt;(nrow)[ncol] = <span class="number">255</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    kernel.<span class="built_in">position</span>[<span class="number">0</span>] = <span class="built_in">position</span>[<span class="number">0</span>];</span><br><span class="line">    kernel.<span class="built_in">position</span>[<span class="number">1</span>] = <span class="built_in">position</span>[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> kernel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 膨胀</span></span><br><span class="line"><span class="comment"> img为原图像，dst为膨胀后的图像，kernel为结构元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getDilation</span><span class="params">(Mat img, Mat &amp;dst, Kernel kernel)</span> </span>&#123;</span><br><span class="line">    dst = img.clone();</span><br><span class="line">    Mat B = kernel.B;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结构元素反射</span></span><br><span class="line">    Mat B_x = Mat::zeros(B.cols, B.rows, CV_8U);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nrow = <span class="number">0</span>; nrow &lt; B.rows; nrow++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ncol = <span class="number">0</span>; ncol &lt; B.cols; ncol++) &#123;</span><br><span class="line">            B_x.ptr&lt;uchar&gt;(ncol)[nrow] = B.ptr&lt;uchar&gt;(nrow)[ncol];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r_pos = kernel.<span class="built_in">position</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> c_pos = kernel.<span class="built_in">position</span>[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检验图像的每一个点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nrow = <span class="number">0</span>; nrow &lt; img.rows; nrow++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ncol = <span class="number">0</span>; ncol &lt; img.cols; ncol++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> bingo = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测结构元素中是否有符合的1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; B_x.rows; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B_x.cols; j++) &#123;</span><br><span class="line">                    <span class="comment">// 图像中的位置（有可能越界）</span></span><br><span class="line">                    <span class="keyword">int</span> row = nrow - r_pos + i;</span><br><span class="line">                    <span class="keyword">int</span> col = ncol - c_pos + j;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (B_x.ptr&lt;uchar&gt;(i)[j] == <span class="number">255</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (row &gt;= <span class="number">0</span> &amp;&amp; row &lt; img.rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; img.cols) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (img.ptr&lt;uchar&gt;(row)[col] == <span class="number">255</span>) &#123;</span><br><span class="line">                                bingo = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (bingo) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (bingo) &#123; <span class="comment">//如果符合，即存在重合的1，则置1</span></span><br><span class="line">                dst.ptr&lt;uchar&gt;(nrow)[ncol] = <span class="number">255</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果没有符合的，则置0</span></span><br><span class="line">                dst.ptr&lt;uchar&gt;(nrow)[ncol] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mat img2,dilation_dst; <span class="comment">//图像二和其膨胀结果</span></span><br><span class="line">    img2 = imread(<span class="string">"img2.png"</span>, IMREAD_GRAYSCALE); <span class="comment">//获取原图的灰度图像</span></span><br><span class="line">    <span class="comment">// 读取图片失败，则停止</span></span><br><span class="line">    <span class="keyword">if</span> (img2.empty()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"读取图像文件失败"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Otsu二值化</span></span><br><span class="line">    Mat img2_twoColor;</span><br><span class="line">    threshold(img2, img2_twoColor, <span class="number">0</span>, <span class="number">255</span>, THRESH_OTSU);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 矩形结构元素</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>[<span class="number">2</span>] = &#123;<span class="number">7</span>, <span class="number">7</span>&#125;; <span class="comment">//结构元素的大小</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">position</span>[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;; <span class="comment">//原点位置</span></span><br><span class="line">    Kernel kernel = getRectKernel(<span class="built_in">size</span>, <span class="built_in">position</span>);</span><br><span class="line">    </span><br><span class="line">    getDilation(img2_twoColor, dilation_dst, kernel); <span class="comment">//膨胀</span></span><br><span class="line">    </span><br><span class="line">    imshow(<span class="string">"img2"</span>,img2_twoColor);</span><br><span class="line">    imshow(<span class="string">"dilation_dst"</span>, dilation_dst);</span><br><span class="line">    imwrite(<span class="string">"dilation_dst.jpg"</span>, dilation_dst);</span><br><span class="line">    waitKey(); <span class="comment">//等待键值输入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h2><p>原图像：</p>
<p><img src="https://i.loli.net/2020/01/23/hrcJ4OzdtAiDmau.png" alt="img2.png" style="zoom:150%;" /></p>
<p>膨胀后的图像（矩形结构元素）：</p>
<p><img src="https://i.loli.net/2020/01/23/u8RTH9BgPibLvWp.jpg" alt="dilation_dst.jpg" style="zoom:150%;" /></p>
<h1 id="开运算"><a href="#开运算" class="headerlink" title="开运算"></a>开运算</h1><p>​    开运算为先腐蚀再膨胀。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Kernel</span>&#123;</span></span><br><span class="line">    Mat B;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">position</span>[<span class="number">2</span>]; <span class="comment">//原点位置</span></span><br><span class="line">&#125;; <span class="comment">//结构元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 生成矩形结构元素</span></span><br><span class="line"><span class="comment"> size为结构元素的大小，position为原点位置</span></span><br><span class="line"><span class="comment"> 返回生成的结构元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Kernel <span class="title">getRectKernel</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">size</span>, <span class="keyword">int</span>* <span class="built_in">position</span>)</span> </span>&#123;</span><br><span class="line">    Kernel kernel;</span><br><span class="line">    kernel.B = Mat::ones(<span class="built_in">size</span>[<span class="number">0</span>], <span class="built_in">size</span>[<span class="number">1</span>], CV_8U);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nrow = <span class="number">0</span>; nrow &lt; kernel.B.rows; nrow++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ncol = <span class="number">0</span>; ncol &lt; kernel.B.cols; ncol++) &#123;</span><br><span class="line">            kernel.B.ptr&lt;uchar&gt;(nrow)[ncol] = <span class="number">255</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    kernel.<span class="built_in">position</span>[<span class="number">0</span>] = <span class="built_in">position</span>[<span class="number">0</span>];</span><br><span class="line">    kernel.<span class="built_in">position</span>[<span class="number">1</span>] = <span class="built_in">position</span>[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> kernel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 腐蚀</span></span><br><span class="line"><span class="comment"> img为原图像，dst为腐蚀后的图像，kernel为结构元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getErosion</span><span class="params">(Mat img, Mat &amp;dst, Kernel kernel)</span></span>&#123;</span><br><span class="line">    dst = img.clone();</span><br><span class="line">    Mat B = kernel.B;</span><br><span class="line">    <span class="keyword">int</span> r_pos = kernel.<span class="built_in">position</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> c_pos = kernel.<span class="built_in">position</span>[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历查重</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nrow = r_pos; nrow &lt; img.rows-r_pos; nrow++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ncol = c_pos; ncol &lt; img.cols-c_pos; ncol++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> bingo = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (img.ptr&lt;uchar&gt;(nrow)[ncol] == <span class="number">255</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; B.rows; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.cols; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (B.ptr&lt;uchar&gt;(i)[j] == <span class="number">255</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (img.ptr&lt;uchar&gt;(i+nrow-r_pos)[j+ncol-c_pos] != <span class="number">255</span>) &#123;</span><br><span class="line">                                bingo = <span class="literal">false</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!bingo) &#123; <span class="comment">//不符合</span></span><br><span class="line">                dst.ptr&lt;uchar&gt;(nrow)[ncol] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 膨胀</span></span><br><span class="line"><span class="comment"> img为原图像，dst为膨胀后的图像，kernel为结构元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getDilation</span><span class="params">(Mat img, Mat &amp;dst, Kernel kernel)</span> </span>&#123;</span><br><span class="line">    dst = img.clone();</span><br><span class="line">    Mat B = kernel.B;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结构元素反射</span></span><br><span class="line">    Mat B_x = Mat::zeros(B.cols, B.rows, CV_8U);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nrow = <span class="number">0</span>; nrow &lt; B.rows; nrow++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ncol = <span class="number">0</span>; ncol &lt; B.cols; ncol++) &#123;</span><br><span class="line">            B_x.ptr&lt;uchar&gt;(ncol)[nrow] = B.ptr&lt;uchar&gt;(nrow)[ncol];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r_pos = kernel.<span class="built_in">position</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> c_pos = kernel.<span class="built_in">position</span>[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检验图像的每一个点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nrow = <span class="number">0</span>; nrow &lt; img.rows; nrow++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ncol = <span class="number">0</span>; ncol &lt; img.cols; ncol++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> bingo = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测结构元素中是否有符合的1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; B_x.rows; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B_x.cols; j++) &#123;</span><br><span class="line">                    <span class="comment">// 图像中的位置（有可能越界）</span></span><br><span class="line">                    <span class="keyword">int</span> row = nrow - r_pos + i;</span><br><span class="line">                    <span class="keyword">int</span> col = ncol - c_pos + j;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (B_x.ptr&lt;uchar&gt;(i)[j] == <span class="number">255</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (row &gt;= <span class="number">0</span> &amp;&amp; row &lt; img.rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; img.cols) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (img.ptr&lt;uchar&gt;(row)[col] == <span class="number">255</span>) &#123;</span><br><span class="line">                                bingo = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (bingo) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (bingo) &#123; <span class="comment">//如果符合，即存在重合的1，则置1</span></span><br><span class="line">                dst.ptr&lt;uchar&gt;(nrow)[ncol] = <span class="number">255</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果没有符合的，则置0</span></span><br><span class="line">                dst.ptr&lt;uchar&gt;(nrow)[ncol] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mat img3, erosion_dst, opening_dst; <span class="comment">//图像三和其开运算结果</span></span><br><span class="line">    img3 = imread(<span class="string">"img3.png"</span>, IMREAD_GRAYSCALE); <span class="comment">//获取原图的灰度图像</span></span><br><span class="line">    <span class="comment">// 读取图片失败，则停止</span></span><br><span class="line">    <span class="keyword">if</span> (img3.empty()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"读取图像文件失败"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Otsu二值化</span></span><br><span class="line">    Mat img3_twoColor;</span><br><span class="line">    threshold(img3, img3_twoColor, <span class="number">0</span>, <span class="number">255</span>, THRESH_OTSU);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 矩形结构元素</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>[<span class="number">2</span>] = &#123;<span class="number">4</span>, <span class="number">4</span>&#125;; <span class="comment">//结构元素的大小</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">position</span>[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;; <span class="comment">//原点位置</span></span><br><span class="line">    Kernel kernel = getRectKernel(<span class="built_in">size</span>, <span class="built_in">position</span>);</span><br><span class="line">    </span><br><span class="line">    getErosion(img3_twoColor, erosion_dst, kernel); <span class="comment">//腐蚀</span></span><br><span class="line">    getDilation(erosion_dst, opening_dst, kernel); <span class="comment">//膨胀</span></span><br><span class="line">    </span><br><span class="line">    imshow(<span class="string">"img3"</span>,img3);</span><br><span class="line">    imshow(<span class="string">"erosion_dst"</span>, erosion_dst);</span><br><span class="line">    imshow(<span class="string">"opening_dst"</span>, opening_dst);</span><br><span class="line">    imwrite(<span class="string">"opening_dst.jpg"</span>, opening_dst);</span><br><span class="line">    waitKey(); <span class="comment">//等待键值输入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h2><p>原图像：</p>
<p><img src="https://i.loli.net/2020/01/23/xFwuLygDzo8enUP.png" alt="image.png" style="zoom:150%;" /></p>
<p>开运算结果：</p>
<p><img src="https://i.loli.net/2020/01/23/pHGyOWlUz3wxedY.jpg" alt="opening_dst.jpg" style="zoom:150%;" /></p>
<h1 id="闭运算"><a href="#闭运算" class="headerlink" title="闭运算"></a>闭运算</h1><p>​    闭运算为先膨胀再腐蚀。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Kernel</span>&#123;</span></span><br><span class="line">    Mat B;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">position</span>[<span class="number">2</span>]; <span class="comment">//原点位置</span></span><br><span class="line">&#125;; <span class="comment">//结构元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 生成矩形结构元素</span></span><br><span class="line"><span class="comment"> size为结构元素的大小，position为原点位置</span></span><br><span class="line"><span class="comment"> 返回生成的结构元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Kernel <span class="title">getRectKernel</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">size</span>, <span class="keyword">int</span>* <span class="built_in">position</span>)</span> </span>&#123;</span><br><span class="line">    Kernel kernel;</span><br><span class="line">    kernel.B = Mat::ones(<span class="built_in">size</span>[<span class="number">0</span>], <span class="built_in">size</span>[<span class="number">1</span>], CV_8U);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nrow = <span class="number">0</span>; nrow &lt; kernel.B.rows; nrow++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ncol = <span class="number">0</span>; ncol &lt; kernel.B.cols; ncol++) &#123;</span><br><span class="line">            kernel.B.ptr&lt;uchar&gt;(nrow)[ncol] = <span class="number">255</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    kernel.<span class="built_in">position</span>[<span class="number">0</span>] = <span class="built_in">position</span>[<span class="number">0</span>];</span><br><span class="line">    kernel.<span class="built_in">position</span>[<span class="number">1</span>] = <span class="built_in">position</span>[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> kernel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 腐蚀</span></span><br><span class="line"><span class="comment"> img为原图像，dst为腐蚀后的图像，kernel为结构元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getErosion</span><span class="params">(Mat img, Mat &amp;dst, Kernel kernel)</span></span>&#123;</span><br><span class="line">    dst = img.clone();</span><br><span class="line">    Mat B = kernel.B;</span><br><span class="line">    <span class="keyword">int</span> r_pos = kernel.<span class="built_in">position</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> c_pos = kernel.<span class="built_in">position</span>[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历查重</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nrow = r_pos; nrow &lt; img.rows-r_pos; nrow++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ncol = c_pos; ncol &lt; img.cols-c_pos; ncol++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> bingo = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (img.ptr&lt;uchar&gt;(nrow)[ncol] == <span class="number">255</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; B.rows; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.cols; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (B.ptr&lt;uchar&gt;(i)[j] == <span class="number">255</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (img.ptr&lt;uchar&gt;(i+nrow-r_pos)[j+ncol-c_pos] != <span class="number">255</span>) &#123;</span><br><span class="line">                                bingo = <span class="literal">false</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!bingo) &#123; <span class="comment">//不符合</span></span><br><span class="line">                dst.ptr&lt;uchar&gt;(nrow)[ncol] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 膨胀</span></span><br><span class="line"><span class="comment"> img为原图像，dst为膨胀后的图像，kernel为结构元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getDilation</span><span class="params">(Mat img, Mat &amp;dst, Kernel kernel)</span> </span>&#123;</span><br><span class="line">    dst = img.clone();</span><br><span class="line">    Mat B = kernel.B;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 结构元素反射</span></span><br><span class="line">    Mat B_x = Mat::zeros(B.cols, B.rows, CV_8U);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nrow = <span class="number">0</span>; nrow &lt; B.rows; nrow++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ncol = <span class="number">0</span>; ncol &lt; B.cols; ncol++) &#123;</span><br><span class="line">            B_x.ptr&lt;uchar&gt;(ncol)[nrow] = B.ptr&lt;uchar&gt;(nrow)[ncol];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r_pos = kernel.<span class="built_in">position</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> c_pos = kernel.<span class="built_in">position</span>[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检验图像的每一个点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nrow = <span class="number">0</span>; nrow &lt; img.rows; nrow++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ncol = <span class="number">0</span>; ncol &lt; img.cols; ncol++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> bingo = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测结构元素中是否有符合的1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; B_x.rows; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B_x.cols; j++) &#123;</span><br><span class="line">                    <span class="comment">// 图像中的位置（有可能越界）</span></span><br><span class="line">                    <span class="keyword">int</span> row = nrow - r_pos + i;</span><br><span class="line">                    <span class="keyword">int</span> col = ncol - c_pos + j;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (B_x.ptr&lt;uchar&gt;(i)[j] == <span class="number">255</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (row &gt;= <span class="number">0</span> &amp;&amp; row &lt; img.rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; img.cols) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (img.ptr&lt;uchar&gt;(row)[col] == <span class="number">255</span>) &#123;</span><br><span class="line">                                bingo = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (bingo) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (bingo) &#123; <span class="comment">//如果符合，即存在重合的1，则置1</span></span><br><span class="line">                dst.ptr&lt;uchar&gt;(nrow)[ncol] = <span class="number">255</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果没有符合的，则置0</span></span><br><span class="line">                dst.ptr&lt;uchar&gt;(nrow)[ncol] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mat img4, dilation_dst, closing_dst; <span class="comment">//图像四和其闭运算结果</span></span><br><span class="line">    img4 = imread(<span class="string">"img4.png"</span>, IMREAD_GRAYSCALE); <span class="comment">//获取原图的灰度图像</span></span><br><span class="line">    <span class="comment">// 读取图片失败，则停止</span></span><br><span class="line">    <span class="keyword">if</span> (img4.empty()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"读取图像文件失败"</span>);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Otsu二值化</span></span><br><span class="line">    Mat img4_twoColor;</span><br><span class="line">    threshold(img4, img4_twoColor, <span class="number">0</span>, <span class="number">255</span>, THRESH_OTSU);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 矩形结构元素</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>[<span class="number">2</span>] = &#123;<span class="number">4</span>, <span class="number">4</span>&#125;; <span class="comment">//结构元素的大小</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">position</span>[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;; <span class="comment">//原点位置</span></span><br><span class="line">    Kernel kernel = getRectKernel(<span class="built_in">size</span>, <span class="built_in">position</span>);</span><br><span class="line">    </span><br><span class="line">    getDilation(img4_twoColor, dilation_dst, kernel); <span class="comment">//膨胀</span></span><br><span class="line">    getErosion(dilation_dst, closing_dst, kernel); <span class="comment">//腐蚀</span></span><br><span class="line">    </span><br><span class="line">    imshow(<span class="string">"img4"</span>,img4);</span><br><span class="line">    imshow(<span class="string">"dilation_dst"</span>, dilation_dst);</span><br><span class="line">    imshow(<span class="string">"closing_dst"</span>, closing_dst);</span><br><span class="line">    imwrite(<span class="string">"closing_dst.jpg"</span>, closing_dst);</span><br><span class="line">    waitKey(); <span class="comment">//等待键值输入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h2><p>原图像：</p>
<p><img src="https://i.loli.net/2020/01/23/Hg5mL7JksCveB1Q.png" alt="image.png" style="zoom:150%;" /></p>
<p>闭运算结果：</p>
<p><img src="https://i.loli.net/2020/01/23/p5zsLPN9o6uhrF7.jpg" alt="closing_dst.jpg" style="zoom:150%;" /></p>
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>OpenCV</tag>
        <tag>图像处理</tag>
        <tag>数学形态学</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络-自顶向下方法》笔记</title>
    <url>/2020/03/16/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>​    计算机网络课堂笔记，参考用书《计算机网络-自顶向下方法》。</p>
<a id="more"></a>
<h1 id="计算机网络和因特网"><a href="#计算机网络和因特网" class="headerlink" title="计算机网络和因特网"></a>计算机网络和因特网</h1><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>​    起源是为了形成一个自主、自治、互联的计算机通信系统。</p>
<h3 id="构成描述"><a href="#构成描述" class="headerlink" title="构成描述"></a>构成描述</h3><p>​    因特网也被称为“网中网”，我们所用的网络都是大网中的小网（套娃）。</p>
<ul>
<li>接入网络的设备——网络边缘<ul>
<li><strong>主机</strong>（host） = <strong>端系统</strong>（end system）</li>
<li>运行的联网app</li>
</ul>
</li>
<li><strong>通信链路</strong>（communication link）——接入网<ul>
<li>媒介：同轴电缆、铜线、光纤、无线电频谱</li>
<li>传输速率：带宽 bps</li>
</ul>
</li>
<li><strong>分组交换机</strong>（packet switch）——网络核心<ul>
<li><strong>路由器</strong>（router）和 <strong>链路层交换机</strong>（link-layer switch）</li>
</ul>
</li>
</ul>
<ul>
<li><strong>协议</strong>：控制发送、接收信息。比如，TCP, IP, HTTP等等。每个层次有每个层次的协议。</li>
<li><strong>网络标准</strong><ul>
<li>因特网工程任务组（<strong>IETF</strong>）： 制定网络标准的组织</li>
<li>请求评论（<strong>RFC</strong>）：IETF的标准文档</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2020/03/19/J1qlUrQx9LiTFY2.png" style="zoom:50%;" /></p>
<h3 id="服务描述"><a href="#服务描述" class="headerlink" title="服务描述"></a>服务描述</h3><ul>
<li><p>为应用程序提供服务的基础设施</p>
<p>即用户使用应用。</p>
</li>
<li><p>应用程序编程接口</p>
<p>即编写应用。</p>
</li>
</ul>
<h2 id="网络边缘（Network-Edge）"><a href="#网络边缘（Network-Edge）" class="headerlink" title="网络边缘（Network Edge）"></a>网络边缘（Network Edge）</h2><p>​    与因特网相接的计算机及其他设备位于因特网的边缘，称为<strong>端系统</strong>。</p>
<p>端系统 = 主机，可以被划为下面两种：</p>
<ul>
<li>客户（client）</li>
<li>服务器（server）：比如有企业存储大量数据的大型<strong>数据中心</strong>（data centers）</li>
</ul>
<h3 id="接入网（Access-Networks）"><a href="#接入网（Access-Networks）" class="headerlink" title="接入网（Access Networks）"></a>接入网（Access Networks）</h3><p>​    网络边缘的端系统  通过 <strong>接入网</strong>（物理链路）  连接到  <strong>边缘路由器</strong>（端系统到任何其他远程端系统的路径上的第一台路由器）。</p>
<h4 id="家庭接入：DSL、电缆、FTTH、拨号和卫星"><a href="#家庭接入：DSL、电缆、FTTH、拨号和卫星" class="headerlink" title="家庭接入：DSL、电缆、FTTH、拨号和卫星"></a>家庭接入：DSL、电缆、FTTH、拨号和卫星</h4><ul>
<li><strong>数字用户线</strong>（digital subscriber line，<strong>DSL</strong>）</li>
</ul>
<p>​    利用<strong>电话线路</strong>接入网络。其中 <strong>ADSL</strong>是非对称的数字用户线，基本都用ADSL，因为一般下行的数据量都远大于上行的数据量，所以要设计成非平衡的链路。</p>
<p>​    采用<strong>独占</strong>的<strong>频分多路复用</strong>来传输。因为利用的是原有的电话线路，所以需要将DSL传输的网络信号（上行、下行）和电话信号通过频分多路复用来区分开来。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>频段</th>
<th>传输信号</th>
</tr>
</thead>
<tbody>
<tr>
<td>0~4K</td>
<td>电话语音线路</td>
</tr>
<tr>
<td>4K~50K</td>
<td>上行信号</td>
</tr>
<tr>
<td>50K~1M</td>
<td>下行信号</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://i.loli.net/2020/03/20/oCDhqtVGuRLjenm.png" alt="截屏2020-03-20上午12.22.20.png" style="zoom:50%;" /></p>
<ul>
<li><p><strong>电缆因特网接入</strong>（cable Internet access）</p>
<p>利用<strong>有线电视网</strong>接入网络。结构上，通过粗的同轴电缆接入社区，再用细的同轴电缆接入每家每户。</p>
<p>采用<strong>共享</strong>的<strong>频分多路复用</strong>来传输。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/03/20/w1BdRQcMi5KS7Iz.png" style="zoom:50%;" /></p>
<ul>
<li><strong>混合光纤同轴电缆</strong>（<strong>HFC</strong>）</li>
</ul>
<p>​    <strong>同轴电缆</strong>和<strong>光纤节点</strong>相连再接入边缘路由器。</p>
<p>​    <strong>不对称</strong>的<strong>竞争式协议</strong>，最高可达到30Mbps的下行速率和2Mbps的上行速率。由于采用竞争式协议，在用户少时使用体验优于普通的电缆因特网接入，但是在用户多时容易造成卡顿。</p>
<p><img src="https://i.loli.net/2020/03/20/xsZF9RbLfSq82or.png" style="zoom:50%;" /></p>
<h4 id="企业（家庭）接入：以太网和WiFi"><a href="#企业（家庭）接入：以太网和WiFi" class="headerlink" title="企业（家庭）接入：以太网和WiFi"></a>企业（家庭）接入：以太网和WiFi</h4><ul>
<li><strong>以太网</strong>：使用双绞铜线与一台以太网交换机相连，速率可达到100Mbps、1Gbps、10Gbps。</li>
<li><strong>WiFi</strong>：IEEE802.11技术无线LAN，范围在几十米内。</li>
</ul>
<h4 id="广义无线接入：4G和5G"><a href="#广义无线接入：4G和5G" class="headerlink" title="广义无线接入：4G和5G"></a>广义无线接入：4G和5G</h4><p>​    详见第六章</p>
<h3 id="物理媒体（Physical-Media）"><a href="#物理媒体（Physical-Media）" class="headerlink" title="物理媒体（Physical Media）"></a>物理媒体（Physical Media）</h3><ul>
<li>导引型媒体（guided media）：信号在固体媒体中传输，比如光缆、双绞铜线和同轴电缆。</li>
<li>非导引型媒体（unguided media）：电波在空气中传播，比如无线局域网或数字卫星频道。</li>
</ul>
<h2 id="网络核心（Network-Core）"><a href="#网络核心（Network-Core）" class="headerlink" title="网络核心（Network Core）"></a>网络核心（Network Core）</h2><p>​    网络核心：由端系统的分组交换机和链路构成的网状网络。下图标亮部分即使网络核心。</p>
<p>​    一共有三种交换方式：报文交换（很少使用）、分组交换和电路交换</p>
<p><img src="https://i.loli.net/2020/03/20/dAzBna3i9lZU2uN.png" style="zoom:50%;" /></p>
<h3 id="分组交换（Packet-Switching）"><a href="#分组交换（Packet-Switching）" class="headerlink" title="分组交换（Packet Switching）"></a>分组交换（Packet Switching）</h3><p>​    端系统之间彼此传输报文，分组交换中，将长报文划分为分组，分组再通过通信链路和分组交换机（分为路由器和链路层交换机）传送。</p>
<ol>
<li><p><strong>存储转发传输</strong>（Store-and-Forward Transmission）</p>
<p>​    分组交换和报文交换都采用了存储转发的传输形式。但分组交换的存储转发以分组为单位，即交换机接收到整个分组后才能输出该分组的数据；而报文交换的存储转发单位为报文，需要交换机接收到整个报文后才能输出。</p>
<p><img src="https://i.loli.net/2020/03/20/YZt3aBmjsS1dLIi.png" style="zoom:50%;" /></p>
<p>​    传输相同大小的数据包，分组交换比报文交换更快。下面是分组交换传输3L大小的报文的时间流，报文分为3个大小为L的分组，根据分组交换原理，一共耗费了 4L/R 时间完成传输（即<strong>存储转发时延</strong>）。而如果使用报文传输同样的3L大小的报文则需要耗费 6L/R 时间。</p>
<p><img src="https://i.loli.net/2020/03/20/zkxt9eo4fQqmLRV.jpg" alt="分组交换.jpg" style="zoom: 30%;" /></p>
</li>
<li><p><strong>排队时延</strong>（Queuing Delay）和<strong>分组丢失</strong>（Packet Loss）</p>
<p>​    分组交换机有有一个<strong>输出缓存</strong>（output buffer），分组可能会在分组交换机上排队等待输出，造成排队时延。</p>
<p>​    分组交换机的缓存空间是有限的，所以在过于拥堵时会产生分组丢失（丢包）。</p>
<p><img src="https://i.loli.net/2020/03/20/iCtTZGq6BQuHzwa.png" style="zoom:50%;" /></p>
</li>
<li><p><strong>转发表</strong>（Forwarding Table）和<strong>路由选择协议</strong>（Routing Protocol）</p>
<ul>
<li><strong>路由</strong>：分组中包括IP地址；</li>
<li><strong>转发</strong>：路由器中将目的地址映射为输出链路。</li>
</ul>
</li>
</ol>
<h3 id="电路交换（Circuit-Switching）"><a href="#电路交换（Circuit-Switching）" class="headerlink" title="电路交换（Circuit Switching）"></a>电路交换（Circuit Switching）</h3><p>​    <strong>端到端连接</strong>（end- to-end connection）：在发送数据之前，必须先在发送和接收两端建立端到端连接，并预留一部分带宽。而分组交换不预留，所以会造成排队和丢包。</p>
<p><img src="https://i.loli.net/2020/03/20/D91fBHdvxo24MFT.png" style="zoom:50%;" /></p>
<h4 id="频分多路复用（FDM）"><a href="#频分多路复用（FDM）" class="headerlink" title="频分多路复用（FDM）"></a>频分多路复用（FDM）</h4><p>​    链路中的每条连接专用一个频段。</p>
<p><img src="https://i.loli.net/2020/03/20/NubPYJA6WrcvsqI.png" style="zoom: 40%;" /></p>
<h4 id="时分多路复用（TDM）"><a href="#时分多路复用（TDM）" class="headerlink" title="时分多路复用（TDM）"></a>时分多路复用（TDM）</h4><p>​    远距离传输会有衰减，所以考虑用<strong>数字信号</strong>进行传输。在时域上对信号进行<strong>采样</strong>，接收时再将采样信号恢复。</p>
<p>​    TDM在时域上被划分为固定的<strong>帧</strong>（frame），每帧又被划分为固定数量的<strong>时隙</strong>（slot），链路中的每条连接专用一个时隙。</p>
<p><img src="https://i.loli.net/2020/03/21/yLN9bmafTdIqj6c.png" style="zoom: 67%;" /></p>
<h3 id="分组交换-amp-电路交换"><a href="#分组交换-amp-电路交换" class="headerlink" title="分组交换 &amp; 电路交换"></a>分组交换 &amp; 电路交换</h3><p>​    分组交换的性能优于电路交换，适用于随机数据，可以满足更多用户。</p>
<p>​    电路交换需要预留带宽，相当于固定了链路用户的数量。而分组交换不需要预留带宽，用户使用网络是有一定概率的，在一个时刻较多人使用的概率其实相对较低，所以一条链路可以给更多的用户使用。</p>
<p>​    电路交换适用于特殊情况，比如要保障传输数据能力。</p>
<h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>​    网络结构是网中之网，具有层次结构。</p>
<ul>
<li><strong>ISP</strong>：ISP分为许多层级，比如<strong>第一层ISP</strong>（tier-1 ISP）、<strong>区域ISP</strong>（regional ISP）、<strong>接入ISP</strong>（access ISP）。端系统通过接入ISP与因特网相连，全球的ISP通过各个层级相连，形成了互联网的互联。</li>
<li>因特网交换点（Internet Exchange Point，<strong>IXP</strong>）：由第三方公司创建，IXP是一个汇合点，多个ISP在此处对等。</li>
</ul>
<p><img src="https://i.loli.net/2020/03/21/NugS6r92GDaCqeJ.png" style="zoom: 60%;" /></p>
<h2 id="协议（Protocol）"><a href="#协议（Protocol）" class="headerlink" title="协议（Protocol）"></a>协议（Protocol）</h2><p>​    协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及报文发送和/或接收一条报文或其他时间所采取的动作。</p>
<p>​    协议三大要素：</p>
<ul>
<li>语法（Syntax）：每一段内容符合一定规则的格式，比如一个报文前8位是原地址，后八个是目的地址（只是举例，不要当真）之类。</li>
<li>语义（Semantics）：每一段内容需要代表某种意义，比如原地址部分的二进制到底是指哪个地址。</li>
<li>同步（Timing）：通信的过程，即每一段任务的执行顺序。</li>
</ul>
<p><img src="https://i.loli.net/2020/03/22/RS7Lpk2YjGtCnKV.png" style="zoom:50%;" /></p>
<h2 id="协议层次（Protocol-Layer）及其服务模型"><a href="#协议层次（Protocol-Layer）及其服务模型" class="headerlink" title="协议层次（Protocol Layer）及其服务模型"></a>协议层次（Protocol Layer）及其服务模型</h2><h3 id="五层因特网协议栈"><a href="#五层因特网协议栈" class="headerlink" title="五层因特网协议栈"></a>五层因特网协议栈</h3><p>​    因特网协议栈由5个层次组成：物理层、链路层、网络层、传输层和应用层。因特网协议栈是一个理想模型。</p>
<p>​    下层为上层提供服务。越下面的层，越靠近硬件；越上面的层，越靠近用户。</p>
<p><img src="https://i.loli.net/2020/03/22/oYnb8OzPqg461Ux.png" alt="截屏2020-03-22上午12.23.35.png" style="zoom: 20%;" /></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">层次</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">应用层（Application Layer）</td>
<td>支持网络应用，应用协议仅仅是网络应用的一个组成部分，运行在不同主机上的进程则使用应用层协议进行通信。</td>
</tr>
<tr>
<td style="text-align:center">传输层（Transport Layer）</td>
<td>负责为信源和信宿提供应用程序进程间的数据传输服务，这一层上主要定义了两个传输协议，传输控制协议即TCP和用户数据报协议UDP。</td>
</tr>
<tr>
<td style="text-align:center">网络层（Network Layer）</td>
<td>负责将<strong>数据报</strong>独立地从信源发送到信宿，主要解决路由选择、拥塞控制和网络互联等问题。</td>
</tr>
<tr>
<td style="text-align:center">链路层（Link Layer）</td>
<td>负责将IP数据报封装成合适在物理网络上传输的<strong>帧</strong>格式并传输，或将从物理网络接收到的帧解封，取出IP数据报交给网络层。</td>
</tr>
<tr>
<td style="text-align:center">物理层（Physical Layer）</td>
<td>负责将<strong>比特流</strong>在结点间传输，即负责物理传输。该层的协议既与链路有关也与传输介质有关。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h3><p>​    OSI模型由国际标准化组织（ISO）制定，实际并没有应用，只有理论。</p>
<p>​    OSI模型由7层组成：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。</p>
<h3 id="封装（Encapsulation）"><a href="#封装（Encapsulation）" class="headerlink" title="封装（Encapsulation）"></a>封装（Encapsulation）</h3><p>​    在发送端，</p>
<ol>
<li><p>应用层：将 <strong>应用层报文</strong>（application-layer message）M传送给传输层；</p>
</li>
<li><p>传输层：接收报文M，附上传输层首部信息Ht（包括差错检测位信息等），构成 <strong>传输层报文段</strong>（transport-layer segment），将其传递给网络层；</p>
</li>
<li><p>网络层：接收传输层报文段，附上网络层首部信息Hn（包括源和目的地址等），构成 <strong>网络层数据段</strong>（network-layer datagram），将其传递给网络层；</p>
</li>
<li><p>链路层：接收网络层数据段，附上链路层首部信息Hl，构成 <strong>链路层帧</strong>（link-layer frame），将其传递给物理层；</p>
</li>
<li><p>物理层：负责比特流物理传输。</p>
<p>在接收端以反方向重构报文段。</p>
</li>
</ol>
<p><img src="https://i.loli.net/2020/03/22/uBFK4rGifLvsHqE.png" style="zoom:50%;" /></p>
<h2 id="物理层概述"><a href="#物理层概述" class="headerlink" title="物理层概述"></a>物理层概述</h2><p>​    在两个物理媒体间进行比特流传输，上层都是逻辑链接，只有物理层是实际的物理连接。</p>
<h3 id="物理层基本目标"><a href="#物理层基本目标" class="headerlink" title="物理层基本目标"></a>物理层基本目标</h3><ul>
<li>保证发送信号“0”和“1”的正确性以及发送和接收的一致性；</li>
<li>比特流传输的模式、速度、持续时间和信号失真；</li>
<li>接口设计：引脚数目、功能等等；</li>
<li>信号传输的程序：如何安排传输过程和事件次序。</li>
</ul>
<h3 id="物理层的基本特性"><a href="#物理层的基本特性" class="headerlink" title="物理层的基本特性"></a>物理层的基本特性</h3><ul>
<li><p><strong>机械特性</strong>：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等；</p>
</li>
<li><p><strong>电气特性</strong>：指明传输模式、电压范围、编码、阻抗匹配、传输速率以及传输距离等等；</p>
</li>
<li><p><strong>功能特性</strong>：指明各条物理线路的功能，比如某条线上出现的某一电平的电压表示何种意义，</p>
<p>物理接口信号线按功能分为四类：数据线、控制线、定时线和地线；</p>
</li>
<li><p><strong>规程特性</strong>：指明各物理线路工作规程和时序的关系，比如对于不同功能的各种可能事件的出现顺序，</p>
<p>信号传输的模式：单工（仅单向通行）、半双工（双方通，但一个时刻仅一方通）、全双工（双方随时通）。</p>
</li>
</ul>
<h2 id="基本通信原理"><a href="#基本通信原理" class="headerlink" title="基本通信原理"></a>基本通信原理</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>数据（data）：对于客观事实描述的物理符号，包括数字、文本、语言、图像等等；</li>
<li>信息（information）：数据的集合；</li>
<li>信号（signal）：数据传输中的表现形式，比如模拟信号、数字信号；</li>
<li>信道（channel）：往固定方向传输信息的媒介。</li>
</ul>
<p><strong>模拟传输VS数字传输</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>传输方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>模拟</td>
<td>对信道有高利用率</td>
<td>不抗噪</td>
</tr>
<tr>
<td>数字</td>
<td>信号不易失真</td>
<td>需要更宽的带宽</td>
</tr>
</tbody>
</table>
</div>
<h3 id="信道特性"><a href="#信道特性" class="headerlink" title="信道特性"></a>信道特性</h3><ul>
<li><p><strong>码元</strong>（Symbol）：承载信息量的基本信号单位。</p>
<p>​    下面是马原分级数 N 与所需bit位数 n 的关系（N个离散的值需要n个bits）</p>
<script type="math/tex; mode=display">
n=log_2N</script><p><img src="https://i.loli.net/2020/03/22/wxHkuoMDth7Bqpm.jpg" style="zoom:40%;" /></p>
</li>
<li><p><strong>波特率</strong>（Baud rate）：传输码元的速率。</p>
</li>
<li><p><strong>比特率</strong>（Bit rate）：传输比特的速率。</p>
<p>波特率与比特率的关系</p>
<script type="math/tex; mode=display">
bit\ rate(b/s)=baud\ rate*n</script></li>
<li><p><strong>信道容量</strong>（Channel capacity）：在一个信道中能够可靠地传送信息时可达速率的最小上界，单位 bps。</p>
</li>
<li><p><strong>频带宽度</strong>（Frequency bandwidth）：信道允许的信号频率范围，单位 Hz。</p>
<script type="math/tex; mode=display">
Frequency\ bandwidth = maximum\ bandwidth-minimum\ bandwidth</script></li>
<li><p><strong>传输延迟</strong>（Transmission delay）：包括发送到接受的处理事件、电信号的响应时间、中间介质的传输时间。</p>
</li>
<li><p><strong>奈奎斯特定理</strong>（Nyquist’s Law）</p>
<ol>
<li>对于理想的低通信号，在一个频带宽度为 W 的信道，其码元的最大传输速率 = 2W Baud</li>
<li>对于理想的带通信号，在一个频带宽度为 W 的信道，其码元的最大传输速率 = W Baud</li>
</ol>
</li>
<li><p><strong>香农定理</strong>（Shannon’s Formula）</p>
<p>信道的信息传输速率C（单位：bps）</p>
<script type="math/tex; mode=display">
C=Wlog_2(1+S/N)</script><ul>
<li><p>W -  带宽，单位 Hz</p>
</li>
<li><p>S  -  信道的平均信号功率</p>
</li>
<li><p>N  -  信道的高斯噪声功率</p>
</li>
<li><p>S/N  -  信号功率与噪声功率之比（也可以叫信噪比）</p>
<p>一般情况下，信噪比不用 $S/N$ 表示，而是 $10log_{10}S/N$ ，单位为dB。</p>
</li>
</ul>
</li>
</ul>
<h3 id="模拟-数字信号传输"><a href="#模拟-数字信号传输" class="headerlink" title="模拟/数字信号传输"></a>模拟/数字信号传输</h3><p>​    模拟信道只能传输模拟信号，数字信道只能传输数字信号。</p>
<h4 id="调制解调器"><a href="#调制解调器" class="headerlink" title="调制解调器"></a>调制解调器</h4><p>​    数字/模拟信号 经过 <strong>调制</strong> 变成 <strong>模拟信号</strong>，如此可在 模拟信道 上传输，再经过 <strong>解调</strong> 变成 数字/模拟信号。</p>
<p><img src="https://i.loli.net/2020/03/23/4mKvzSkIDigxhFX.png" style="zoom:40%;" /></p>
<h4 id="编码解码器"><a href="#编码解码器" class="headerlink" title="编码解码器"></a>编码解码器</h4><p>​    数字/模拟信号 经过 <strong>编码</strong> 变成 <strong>数字信号</strong>，如此可在 数字信道 上传输，再经过 <strong>解码</strong> 变成 数字/模拟信号。</p>
<p><img src="https://i.loli.net/2020/03/23/OcMLw2JjiA9FsSP.png" alt="截屏2020-03-23上午1.37.30.png" style="zoom:40%;" /></p>
<h4 id="调制（Modulation）：数字信号到模拟信号"><a href="#调制（Modulation）：数字信号到模拟信号" class="headerlink" title="调制（Modulation）：数字信号到模拟信号"></a>调制（Modulation）：数字信号到模拟信号</h4><p>​    从数字信号到模拟信号的调制主要有三种方法：</p>
<ul>
<li><p><strong>调幅</strong>（Amplitude Modulation，<strong>AM</strong>）</p>
<p>把数字信号转化成不同幅度的正弦信号。</p>
<p><img src="https://i.loli.net/2020/03/23/tsgLBTpczPWhOHS.png" style="zoom:50%;" /></p>
</li>
<li><p><strong>调频</strong>（Frequency Modulation，<strong>FM</strong>）</p>
<p>把数字信号转化成不同频率的正弦信号。</p>
<p><img src="https://i.loli.net/2020/03/23/RJEuCxXSblUhyfV.png" style="zoom:40%;" /></p>
</li>
<li><p><strong>调相</strong>（Phase Modulation，<strong>PM</strong>）</p>
<p>把数字信号转化成不同相位的正弦信号。</p>
<p><img src="https://i.loli.net/2020/03/23/2NDtUwYbpmuHPVo.png" style="zoom:40%;" /></p>
</li>
</ul>
<h4 id="脉码调制（Pulse-Code-Modulation-PCM）"><a href="#脉码调制（Pulse-Code-Modulation-PCM）" class="headerlink" title="脉码调制（Pulse Code Modulation, PCM）"></a>脉码调制（Pulse Code Modulation, PCM）</h4><p>​    模拟信号变成数字信号。</p>
<p>脉码调制步骤：</p>
<ol>
<li><p>采样（Sampling system）</p>
<p>采样频率是信号频率的两倍，则可不失真地恢复原始信号。</p>
</li>
<li><p>量化（Quantify）</p>
<p>取整采样信号。</p>
</li>
<li><p>编码（Coding）</p>
<p>量化后的信号编码成二进制。</p>
</li>
</ol>
<p><img src="https://i.loli.net/2020/03/23/ze59JcGyOojH2Dx.png" style="zoom: 33%;" /></p>
<h4 id="数字信号编码（Digital-signal-coding）"><a href="#数字信号编码（Digital-signal-coding）" class="headerlink" title="数字信号编码（Digital signal coding）"></a>数字信号编码（Digital signal coding）</h4><p>​    数字信号到数字信号。</p>
<h5 id="不归零编码（Non-Return-To-Zero-NRZ）"><a href="#不归零编码（Non-Return-To-Zero-NRZ）" class="headerlink" title="不归零编码（Non-Return-To-Zero, NRZ）"></a>不归零编码（Non-Return-To-Zero, NRZ）</h5><p>​    主要介绍两种不归零编码。</p>
<ul>
<li><p>Non-Return-To-Zero Level (<strong>NRZ-L</strong>) Coding</p>
<p>​    高电平表示“1”，低电平表示“0”。</p>
<p><img src="https://i.loli.net/2020/03/23/XmcGZnlLOg92azH.png" style="zoom: 15%;" /></p>
<p>NRZ-L的优点：简单好实现</p>
<p>NRZ-L的缺点：</p>
<ul>
<li>难以分清二进制一位的开始和结束，所以必须要带<strong>同步时钟</strong>（外同步）来同步。可以把上图的虚线当作是同步时钟，当把虚线去掉是，相同电平的信号就不好判断开始和结束了。</li>
<li>在传输全“1”或全“0”信号时，此时传输的只有直流分量（傅立叶分不出正弦或余弦分量），这样线路上会有比较大的噪声。</li>
</ul>
</li>
<li><p>反向不归零编码（<strong>NRZ-I</strong>）</p>
<p>​    遇“1”反向。只能解决NRZ-L的部分问题（全“1”问题，不再是直流）</p>
<p><img src="https://i.loli.net/2020/03/23/KQJyzFGPtanmhLk.jpg" style="zoom:50%;" /></p>
</li>
</ul>
<p><strong>外同步</strong>（External synchronization）</p>
<p>​    给系统一个同步时钟信号，设置一个周期的宽度。</p>
<p>​    外同步有诸多不便，于是有了自同步的曼切斯特编码。</p>
<h5 id="曼切斯特编码（Manchester-encoding）"><a href="#曼切斯特编码（Manchester-encoding）" class="headerlink" title="曼切斯特编码（Manchester encoding）"></a>曼切斯特编码（Manchester encoding）</h5><p>​    每个编码由两段组成，“1”：先高后低；“0”：先低后高（可以反过来定义）。</p>
<p><img src="https://i.loli.net/2020/03/23/CwpZhdnVO65m2DX.png" style="zoom: 20%;" /></p>
<p>曼切斯特编码的优点（解决了不归零编码的问题）：</p>
<ul>
<li>自同步，不需要同步时钟；</li>
<li>直流分量为0。</li>
</ul>
<p>曼切斯特编码的缺点：</p>
<ul>
<li><p><strong>基频增加</strong>：基频是不归零编码的两倍，从而比特率变成了不归零编码的一半；</p>
</li>
<li><p><strong>二义性</strong>：组合情况有两种。</p>
<p><img src="https://i.loli.net/2020/03/23/3vlYkrz47V6qC1w.jpg" style="zoom: 40%;" /></p>
</li>
</ul>
<h5 id="差分曼切斯特编码（Differential-Manchester-encoding）"><a href="#差分曼切斯特编码（Differential-Manchester-encoding）" class="headerlink" title="差分曼切斯特编码（Differential Manchester encoding）"></a>差分曼切斯特编码（Differential Manchester encoding）</h5><p>​    解决曼切斯特编码的二义性。</p>
<ul>
<li>“1”：自己的前半波与前一个编码的后半波相同；</li>
<li><p>“0”：自己的前半波与前一个编码的后半波相反。</p>
<p> 有两种画法，初始为高、初始为低，两种画法结果对称。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/03/23/mdYhZEKHulpkjTW.png" style="zoom: 33%;" /></p>
<p>​    差分曼切斯特编码的优点：</p>
<ul>
<li>解决NRZ问题</li>
<li>解决二义性问题</li>
</ul>
<p>​    差分曼切斯特编码的缺点（同曼切斯特编码）：</p>
<ul>
<li>基频翻倍</li>
<li>高频噪声增加</li>
</ul>
<h5 id="块编码（Block-encoding）"><a href="#块编码（Block-encoding）" class="headerlink" title="块编码（Block encoding）"></a>块编码（Block encoding）</h5><ol>
<li>将原信号每 m bits 分为一块；</li>
<li>把 m bits 的每块映射成 n bits 的块（m &lt; n）；</li>
<li>将 n bits 的块重新组合起来。</li>
</ol>
<p><img src="https://i.loli.net/2020/03/23/5D78VTnaSXjMyfR.png" style="zoom:33%;" /></p>
<h3 id="多路复用（Multiplexing）"><a href="#多路复用（Multiplexing）" class="headerlink" title="多路复用（Multiplexing）"></a>多路复用（Multiplexing）</h3><h4 id="频分多路复用（Frequency-division-multiplexing，FDM）"><a href="#频分多路复用（Frequency-division-multiplexing，FDM）" class="headerlink" title="频分多路复用（Frequency division multiplexing，FDM）"></a>频分多路复用（Frequency division multiplexing，FDM）</h4><p>​    见 <a href="https://gy23333.github.io/2020/03/16/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0/#%E9%A2%91%E5%88%86%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%88FDM%EF%BC%89">频分多路复用</a> 。</p>
<h4 id="时分多路复用（Time-division-multiplexing，TDM）"><a href="#时分多路复用（Time-division-multiplexing，TDM）" class="headerlink" title="时分多路复用（Time division multiplexing，TDM）"></a>时分多路复用（Time division multiplexing，TDM）</h4><p>​    见 <a href="https://gy23333.github.io/2020/03/16/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0/#%E6%97%B6%E5%88%86%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%88TDM%EF%BC%89">时分多路复用</a> 。</p>
<h4 id="波分多路复用（Wavelength-division-multiplexing，WDM）"><a href="#波分多路复用（Wavelength-division-multiplexing，WDM）" class="headerlink" title="波分多路复用（Wavelength division multiplexing，WDM）"></a>波分多路复用（Wavelength division multiplexing，WDM）</h4><p>​    和FDM原理相同，但主要在光波中采用。</p>
<h4 id="码分多路复用（Code-division-multiplexing，CDM）"><a href="#码分多路复用（Code-division-multiplexing，CDM）" class="headerlink" title="码分多路复用（Code division multiplexing，CDM）"></a>码分多路复用（Code division multiplexing，CDM）</h4><p>举例说明</p>
<p>​    每台设备都给一个不同向量的码片，比如手机A的码片为A，手机B的码片为B。不同设备的码片正交，即</p>
<script type="math/tex; mode=display">
\begin{cases}
A\times B = 0\\
A\times A = 1
\end{cases}</script><p>​    要向手机A发送数据a，向手机B发送数据b，则在信道中发送 $a\times A + b\times B$。</p>
<p>​    在手机A接收数据时，将接收到的信号乘A。</p>
<script type="math/tex; mode=display">
(a\times A + b\times B) \times A = a\times A\times A + b\times B \times A = a</script><p>​    同理手机B，如此两台设备同时利用一条信道传输，并成功分离各自的数据。</p>
<h2 id="延时、丢包、吞吐量"><a href="#延时、丢包、吞吐量" class="headerlink" title="延时、丢包、吞吐量"></a>延时、丢包、吞吐量</h2><h3 id="延时（delay）"><a href="#延时（delay）" class="headerlink" title="延时（delay）"></a>延时（delay）</h3><p>​    现实中的计算机系统不是理想系统，事件是随机突发的，所以不可避免的存在延时。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/delay.png" alt="delay.png" style="zoom:33%;" /></p>
<p>​    数据包的延时由四个部分组成：</p>
<script type="math/tex; mode=display">
d_{nodal} = d_{prop}+d_{queue}+d_{trans}+d_{prop}</script><ul>
<li><p><strong>处理时延</strong>（Nodal Processing Delay，$d_{proc}$）</p>
<p>​    路由器接收到分组对其进行处理的时间（比如差错检测），耗时很短，毫秒级。</p>
</li>
<li><p><strong>排队时延</strong>（Queuing Delay，$d_{queue}$）</p>
<p>​    分组在链路上等待传输的时间，取决于先期到达的正在排队等待向链路传输的分组数量。</p>
</li>
<li><p><strong>传输时延</strong>（Transmission Delay，$d_{trans}$）</p>
<p>​    将分组的比特流传输到链路的时间（比如进行编码转换成查分曼切斯特编码的时间）。</p>
<p>​    如分组长度 L ，传输速率 R bps，则其传输时延为：</p>
<script type="math/tex; mode=display">
d_{trans}=L/R</script><p>​    所以传输时间取决于分组长度和传输速率。</p>
</li>
<li><p><strong>传播时延</strong>（Propagation Delay，$$）</p>
<p>​    信号在媒体上传播的时间。</p>
<p>​    如物理链路的长度 d，传播速度 s m/sec，则其传播时延为：</p>
<script type="math/tex; mode=display">
d_{prop}=d/s</script></li>
</ul>
<h3 id="丢包（Packet-Loss）"><a href="#丢包（Packet-Loss）" class="headerlink" title="丢包（Packet Loss）"></a>丢包（Packet Loss）</h3><p>​    流量强度（traffic intensity）代表了路由器上排队的拥堵率。</p>
<script type="math/tex; mode=display">
traffic\ intensity = (L\times a)/R</script><p>​    其中，L —— 分组长度（bits）；</p>
<p>​               R —— 链路带宽（bps）；</p>
<p>​               a —— 平均分组到达速率</p>
<ul>
<li>流量强度接近0时，几乎没有分组到达，排队延时很小；</li>
<li>流量强度0～1时，平均排队长度越来越长，排队延时越来越长；</li>
<li>流量强度接近1时，存在到达率超过传输时间间隔，拥堵。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/traffic%20intensity.png" alt="traffic intensity.png" style="zoom: 50%;" /></p>
<p>​    路由器的排队容量是有限的，当分组到达一个已满的队列时，路由器将丢弃该分组，产生丢包。</p>
<h3 id="吞吐量（Throughput）"><a href="#吞吐量（Throughput）" class="headerlink" title="吞吐量（Throughput）"></a>吞吐量（Throughput）</h3><p>​    从主机A到主机B传文件，B接收文件的速率为<strong>瞬时吞吐量</strong>（instantaneous throughput），单位bps；所有时间的平均速率为<strong>平均吞吐量</strong>（average throughput）。</p>
<p>​    串联链路吞吐量取决于<strong>瓶颈链路</strong>（bottleneck link）。</p>
<script type="math/tex; mode=display">
Throughput = min\{R_1, R_2,...,R_N\}</script><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Throughput.png" alt="Throughput.png" style="zoom:70%;" /></p>
<h1 id="应用层（Application-Layer）"><a href="#应用层（Application-Layer）" class="headerlink" title="应用层（Application Layer）"></a>应用层（Application Layer）</h1><h2 id="网络应用原理"><a href="#网络应用原理" class="headerlink" title="网络应用原理"></a>网络应用原理</h2><ul>
<li>可以在不同类型主机运行；</li>
<li>可以在不同终端间相互通讯；</li>
<li>在编写网络应用的过程中，不需要考虑网络核心设备，网络核心不会允许应用；</li>
<li>端系统上的应用可以快速开发，而且易于传播。</li>
</ul>
<h3 id="网络应用结构"><a href="#网络应用结构" class="headerlink" title="网络应用结构"></a>网络应用结构</h3><h4 id="客户机-服务器体系结构（Client-server-architecture）"><a href="#客户机-服务器体系结构（Client-server-architecture）" class="headerlink" title="客户机-服务器体系结构（Client-server architecture）"></a>客户机-服务器体系结构（Client-server architecture）</h4><p>​    例如：HTTP、IMAP、FTP</p>
<p><strong>服务器</strong>：</p>
<ul>
<li>永远在线；</li>
<li>IP地址恒定；</li>
<li>服务器往往在数据中心，通过多台服务器进行扩展。</li>
</ul>
<p><strong>客户机</strong>：</p>
<ul>
<li>可以和服务器进行通信；</li>
<li>可能间断性连接网络；</li>
<li>可能是动态的IP地址；</li>
<li>客户机之间不会直接通信；</li>
</ul>
<h4 id="点对点体系结构（Peer-peer-architecture）"><a href="#点对点体系结构（Peer-peer-architecture）" class="headerlink" title="点对点体系结构（Peer-peer architecture）"></a>点对点体系结构（Peer-peer architecture）</h4><ul>
<li>没有一个一直在线的服务器；</li>
<li>任意端系统之间直接进行通信；</li>
<li>每个点（peer）向其他的点请求服务，同时作为回报也会提供相应的服务；</li>
</ul>
<p>优点：<strong>自扩展性</strong>（self-scalability）：新的点都会提供服务容量和负荷。</p>
<p>缺点：每个点都是间断性连接，而且IP地址会改变。</p>
<p>例子：P2P的文件分享。</p>
<h3 id="进程通信（Processes-Communicating）"><a href="#进程通信（Processes-Communicating）" class="headerlink" title="进程通信（Processes Communicating）"></a>进程通信（Processes Communicating）</h3><h4 id="客户机和服务器进程"><a href="#客户机和服务器进程" class="headerlink" title="客户机和服务器进程"></a>客户机和服务器进程</h4><p>​    <strong>进程</strong>（Processe）：一台主机上运行的程序。</p>
<ul>
<li>在同一台主机上，两个进程通过<strong>进程间通信</strong>（inter-process communication）来进行通信。进程间通信由操作系统定义；</li>
<li><p>不同主机之间，进程通信同过报文交换，</p>
<p>比如并行计算中的MP和MPI，MP（Multi Processing）只能用于同一台主机间的通信，MPI（Message Processing Interface）主要用于不同主机之间的通信，也适用于同一台主机。</p>
</li>
</ul>
<p>​    <strong>客户机进程</strong>（client process）：发起通信的进程。</p>
<p>​    <strong>服务器进程</strong>（server process）：等待连接的进程。</p>
<div class="note info">
            <p>P2P应用也存在客户机进程和服务器进程。</p>
          </div>
<h4 id="套接字（Sockets）"><a href="#套接字（Sockets）" class="headerlink" title="套接字（Sockets）"></a>套接字（Sockets）</h4><p>​    进程之间通过socket来接收/发送消息。</p>
<p>socket在进程通信中的作用相当于一个信封：</p>
<ul>
<li>通信的信息需要装进socket</li>
<li>应用层下的各层作为基础设施，将信传到另一个进程</li>
<li>两个进程间的通讯会有两个socket</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/socket.png" alt="socket.png" style="zoom:50%;" /></p>
<h4 id="进程寻址（Addressing-Processes）"><a href="#进程寻址（Addressing-Processes）" class="headerlink" title="进程寻址（Addressing Processes）"></a>进程寻址（Addressing Processes）</h4><p>​    如果两个主机之间的进程进行通信，发送端不仅要知道接收端的IP地址还需要知道进程相应的端口号。</p>
<ul>
<li><p><strong>IP地址</strong>：IPv4中32位IP，负责找到接收端主机。</p>
</li>
<li><p><strong>端口号</strong>（port number）：每台主机都可能运行着多个进程，每个进程对应一个端口号。</p>
<p>比如，HTTP服务端口号80、邮件服务端口号25</p>
</li>
</ul>
<h3 id="应用层协议（Application-Layer-Protocols）"><a href="#应用层协议（Application-Layer-Protocols）" class="headerlink" title="应用层协议（Application-Layer Protocols）"></a>应用层协议（Application-Layer Protocols）</h3><p>​    网络应用的开发必须遵守网络协议。</p>
<h4 id="应用层协议的分类"><a href="#应用层协议的分类" class="headerlink" title="应用层协议的分类"></a>应用层协议的分类</h4><p><strong>公开网络协议</strong></p>
<ul>
<li>定义在RFC中</li>
<li>统一标准，易于相互操作</li>
<li>例如：HTTP、SMTP</li>
</ul>
<p><strong>专用网络协议</strong></p>
<ul>
<li>一些非公开的网络协议</li>
<li>例如：Skype</li>
</ul>
<h4 id="应用层协议内容"><a href="#应用层协议内容" class="headerlink" title="应用层协议内容"></a>应用层协议内容</h4><p>应用层协议定义了</p>
<ul>
<li>消息交换的类型：比如请求、响应</li>
<li>消息的语法：消息中有哪些字段以及这些字段如何定义</li>
<li>消息的语义：消息字段内容的含义</li>
<li>规则：进程什么时候、如何发送/接收消息</li>
</ul>
<h4 id="app对传输服务的需求"><a href="#app对传输服务的需求" class="headerlink" title="app对传输服务的需求"></a>app对传输服务的需求</h4><ul>
<li><p><strong>数据完整性</strong>（data integrity）</p>
<p>​    一些app需要100%可靠的文件传输，比如文件传输；有一些运行一部分的丢失，比如语音。</p>
</li>
<li><p><strong>时效性</strong>（timing）</p>
<p>​    一些app要求较少的延时，比如对话直播。</p>
</li>
<li><p><strong>吞吐率</strong>（throughput）</p>
<p>​    吞吐率，即<strong>最小带宽</strong>，一些app存在一个吞吐率下限才能正常使用，比如视频音频等多媒体；有些app运行弹性的吞吐率，比如邮件传输，吞吐率小可以慢慢传过去。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_appsRequirements.png" alt="appsRequirements.png" style="zoom:60%;" /></p>
<h3 id="网络传输协议服务"><a href="#网络传输协议服务" class="headerlink" title="网络传输协议服务"></a>网络传输协议服务</h3><p>​    <strong>传输层</strong>提供为应用层提供的两种传输服务。</p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>​    传输控制协议（TCP）</p>
<ul>
<li><strong>面向连接</strong>（connection-oriented）：需要客户端和服务器之间能够建立连接</li>
<li><strong>可靠传输</strong>（reliable transport）：数据完整性高</li>
<li><strong>流量控制</strong>（flow control）：发送方不能发送太多数据导致接收方过载</li>
<li><strong>阻塞控制</strong>（congestion control）：不能有太多个主机同时发送导致网络过载</li>
<li>不提供的服务：时效性、最小带宽（吞吐率）、安全性</li>
</ul>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>​    UDP是一种<strong>不提供不必要服务</strong>的轻量传输协议。优点是速度快、灵活性好。</p>
<ul>
<li><strong>不需要建立连接</strong></li>
<li><strong>不可靠的数据传输</strong></li>
<li>不提供的服务：基本都不提供，不提供包括可靠传输、流量控制、阻塞控制、时效性、最小带宽（吞吐率）、安全性</li>
</ul>
<h4 id="不同app选择的网络传输协议"><a href="#不同app选择的网络传输协议" class="headerlink" title="不同app选择的网络传输协议"></a>不同app选择的网络传输协议</h4><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_appsProtocols.png" style="zoom:60%;" /></p>
<h2 id="Web和HTTP"><a href="#Web和HTTP" class="headerlink" title="Web和HTTP"></a>Web和HTTP</h2><p>​    World Wide Web 中的网页由超链接（hyperlink）连接。</p>
<ul>
<li>页面由很多对象（object）组成，对象存储在服务器中；</li>
<li>对象有多种类型，可以是HTML文件，JPEG图片，动态脚本等等；</li>
<li>网页以HTML文件为基础，包括了许多参考对象，每个对象都可以通过URL来寻址。例如一张图片的URL为<code>www.someshcool.edu/someDept/pic.gif</code>，其中<code>www.someshcool.edu</code>为主机名，<code>/someDept/pic.gif</code>为路径名。</li>
</ul>
<h3 id="HTTP概述"><a href="#HTTP概述" class="headerlink" title="HTTP概述"></a>HTTP概述</h3><p>​    超文本传输协议（hypertext transfer protocol, HTTP）</p>
<ul>
<li><p>网页的<strong>应用层</strong>协议</p>
</li>
<li><p>基于<strong>客户机-服务器体系结构</strong></p>
<ul>
<li>客户机：负责请求、接收和显示Web对象</li>
<li>服务器：Web服务器负责发送对象，响应客户机请求</li>
</ul>
</li>
</ul>
<ul>
<li>HTTP的传输层使用<strong>TCP</strong><ol>
<li>客户机发起TCP连接（创建socket，<strong>端口号80</strong>）</li>
<li>服务器接收TCP连接</li>
<li>在浏览器和网页服务器之间进行HTTP信息的交换</li>
<li>TCP连接可以断开</li>
</ol>
</li>
</ul>
<ul>
<li>HTTP是无状态的<br>​    &emsp;&emsp;服务器不会保留之前客户机发的请求信息。<br>​    &emsp;&emsp;协议要维持状态是很复杂的：保留之前的历史记录很消耗资源；如果客户机或着服务器有死机，它们的状态会不一致，还需要重新同步，这很麻烦。</li>
</ul>
<ul>
<li>HTTP消息类型：请求（request）与响应（response）</li>
</ul>
<h3 id="HTTP连接类型"><a href="#HTTP连接类型" class="headerlink" title="HTTP连接类型"></a>HTTP连接类型</h3><h4 id="非持久性连接（Non-persistent-HTTP）"><a href="#非持久性连接（Non-persistent-HTTP）" class="headerlink" title="非持久性连接（Non-persistent HTTP）"></a>非持久性连接（Non-persistent HTTP）</h4><h5 id="非持久性HTTP步骤"><a href="#非持久性HTTP步骤" class="headerlink" title="非持久性HTTP步骤"></a>非持久性HTTP步骤</h5><ol>
<li>TCP连接开启</li>
<li>通过这个TCP连接最多传输一个对象</li>
<li><p>TCP连接关闭</p>
<p>如果要加载多个对象时，需要多次非持久性HTTP连接。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Non-persistent%20HTTP(1).png" alt="Non-persistent%20HTTP(1).png" style="zoom:67%;" /><br><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Non-persistent%20HTTP(2).png" alt="Non-persistent%20HTTP(2).png" style="zoom:67%;" /></p>
<h5 id="非持久性HTTP响应时间"><a href="#非持久性HTTP响应时间" class="headerlink" title="非持久性HTTP响应时间"></a>非持久性HTTP响应时间</h5><p>  <strong>RTT</strong>：往返时间（Round Trip Time）,一个很小的数据包（处理文件的时间可忽略）从客户机传到服务器再传回来的时间。</p>
<p>  <strong>HTTP响应时间</strong>（一个对象）：</p>
<ul>
<li>1个RTT：建立TCP连接的时间</li>
<li>1个RTT：HTTP请求以及收到HTTP响应的前几个字符的时间</li>
<li><p>对象/文件传输的时间</p>
<p>对一个对象来说，非持久性HTTP响应时间为</p>
<script type="math/tex; mode=display">
Nonpersistent\ HTTP\ response\ time = 2RTT + file\ transmission\ time</script></li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/NetWork%20Non-persistent%20HTTP%20response%20time.png" alt="Non-persistent response time.png" style="zoom:50%;" /></p>
<div class="note warning">
            <p>  例题：如果一个网页包含1个HTML和10个对象，则非持久性HTTP响应需要多少时间？</p><script type="math/tex; mode=display">  2RTT \times (1+10) + total\ file\ transmission\ time</script>
          </div>
<h5 id="非持久性HTTP的问题"><a href="#非持久性HTTP的问题" class="headerlink" title="非持久性HTTP的问题"></a>非持久性HTTP的问题</h5><ul>
<li>每传输一个对象都需要耗费 $2RTT$ </li>
<li>每建立一个TCP连接都会对操作系统（OS）产生负荷</li>
<li>并行抓取：浏览器常常开多个并行的TCP连接去抓取对象</li>
</ul>
<div class="note warning">
            <p>例题：一个网页包含1个HTML和10张图片，共有5个并行的TCP连接，则非持久性HTTP响应需要多少个RTT？<br>  &emsp;&emsp;首先传输HTML需要 $2RTT$ 的时间，5个并行的TCP连接传输10个对象需要2个 $2RTT$ 的时间。</p><script type="math/tex; mode=display">  RTT\ in\ Response\ Time = 2RTT + 2 \times 2RTT = 6RTT</script>
          </div>
<h4 id="持久性连接（Persistent-HTTP）"><a href="#持久性连接（Persistent-HTTP）" class="headerlink" title="持久性连接（Persistent HTTP）"></a>持久性连接（Persistent HTTP）</h4><h5 id="持久性HTTP步骤"><a href="#持久性HTTP步骤" class="headerlink" title="持久性HTTP步骤"></a>持久性HTTP步骤</h5><ol>
<li>开启TCP连接</li>
<li>通过这一个TCP连接可以传多个对象</li>
<li>TCP连接关闭</li>
</ol>
<h5 id="持久性HTTP特点（HTTP1-1）"><a href="#持久性HTTP特点（HTTP1-1）" class="headerlink" title="持久性HTTP特点（HTTP1.1）"></a>持久性HTTP特点（HTTP1.1）</h5><ul>
<li>服务器在发送响应后保持连接开启状态</li>
<li>后续这个客户机\服务器的HTTP消息都通过该开启的连接发送</li>
<li>两种发送对象方式：HTTP1.1采用流水的方式发送：一次性把对象全发了；另一种是客户机接收到一个对象后接着发下一个对象的请求</li>
<li>至少需要1个RTT发完所有对象</li>
</ul>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>​    &emsp;&emsp;域名系统（Domain Name System，DNS）通过分布式的数据库来实现IP地址和域名的映射。</p>
<ul>
<li><strong>层级结构的域名服务器提供分布式的数据库</strong></li>
<li><strong>应用层协议</strong>：主机和域名服务器通过通信来实现IP地址和域名的转换</li>
</ul>
<div class="note info">
            <p>DNS作为一个<strong>网络核心功能</strong>，为什么要放在应用层？<br>&emsp;&emsp;与网络结构设计理念有关，网络中主机很多映射很复杂，希望将复杂度留在端系统中，而不是在网络核心。</p>
          </div>
<h3 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h3><ul>
<li>IP地址和域名的转换</li>
<li>主机的别名</li>
<li>邮件服务的别名</li>
<li>负荷分配：有些Web可能有多个服务器，即会有多个IP地址对应一个域名，可调整IP地址的顺序以分配负荷。</li>
</ul>
<h3 id="DNS：分布式、层级的数据库"><a href="#DNS：分布式、层级的数据库" class="headerlink" title="DNS：分布式、层级的数据库"></a>DNS：分布式、层级的数据库</h3><div class="note info">
            <p>为什么要选用分布的DNS，而不采用集中式的DNS？</p><ul><li>单点可能失效：一个故障就gg了</li><li>流量问题：所有客户机都访问一个域名服务器，会产生很大的流量</li><li>远程的集中式数据库：客户机要访问可能要花费很多时间，RTT会很大，造成大时延</li></ul>
          </div>
<p>  &emsp;&emsp;DNS采用三层结构</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_DNS%20Server.png" alt="DNS Server.png" style="zoom: 33%;" /></p>
<p>一个客户机得到<code>www.amazon.com</code>的IP地址的步骤：</p>
<ol>
<li>客户机先查询根域名服务器，得到顶级域名服务器<code>.com DNS server</code>的地址；</li>
<li>客户机查询顶级域名服务器<code>.com DNS server</code>，得到权威域名服务器<code>amazon.com DNS server</code>的地址；</li>
<li>客户机查询权威域名服务器<code>amazon.com DNS server</code>，得到<code>www.amazon.com</code>的IP地址</li>
</ol>
<h4 id="根域名服务器（Root-Name-Server）"><a href="#根域名服务器（Root-Name-Server）" class="headerlink" title="根域名服务器（Root Name Server）"></a>根域名服务器（Root Name Server）</h4><ul>
<li>官方的服务器，是<u>连接的最后的方法</u>（如果知道下级域名服务器的地址就不需要再从头开始查询根域名服务器，不然会对根域名服务器产生很大的流量负荷）</li>
<li>对网络运行相当重要，离开根域名服务器网络无法正常工作</li>
<li>域名系统安全扩展（Domain Name System Security Extensions，DNSSEC） —— 对DNS提供给DNS客户端（解析器）的DNS数据来源进行认证，并验证不存在性和校验数据完整性验证。</li>
<li>ICANN（互联网名称与数字地址分配机构，Internet Corporation for Assigned Names and Numbers）—— 管理根域名服务器的组织</li>
</ul>
<div class="note info">
            <p>世界上现在有13个根域名服务器，分布在世界各地。</p>
          </div>
<h4 id="顶层域名服务器（Top-Level-Domain-Server-TLD）"><a href="#顶层域名服务器（Top-Level-Domain-Server-TLD）" class="headerlink" title="顶层域名服务器（Top-Level Domain Server, TLD）"></a>顶层域名服务器（Top-Level Domain Server, TLD）</h4><ul>
<li>各种类型的TLD，比如<code>.com</code>、<code>.org</code>、<code>net</code>、<code>.edu</code>等等，国家的TLD，比如<code>.cn</code>、<code>.uk</code>等等。</li>
<li>Network Solutions：管理<code>.com</code>、<code>net</code>TLD的组织</li>
<li>Educause：管理<code>.edu</code>的组织</li>
</ul>
<h4 id="权威域名服务器（Authoritative-Domain-Server）"><a href="#权威域名服务器（Authoritative-Domain-Server）" class="headerlink" title="权威域名服务器（Authoritative Domain Server）"></a>权威域名服务器（Authoritative Domain Server）</h4><ul>
<li>组织自己的DNS服务器，用来提供组织内部的域名到IP地址的映射</li>
<li>由组织自己或者服务提供商来维护</li>
</ul>
<h4 id="本地域名服务器（Local-DNS-Name-Server）"><a href="#本地域名服务器（Local-DNS-Name-Server）" class="headerlink" title="本地域名服务器（Local DNS Name Server）"></a>本地域名服务器（Local DNS Name Server）</h4><ul>
<li>严格来说不属于层级结构</li>
<li>每个ISP都会有一个本地域名服务器，也叫做<strong>默认域名服务器</strong>（default name server）</li>
<li>当主机要进行DNS查询时，查询会被直接送到本地的DNS服务器。</li>
<li>作用：<ul>
<li>缓存：可以缓存最近收到的域名到IP地址的映射（缓存有时效，会过期）</li>
<li>代理：可以作为代理，代替主机在层级结构中进行查询</li>
</ul>
</li>
</ul>
<h3 id="DNS查询方法"><a href="#DNS查询方法" class="headerlink" title="DNS查询方法"></a>DNS查询方法</h3><h4 id="迭代查询（iterated-query）"><a href="#迭代查询（iterated-query）" class="headerlink" title="迭代查询（iterated query）"></a>迭代查询（iterated query）</h4><p>&emsp;&emsp;被联系到的服务器会将后一个服务器的名字反馈回来，即“我不认识这个域名，但是你可以去问那台服务器(=ﾟωﾟ)ﾉ”</p>
<p>&emsp;&emsp;下面的迭代查询过程，利用本地域名服务器作为代理迭代查询域名对于的IP地址。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_iterated-query.png" alt="iterated query.png" style="zoom:40%;" /></p>
<h4 id="递归查询（recursive-query）"><a href="#递归查询（recursive-query）" class="headerlink" title="递归查询（recursive query）"></a>递归查询（recursive query）</h4><p>&emsp;&emsp;把域名解析的负担交给了联系到的域名服务器，这种方法对于高级的负担增加，所以一般采用迭代查询而不采用递归查询。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_recursive-query.png" alt="recursive query.png" style="zoom:38%;" /></p>
<h3 id="DNS缓存和更新"><a href="#DNS缓存和更新" class="headerlink" title="DNS缓存和更新"></a>DNS缓存和更新</h3><ul>
<li>一旦域名服务器学习到了一个映射，它就会<strong>缓存</strong>这个映射。缓存往往在本地域名服务器里，这样可以减轻根域名服务器的压力。</li>
<li><strong>缓存有效时间TTL</strong>，过了有效时间该缓存就会被删除。</li>
<li><strong>更新/通知机制</strong>：由IETF制定的 RFC2136 标准。<br>&emsp;&emsp;如果中途域名主机改变IP地址，整个网络可能都不知道真正的IP地址，直到TTL到时，所以需要更新/通知机制。</li>
</ul>
<h3 id="DNS记录和消息"><a href="#DNS记录和消息" class="headerlink" title="DNS记录和消息"></a>DNS记录和消息</h3><h4 id="DNS记录"><a href="#DNS记录" class="headerlink" title="DNS记录"></a>DNS记录</h4><p>&emsp;&emsp;DNS的分布式数据库里存储了<strong>资源记录</strong>（resource record, RR）</p>
<p>RR的格式：<code>(name, value, type, ttl)</code></p>
<p><strong>type = A</strong></p>
<ul>
<li>name：主机名</li>
<li>value：对应的IP地址</li>
</ul>
<p><strong>type = NS</strong></p>
<ul>
<li>name：域（如<code>foo.com</code>）</li>
<li>value：对应的权威域名服务器的主机名</li>
</ul>
<p><strong>type = CNAME</strong></p>
<ul>
<li>name：别名</li>
<li>value：对应的规范主机名</li>
<li>比如 <code>www.ibm.com</code> 是 <code>servereast.backup2.ibm.com</code> 的别名，这与负荷的分配有关，可能有多个服务器。</li>
</ul>
<p><strong>type = MX</strong></p>
<ul>
<li>name：邮件服务器别名</li>
<li>value：对应的规范主机名</li>
</ul>
<h4 id="DNS消息"><a href="#DNS消息" class="headerlink" title="DNS消息"></a>DNS消息</h4><p>&emsp;&emsp;DNS有两种消息类型：查询（query）和回答（reply），两种消息格式相同。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_DNS-message.png" alt="DNS message.png" style="zoom: 50%;" /></p>
<h4 id="向DNS数据库插入记录"><a href="#向DNS数据库插入记录" class="headerlink" title="向DNS数据库插入记录"></a>向DNS数据库插入记录</h4><p>比如要创建一个<code>networkutopia.com</code>的网站</p>
<ul>
<li>先在<code>.com</code>的TLD提供商 Network Solution 注册 <code>networkutopia.com</code><ul>
<li>提供信息：域名、权威域名服务器的IP地址</li>
<li>提供商会向<code>.com</code>TLD服务器插入 NS、A 的RR<br>(<code>networkutopia.com</code>, <code>dns1.networkutopia.com</code>, NS)<br>(<code>dns1.networkutopia.com</code>, <code>212.212.212.1</code>, A)</li>
</ul>
</li>
<li>在自己的权威域名服务器上进行配置<ul>
<li>插入<code>www.networkutopia.com</code>的type A记录</li>
<li>如果是邮件服务，插入<code>networkutopia.com</code>的type MX记录</li>
</ul>
</li>
</ul>
<h3 id="DNS查询工具"><a href="#DNS查询工具" class="headerlink" title="DNS查询工具"></a>DNS查询工具</h3><p>&emsp;&emsp;在命令行用<code>nslookup</code>进行DNS查询。</p>
<h4 id="nslookup直接查询"><a href="#nslookup直接查询" class="headerlink" title="nslookup直接查询"></a>nslookup直接查询</h4><p>&emsp;&emsp;查询一个域名的A记录，如果没指定dns-server，用系统默认的dns服务器。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nslookup domain [dns-server]</span><br></pre></td></tr></table></figure>
<h4 id="nslookup查询其他记录"><a href="#nslookup查询其他记录" class="headerlink" title="nslookup查询其他记录"></a>nslookup查询其他记录</h4>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nslookup -qt&#x3D;type domain [dns-server]</span><br></pre></td></tr></table></figure>
<p>type可以是以下这些类型：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>type</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>地址记录</td>
</tr>
<tr>
<td>AAAA</td>
<td>地址记录</td>
</tr>
<tr>
<td>AFSDB</td>
<td>Andrew文件系统数据库服务器记录</td>
</tr>
<tr>
<td>ATMA</td>
<td>ATM地址记录</td>
</tr>
<tr>
<td>CNAME</td>
<td>别名记录</td>
</tr>
<tr>
<td>HINFO</td>
<td>硬件配置记录，包括CPU、操作系统信息</td>
</tr>
<tr>
<td>ISDN</td>
<td>域名对应的ISDN号码</td>
</tr>
<tr>
<td>MB</td>
<td>存放指定邮箱的服务器</td>
</tr>
<tr>
<td>MG</td>
<td>邮件组记录</td>
</tr>
<tr>
<td>MINFO</td>
<td>邮件组和邮箱的信息记录</td>
</tr>
<tr>
<td>MR</td>
<td>改名的邮箱记录</td>
</tr>
<tr>
<td>MX</td>
<td>邮件服务器记录</td>
</tr>
<tr>
<td>NS</td>
<td>名字服务器记录</td>
</tr>
<tr>
<td>PTR</td>
<td>反向记录</td>
</tr>
<tr>
<td>RP</td>
<td>负责人记录</td>
</tr>
<tr>
<td>RT</td>
<td>路由穿透记录</td>
</tr>
<tr>
<td>SRV</td>
<td>TCP服务器信息记录</td>
</tr>
<tr>
<td>TXT</td>
<td>域名对应的文本信息</td>
</tr>
<tr>
<td>X25</td>
<td>域名对应的X.25地址记录</td>
</tr>
</tbody>
</table>
</div>
<h2 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h2><p>&emsp;&emsp;点对点体系结构（Peer-peer architecture）</p>
<h3 id="P2P概述"><a href="#P2P概述" class="headerlink" title="P2P概述"></a>P2P概述</h3><ul>
<li>没有一个一直在线的服务器；</li>
<li>任意端系统之间直接进行通信；</li>
<li>每个点（peer）向其他的点请求服务，同时作为回报也会提供相应的服务；</li>
</ul>
<p>优点：<strong>自扩展性</strong>（self-scalability）：新的点都会提供服务容量和负荷。</p>
<p>缺点：每个点都是间断性连接，而且IP地址会改变。</p>
<p>例子：P2P的文件分享。</p>
<h3 id="文件分发：客户机-服务器结构-vs-P2P"><a href="#文件分发：客户机-服务器结构-vs-P2P" class="headerlink" title="文件分发：客户机-服务器结构 vs P2P"></a>文件分发：客户机-服务器结构 vs P2P</h3><p>&emsp;&emsp;从一个服务器分发大小为F的文件到N个节点需要多少时间？（每个节点上传和下载的速率都是有限的，网络中有足够的带宽）</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_file-distribution.png" alt="file distribution.png" style="zoom: 40%;" /></p>
<p>如果选用<strong>客户机-服务器</strong>结构</p>
<ul>
<li>服务器上传：需要上传这份文件 $N$ 次，上传速度为 $u_s$，则需要的上传时间为 $NF/u_s$</li>
<li><p>客户机下载：每个客户机都需要下载文件，$d_{min}$ 是客户机最小下载速度，则客户机下载的最大时间为 $F/d{min}$</p>
<p>&emsp;&emsp;客户机-服务器结构的分发时间</p>
<script type="math/tex; mode=display">
D_{c\_s} \geq max\{NF/u_s, F/d_{min}\}</script><p>&emsp;&emsp;此处的N导致耗费的时间随要下载的节点的数量线性增长，当要下载的节点数目大时，要耗费相当多的时间。</p>
<div class="note info">
            <p>&emsp;&emsp;不需要先上传完再下载，参考<a href="https://gy23333.github.io/2020/03/16/《计算机网络-自顶向下方法》笔记/#分组交换（Packet-Switching）">第一章/网络核心/分组交换</a>，以分组为单位发送，可以忽略上传到下载的时间。</p>
          </div>
</li>
</ul>
<p>如果选用<strong>P2P</strong>结构</p>
<ul>
<li>服务器上传：服务器至少要上传1次文件，上传时间为 $F/u_s$</li>
<li>客户机下载：每个客户机都要下载文件，客户机最大下载时间为$F/d_{min}$</li>
<li><p>客户机上传：每个下载了文件的客户机都可以上传文件，此时总上传速率可以达到$u_s+\sum\limits^{n} u_i$</p>
<p>&emsp;&emsp;P2P结构的分发时间</p>
<script type="math/tex; mode=display">
D_{P2P} \geq max\{F/u_s, F/d_{min}, NF/(u_s+\sum\limits^{n} u_i)\}</script></li>
</ul>
<p>客户机-服务器结构和P2P分发时间对比</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_vsPic.png" alt="vsPic.png" style="zoom:33%;" /></p>
<h3 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h3><ul>
<li>文件分为大小为 256Kb的块（chunk）</li>
<li>每个节点负责上传和下载的文件块</li>
<li>追踪器（tracker）：追踪参加洪流的节点</li>
<li>洪流（torrent）：有一组节点相互交换文件块</li>
<li><p>新的节点想下载文件，先询问追踪器参加的节点，再从相近的节点处下载文件块</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_P2P-file.png" alt="P2P file.png" style="zoom:50%;" /></p>
</li>
<li><p>节点加入洪流：</p>
<ul>
<li>本身没有文件块，但是随着时间的推移会从其他节点获取文件块</li>
<li>需要在追踪器进行登记，并且一般连接临近的节点</li>
</ul>
</li>
<li>下载时，节点会上传文件块到其他节点</li>
<li>节点可以更改交换文件块的节点</li>
<li>节点随时会上线和下线</li>
<li>一旦节点有了完整的文件，它可以离开或者留在洪流中</li>
</ul>
<h4 id="请求文件块"><a href="#请求文件块" class="headerlink" title="请求文件块"></a>请求文件块</h4><ul>
<li>在给定的时间，不同的节点拥有不同的文件块</li>
<li>一定周期，新的节点会问每个节点有哪些块</li>
<li>新节点会从其他节点处下载缺失的文件块<br><strong>最稀缺优先</strong>（rarest first）：如果有10个节点都有第1、2块，只有一个节点有第3块，则先下载第3块。</li>
</ul>
<h4 id="发送文件块"><a href="#发送文件块" class="headerlink" title="发送文件块"></a>发送文件块</h4><p>  &emsp;&emsp;发送文件块遵守<strong>一报还一报原则（tit-for-tat）</strong></p>
<ul>
<li>节点会给目前给它发送文件块速率最高的四个节点发送文件块，其他节点就不发送了，每隔 10s 会选出新的top4</li>
<li><p>每隔 30s 会随机选择其他节点发送文件块，这样这个随机节点可能就会成为新的top4</p>
<div class="note info">
            <p>tit-for-tat原则：上传速率快的节点相应地得到高下载速率的回报。</p>
          </div>
</li>
</ul>
<h2 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h2><p>  &emsp;&emsp;目标：建立客户机/服务器的应用中的通信运用socket</p>
<p>  &emsp;&emsp;socket：相当于应用进程和点对点传输协议之间的一扇门</p>
<p>  &emsp;&emsp;socket类型：对应TCP和UDP有两种socket</p>
<h3 id="UDP中的socket编程"><a href="#UDP中的socket编程" class="headerlink" title="UDP中的socket编程"></a>UDP中的socket编程</h3><p>  UDP：客户机与服务器之间没有连接</p>
<ul>
<li>发送数据前不需要握手</li>
<li>发送数据包附加IP地址+端口号</li>
<li><p>接收方从数据包中提取处IP地址+端口号</p>
<div class="note info">
            <p>&emsp;&emsp;UDP提供的是一种不可靠的数据流传输，传输过程中可能会丢包，接收的时候顺序也可能被打乱。</p>
          </div>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_UDP_socket.png" alt="UDP socket.png" style="zoom:50%;" /></p>
<h4 id="UDP中的socket编程示例"><a href="#UDP中的socket编程示例" class="headerlink" title="UDP中的socket编程示例"></a>UDP中的socket编程示例</h4><p>&emsp;&emsp;这里jupyter notebook中进行编程，安装好jupyter notebook后，在命令行执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure>
<p>即可启动jupyter notebook</p>
<p>UDP服务器代码</p>
<figure class="highlight python"><figcaption><span>UDPServer.ipynb</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> * <span class="comment">#引入socket库</span></span><br><span class="line"></span><br><span class="line">serverPort = <span class="number">12000</span> <span class="comment">#服务器端口号</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_DGRAM) <span class="comment">#创建服务器套接字</span></span><br><span class="line">serverSocket.bind((<span class="string">''</span>, serverPort)) <span class="comment">#给套接字绑定端口号</span></span><br><span class="line">print(<span class="string">'The server is ready to receive.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>: <span class="comment">#服务器要一直在线等待，所以给一个死循环</span></span><br><span class="line">    message, clientAddress = serverSocket.recvfrom(<span class="number">2048</span>) <span class="comment">#从服务器套接字中读取信息（发送的消息和客户机IP地址+端口号）</span></span><br><span class="line">    modifiedMessage = message.decode().upper() <span class="comment">#对消息进行处理（此处是改大写）</span></span><br><span class="line">    </span><br><span class="line">    serverSocket.sendto(modifiedMessage.encode(), clientAddress) <span class="comment">#将处理后的消息发回给客户机</span></span><br></pre></td></tr></table></figure>
<p>UDP客户机代码</p>
<figure class="highlight python"><figcaption><span>UDPClient.ipynb</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> * <span class="comment">#引入socket库</span></span><br><span class="line"></span><br><span class="line">serverName = gethostname() <span class="comment">#由于没得服务器，服务器主机用本机来当</span></span><br><span class="line">serverPort = <span class="number">12000</span> <span class="comment">#服务器端口号</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_DGRAM) <span class="comment">#创建客户机套接字</span></span><br><span class="line"></span><br><span class="line">message = input(<span class="string">'Input lowercase sentence:'</span>) <span class="comment">#得到输入字符串</span></span><br><span class="line">clientSocket.sendto(message.encode(),(serverName, serverPort)) <span class="comment">#发送数据到相应主机名+端口号的服务器进程</span></span><br><span class="line"></span><br><span class="line">modifiedMessage, serverAddress = clientSocket.recvfrom(<span class="number">2048</span>) <span class="comment">#接收服务器发回的消息</span></span><br><span class="line">print(modifiedMessage.decode()) <span class="comment">#显示接收的字符串</span></span><br><span class="line"></span><br><span class="line">clientSocket.close() <span class="comment">#关闭客户机socket</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;先运行UDPServer.ipynb，启动服务器运行。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_UDP_socket_server.png" alt="UDP socket.png" style="zoom:50%;" /></p>
<p>&emsp;&emsp;先运行UDPClient.ipynb，进行客户机访问。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_UDP_socket_client.png" alt="UDP socket.png" style="zoom:50%;" /></p>
</li>
</ul>
<h3 id="TCP中的socket编程"><a href="#TCP中的socket编程" class="headerlink" title="TCP中的socket编程"></a>TCP中的socket编程</h3><ul>
<li>服务器的先行准备<ul>
<li>服务器必须先运行</li>
<li>服务器需要创建socket来连接客户机</li>
</ul>
</li>
<li>客户机连接服务器<ul>
<li>客户机需要创建自己的socket，明确服务器进程的IP地址和端口号</li>
<li>客户机创建socket时，客户机和服务器之间需建立TCP连接</li>
</ul>
</li>
<li><p>服务器接收客户机消息</p>
<ul>
<li>服务器需创建一个新的socket，为了服务器进程能够和客户机进行通信<ul>
<li>要运行服务器与多个客户机进行通信</li>
<li>用源的端口号来区分不同的客户机</li>
</ul>
</li>
</ul>
<div class="note info">
            <p>&emsp;&emsp;TCP提供的是一种可靠的字节流（byte-stream）传输（pipe）。</p>
          </div>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP_socket.png" alt="TCP socket.png" style="zoom:50%;" /></p>
</li>
</ul>
<h4 id="TCP中的socket编程示例"><a href="#TCP中的socket编程示例" class="headerlink" title="TCP中的socket编程示例"></a>TCP中的socket编程示例</h4><p>  TCP服务器代码<br>  <figure class="highlight python"><figcaption><span>TCPServer.ipynb</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> * <span class="comment">#引入socket库</span></span><br><span class="line"></span><br><span class="line">serverPort = <span class="number">12000</span> <span class="comment">#服务器端口号</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_STREAM) <span class="comment">#创建服务器套接字（前台）</span></span><br><span class="line">serverSocket.bind((<span class="string">''</span>, serverPort)) <span class="comment">#给套接字绑定端口号</span></span><br><span class="line">serverSocket.listen(<span class="number">1</span>)</span><br><span class="line">print(<span class="string">'The server is ready to receive.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>: <span class="comment">#服务器要一直在线等待，所以给一个死循环</span></span><br><span class="line">    connectionSocket, addr = serverSocket.accept() <span class="comment">#前台套接字接收到请求后，创建一个新的套接字（窗口）</span></span><br><span class="line">    </span><br><span class="line">    sentence = connectionSocket.recv(<span class="number">1024</span>).decode() <span class="comment">#窗口套接字读取信息</span></span><br><span class="line">    capitalizedSentence = sentence.upper() <span class="comment">#对消息进行处理（此处是改大写）</span></span><br><span class="line">    </span><br><span class="line">    connectionSocket.send(capitalizedSentence.encode()) <span class="comment">#将处理后的信息发回给客户机</span></span><br><span class="line">    </span><br><span class="line">    connectionSocket.close() <span class="comment">#关闭窗口套接字，前台套接字保持开放</span></span><br></pre></td></tr></table></figure></p>
<p>  TCP客户机代码<br>  <figure class="highlight python"><figcaption><span>TCPClient.ipynb</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> * <span class="comment">#引入socket库</span></span><br><span class="line"></span><br><span class="line">serverName = gethostname() <span class="comment">#由于没得服务器，服务器主机用本机来当</span></span><br><span class="line">serverPort = <span class="number">12000</span> <span class="comment">#服务器端口号</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_STREAM) <span class="comment">#创建客户机套接字(类型为字节流SOCK_STREAM)</span></span><br><span class="line">clientSocket.connect((serverName, serverPort)) <span class="comment">#TCP连接</span></span><br><span class="line"></span><br><span class="line">sentence = input(<span class="string">'Input lowercase sentence:'</span>) <span class="comment">#得到输入字符串</span></span><br><span class="line">clientSocket.send(sentence.encode()) <span class="comment">#发送数据到服务器</span></span><br><span class="line"></span><br><span class="line">modifiedSentence = clientSocket.recv(<span class="number">1024</span>) <span class="comment">#接收服务器发回的消息</span></span><br><span class="line">print(<span class="string">'From server:'</span>, modifiedSentence.decode()) <span class="comment">#显示接收的字符串</span></span><br><span class="line"></span><br><span class="line">clientSocket.close() <span class="comment">#关闭客户机socket</span></span><br></pre></td></tr></table></figure></p>
<p>  &emsp;&emsp;先运行TCPServer.ipynb，启动服务器运行。</p>
<p>  <img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP_socket_server.png" alt="TCP socket.png" style="zoom:50%;" /></p>
<p>  &emsp;&emsp;先运行TCPClient.ipynb，进行客户机访问。</p>
<p>  <img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP_socket_client.png" alt="TCP socket.png" style="zoom:50%;" /></p>
<h1 id="传输层（Transport-Layer）"><a href="#传输层（Transport-Layer）" class="headerlink" title="传输层（Transport Layer）"></a>传输层（Transport Layer）</h1><h2 id="传输层服务"><a href="#传输层服务" class="headerlink" title="传输层服务"></a>传输层服务</h2><h3 id="传输层概述"><a href="#传输层概述" class="headerlink" title="传输层概述"></a>传输层概述</h3><ul>
<li>为不同主机之间的应用进程提供通信的桥梁</li>
<li>端对端：传输层协议在端系统间运行，不需要涉及网络核心<ul>
<li>发送方把应用层接到的消息分成段（segment），再把这些段传输给网络层</li>
<li>接收方把接收到的段重新拼装成消息，传输给应用层</li>
</ul>
</li>
<li>传输层的协议：TCP和UDP</li>
</ul>
<p><strong>传输层和网络层对比</strong></p>
<ul>
<li>网络层：主机之间的通信</li>
<li><p>传输层：进程之间的通信</p>
<p>传输层依赖于并能强化网络层服务。</p>
</li>
</ul>
<h3 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h3><ul>
<li>TCP：可靠的，有序的传送<ul>
<li>拥塞控制</li>
<li>流量控制</li>
<li>需要建立连接</li>
</ul>
</li>
<li><p>UDP：不可靠的，无序的传送</p>
<ul>
<li>提供尽力而为交付服务</li>
</ul>
<p>二者均不提供的服务：延时保障、带宽保障</p>
</li>
</ul>
<h2 id="多路复用（Multiplexing）与多路分用（Demultiplexing）"><a href="#多路复用（Multiplexing）与多路分用（Demultiplexing）" class="headerlink" title="多路复用（Multiplexing）与多路分用（Demultiplexing）"></a>多路复用（Multiplexing）与多路分用（Demultiplexing）</h2><p>  &emsp;&emsp;多路复用存在于发送方：发送方需要处理多个套接字，并且给套接字加上传输层的头部。</p>
<p>  &emsp;&emsp;多路分用存在于接收方：利用头部信息，将接收到的报文段传输给正确的套接字。</p>
<p>  <img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Multiplexing.png" alt="Multiplexing/demultiplexing.png" style="zoom:50%;" /></p>
<h3 id="多路分用"><a href="#多路分用" class="headerlink" title="多路分用"></a>多路分用</h3><h4 id="多路分用工作流程"><a href="#多路分用工作流程" class="headerlink" title="多路分用工作流程"></a>多路分用工作流程</h4><ul>
<li>主机收到IP数据报（IP datagram）<ul>
<li>每个数据报有源IP地址和目的IP地址</li>
<li>每个数据报携带一个传输层报文段（segment）</li>
<li>每个报文段有源和目的的端口号</li>
</ul>
</li>
<li><p>主机利用IP地址和端口号来把报文段传入正确的套接字</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_segment-format.png" alt="segment format.png" style="zoom:50%;" /></p>
</li>
</ul>
<h4 id="无连接的多路分用（Connectionless-demultiplexing）"><a href="#无连接的多路分用（Connectionless-demultiplexing）" class="headerlink" title="无连接的多路分用（Connectionless demultiplexing）"></a>无连接的多路分用（Connectionless demultiplexing）</h4><p>  &emsp;&emsp;参考<a href="https://gy23333.github.io/2020/03/16/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0/#UDP%E4%B8%AD%E7%9A%84socket%E7%BC%96%E7%A8%8B">UDP的socket工作方式</a>，如果数据报的<strong>目的IP地址和端口号</strong>相同，它们将被传到同一个socket当中。（即使数据报的源可能不同）</p>
<h4 id="面向连接的多路分用（Connection-oriented-demux）"><a href="#面向连接的多路分用（Connection-oriented-demux）" class="headerlink" title="面向连接的多路分用（Connection-oriented demux）"></a>面向连接的多路分用（Connection-oriented demux）</h4><p>  &emsp;&emsp;参考<a href="https://gy23333.github.io/2020/03/16/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0/#TCP%E4%B8%AD%E7%9A%84socket%E7%BC%96%E7%A8%8B">TCP的socket工作方式</a></p>
<ul>
<li>标记TCP的socket需要4元组：源IP地址、源端口号、目的IP地址、目的端口号</li>
<li>多路分用：接收方要用到上面4个值来传入不同的socket</li>
<li>服务器的主机可能要同时支持多个TCP连接</li>
<li>web服务器有不同的socket对应每个连接的客户机，其中非持久性HTTP会给每个请求都建立新的socket。</li>
</ul>
<h2 id="UDP-1"><a href="#UDP-1" class="headerlink" title="UDP"></a>UDP</h2><h2 id="UDP概述"><a href="#UDP概述" class="headerlink" title="UDP概述"></a>UDP概述</h2><p>  &emsp;&emsp;UDP（User Datagram Protocol，用户数据报协议），标准为RFC 768。</p>
<ul>
<li>只有基本的功能</li>
<li>尽力而为的服务，UDP可能会丢包或者失序</li>
<li><p>不用连接：客户机和服务器不需要握手，每个UDP段都是独立处理的</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_UDP-segment.png" alt="UDP segment.png" style="zoom:50%"></p>
</li>
<li><p>UDP的优点</p>
<ul>
<li>不需要进行连接，连接可能会造成时延</li>
<li>简单：不需要考虑连接的状态</li>
<li>相对小的头的大小</li>
<li>不需要拥塞控制，可以尽快地把UDP段发出去</li>
</ul>
</li>
<li>UDP的应用<ul>
<li>流媒体的app（运行一部分数据的丢失，但是对速度很敏感）</li>
<li>DNS</li>
<li>SNMP</li>
</ul>
</li>
<li>通过UDP进行可靠的传输（UDP本身是不可靠的）<ul>
<li>在应用层增加可靠性</li>
<li>app要有对应的错误恢复方法</li>
</ul>
</li>
</ul>
<h3 id="UDP校验和（UDP-checksum）"><a href="#UDP校验和（UDP-checksum）" class="headerlink" title="UDP校验和（UDP checksum）"></a>UDP校验和（UDP checksum）</h3><p>  &emsp;&emsp;位于UDP头部，负责检测传输的段有没有发生“错误”（比如位的翻转）</p>
<ul>
<li>发送方：<ul>
<li>把发送的段的内容包括头部分，当作一组16-bit的整数</li>
<li>校验和：报文段中的所有16-bit的和的取关于“1”的补码</li>
<li>发送方要将校验和放到UDP的校验和部分</li>
</ul>
</li>
<li><p>接收方：</p>
<ul>
<li>计算接收到的报文段的校验和</li>
<li>将接收方的校验和与发送方的校验和进行比较，不同则检测出错误，相同则没检测出错误</li>
</ul>
<div class="note info">
            <p>&emsp;&emsp;校验和相同只能说是“检验不出错误”，不能保障没有错误。比如传输中多个16bit字发生错误，但是可能恰巧相加校验和不变。</p>
          </div>
<div class="note warning">
            <p>  例题：有两个16-bit的字，1110011001100110 和 1101010101010101，求校验和。</p><script type="math/tex; mode=display">\begin{split}   &1110011001100110\\\\  +\ &1101010101010101\\\\  ———————&—————————\\\\  wrap\ around\quad1&1011101110111011\quad\\\\  sum\quad&1011101110111100\\\\  checksum\quad&0100010001000011  \end{split}</script><p>  &emsp;&emsp;wraparound存在溢出，进位的部分回卷，加到最后一位。</p>
          </div>
</li>
</ul>
<h2 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h2><p>  &emsp;&emsp;可靠数据传输原理（Principles of reliable data transfer, <strong>rdt</strong>）</p>
<ul>
<li><p>对应用层、传输层、链路层都很重要</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_provide-service.png" alt="provide service.png" style="zoom:46%">&emsp;&emsp;<img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_service-implementation.png" alt="service implementation.png" style="zoom:50%"></p>
</li>
<li><p>不可靠信道的特点决定了不可靠传输协议的复杂度</p>
</li>
</ul>
<p>调用接口函数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>接口函数</th>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rdt_send()</code></td>
<td>data</td>
<td>调用数据传输协议的发送方，将要发送的数据交付给位于接收方的较高层</td>
</tr>
<tr>
<td><code>udt_send()</code></td>
<td>packet</td>
<td>rdt调用，通过不可靠信道，将packet传输到接收方</td>
</tr>
<tr>
<td><code>rdt_rcv()</code></td>
<td>packet</td>
<td>在packet到达接收方信道时调用</td>
</tr>
<tr>
<td><code>deliver_data()</code></td>
<td>data</td>
<td>rdt调用，传输数据到高层</td>
</tr>
</tbody>
</table>
</div>
<div class="note info">
            <p>与不可靠信道之间的函数调用都是双向的，由于其不可靠性，需要进行确认的控制信号（ACK，NAK）。</p>
          </div>
<h3 id="rdt1-0：经可靠信道的可靠数据传输"><a href="#rdt1-0：经可靠信道的可靠数据传输" class="headerlink" title="rdt1.0：经可靠信道的可靠数据传输"></a>rdt1.0：经可靠信道的可靠数据传输</h3><h4 id="rdt1-0概述"><a href="#rdt1-0概述" class="headerlink" title="rdt1.0概述"></a>rdt1.0概述</h4><ul>
<li>下层信道完全可靠：rdt1.0中假设下层的信道是一个完全可靠的信道（理想情况）<ul>
<li>没有bit的错误</li>
<li>没有分组（packet）丢失</li>
</ul>
</li>
<li>发送方和接收方的<strong>有限状态机（FSM）</strong>（存在状态和操作）<ul>
<li>发送方发送数据给下层信道</li>
<li>接收方接收下层信道传来的数据</li>
</ul>
</li>
</ul>
<h4 id="rdt1-0有限状态机"><a href="#rdt1-0有限状态机" class="headerlink" title="rdt1.0有限状态机"></a>rdt1.0有限状态机</h4><h5 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h5><p>&emsp;&emsp;发送方首先在“<strong>等待上级调用</strong>”的状态，<code>rdt_send(data)</code>上级调用rdt，从上级接收到data，<code>make_pkt(data)</code>将data装到packet里，再用<code>udt_send(packet)</code>将packet发送出去，完成后发送方再回到“等待上级调用”的状态。（发送方只有一个状态）</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt1-0-sender.png" alt="rdt1.0 sender.png" style="zoom:50%"></p>
<h5 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h5><p>&emsp;&emsp;接收方首先在“<strong>等待下级调用</strong>”的状态，<code>rdt_rcv(packet)</code>下级调用rdt，从下级接收到packet，用<code>extract(packet, data)</code>将packet重新恢复成data，提取出来的data再通过<code>deliver_data(data)</code>传送给上级。完成后接收方再回到“等待下级调用”的状态。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt1-0-receiver.png" alt="rdt1.0 receiver.png" style="zoom:50%"></p>
<p>下层信道不可能完全可靠 =&gt; 引入rdt2.0</p>
<h3 id="rdt2-0：经具有比特差错信道的数据传输"><a href="#rdt2-0：经具有比特差错信道的数据传输" class="headerlink" title="rdt2.0：经具有比特差错信道的数据传输"></a>rdt2.0：经具有比特差错信道的数据传输</h3><p>&emsp;&emsp;引入差错检测、控制信号和重传机制，解决下层信道不可靠问题。</p>
<h4 id="rdt2-0概述"><a href="#rdt2-0概述" class="headerlink" title="rdt2.0概述"></a>rdt2.0概述</h4><ul>
<li>packet在下层信道传输中会出现<strong>比特翻转</strong>：可以引入<a href="https://gy23333.github.io/2020/03/16/《计算机网络-自顶向下方法》笔记/#UDP校验和（UDP-checksum）"><strong>校验和（checksum）</strong></a>来检测比特错误。</li>
<li>错误恢复——如果检验到错误如何恢复？<ul>
<li><strong>ACKs（acknowledgements）</strong>：接收方告诉发送方收到的pkt是正确的</li>
<li><strong>NAKs（negative acknowledgements）</strong>：接收方告诉发送方收到的pkt是错误的</li>
<li>发送方收到NAK则重传那个pkt</li>
</ul>
</li>
<li>rdt2.0引入的新机制<ul>
<li>差错检测：checksum</li>
<li>接收方反馈：控制信号（control msg），即ACK和NAK</li>
<li>重传</li>
</ul>
</li>
</ul>
<h4 id="rdt2-0无限状态机"><a href="#rdt2-0无限状态机" class="headerlink" title="rdt2.0无限状态机"></a>rdt2.0无限状态机</h4><h5 id="发送方-1"><a href="#发送方-1" class="headerlink" title="发送方"></a>发送方</h5><p>&emsp;&emsp;rdt2.0的发送方有2个状态——<strong>等待上级调用</strong>、<strong>等待ACK或NAK</strong>。发送方最初处于“<strong>等待上级调用</strong>”的状态，<code>rdt_send(data)</code>上级调用rdt，从上级接收到data，<code>sndpkt = make_pkt(data, checksum)</code>将data装到packet里，再用<code>udt_send(sndpkt)</code>将packet发送出去。此时，发送方变为“<strong>等待ACK或NAK</strong>”的状态。<code>rdt_rcv(rcvpkt)</code>接收反馈，如果<code>isNAK(rcvpkt)</code>即接收到NAK，则重传<code>udt_send(sndpkt)</code>，并保持“<strong>等待ACK或NAK</strong>”的状态；如果<code>isACK(rcvpkt)</code>即接收到ACK，则回到“<strong>等待上级调用</strong>”的状态。</p>
<div class="note info">
            <p>停等机制（stop and wait）</p><p>&emsp;&emsp;发送方发送一个packet，然后等待接收方的响应。</p>
          </div>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt2-0-sender.png" alt="rdt2.0 sender.png" style="zoom:50%"></p>
<h5 id="接收方-1"><a href="#接收方-1" class="headerlink" title="接收方"></a>接收方</h5><p>&emsp;&emsp;接收方还是只有一个状态——<strong>等待下级调用</strong>。接收方首先在“<strong>等待下级调用</strong>”的状态，<code>rdt_rcv(rcvpkt)</code>接收方接收packet，如果<code>corrupt(rcvpkt)</code>，即检测到错误，则<code>udt_send(NAK)</code>反馈NAK；如果<code>notcorrupt(rcvpkt)</code>，即未检测到错误，则<code>extract(packet, data)</code>将packet重新恢复成data，<code>deliver_data(data)</code>将data传送给上级，最后<code>udt_send(ACK)</code>反馈ACK。完成后接收方再回到“等待下级调用”的状态。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt2-0-receiver.png" alt="rdt2.0 receiver.png" style="zoom:50%"></p>
<p>接收方可能判断ACK/NAK信号出错，导致发送分组重复 =&gt; 引入rdt2.1</p>
<h3 id="rdt2-1：接收方判断ACK-NAK信号出错"><a href="#rdt2-1：接收方判断ACK-NAK信号出错" class="headerlink" title="rdt2.1：接收方判断ACK/NAK信号出错"></a>rdt2.1：接收方判断ACK/NAK信号出错</h3><p>&emsp;&emsp;引入0/1序号和丢弃分组，解决接收方判断ACK/NAK信号出错，导致发送分组重复问题。但这也让发送方和接收方有限状态机的状态翻倍。</p>
<h4 id="rdt2-1有限状态机"><a href="#rdt2-1有限状态机" class="headerlink" title="rdt2.1有限状态机"></a>rdt2.1有限状态机</h4><h5 id="发送方-2"><a href="#发送方-2" class="headerlink" title="发送方"></a>发送方</h5><p>&emsp;&emsp;相较于rdt2.0，rdt2.1在发送的packet里包含了0/1序号（sequence number），所以发送方有4种状态——<strong>等待上级调用 0</strong>、<strong>等待ACK或NAK 0</strong>、<strong>等待上级调用 1</strong>、<strong>等待ACK或NAK 1</strong>。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt2-1-sender.png" alt="rdt2.1 sender.png" style="zoom:50%"></p>
<h5 id="接收方-2"><a href="#接收方-2" class="headerlink" title="接收方"></a>接收方</h5><p>&emsp;&emsp;接收方有2种状态——<strong>等待下级调用 0</strong>、<strong>等待下级调用 1</strong>。只有在数据包ACK且<strong>收到的packet序号与目前状态等待的序号相同</strong>时，才能向上传输。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt2-1-receiver.png" alt="rdt2.1 receiver.png" style="zoom:50%"></p>
<div class="note info">
            <p>为什么接收方等待1状态接收到0的packet时，为什么要反馈ACK？</p><p>&emsp;&emsp;为了让发送方的状态转移，从“等待ACK或NAK 0”到“等待上级调用 1”。</p>
          </div>
<h3 id="rdt2-2：不发送NAK的协议"><a href="#rdt2-2：不发送NAK的协议" class="headerlink" title="rdt2.2：不发送NAK的协议"></a>rdt2.2：不发送NAK的协议</h3><p>&emsp;&emsp;用重复的ACK替代NAK，解决信号冗余问题。</p>
<h4 id="rdt2-2概述"><a href="#rdt2-2概述" class="headerlink" title="rdt2.2概述"></a>rdt2.2概述</h4><ul>
<li>只用ACK，不用NAK，实现和rdt2.1一样的功能。</li>
<li>在检测到错误时，不发送NAK，但是接收方要发送判断上一次序号的ACK（同时包括序号）</li>
<li>用重复的ACK代替NAK</li>
</ul>
<h4 id="rdt2-2有限状态机"><a href="#rdt2-2有限状态机" class="headerlink" title="rdt2.2有限状态机"></a>rdt2.2有限状态机</h4><h5 id="发送方-3"><a href="#发送方-3" class="headerlink" title="发送方"></a>发送方</h5><p>&emsp;&emsp;将rdt2.1中的<code>isNAK(rcvpkt)</code>判断本次反馈是NAK，替代成判断上次序号的反馈是ACK，比如rdt2.2在“<strong>等待ACK 0</strong>”时，如果<code>isACK(rcvpkt, 1)</code>，则相当于收到来rdt2.1中的<code>isNAK(rcvpkt)</code>。其余不变。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt2-2-sender.png" alt="rdt2.2 sender.png" style="zoom:50%"></p>
<h5 id="接收方-3"><a href="#接收方-3" class="headerlink" title="接收方"></a>接收方</h5><p>&emsp;&emsp;接收方如果校验和检测出错，则发送上一次序号的ACK；在校验和检测正确时，发送ACK也需要带上本次的序号。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt2-2-receiver.png" alt="rdt2.2 receiver.png" style="zoom:50%"></p>
<h3 id="rdt3-0：信道存在错误和丢包"><a href="#rdt3-0：信道存在错误和丢包" class="headerlink" title="rdt3.0：信道存在错误和丢包"></a>rdt3.0：信道存在错误和丢包</h3><h4 id="rdt3-0概述"><a href="#rdt3-0概述" class="headerlink" title="rdt3.0概述"></a>rdt3.0概述</h4><p>&emsp;&emsp;发送端在一个合理的时间内，等待接收ACK。</p>
<ul>
<li>当在等待时间内没有接收ACK时，重传</li>
<li>超过时间可能有两种情况：丢包或时延，如果发生时延可能会重复发生pkt，此时rdt2.1和2.2中的序号可以解决问题，同样的发生ACK得带上序号。</li>
<li>需要计时器</li>
</ul>
<h4 id="rdt3-0有限状态机"><a href="#rdt3-0有限状态机" class="headerlink" title="rdt3.0有限状态机"></a>rdt3.0有限状态机</h4><p>&emsp;&emsp;发送方传输开始时，<code>start_timer</code>启动计时器。如果<code>timeout</code>传输超时，则重新启动计时器；如果在规定时间内接收到反馈，则<code>stop_timer</code>结束计时。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt3-0-sender.png" alt="rdt3.0 sender.png" style="zoom:50%"></p>
<h4 id="rdt3-0流程"><a href="#rdt3-0流程" class="headerlink" title="rdt3.0流程"></a>rdt3.0流程</h4><h5 id="正常流程"><a href="#正常流程" class="headerlink" title="正常流程"></a>正常流程</h5><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt3-0-NoLoss.png" alt="rdt3.0 NoLoss.png" style="zoom:50%"></p>
<h5 id="丢packet"><a href="#丢packet" class="headerlink" title="丢packet"></a>丢packet</h5><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt3-0-LossPacket.png" alt="rdt3.0 LossPacket.png" style="zoom:50%"></p>
<h5 id="丢ACK"><a href="#丢ACK" class="headerlink" title="丢ACK"></a>丢ACK</h5><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt3-0-LossACK.png" alt="rdt3.0 LossACK.png" style="zoom:50%"></p>
<h5 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h5><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_rdt3-0-timeout.png" alt="rdt3.0 timeout.png" style="zoom:50%"></p>
<h4 id="rdt3-0性能"><a href="#rdt3-0性能" class="headerlink" title="rdt3.0性能"></a>rdt3.0性能</h4><p>&emsp;&emsp;rdt3.0性能很差</p>
<div class="note warning">
            <p>例题：一个 1Gbps的链路，15ms的传播时延，传输8000bit的packet，求发送方的使用效率。</p><p>传输时延</p><script type="math/tex; mode=display">D_{tran} = \frac LR = \frac{8000\ bits}{10^9\ bits/sec} = 8 ms</script><p>发送方使用效率</p><script type="math/tex; mode=display">U_{sender} = \frac{L/R}{RTT+L/R} = \frac{0.008}{30.008} = 0.00027</script><p>&emsp;&emsp;可见rdt3.0的使用效率很低。</p>
          </div>
<p>&emsp;&emsp;rdt3.0网络协议限制了物理资源的使用率。</p>
<h2 id="流水线协议"><a href="#流水线协议" class="headerlink" title="流水线协议"></a>流水线协议</h2><p>&emsp;&emsp;采用流水线的机制，不要等一个RTT发送回来再发下一个（即不再采用停等机制），来提高物理资源的使用率。</p>
<span class="label info">图 停等机制（Stop-and-wait）</span>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Stop-and-Wait-Operation.png" alt="Stop-and-Wait Operation.png" style="zoom:50%"></p>
<span class="label info">图 流水线机制（Pipelined Operation）</span>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Pipelined-Operation.png" alt="Pipelined Operation.png" style="zoom:50%"></p>
<h3 id="回退N步（Go-back-N，GBN）"><a href="#回退N步（Go-back-N，GBN）" class="headerlink" title="回退N步（Go-back-N，GBN）"></a>回退N步（Go-back-N，GBN）</h3><ul>
<li>发送方可以有至多N个没有ACK的packet同时在流水线上</li>
<li>接收方只发送累计ACK</li>
<li>发送方给最早还没ACK的packet一个计时器，当这个计时器到时时，重传所有的未ACK的packet。</li>
</ul>
<h4 id="GBN发送方"><a href="#GBN发送方" class="headerlink" title="GBN发送方"></a>GBN发送方</h4><ul>
<li>packet头部有k bit的序号，则可以表示 $2^k$ 个序号。</li>
<li>“窗口”大小为N，这一段是允许的未ACK的packet</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_GBN-sender.png" alt="GBN sender.png" style="zoom:50%"></p>
<ul>
<li>ACK(n)累计确认：ACK在发送的时候要带上序号#n，即#n及之前的packet都收到了。接收方发送ACK n，则证明#n及之前的packet都收到了。否则接收方还是发送之前的ACK（重复）。</li>
<li>计时器只给最早的未ACK的packet保留</li>
<li>如果timeout（n），重传#n以及比#n更大的未ACK的packet</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_GBN-sender(1).png" alt="GBN sender.png" style="zoom:50%"></p>
<h4 id="GBN接收方"><a href="#GBN接收方" class="headerlink" title="GBN接收方"></a>GBN接收方</h4><ul>
<li>发送的ACK是顺序接收到的packet里面最大的序列号#<ul>
<li>可能会产生重复的ACK</li>
<li>只需要记住期望的序列号（expextedseqnum）</li>
</ul>
</li>
<li>乱序到达的packet<ul>
<li>直接丢弃，不缓存（缓存会造成数据重复）</li>
<li>重新发送顺序最大序列号#</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_GBN-receiver.png" alt="GBN receiver.png" style="zoom:50%"></p>
<h4 id="GBN流程"><a href="#GBN流程" class="headerlink" title="GBN流程"></a>GBN流程</h4><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_GBN-action.png" alt="GBN action.png" style="zoom:50%"></p>
<div class="note warning">
            <p>例题：采用GBN协议，一个发送方发送了 #0到#5 的packet，但是只收到了 ACK0 和 ACK2。问发送方要重发哪些packet？</p><p>&emsp;&emsp;重发#3、#4、#5 的 packet。</p><p>&emsp;&emsp;虽然没有收到ACK1，但是接收方只有在#n及之前的packet都收到了的时候，才会发送ACKn，发送方接收到ACK n，则证明接收方#n及之前的packet都收到了。所以ACK1应该是在发送过程中丢包了，但是实际接收方已经收到了#1 packet。所以重发#3、#4、#5 的 packet。</p>
          </div>
<h3 id="选择重传（Selective-Repeat，SR）"><a href="#选择重传（Selective-Repeat，SR）" class="headerlink" title="选择重传（Selective Repeat，SR）"></a>选择重传（Selective Repeat，SR）</h3><ul>
<li>接收方分别确认所有正确收到的pkt<ul>
<li>缓存pkt，最终有序传给上层</li>
</ul>
</li>
<li>发送方重发没ACK的pkt<ul>
<li>发送方给每个还没ACK的packet都维持一个计时器</li>
</ul>
</li>
<li>发送方的window<ul>
<li>N个连续的序号</li>
<li>限制发送并且未ACK的pkt</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_SR-windows.png" alt="SR windows.png" style="zoom:50%"></p>
<h4 id="SR发送方"><a href="#SR发送方" class="headerlink" title="SR发送方"></a>SR发送方</h4><ul>
<li>收到上层数据<ul>
<li>如果window里还有可用序列，则继续发送</li>
</ul>
</li>
<li>timeout(n)<ul>
<li>重发<code>pkt n</code>，重启timer</li>
</ul>
</li>
<li>如果<code>ACK(n)</code>在可接收范围内$[sendbase, sendbase+N-1]$<ul>
<li>将<code>pkt n</code>标记为接收完成</li>
<li>如果 n 是最小的未ACK的pkt，则将window滑动到下一个未ACK的pkt</li>
</ul>
</li>
</ul>
<h4 id="SR接收方"><a href="#SR接收方" class="headerlink" title="SR接收方"></a>SR接收方</h4><ul>
<li>如果<code>pkt n</code>在接收范围内$[rcvbase, rcvbase+N-1]$<ul>
<li>发送<code>ACK(n)</code></li>
<li>如果不是按序到达，则缓存pkt</li>
<li>如果是按序到达，则向上交付已有的按序的缓存，并将window滑动到下一个未收到的pkt</li>
</ul>
</li>
<li>如果<code>pkt n</code>在$[rcvbase-N, rcvbase-1]$内<ul>
<li>发送<code>ACK(n)</code></li>
</ul>
</li>
<li>其他情况忽略</li>
</ul>
<h4 id="SR流程"><a href="#SR流程" class="headerlink" title="SR流程"></a>SR流程</h4><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_SR-action.png" alt="SR action.png" style="zoom:50%"></p>
<h4 id="SR困境"><a href="#SR困境" class="headerlink" title="SR困境"></a>SR困境</h4><p>&emsp;&emsp;比如下面序列号有：#0, #1, #2, #3，window大小为3的情况。SR会无法分清a、b两种情况，导致在b中误判重发的第一轮的<code>pkt0</code>，被当作后一轮的<code>pkt0</code>填入。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_SR-dilemma.png" alt="SR dilemma.png" style="zoom:40%"></p>
<h2 id="TCP-1"><a href="#TCP-1" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP概论"><a href="#TCP概论" class="headerlink" title="TCP概论"></a>TCP概论</h3><ul>
<li>点对点（point-to-point）：一个发送方、一个接收方</li>
<li>可靠的、有序的字节流<ul>
<li>没有消息的边界</li>
</ul>
</li>
<li>流水线机制<ul>
<li>窗口大小由拥塞和流量控制</li>
</ul>
</li>
<li>全双工<ul>
<li>同时双向数据流</li>
<li>MSS（maximum segment size）：最大报文段长度</li>
</ul>
</li>
<li>面向连接<ul>
<li>握手：交换控制信息，初始化发送方和接收方的状态</li>
</ul>
</li>
<li>流量控制</li>
</ul>
<h3 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h3><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-segment-structure.png" alt="TCP segment structure.png" style="zoom:30%"></p>
<p>1、端口号：用来标识同一台计算机的不同的应用进程。</p>
<ul>
<li>源端口：源端口和IP地址的作用是标识报文的返回地址。</li>
<li>目的端口：端口指明接收方计算机上的应用程序接口。</li>
</ul>
<p>&emsp;&emsp;TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。</p>
<p>2、序号和确认号：是TCP可靠传输的关键部分。序号是本报文段发送的数据组的第一个字节的序号。在TCP传送的流中，每一个字节一个序号。e.g.一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为400。所以序号确保了TCP传输的有序性。确认号，即ACK，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。</p>
<p>3、数据偏移／首部长度：4bits。由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32/8 = 60，故报头最大长度为60字节。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。</p>
<p>4、保留：为将来定义新的用途保留，现在一般置0。</p>
<p>5、控制位：URG  ACK  PSH  RST  SYN  FIN，共6个，每一个标志位表示一个控制功能。</p>
<ul>
<li>URG：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。</li>
<li>ACK：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。</li>
<li>PSH：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。</li>
<li>RST：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。</li>
<li>SYN：同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。</li>
<li>FIN：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。</li>
</ul>
<p>6、窗口：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。</p>
<p>7、校验和：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。</p>
<p>8、紧急指针：只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。</p>
<p>9、选项和填充：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。</p>
<p>10、数据部分： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。</p>
<h4 id="TCP序号"><a href="#TCP序号" class="headerlink" title="TCP序号"></a>TCP序号</h4><p>&emsp;&emsp;报文段（segment）的序号：字节流第一个字节的序号</p>
<div class="note warning">
            <p>例题：下面文件的前3个报文段的序号分别是？</p><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-segment%23.png" alt="TCP segment sequenceNum.png" style="zoom:50%"></p><p>&emsp;&emsp;第一个报文段：0；第二个报文段：1000；第三个报文段：2000</p>
          </div>
<h4 id="TCP-ACK"><a href="#TCP-ACK" class="headerlink" title="TCP ACK"></a>TCP ACK</h4><ul>
<li>TCP报文的ACK填写：期望从另一方收到的下一个字节序号<ul>
<li>主机A接收到从主机B传来的字节#0～535，A下一个期望接到的字节#为536，所以主机A发送的报文段的ACK中填536。</li>
</ul>
</li>
<li>累计ACK（cumulative ACK）:与GBN相似<ul>
<li>主机A接收到从主机B传来的字节 #0～535 和 #900～1000，A下一个期望接到的字节#依旧为536，所以主机A下一个发送的报文段的ACK中填536。</li>
</ul>
</li>
</ul>
<h4 id="TCP-序号和ACK传输"><a href="#TCP-序号和ACK传输" class="headerlink" title="TCP 序号和ACK传输"></a>TCP 序号和ACK传输</h4><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-segment-eg.png" alt="TCP segment eg.png" style="zoom:40%"></p>
<h4 id="TCP计时"><a href="#TCP计时" class="headerlink" title="TCP计时"></a>TCP计时</h4><p>如何设置TCP timeout值？</p>
<ul>
<li>$time &gt; RTT$（但是RTT会改变）</li>
<li>不能太短：过早timeout造成不必要的重传</li>
<li>不能太长：对丢包反应太慢</li>
</ul>
<p>如何EstimateRTT（估计RTT）？</p>
<ul>
<li>SampleRTT（样本RTT）：计算发送segment到接收ACK的时间，忽略重传</li>
<li>SampleRTT多次测量取平均</li>
</ul>
<p>则EstimateRTT为</p>
<script type="math/tex; mode=display">
EstimateRTT = (1-\alpha )*EstimateRTT + \alpha *SamleRTT</script><ul>
<li>指数加权移动平均（不是线形的，存在迭代使原来的SamleRTT的系数越来越小，越靠后的越接近当前网络状态）</li>
<li>EstimateRTT的变化通常比SamleRTT变化更加平滑</li>
<li>一般，$\alpha = 0.125$</li>
</ul>
<p>DevRTT（偏差RTT）为（一般$\beta = 0.25$）</p>
<script type="math/tex; mode=display">
DevRTT = (1-\beta )*DevRTT + \beta *|SampleRTT-EstimatedRTT|</script><p>重传超时间隙（TimeoutInterval）</p>
<script type="math/tex; mode=display">
TimeoutInterval = EstimatedRTT + 4*DevRTT</script><h3 id="TCP可靠数据传输"><a href="#TCP可靠数据传输" class="headerlink" title="TCP可靠数据传输"></a>TCP可靠数据传输</h3><ul>
<li>TCP的rdt服务是建立在IP的不可靠传输上的<ul>
<li>流水机制</li>
<li>累计ACK</li>
<li>一个timer</li>
</ul>
</li>
<li>重传触发情况<ul>
<li>超时</li>
<li>重复的ACK</li>
</ul>
</li>
</ul>
<h4 id="TCP简化"><a href="#TCP简化" class="headerlink" title="TCP简化"></a>TCP简化</h4><p>&emsp;&emsp;TCP简化版：无重复ACK、拥塞控制和流量控制。</p>
<h5 id="TCP-sender"><a href="#TCP-sender" class="headerlink" title="TCP sender"></a>TCP sender</h5><p>TCP sender 的3种事件</p>
<ul>
<li>从上一层收到数据<ul>
<li>分段，创建seq#（报文中字节流第一个字节的序号）</li>
<li>开始timer<ul>
<li>只给最早一个未ACK的segment timer</li>
<li>用 TimeoutInterval 作为timeout时间</li>
</ul>
</li>
</ul>
</li>
<li>超时<ul>
<li>重传segment</li>
<li>重启timer</li>
</ul>
</li>
<li>收到ACK<ul>
<li>如果收到未ACK的segment的ACK<ul>
<li>更新被ACK的segment标记</li>
<li>从最近的一个未ACK的segment开新的timer</li>
</ul>
</li>
</ul>
</li>
</ul>
<span class="label info">图 TCP sender简化版</span>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-sender.png" alt="TCP sender.png" style="zoom:30%"></p>
<h5 id="TCP重传情况"><a href="#TCP重传情况" class="headerlink" title="TCP重传情况"></a>TCP重传情况</h5><span class="label info">图 ACK丢包</span>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-lostACK.png" alt="TCP lost ACK.png" style="zoom:50%"></p>
<span class="label info">图 提前timeout</span>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-premature-timeout.png" alt="TCP premature timeout.png" style="zoom:50%"></p>
<span class="label info">图 累计ACK</span>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-cumulativeACK.png" alt="TCP cumulative ACK.png" style="zoom:50%"></p>
<h5 id="TCP-receiver"><a href="#TCP-receiver" class="headerlink" title="TCP receiver"></a>TCP receiver</h5><div class="table-container">
<table>
<thead>
<tr>
<th>事件</th>
<th>TCP接收方反应</th>
</tr>
</thead>
<tbody>
<tr>
<td>具有所期望序号的按序报文段到达。所有在期望序号及以前的数据都已经被确认</td>
<td><strong>延迟的ACK</strong>，对另一个按序报文段的到达最多等待500ms。如果下一个按序报文段在这个时间间隔内没有到达，则发送一个ACK</td>
</tr>
<tr>
<td>具有所期望序号的按序报文段到达。另一个按序报文段等待ACK传输</td>
<td>立即发送单个累计ACK，以确认两个按序报文段</td>
</tr>
<tr>
<td>比期望序号大的失序报文段到达。检测出间隔</td>
<td>立即发送冗余ACK，指示下一个期待字节的序号（其为间隔的低端的序号）</td>
</tr>
<tr>
<td>能部分或完全填充接收数据间隔的报文段到达</td>
<td>倘若该报文段起始于间隔的低端，则立即发送ACK</td>
</tr>
</tbody>
</table>
</div>
<h4 id="TCP快速重传"><a href="#TCP快速重传" class="headerlink" title="TCP快速重传"></a>TCP快速重传</h4><ul>
<li>timeout时间长，造成长时延</li>
<li>通过重复的ACK检测丢包<ul>
<li>发送方会发送很多个segment</li>
<li>如果有segment丢失，则可能会收到很多个重复的ACK</li>
</ul>
</li>
</ul>
<p>TCP快速重传机制：</p>
<p>&emsp;&emsp;如果发送方收到对同一数据收到3个重复的ACK（实际收到4次该ACK），则认为此时未ACK的segment丢失，不需再等待timeout，重发未ACK的最小seq#</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-fastRetransmission.png" alt="TCP fast retransmit.png" style="zoom:50%"></p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>&emsp;&emsp;接收方要控制发送方，使发送方不会发送得太快导致接收方的缓存（buffer）溢出。</p>
<ul>
<li>接收方告诉发送方free buffer大小，包含在TCP报文的<strong>rwnd</strong>（receive window中）<ul>
<li>RcvBuffer socket设定大小（一般，4096）</li>
<li>一些操作系统也可以自动调节RcvBuffer</li>
</ul>
</li>
</ul>
<span class="label info">图 接收方缓存</span>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-receiverBuffering.png" alt="TCP  receiver Buffering.png" style="zoom: 25%;"></p>
<ul>
<li>sender通过rwnd来限制unacked segment的数量</li>
<li>保障receive的buffer不会溢出</li>
</ul>
<div class="note info">
            <p>&emsp;&emsp;如果sender接收到$rwnd=0$，此时没有剩余buffer，再发送数据会造成receiver buffer溢出，但是有要防止锁住。<br>&emsp;&emsp;所以sender向receiver发送一个1 byte data的报文，以更新rwnd。</p>
          </div>
<h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><h4 id="TCP建立连接：3次握手"><a href="#TCP建立连接：3次握手" class="headerlink" title="TCP建立连接：3次握手"></a>TCP建立连接：3次握手</h4><p>建立连接之前，先握手</p>
<ul>
<li>双方同意建立连接</li>
<li>同意连接的参数</li>
</ul>
<div class="note info">
            <p>&emsp;&emsp;为什么两次握手行不通？</p><ul><li>各种delay</li><li>消息丢失导致重传</li><li>消息乱序</li></ul>
          </div>
<p>图 TCP3次握手&emsp;&emsp;<br><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-three-way-handshake.png" alt="TCP three-way handshake.png" style="zoom:40%"></p>
<h4 id="TCP关闭连接：4次挥手"><a href="#TCP关闭连接：4次挥手" class="headerlink" title="TCP关闭连接：4次挥手"></a>TCP关闭连接：4次挥手</h4><ul>
<li>client、server两边都可关闭连接<ul>
<li>发送TCP segment的 FIN bit = 1</li>
</ul>
</li>
<li>用ACK回应FIN（ACK可以和FIN一起发）</li>
<li>同时收到FIN也可以处理（双工）</li>
</ul>
<p>图 TCP关闭连接<br><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-closeConnection.png" alt="TCP closing connection.png" style="zoom: 40%;"></p>
<span class="label info">图 TCP双方状态循环</span>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-Lifecycle.png" alt="TCP Lifecycle.png" style="zoom: 40%;"></p>
<h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><p>拥塞：</p>
<ul>
<li>非正式定义：太多的源发送数据太多太快，导致网络无法处理</li>
<li>和流量控制不同（流量控制c-s一对一）</li>
<li>产生丢包、延时</li>
<li>网络前十的问题</li>
</ul>
<h3 id="场景一：2个Sender-和1个无限buffer的Router"><a href="#场景一：2个Sender-和1个无限buffer的Router" class="headerlink" title="场景一：2个Sender, 和1个无限buffer的Router"></a>场景一：2个Sender, 和1个无限buffer的Router</h3><ul>
<li>2个sender，2个receiver</li>
<li>1个router带无限buffer</li>
<li>输出链路的容量：R</li>
<li>没有重传（无限buffer不会丢包）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Congestion-scenario1.png" alt="Congestion scenario1.png" style="zoom: 50%;"></p>
<span class="label info">图 输入速率-输出速率</span>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Congestion-scenario1-out.png" alt="Congestion scenario1 out.png" style="zoom: 50%;"></p>
<span class="label info">图 输入速率-时延</span>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Congestion-scenario1-delay.png" alt="Congestion scenario1 delay.png" style="zoom: 50%;"></p>
<h3 id="场景二：2个Sender-和1个有限buffer的Router"><a href="#场景二：2个Sender-和1个有限buffer的Router" class="headerlink" title="场景二：2个Sender, 和1个有限buffer的Router"></a>场景二：2个Sender, 和1个有限buffer的Router</h3><ul>
<li>一个router、有限buffer</li>
<li>重传timeout的packet<ul>
<li>$\lambda _{in}$ —— 源数据</li>
<li>$\lambda _{in}’$ —— 源数据+重传<script type="math/tex; mode=display">
\lambda _{in}' \geq \lambda _{in}</script></li>
</ul>
</li>
</ul>
<div class="note info">
            <p>正常理想情况下，</p><script type="math/tex; mode=display">\lambda _{in}' \geq \lambda _{in} = \lambda _{out}</script>
          </div>
<p>情况一（理想）：sender只在router的buffer有空时才发送</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Congestion-scenario2-pic1.png" alt="Congestion scenario2 pic1.png" style="zoom: 50%;"></p>
<p>情况二：知道丢包，当router的buffer满了，packet丢失。sender只有在知道丢包时才重传。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Congestion-scenario2-pic2.png" alt="Congestion scenario2 pic2.png" style="zoom: 50%;"></p>
<p>情况三：重复packet</p>
<ul>
<li>在router的buffer满时，packet可以丢包</li>
<li>提前timeout，会导致发送两个相同的packet</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Congestion-scenario2-pic3.png" alt="Congestion scenario2 pic3.png" style="zoom: 50%;"></p>
<h3 id="拥塞代价"><a href="#拥塞代价" class="headerlink" title="拥塞代价"></a>拥塞代价</h3><ul>
<li>排队延时</li>
<li>丢包导致重传</li>
<li>提前timeout导致非必要的重传，pkt重复，降低吞吐量</li>
<li>当一个packet被丢弃，其上游提供给这个packet的传输容量都浪费了</li>
</ul>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;sender逐渐增加发送速率（window size），从而探查可用bandwidth，直到丢包</p>
<ul>
<li>加性增（additive increase）：cwnd每次每个RTT增加 1 MSS 直到检测到丢包（MSS 最大报文段长度）</li>
<li>乘性减（multiplicative decrease）：如果发生丢包，cwnd减半</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-AIMD.png" alt="TCP AIMD.png" style="zoom: 30%;"></p>
<ul>
<li>sender传输限制<script type="math/tex; mode=display">
LastByteSent - LastByteAcked \leq cwnd</script></li>
<li><strong>cwnd</strong>是动态的随着网络拥塞程度变化的函数</li>
<li>结合之前的rwnd，实际的窗口大小为 $min{ rwnd, cwnd }$</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-cwnd.png" alt="TCP cwnd.png" style="zoom: 30%;"></p>
<p><strong>TCP发送速率（TCP sending rate）</strong></p>
<p>&emsp;&emsp;发送cwnd bytes，等待1个RTT接收ACK，然后再发送后续的bytes。</p>
<script type="math/tex; mode=display">
rate \approx \frac{cwnd}{RTT}\ bytes/sec</script><h3 id="TCP慢启动（TCP-slow-start）"><a href="#TCP慢启动（TCP-slow-start）" class="headerlink" title="TCP慢启动（TCP slow start）"></a>TCP慢启动（TCP slow start）</h3><ul>
<li>连接开始时，先指数级增长发送速率，直到出现<strong>丢包</strong><ul>
<li>初始，$cwnd = 1\ MSS$</li>
<li>每经过一个RTT，翻倍cwnd（实际上，每收到一个ACK，cwnd+1）</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-slow-start.png" alt="TCP slow start.png" style="zoom: 50%;"></p>
<p>当出现<strong>丢包</strong>时，</p>
<ul>
<li>timeout情况<ul>
<li>cwnd重新设为 1MSS</li>
<li>重新开始慢启动，直到到达一个threshold</li>
</ul>
</li>
<li>3个重复的ACK情况（TCP RENO版本）<ul>
<li>重复的ACK既然能收到，那么网络还是有一定的传输能力，不需要像timeout一样重开。</li>
<li>cwnd减半（乘性减）</li>
</ul>
</li>
<li>TCP Tahoe版本中，timeout和3个重复的ACK都将cwnd设为 1MSS</li>
</ul>
<h3 id="从-slow-start-到-CA-的转换"><a href="#从-slow-start-到-CA-的转换" class="headerlink" title="从 slow start 到 CA 的转换"></a>从 slow start 到 CA 的转换</h3><p>&emsp;&emsp;当cwnd达到上次timeout时的1/2（即sstresh）时，从指数级增长变成线形增长。</p>
<p><strong>sstresh</strong> —— 出现丢包时，将sstresh设置为此时cwnd的1/2</p>
<p>图 TCP Tahoe/Reno下cwnd的变化图【注：中间有一次3次ACK的丢包】<br><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-congestion-window.png" alt="TCP congestion window.png" style="zoom: 50%;"></p>
<h3 id="TCP拥塞控制FSM"><a href="#TCP拥塞控制FSM" class="headerlink" title="TCP拥塞控制FSM"></a>TCP拥塞控制FSM</h3><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-congestion-control.png" alt="TCP congestion control.png" style="zoom: 70%;"></p>
<h3 id="TCP吞吐量"><a href="#TCP吞吐量" class="headerlink" title="TCP吞吐量"></a>TCP吞吐量</h3><ul>
<li>avg TCP throughput（TCP平均吞吐量）由window size 和 RTT 决定（忽略slow start，假设一直由data在发送）</li>
<li>W：丢包时的 window size，avg window size 为 $3/4W$，则TCP平均吞吐量为<script type="math/tex; mode=display">
avg\ TCP\ throughput = \frac34 \frac{W}{RTT}\ bytes/sec</script></li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-throughput.png" alt="TCP throughput.png" style="zoom: 30%;"></p>
<h3 id="高速TCP"><a href="#高速TCP" class="headerlink" title="高速TCP"></a>高速TCP</h3><p>&emsp;&emsp;假设一条具有 1500byte 报文段和 100ms RTT 的TCP连接，用此连接以 10Gps 发送数据。此时平均拥塞窗口长度为 83.333 个报文段。TCP连接的吞吐量公式（单位 bytes/sec）：</p>
<script type="math/tex; mode=display">
TCP\ throughput = \frac{1.22MSS}{RTT\sqrt{L}}</script><p>10Gps的吞吐量，报文段丢失概率为 $2\times 10^{-10}$</p>
<h3 id="TCP公平性"><a href="#TCP公平性" class="headerlink" title="TCP公平性"></a>TCP公平性</h3><p>目标：K条TCP连接，经过R bps的瓶颈，每条TCP连接分 R/Kbps，则公平。</p>
<p>&emsp;&emsp;以两条TCP连接为例，从A出发，经过加性增、乘性减，会逐渐趋向公平线。所以TCP可以实现公平性。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-Fairness.png" alt="TCP Fairness.png" style="zoom: 50%;"></p>
<h3 id="Explicit-Congestion-Notification（ECN）"><a href="#Explicit-Congestion-Notification（ECN）" class="headerlink" title="Explicit Congestion Notification（ECN）"></a>Explicit Congestion Notification（ECN）</h3><p><strong>网络辅助的拥塞控制</strong></p>
<ul>
<li>ToS field（IP datagram头部的 2 bits）可以被网络路由标记，以显示拥塞</li>
<li>ToS field会被送到receiver的主机</li>
<li>receiver在发送给sender的ACK中嵌入ECE，来通知sender有拥塞</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-ECN.png" alt="TCP ECN.png" style="zoom: 50%;"></p>
<h1 id="网络层（Network-Layer）"><a href="#网络层（Network-Layer）" class="headerlink" title="网络层（Network Layer）"></a>网络层（Network Layer）</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li>在发送和接收的主机之间传送packet</li>
<li>路由器（router）要检验通过的IP数据报（IP datagram）的头部</li>
</ul>
<h3 id="网络层功能"><a href="#网络层功能" class="headerlink" title="网络层功能"></a>网络层功能</h3><ul>
<li>路由（Routing）：决定packet从源到目的路径</li>
<li>转发（Forwarding）：将packet从route的输入端口到合适的输出端口</li>
<li>连接建立（Connection setup）：一些网络结构要求数据传输前先建立路由路径</li>
</ul>
<h3 id="网络层服务"><a href="#网络层服务" class="headerlink" title="网络层服务"></a>网络层服务</h3><ul>
<li>确保交付（Guaranteed delivery）</li>
<li>具有时延上界的确保交付（Guaranteed delivery with bounded delay）</li>
<li>有序分组交付（In-order packet delivery）</li>
<li>确保最小带宽（Guaranteed minimal bandwidth）</li>
<li>安全性服务（Security）</li>
</ul>
<p>&emsp;&emsp;网络层提供<strong>尽力而为的服务</strong>（best-effort service）。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_service-models.png" alt="Network layer service models" style="zoom: 30%;"></p>
<h2 id="虚电路和数据报网络（Virtual-circuit-and-datagram-networks）"><a href="#虚电路和数据报网络（Virtual-circuit-and-datagram-networks）" class="headerlink" title="虚电路和数据报网络（Virtual circuit and datagram networks）"></a>虚电路和数据报网络（Virtual circuit and datagram networks）</h2><ul>
<li>数据报网络是无连接的服务</li>
<li>虚电路是面向连接的服务</li>
<li>端到端的服务、运行在网络核心</li>
</ul>
<h3 id="虚电路（Virtual-circuit，VC）"><a href="#虚电路（Virtual-circuit，VC）" class="headerlink" title="虚电路（Virtual circuit，VC）"></a>虚电路（Virtual circuit，VC）</h3><ul>
<li>呼叫建立 -&gt; 数据传输 -&gt; 呼叫拆除</li>
<li>每个packet携带VC号</li>
<li>路径上的每个router会给每个经过的VC维护连接状态</li>
<li>链路、路由资源（带宽、缓存）都会分配到VC</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Virtual-circuit.png" alt="Virtual circuit" style="zoom: 30%;"></p>
<p>VC组成：</p>
<ul>
<li>从源到目的的路径</li>
<li>VC号：路径上每个链路都有一个号码（可以变化）</li>
<li>转发表</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Forwarding-Table.png" alt="Forwarding Tables" style="zoom: 30%;"></p>
<p>路由维持连接状态的信息。</p>
<p><strong>信令协议(signaling protocol)</strong></p>
<p>VC采用信令协议(signaling protocol)</p>
<ul>
<li>用来建立、维护、拆除VC</li>
<li>用在ATM、frame-relay、X.25</li>
<li>VC在Internet中没有使用</li>
</ul>
<h3 id="数据报网络（Datagram-networks）"><a href="#数据报网络（Datagram-networks）" class="headerlink" title="数据报网络（Datagram networks）"></a>数据报网络（Datagram networks）</h3><ul>
<li>无连接</li>
<li>路由没有端到端的连接状态</li>
<li>packet通过目的主机ID来路由，同一个源到目的的packet可能走不同的路径。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_datagram-networks.png" alt="Datagram networks" style="zoom: 30%;"></p>
<p>转发表存储地址范围对应的链路接口，比如</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Destination Address Range</th>
<th>Link Interface</th>
</tr>
</thead>
<tbody>
<tr>
<td>11001000 00010111 00010000 00000000 ～ 11001000 00010111 00010111 11111111</td>
<td>0</td>
</tr>
<tr>
<td>11001000 00010111 00011000 00000000 ～ 11001000 00010111 00011000 11111111</td>
<td>1</td>
</tr>
<tr>
<td>11001000 00010111 00011001 00000000 ～ 11001000 00010111 00011111 11111111</td>
<td>2</td>
</tr>
<tr>
<td>Otherwise</td>
<td>3</td>
</tr>
</tbody>
</table>
</div>
<p><strong>最长前缀匹配</strong></p>
<p>&emsp;&emsp;选择 Link Interface 遵循最长前缀匹配原则。</p>
<p>例题：下面转发表</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Longest-prefix-matching.png" alt="Forwarding Table" style="zoom: 30%;"></p>
<p>目的地址<code>11001000 00010111 00010110 10100001</code> 和 <code>11001000 00010111 00011000 10101010</code> 分别对应的Link Interface为？</p>
<p><code>11001000 00010111 00010110 10100001</code> -&gt; 0</p>
<p><code>11001000 00010111 00011000 10101010</code> -&gt; 1（与1和2都匹配，但是与1匹配更长）</p>
<h3 id="虚电路和数据报网络选择"><a href="#虚电路和数据报网络选择" class="headerlink" title="虚电路和数据报网络选择"></a>虚电路和数据报网络选择</h3><p>Internet：网络核心简单，复杂度在网络边缘</p>
<ul>
<li>计算机数据交换：弹性服务，没有严格时间要求</li>
<li>链路类型多：有不同特性，不能统一服务</li>
<li>“智能”端系统</li>
</ul>
<p>ATM：复杂度在网络核心</p>
<ul>
<li>电话演变而来</li>
<li>人之间的交流：严格的时间限制、可靠性、确定的服务保障</li>
<li>“笨拙”端系统</li>
</ul>
<h2 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h2><h3 id="路由器结构"><a href="#路由器结构" class="headerlink" title="路由器结构"></a>路由器结构</h3><ul>
<li>输入端口（Input port）</li>
<li>交换结构（Switch fabric）</li>
<li>输出端口（Output port）</li>
<li>路由选择处理器（Routing processor）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Router-architecture.png" alt="Router architecture.png" style="zoom: 50%;"></p>
<ul>
<li>上半部分为控制面板：软件、毫秒级</li>
<li>下半部分为数据面板：硬件、纳秒级</li>
</ul>
<h4 id="输入端口（Input-port）"><a href="#输入端口（Input-port）" class="headerlink" title="输入端口（Input port）"></a>输入端口（Input port）</h4><ol>
<li>线路端接（line termination）：物理层功能，用来比特的接收</li>
<li>数据链路处理（协议，拆封）（data link processing (protocol, decapsulation)）：数据链路层功能，比如以太网</li>
<li>查找、转发、排队（lookup, forwarding, queueing）<ul>
<li>分散交换：给出数据报目的地，然后根据转发表查找输出端口</li>
<li>目标：希望在“line speed”上完成输入端口的处理</li>
<li>排队：数据报到达速度大于转发速度</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Input-port-processing.png" alt="Input port processing.png" style="zoom: 50%;"></p>
<h4 id="交换结构（Switch-fabric）"><a href="#交换结构（Switch-fabric）" class="headerlink" title="交换结构（Switch fabric）"></a>交换结构（Switch fabric）</h4><p>&emsp;&emsp;三种交换结构：共享内存、共享总线、交叉开关矩阵</p>
<h5 id="共享内存（Switching-via-memory）"><a href="#共享内存（Switching-via-memory）" class="headerlink" title="共享内存（Switching via memory）"></a>共享内存（Switching via memory）</h5><ul>
<li>初代路由常采用共享内存</li>
<li>pkt在memory复制</li>
<li>速度被内存带宽限制，每个datagram都要经过2个bus</li>
<li>Cisco Catalyst 8500</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Switching-Memory.png" alt="Switching via memory.png" style="zoom: 70%;"></p>
<h5 id="共享总线（Switching-via-a-bus）"><a href="#共享总线（Switching-via-a-bus）" class="headerlink" title="共享总线（Switching via a bus）"></a>共享总线（Switching via a bus）</h5><ul>
<li>datagram通过共享的bus从输入端口到输出端口</li>
<li>总线冲突（bus contention）：交换速度被总线带宽限制</li>
<li>Cisco 5600</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Switching-Bus.png" alt="Switching via a bus.png" style="zoom: 70%;"></p>
<h5 id="交叉开关矩阵（Switching-via-an-interconnection-network）"><a href="#交叉开关矩阵（Switching-via-an-interconnection-network）" class="headerlink" title="交叉开关矩阵（Switching via an interconnection network）"></a>交叉开关矩阵（Switching via an interconnection network）</h5><ul>
<li>客服总线带宽的限制</li>
<li>纵横式交换机是一种由2N条总线组成的互联网络，连接N个输入端口和N个输出端口</li>
<li>可并行转发多个分组，但如果同输入输出端口，还是必须等待前一个发送了再发下一个</li>
<li>Cisco 12000</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Switching-Interconnection-Network.png" alt="Switching via an interconnection network.png" style="zoom: 70%;"></p>
<h4 id="输出端口（Output-port）"><a href="#输出端口（Output-port）" class="headerlink" title="输出端口（Output port）"></a>输出端口（Output port）</h4><ol>
<li>排队（缓存管理）（Queueing(datagram buffer)）<ul>
<li>缓存：当数据报到达快于传输速率，如果缓存不够会导致丢包</li>
<li>调度方法：从排队中选择数据报进行传输，例如按时间顺序、按优先级顺序</li>
</ul>
</li>
<li>数据链路处理（协议，封装）（Data link processing(protocol, encapsulation)）</li>
<li>线路端接（Line termination）</li>
</ol>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Output-port-processing.png" alt="Output port processing.png" style="zoom: 50%;"></p>
<h3 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h3><h4 id="输入端口排队"><a href="#输入端口排队" class="headerlink" title="输入端口排队"></a>输入端口排队</h4><ul>
<li>当fabric比input port慢时，发生排队</li>
<li>buffer满时，出现排队延时和丢包</li>
<li>队首阻塞（Head-of-the-Line blocking，HOL）：队首的datagram会阻塞排在它后面的datagram输入</li>
</ul>
<h4 id="输出端口排队"><a href="#输出端口排队" class="headerlink" title="输出端口排队"></a>输出端口排队</h4><ul>
<li>当switch到达比output line快，发生排队</li>
<li>buffer满时，出现排队延时和丢包</li>
</ul>
<h2 id="路由算法（Routing-algorithms）"><a href="#路由算法（Routing-algorithms）" class="headerlink" title="路由算法（Routing algorithms）"></a>路由算法（Routing algorithms）</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p><strong>路由协议</strong></p>
<p>目标：从源到目的找到一条最好的路径</p>
<ul>
<li>一般，最好路径是最小代价路径</li>
<li>但也可以有其他定义</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Abstract-graph-model.png" alt="Abstract graph model.png" style="zoom: 50%;"></p>
<ul>
<li>路由 -&gt; 节点</li>
<li>物理链路 -&gt; 边</li>
<li>链路代价：可以是延时、花费或拥塞等级等等</li>
</ul>
<p>路由图表示：</p>
<script type="math/tex; mode=display">
G = (N,E)</script><ul>
<li>路由器集合：$N = {u,v,w,x,y,z}$</li>
<li>链路集合：$E = {(u,v),(u,x),(v,x),(v,w),(x,w),(x,y),(w,y),(w,z),(y,z)}$</li>
<li>路径cost：$cost\ of\ path\ (x<em>1,x_2,x_3,…,x_p)=c(x_1,x_2)+c(x_2,x_3)+…+c(x</em>{p-1},x_p)$</li>
</ul>
<p>路由算法：找到cost最小路径</p>
<p><strong>路由算法分类</strong></p>
<ul>
<li>全局/分散信息<ul>
<li>全局：知道所有路由信息</li>
<li>分散：只知道邻居路由的信息，需要进行迭代查询</li>
</ul>
</li>
<li>静态/动态<ul>
<li>静态：需要手动配置，路由变化慢</li>
<li>动态：路由变化快，周期更新</li>
</ul>
</li>
</ul>
<h3 id="LS算法：路由选择算法（Link-state-alorithm）"><a href="#LS算法：路由选择算法（Link-state-alorithm）" class="headerlink" title="LS算法：路由选择算法（Link state alorithm）"></a>LS算法：路由选择算法（Link state alorithm）</h3><h4 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h4><ul>
<li>基于<strong>全局</strong>信息的算法</li>
<li>计算从源到所有其他节点的最小cost</li>
<li>迭代：经过k次迭代可知到k个目的的路径cost</li>
</ul>
<p>算法步骤如下：<br>G={V,E}</p>
<ol>
<li>初始时令 S={V0},T=V-S={其余顶点}，T中顶点对应的距离值<br>若存在<V0,Vi>，d(V0,Vi)为<V0,Vi>弧上的权值<br>若不存在<V0,Vi>，d(V0,Vi)为∞</li>
<li>从T中选取一个与S中顶点有关联边且权值最小的顶点W，加入到S中</li>
<li>对其余T中顶点的距离值进行修改：若加进W作中间顶点，从V0到Vi的距离值缩短，则修改此距离值<br>重复上述步骤2、3，直到S中包含峙所有顶点，即W=Vi为止</li>
</ol>
<ul>
<li>$c(x,y)$：x到y的cost，如果x，y不是邻居，则为$c(x,y) = \infty $</li>
<li>$D(v)$：从源到目的v的路径的cost</li>
<li>$p(v)$：从源到目的v的路径的前一个节点</li>
<li>$N’$：最小cost路径的节点集</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Dijkstra’s-algorithm(1).png" alt="Dijkstra’s-algorithm(1).png" style="zoom: 30%;"></p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Dijkstra’s-algorithm(2).png" alt="Dijkstra’s-algorithm(2).png" style="zoom: 30%;"></p>
<p><strong>算法复杂度</strong></p>
<p>假如有n个节点，</p>
<ul>
<li>一般的Dijkstra算法需要 $n(n+1)/2$，即$O(n^2)$</li>
<li>通过算法优化，可将复杂度降为$O(n\log n)$</li>
</ul>
<p>&emsp;&emsp;Dijkstra算法存在振荡问题。</p>
<h4 id="广播路由（Broadcast-routing）"><a href="#广播路由（Broadcast-routing）" class="headerlink" title="广播路由（Broadcast routing）"></a>广播路由（Broadcast routing）</h4><p>&emsp;&emsp;通过广播路由得到路由的实时情况。完成广播通信的最直接方式是由发送节点向每个目的地分别发送分组的拷贝。</p>
<ul>
<li><p><strong>洪泛</strong>（Flooding）：从源发送pkt到所有其他的节点</p>
<p>&emsp;&emsp;无限制洪泛会引起<strong>广播风暴</strong>（Broadcast storm），导致广播路由耗光了所有的流量。</p>
</li>
<li><p><strong>受控洪泛</strong>（Controlled flooding）：解决广播风暴问题</p>
<ul>
<li><p><strong>序号控制洪泛</strong>（Sequence-number-controlled flooding）</p>
<p>&emsp;&emsp;源节点将其地址(或其他的唯一标识符)以及广播序号放人广播分组，再向它的所有邻居发送该分组。每个节点维护它已经收到的、复制的和转发的源地址和每个广播分组的序号列表。当一个节点接收到一个广播分组时，它首先检查该分组是否在该列表中。如果在，丢弃该分组;如果不在，复制该分组并向该节点的所有邻居转发。</p>
</li>
<li><p><strong>反向路径广播</strong>(Reverse Path Broadcasting，RPB)</p>
<p>RPB 的基本思想是当一台路由器接收到具有给定源地址的广播分组时， 仅当该分组到达的链路正好是位于它自己到其源的最短单播路径上，它才向其所有出链路 (除了它接收分组的那个)传输分组。否则，该路由器丢弃入分组。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_RPB.png" style="zoom:33%;" /></p>
</li>
</ul>
</li>
<li><p><strong>生成树广播</strong>（Spanning-tree broadcast）：消除了冗余广播pkt，而且能够被任何节点用于开始广播分组</p>
<ul>
<li>在生成树上广播pkt，这样就不再会有圈了</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Spanning-tree-broadcast.png" style="zoom:33%;" /></p>
</li>
</ul>
<h4 id="LS算法"><a href="#LS算法" class="headerlink" title="LS算法"></a>LS算法</h4><p>LS算法 = 广播路由 + Dijkstra算法</p>
<ul>
<li>广播路由：每个节点都要广播链接状态pkt给每个其他节点，从而每个节点都获得相同完整的网络信息</li>
<li>Dijkstra算法：计算源到每个节点的最小cost路径</li>
<li>如果有link cost变化，则重新进行上述操作</li>
</ul>
<h3 id="DV算法：距离向量算法（Distance-vector-algorithm）"><a href="#DV算法：距离向量算法（Distance-vector-algorithm）" class="headerlink" title="DV算法：距离向量算法（Distance vector algorithm）"></a>DV算法：距离向量算法（Distance vector algorithm）</h3><p>&emsp;&emsp;DV算法为基于分散信息、动态的路由算法。</p>
<h4 id="Bellman-Ford公式"><a href="#Bellman-Ford公式" class="headerlink" title="Bellman-Ford公式"></a>Bellman-Ford公式</h4><p>&emsp;&emsp;定义 $d_x(y)$ ：从x到y的最小cost路径的cost</p>
<p>Bellman-Ford方程：$d_x(y)$进行分解</p>
<script type="math/tex; mode=display">
d_x(y) = min_v\{c(x,v)+d_v(y)\}</script><p>例题：通过$d_v(z)$、$d_w(z)$、$d_x(z)$计算$d_u(z)$。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_route-eg.png" style="zoom: 50%;" /></p>
<script type="math/tex; mode=display">
d_u(z) = min\{c(u,v)+d_v(z), c(u,w)+d_w(z), c(u,x)+d_x(z)\} = min(2+5,1+3,5+3) = 4</script><ul>
<li>$D_x(y)$为估算的$d_x(y)$</li>
<li>对于节点x<ul>
<li>知道邻居节点v的 $c(x,v)$</li>
<li>维持邻居的距离向量 $D_v = [D_v(y):y\in N]$</li>
</ul>
</li>
</ul>
<h4 id="DV算法"><a href="#DV算法" class="headerlink" title="DV算法"></a>DV算法</h4><ul>
<li>每个节点定期发送它的 DV estimate 给邻居</li>
<li>当一个节点x收到邻居发来的新的 DV estimate 时，它会根据 B-F公式 更新自己的 DV estimate</li>
<li>多次更新后，DV estimate 会收敛于真实的最小cost $d_x(y)$</li>
</ul>
<p><strong>迭代、异步</strong>：<br>每个本地迭代产生于：</p>
<ul>
<li>本地链接cost改变</li>
<li>邻居发来新的 DV estimate</li>
</ul>
<p><strong>分布</strong>：</p>
<ul>
<li>每个节点只会在它的DV改变的时候才会通知邻居</li>
<li>邻居如果改变再通知邻居</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_DV.png" style="zoom: 50%;" /></p>
<h4 id="好事传得快，坏事传得慢"><a href="#好事传得快，坏事传得慢" class="headerlink" title="好事传得快，坏事传得慢"></a>好事传得快，坏事传得慢</h4><ul>
<li>“好事”（cost变小）：更新完成快</li>
<li>“坏事”（cost变大）：更新完成慢，造成无限问题</li>
</ul>
<p>如何解决无限问题？</p>
<p>&emsp;&emsp;如果要节点最小cost路由要绕路（即不是邻居），则标为$\infty $</p>
<h3 id="LS算法和DV算法对比"><a href="#LS算法和DV算法对比" class="headerlink" title="LS算法和DV算法对比"></a>LS算法和DV算法对比</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>LS</th>
<th>DV</th>
</tr>
</thead>
<tbody>
<tr>
<td>信息复杂度（Message complexity）</td>
<td>$O(nE)$（n个节点，E条链路）</td>
<td>只在邻居之间交换</td>
</tr>
<tr>
<td>收敛速度（Speed of convergence）</td>
<td>$O(n^2)$，可优化到$O(n\log n)$</td>
<td>速度会变化</td>
</tr>
<tr>
<td>强健性（Robustness）</td>
<td>有一定强健性，每个节点都有自己的表</td>
<td>强健性低，节点依赖于邻居</td>
</tr>
</tbody>
</table>
</div>
<h3 id="层次路由（Hierarchical-Routing）"><a href="#层次路由（Hierarchical-Routing）" class="headerlink" title="层次路由（Hierarchical Routing）"></a>层次路由（Hierarchical Routing）</h3><p>之前讨论的路由都是理想化的：所有路由器都相同，网络是“扁平”的。而实际，并不存在这样的理想路由。</p>
<ul>
<li>大规模<ul>
<li>无法存储所有目的的转发表</li>
<li>路由交换流量大，导致淹没链路</li>
</ul>
</li>
<li>管理自治<ul>
<li>因特网是网中网</li>
<li>每个网络管理都希望控制所在网络的路由</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;聚集路由成<strong>自治系统</strong>（autonomous system，AS）</p>
<ul>
<li><strong>AS内的路由</strong>（intra_AS routing）<ul>
<li>在一个AS间的路由</li>
<li>在一个AS的所有路由器运行同一个区域内协议</li>
<li>不同AS的路由器运行不同区域的协议</li>
<li>网管路由器：位于AS边缘，与其他AS的路由器有链接</li>
</ul>
</li>
<li><strong>AS间的路由</strong>（inter_AS routing）<ul>
<li>在不同AS间的路由</li>
<li>网管参与区域间的路由</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_AS.png" style="zoom: 30%;" /></p>
<p><strong>AS分类</strong></p>
<ul>
<li>Stub AS：末端AS，用于小企业</li>
<li>Multihomed AS：多出口AS，用于大企业，外部不能通过它传输</li>
<li>Transit AS：中转AS，网络提供商，用于传输</li>
</ul>
<h2 id="因特网中的路由选择"><a href="#因特网中的路由选择" class="headerlink" title="因特网中的路由选择"></a>因特网中的路由选择</h2><p>&emsp;&emsp;内部网关协议（Interior Gateway Protocols，IGP）是AS内的路由。</p>
<p>常用的IGP有：</p>
<ul>
<li>RIP：路由信息协议，Routing Information Protocol</li>
<li>OSPF：开放最短路径，Open Shortest Path First</li>
<li>IGRP：Interior Gateway Routing Protocol</li>
</ul>
<h3 id="RIP：路由信息协议（Routing-Information-Protocol）"><a href="#RIP：路由信息协议（Routing-Information-Protocol）" class="headerlink" title="RIP：路由信息协议（Routing Information Protocol）"></a>RIP：路由信息协议（Routing Information Protocol）</h3><ul>
<li><p>DV算法</p>
</li>
<li><p>cost：跳数</p>
<p>&emsp;&emsp;<strong>最大15跳</strong>，16跳视为$\infty $。设置最大跳数以防止无穷计数问题，但这也限制了只能用于小网络，大网络很容易超最大跳数。</p>
</li>
<li><p>每30s通过发送通告的方式更新DV，通告最多路由到25个目的</p>
</li>
<li><p>如果超过180s每收到通告，则这个邻居/链路宣告死亡</p>
<ul>
<li>通过该邻居的路由失效</li>
<li>发送新通告给邻居</li>
<li>如果邻居的转发表变化，它也会发送新的通告</li>
<li>链接失败的信息会快速迭代完成<ul>
<li>采用毒性逆转防止循环</li>
<li>将16跳设置为$\infty $</li>
</ul>
</li>
</ul>
</li>
<li><p>RIP运行在应用层（路由器实际可能存在应用层，只是不对用户开放）</p>
</li>
<li>通告用 UDP pkt 周期性发送</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_RIP.png" style="zoom: 30%;" /></p>
<h3 id="OSPF：开放最短路径（Open-Shortest-Path-First）"><a href="#OSPF：开放最短路径（Open-Shortest-Path-First）" class="headerlink" title="OSPF：开放最短路径（Open Shortest Path First）"></a>OSPF：开放最短路径（Open Shortest Path First）</h3><h4 id="OSPF概述"><a href="#OSPF概述" class="headerlink" title="OSPF概述"></a>OSPF概述</h4><ul>
<li>对公众开放</li>
<li>使用<strong>LS算法</strong><ul>
<li>需要发送LS pkt</li>
<li>每个节点采用拓扑结构</li>
<li>路由采用 Dijkstra 算法</li>
</ul>
</li>
<li>OSPF通告每个邻居路由器携带一个条目</li>
<li>通告通过洪泛散布到整个AS<ul>
<li>OSPF消息直接分装在IP数据报上</li>
</ul>
</li>
</ul>
<h4 id="OSPF优点"><a href="#OSPF优点" class="headerlink" title="OSPF优点"></a>OSPF优点</h4><ul>
<li><strong>安全</strong>：所有OSPF消息都要认证，防止恶意侵入</li>
<li><strong>多条相同cost的路径</strong>：当到达某目的的多条路径具有相同的cost时，OSPF允许使用多条路径。即可以分流。</li>
<li><strong>每条链路，给不同的数据类型不同的cost度量</strong></li>
<li><strong>对单播和多播（MOSPF）路由的支持</strong>：对单播进行扩展，以便提供给多播使用</li>
<li><strong>在大域中用分层OSPF</strong></li>
</ul>
<h4 id="分层OSPF"><a href="#分层OSPF" class="headerlink" title="分层OSPF"></a>分层OSPF</h4><ul>
<li>两层结构：<strong>局部区域</strong>（local area）和 <strong>主干</strong>（backbone）<ul>
<li>LS通告只在区域内</li>
<li>每个节点知道该区域的拓扑结构，对于其他区域只知道到那个区域的方向（最短路径）</li>
</ul>
</li>
<li><strong>区域边界路由器</strong>（area border router）：负责为流向该区域以外的分组提供路由选择。汇拢该区域的节点距离信息，通告给其他的区域边界路由器</li>
<li><strong>主干路由器</strong>（backbone router）：在主干内运行OSPF路由</li>
<li><strong>网关路由器</strong>（boundary router）：与其他AS连接</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Hierarchical-OSPF.png" style="zoom: 30%;" /></p>
<h3 id="IGRP（Interior-Gateway-Routing-Protocol）"><a href="#IGRP（Interior-Gateway-Routing-Protocol）" class="headerlink" title="IGRP（Interior Gateway Routing Protocol）"></a>IGRP（Interior Gateway Routing Protocol）</h3><ul>
<li>最初是CISCO私有的，后来开放了，RIP的后继者</li>
<li>DV算法</li>
<li>cost：时延、带宽、可靠性、负荷等等</li>
<li>利用TCP来交换路由更新</li>
<li>利用<strong>扩散更新算法</strong>（Diffusing Update Algorithm,DUAL）来防止循环</li>
</ul>
<h3 id="BGP：边界网管协议（Border-Gateway-Protocol）"><a href="#BGP：边界网管协议（Border-Gateway-Protocol）" class="headerlink" title="BGP：边界网管协议（Border Gateway Protocol）"></a>BGP：边界网管协议（Border Gateway Protocol）</h3><h4 id="BGP概述"><a href="#BGP概述" class="headerlink" title="BGP概述"></a>BGP概述</h4><p>采用 <strong>Path Vector protocol</strong></p>
<ul>
<li>与<strong>DV协议</strong>相似</li>
<li><p>每个边界网关向邻居（对等方）广播到达目的地的整个路径（即 AS的序列）</p>
</li>
<li><p><strong>eBGP</strong>：外部BGP，跨越两个AS对话。从相邻的AS获取子网可达性信息。</p>
</li>
<li><strong>iBGP</strong>：内部BGP，同一个AS中的两台路由器之间的BGP对话。将可达性信息传播到所有内部AS路由器。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_eBGP-iBGP.png" style="zoom: 30%;" /></p>
<ul>
<li>BGP会话：两BGP路由器通过半永久的TCP连接来交换消息<ul>
<li>将路径通告到不同的目标网络前缀（BGP是“路径向量”协议）</li>
</ul>
</li>
<li>如果一个AS向另一个AS通告了某个路由器，则承诺了可以路由到该路由器</li>
</ul>
<h4 id="路径属性和BGP路由"><a href="#路径属性和BGP路由" class="headerlink" title="路径属性和BGP路由"></a>路径属性和BGP路由</h4><ul>
<li>通告前缀（advertised prefix）包括BGP属性<ul>
<li>prefix + attributes = “route”</li>
</ul>
</li>
<li>两个重要attributes<ul>
<li>AS-PATH：路径中的AS的列表</li>
<li>NEXT-HOP：以AS-PATH开头的路由器接口的IP地址</li>
</ul>
</li>
<li>基于policy的路由<ul>
<li>网关接收路由广告使用导入policy接受/拒绝路径（例如，从不通过AS Y路由）</li>
<li>AS policy还确定是否向其他相邻AS通告路径</li>
</ul>
</li>
</ul>
<h4 id="BGP消息"><a href="#BGP消息" class="headerlink" title="BGP消息"></a>BGP消息</h4><ul>
<li>使用TCP交换BGP消息</li>
<li>BGP消息：<ul>
<li>OPEN：打开TCP连接，认证sender</li>
<li>UPDATE：通告新路径（删除旧路径）</li>
<li>KEEP ALIVE：在没有UPDATE的情况下，保持连接活跃；ACK OPEN请求</li>
<li>NOTIFICATION：报告以前的msg中的错误；也用于关闭连接</li>
</ul>
</li>
</ul>
<h4 id="BGP路由选择"><a href="#BGP路由选择" class="headerlink" title="BGP路由选择"></a>BGP路由选择</h4><p>&emsp;&emsp;路由器可能知道到达同一个前缀的多条路由。BGP以下优先级选择路由：</p>
<ul>
<li>本地偏好值：由政策决定</li>
<li>最短 AS-PATH：通过的AS最少</li>
<li>最近 NEXT-HOP 路由器：最近的下一跳路由器</li>
<li>其他标准</li>
</ul>
<p>假设：网关X 将其路径发送到 网关W</p>
<ul>
<li>W 可以选择/不选 X所提供的路径<ul>
<li>根据cost，policy（eg.不通过竞争对手的AS进行路由），防止环路 的原因选择/不选</li>
</ul>
</li>
<li>如果W选择X通告的路径<script type="math/tex; mode=display">
Path(W,Z) = W,Path(X,Z)</script></li>
<li>X可以通过advertisement来控制传入流量：<ul>
<li>eg.不希望将流量路由到Z -&gt; 不通告任何路由到Z</li>
</ul>
</li>
</ul>
<h4 id="BGP路由策略"><a href="#BGP路由策略" class="headerlink" title="BGP路由策略"></a>BGP路由策略</h4><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_BGP-policy.png" style="zoom: 50%;" /></p>
<ul>
<li>A,B,C是ISP（网络服务提供商）</li>
<li>W,X,Y是客户</li>
<li><p>X是 Multihomed AS，连接了两个ISP，也可以称为 dual-homed，一般是大型公司。X可以不允许 B -&gt; X -&gt; C 这条路由，则X不通告B有路由到C</p>
</li>
<li><p>A 通告 B 路径 AW</p>
</li>
<li>B 通告 X 路径 BAW</li>
<li>是否 B 通告 C 路径 BAW ？<ul>
<li>不会，C不是B的客户，B希望强迫C走AW，B只想从客户发送/接收路由</li>
</ul>
</li>
</ul>
<h4 id="Inra-Inter-AS-的区别"><a href="#Inra-Inter-AS-的区别" class="headerlink" title="Inra-/Inter-AS 的区别"></a>Inra-/Inter-AS 的区别</h4><p><strong>规模</strong>：分层可以节省表格大小，减小更新的流量。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Intra-AS</th>
<th>Inter-AS</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Policy</strong></td>
<td>一个管理员，不需要policy决策</td>
<td>管理员想要控制路由，需要有policy</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>关注性能</td>
<td>比起性能更关注policy</td>
</tr>
</tbody>
</table>
</div>
<h2 id="IP：Internet-Protocol"><a href="#IP：Internet-Protocol" class="headerlink" title="IP：Internet Protocol"></a>IP：Internet Protocol</h2><h3 id="IPv4数据报结构"><a href="#IPv4数据报结构" class="headerlink" title="IPv4数据报结构"></a>IPv4数据报结构</h3><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_IP-datagram-format.png" style="zoom: 30%;" /></p>
<ul>
<li><strong>版本</strong>（Version, <strong>4bit</strong>）<br>对于IPv4，字段的值是4。</li>
<li><strong>首部长度</strong>（Header Length， IHL, <strong>4bit</strong>）<br>首部长度说明首部有多少32位字（4字节）。<strong>一般为5</strong>，相当于5*4=20字节。</li>
<li><strong>服务类别</strong>（Type Of Service，<strong>8bit</strong>）</li>
<li><strong>报文长度</strong>（Length, <strong>16bit</strong>）<br>IP首部+数据部分的总长度</li>
<li><strong>标识</strong>（Identification, <strong>16bit</strong>）<br>用于在IP层对数据报进行分片的时候，标识数据包。</li>
<li><strong>标志</strong> （Flags, <strong>3bit</strong>）<br>这个3位字段用于控制和识别分片，它们是：<ul>
<li>位0：保留，必须为0；</li>
<li>位1：禁止分片（Don’t Fragment，DF），当DF=0时才允许分片；</li>
<li>位2：更多分片（More Fragment，MF），MF=1代表后面还有分片，MF=0 代表已经是最后一个分片。<br>如果DF标志被设置为1，但路由要求必须分片报文，此报文会被丢弃。这个标志可被用于发往没有能力组装分片的主机。<br>当一个报文被分片，除了最后一片外的所有分片都设置MF为1。最后一个片段具有非零片段偏移字段，将其与未分片数据包区分开，未分片的偏移字段为0。</li>
</ul>
</li>
<li><strong>分片偏移</strong> （Fragment Offset, <strong>13bit</strong>）<br>这个13位字段指明了每个分片相对于原始报文开头的偏移量，以8字节作单位。</li>
<li><strong>存活时间</strong>（Time To Live，TTL, <strong>8bit</strong>）<br>本数据报的TTL.</li>
<li><strong>协议</strong> （Protocol, <strong>8bit</strong>）<br>1—-icmp, 2—-igmp, 6—-tcp, 17—-udp, 89—-ospf</li>
<li><strong>首部检验和</strong> （Header Checksum， <strong>16bit</strong>）<br>IP首部的校验和</li>
<li><strong>源IP地址</strong>（Source IP, <strong>32bit</strong>）</li>
<li><strong>目的IP地址</strong>（Destination IP, <strong>32bit</strong>）</li>
</ul>
<h3 id="IPv4数据报分片"><a href="#IPv4数据报分片" class="headerlink" title="IPv4数据报分片"></a>IPv4数据报分片</h3><ul>
<li>网络链路有MTU（最大传送单元）— 最大可传输的链路的帧<ul>
<li>不同的链路类型有不同的MTU</li>
</ul>
</li>
<li>如果IP数据报 &gt; MTU ，则分片，到目的地后再重组</li>
<li>IP头部字段用来标记</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_IP%20fragmentation-and-reassembly.png" style="zoom: 50%;" /></p>
<p><strong>IP数据报分片示例</strong></p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Fragmentation.png" style="zoom: 30%;" /></p>
<ul>
<li>本来要发送 4000 byte 的数据报（head部分 + data部分）</li>
<li>链路的 MTU = 1500 bytes</li>
<li><p>需要将数据分为3片来发送</p>
</li>
<li><p><code>length</code>：片长度，包括了 20 bytes IP首部部分，最大为MTU</p>
<ul>
<li>length为1500的数据报，实际包含 $1500-20=1480\ bytes$ 的data部分</li>
<li>最后一片的length为 $(4000-20) - 1480\times 2 + 20 = 1040$</li>
</ul>
</li>
<li><code>fragflag</code>：3 bits<ul>
<li>第二个bit为 DF（Don’t Flag）：为0则该数据报分片，为1则不分片</li>
<li>第三个bit为 MF：为0则后面没有片了，为1则后面还有片</li>
<li>前两片为 1（001），表示该IP数据报分片，且后面还有片</li>
<li>最后一片为 0（000），表示该IP数据报分片，后面没片（即最后一片）</li>
</ul>
</li>
<li><code>offset</code>：data部分偏移量，以 8 bytes 为单位，只计算data部分<ul>
<li>第一片的offset为 0</li>
<li>第二片的offset为 $1480\ bytes/8\ bytes = 185$</li>
</ul>
</li>
</ul>
<h3 id="IPv4编址"><a href="#IPv4编址" class="headerlink" title="IPv4编址"></a>IPv4编址</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><ul>
<li>IP地址：32位、主机和路由器接口的ID</li>
<li><strong>接口</strong>（interface）：主机/路由器 和 物理链接 之间的连接<ul>
<li>路由器一般有多个接口</li>
<li>主机一般有1到2个接口</li>
</ul>
</li>
<li>每个接口都有一个对应的IP地址</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_IP-and-subnets.png" style="zoom: 50%;" /></p>
<p><strong>接口连接方式</strong></p>
<ul>
<li>通过<strong>路由器</strong>连接</li>
<li>有线以太网通过<strong>以太网交换机</strong>连接</li>
<li>无线网络通过<strong>WiFi基站</strong>连接</li>
</ul>
<h4 id="子网（Subnet）"><a href="#子网（Subnet）" class="headerlink" title="子网（Subnet）"></a>子网（Subnet）</h4><p><strong>IP地址</strong></p>
<ul>
<li>网络部分 —— 高位</li>
<li>主机部分 —— 低位</li>
</ul>
<p><strong>子网</strong></p>
<ul>
<li>子网部分相同</li>
<li>可以不通过路由器到达彼此</li>
</ul>
<p>&emsp;&emsp;把路由器去掉，剩下的每个区域都是一个子网。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_subnets.png" style="zoom: 50%;" /></p>
<p>&emsp;&emsp;上图中有6个子网。</p>
<h4 id="分类编制（Classful-Addressing）"><a href="#分类编制（Classful-Addressing）" class="headerlink" title="分类编制（Classful Addressing）"></a>分类编制（Classful Addressing）</h4><ul>
<li>A类<ul>
<li>网络部分前1位 —— <code>0</code></li>
<li>网络部分 8 bits，主机部分 24 bits</li>
<li>IP地址范围：<code>1.0.0.0</code> ～ <code>127.255.255.255</code></li>
</ul>
</li>
<li>B类<ul>
<li>网络部分前2位 —— <code>10</code></li>
<li>网络部分 16 bits，主机部分 16 bits</li>
<li>IP地址范围：<code>128.0.0.0</code> ～ <code>191.255.255.255</code></li>
</ul>
</li>
<li>C类<ul>
<li>网络部分前3位 —— <code>110</code></li>
<li>网络部分 24 bits，主机部分 8 bits</li>
<li>IP地址范围：<code>192.0.0.0</code> ～ <code>223.255.255.255</code></li>
</ul>
</li>
<li>D类<ul>
<li>前4位 —— <code>1110</code></li>
<li>用于多播地址</li>
</ul>
</li>
<li>E类<ul>
<li>前4位 —— <code>1111</code></li>
<li>被留作将来使用</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Classful-Addressing.png" style="zoom: 30%;" /></p>
<h4 id="子网掩码（subnet-mask）"><a href="#子网掩码（subnet-mask）" class="headerlink" title="子网掩码（subnet mask）"></a>子网掩码（subnet mask）</h4><ul>
<li>IP地址采用点分十进制：例如 <code>192.32.216.9</code></li>
<li>分类编制导致了地址资源的浪费</li>
<li>子网和子网掩码：可以减小地址资源的浪费</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_subnetting.png" style="zoom: 30%;" /></p>
<p>&emsp;&emsp;<code>200.23.16.64/27</code>中的<code>27</code>为 <strong>网络部分+子网部分 的位数</strong></p>
<ul>
<li>子网掩码<ul>
<li>网络部分+子网部分 置1</li>
<li>主机部分 置0</li>
</ul>
</li>
<li>子网的网络ID<ul>
<li>网络部分+子网部分 不变</li>
<li>主机部分 置0</li>
</ul>
</li>
</ul>
<h4 id="CIDR：无类的域间路由（Classless-InterDomain-Routing）"><a href="#CIDR：无类的域间路由（Classless-InterDomain-Routing）" class="headerlink" title="CIDR：无类的域间路由（Classless InterDomain Routing）"></a>CIDR：无类的域间路由（Classless InterDomain Routing）</h4><ul>
<li>IP分为两个部分 —— 子网部分 + 主机部分</li>
<li>子网部分可以是任意长度</li>
<li>地址格式：<code>a.b.c.d / x</code>，其中x是子网部分位数</li>
<li>网络部分称为前缀（prefix）</li>
</ul>
<h4 id="如何获取IP地址"><a href="#如何获取IP地址" class="headerlink" title="如何获取IP地址"></a>如何获取IP地址</h4><h5 id="主机如何获取IP地址"><a href="#主机如何获取IP地址" class="headerlink" title="主机如何获取IP地址"></a>主机如何获取IP地址</h5><p>主机获取IP地址：</p>
<ul>
<li>硬编码：自己设置静态的IP设置</li>
<li><strong>DHCP</strong>：动态主机配置（Dynamic Host Configuration Protocol）<br>&emsp;&emsp;当主机连接网络时，允许主机从网络服务器动态获取IP地址。</li>
</ul>
<h6 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h6><ul>
<li>即插即用</li>
<li>可以更新IP</li>
<li>地址重用：主机的IP只有在上线时才固定，下线即释放</li>
<li>支持移动用户</li>
</ul>
<p>&emsp;&emsp;当一台主机加入网络时，从子网中的DHCP服务器获取IP地址。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_DHCP.png" style="zoom: 50%;" /></p>
<h5 id="网络如何获取IP地址"><a href="#网络如何获取IP地址" class="headerlink" title="网络如何获取IP地址"></a>网络如何获取IP地址</h5><p>&emsp;&emsp;从ISP处获取分配的IP地址。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Network-route.png" style="zoom: 30%;" /></p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Network-get-IP.png" style="zoom: 30%;" /></p>
<h5 id="ISP如何获取IP地址"><a href="#ISP如何获取IP地址" class="headerlink" title="ISP如何获取IP地址"></a>ISP如何获取IP地址</h5><p>&emsp;&emsp;ISP从ICANN组织获取IP地址</p>
<p>ICANN：Internet Corporation for Assigned Names and Numbers</p>
<ul>
<li>分配地址</li>
<li>管理DNS</li>
<li>分配域名、解决争议</li>
</ul>
<h4 id="NAT：网络地址转换（Network-Address-Translation）"><a href="#NAT：网络地址转换（Network-Address-Translation）" class="headerlink" title="NAT：网络地址转换（Network Address Translation）"></a>NAT：网络地址转换（Network Address Translation）</h4><ul>
<li>从这个本地网络出去的报文都有着：相同的源IP+不同的端口号</li>
<li>对于外界网络来说，这个本地网络都是一个IP<ul>
<li>本地网络有内部地址，改变该内部地址不需要通知外部网络</li>
<li>改变ISP不需要改变本地网络的内部地址</li>
<li>内部地址在外部不可见（保障安全性）</li>
</ul>
</li>
<li>实现方式<ul>
<li>发送出去的报文：（源IP(内部的IP)，端口号）—&gt; （NAT IP(NAT统一的IP)，新端口号）<ul>
<li>外部发来的报文的目的地址填写：（NAT IP(NAT统一的IP)，新端口号）</li>
</ul>
</li>
<li>NAT转换表：记住（源IP(内部的IP)，端口号）&lt;—&gt; （NAT IP(NAT统一的IP)，新端口号）的转换对</li>
<li>收到的报文：根据NAT转换表，（NAT IP(NAT统一的IP)，新端口号）—&gt; （源IP(内部的IP)，端口号）</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network-address-translation.png" style="zoom: 50%;" /></p>
<ul>
<li>外部不知道内部的情况，所以外部不能发起通信</li>
<li>预留给内部的IP地址：<ul>
<li><code>10.0.0.0</code>~<code>10.255.255.255</code>（A类）</li>
<li><code>176.16.0.0</code>~<code>172.31.255.255</code>（B类）</li>
<li><code>192.168.0.0</code>~<code>192.168.255.255</code>（C类）</li>
</ul>
</li>
<li>可以有16bit的主机地址位（<code>10.0.0.0</code>~<code>10.255.255.255</code>），一个NAT支持内部60000+的连接</li>
<li>NAT存在争议<ul>
<li>路由器本来是在第3层，但NAT修改了端口号，而端口号包含在TCP/UDP的段结构里，即改了第4层的内容</li>
<li>违反了端到端</li>
<li>所以用IPv6来解决地址短缺</li>
</ul>
</li>
</ul>
<h4 id="ICMP：因特网控制消息协议（Internet-Control-Message-Protocol）"><a href="#ICMP：因特网控制消息协议（Internet-Control-Message-Protocol）" class="headerlink" title="ICMP：因特网控制消息协议（Internet Control Message Protocol）"></a>ICMP：因特网控制消息协议（Internet Control Message Protocol）</h4><h5 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h5><ul>
<li>主机、路由器、网关来交流网络层信息<ul>
<li>报错：到达不了主机、网络、端口、协议等等</li>
<li>用于探测：echo request/reply（使用ping）</li>
</ul>
</li>
<li>IP的一部分，但体系结构在IP之上：ICMP消息搭载在IP数据报上</li>
<li><strong>ICMP消息</strong>：type，code，引发错误的IP数据报首部和前8个字节</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Type</th>
<th><strong>Code</strong></th>
<th>description</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>echo reply (ping)</td>
<td>echo响应 (被程序ping使用）</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>dest. network unreachable</td>
<td>目标网络不可达</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>dest host unreachable</td>
<td>目标主机不可达</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>dest protocol unreachable</td>
<td>目标协议不可达</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>dest port unreachable</td>
<td>目标端口不可达</td>
</tr>
<tr>
<td>3</td>
<td>6</td>
<td>dest network unknown</td>
<td>未知的目标网络</td>
</tr>
<tr>
<td>3</td>
<td>7</td>
<td>dest host unknown</td>
<td>未知的目标主机</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>source quench (congestion control - not used)</td>
<td>源端关闭（拥塞控制）</td>
</tr>
<tr>
<td>8</td>
<td>0</td>
<td>echo request (ping)</td>
<td>Echo请求</td>
</tr>
<tr>
<td>9</td>
<td>0</td>
<td>route advertisement</td>
<td>路由通告</td>
</tr>
<tr>
<td>10</td>
<td>0</td>
<td>router discovery</td>
<td>路由器的发现/选择/请求</td>
</tr>
<tr>
<td>11</td>
<td>0</td>
<td>TTL expired</td>
<td>TTL 超时</td>
</tr>
<tr>
<td>12</td>
<td>0</td>
<td>bad IP header</td>
<td>IP 报首部参数错误</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>ICMP是管控制的IP的“兄弟”</li>
<li>ICMP被IP使用，同时作为网络层协议使用IP</li>
<li>ping、traceroute、path MTU discovery 都使用到了ICMP<ul>
<li>ping：使用 ICMP Echo request/repley msgs</li>
<li>path MTU discovery<ul>
<li>发送一个大的IP数据报，该数据报的 don’t fragment 置 1（即不分片）</li>
<li>减小数据报大小，直至成功（成功标志：没有接收到返回的ICMP消息）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a>Traceroute</h5><p>&emsp;&emsp;Traceroute程序：跟踪从一台主机到其他主机之间的路由，用ICMP报文实现。</p>
<ul>
<li>源发送一系列 UDP报文段 到目的<ul>
<li>第一个数据报 TTL=1，第二个数据报 TTL=2，以此类推</li>
<li>使用不常见的端口号</li>
</ul>
</li>
<li>当第n个数据报到达第n台主机时<ul>
<li>这个第n个数据报TTL刚好过期</li>
<li>路由器丢弃该数据报</li>
<li>路由器发送一个ICMP告警报文（type 11，code 0）给源</li>
<li>该ICMP告警报文包括第n台路由器名字及其IP</li>
</ul>
</li>
<li>当该ICMP报文返回到源主机，源主机计算RTT（往返时延），得到第n台路由器名字及其IP</li>
<li>标准的Traceroute程序用相同的TTL发送3个一组的分组，输出对每个TTL提供3个结果</li>
<li>停止条件步骤<ul>
<li>UDP数据报到达目的主机</li>
<li>目的主机返回 ICMP端口不可到达报文（type 3，code 3）</li>
<li>源主机接收到该ICMP报文，则停止</li>
</ul>
</li>
</ul>
<p>在Mac上可在app“系统信息”中的<code>窗口</code>-&gt;<code>网络实用工具</code>中使用Ping、Traceroute等工具。</p>
<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><ul>
<li>动机<ul>
<li>初动机：解决32位IP地址空间分配完的问题</li>
<li>更快处理/转发的头部格式</li>
<li>头部支持QoS</li>
</ul>
</li>
<li>IPv6数据报格式<ul>
<li>固定长度的头部：40 byte （IPv4头部长度不固定）</li>
<li>不允许分片</li>
</ul>
</li>
</ul>
<h4 id="IPv6数据报结构"><a href="#IPv6数据报结构" class="headerlink" title="IPv6数据报结构"></a>IPv6数据报结构</h4><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_IPv6-datagram-format.png" style="zoom:50%;" /></p>
<ul>
<li><p><strong>版本</strong>（Version, <strong>4 bit</strong>）<br>对于IPv6，字段的值是6（0110）。</p>
</li>
<li><p><strong>流量类型</strong>（Traffic class，<strong>8 bit</strong>）</p>
<p>用来标识对应IPv6的通信流类别，类似于IPv4中的ToS。</p>
</li>
<li><p><strong>流标签</strong>（Flow label，<strong>20 bit</strong>）</p>
<p>用来标记报文的数据流类型，以便在网络层区分不同的报文。</p>
</li>
<li><p><strong>有效载荷长度</strong>（Payload length，<strong>16 bit</strong>）</p>
<p>给出了IPv6数据报中跟在定长的40 byte数据报头部后面的字节数量。</p>
</li>
<li><p><strong>下一个头部</strong>（Next Header，<strong>8 bit</strong>）</p>
<p>该字段标识数据报中的内容（数据字段）需要交付给哪个协议（如TCP或UDP）。无扩展的头部，Next Header指向TCP/UDP；有扩展的头部，Next Header指向的下一个头部比如路由选择。与IPv4头部 协议（Protocol）字段相同。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Next-Header.png" style="zoom: 25%;" /></p>
</li>
<li><p><strong>跳段数限制</strong>（Hop limit，<strong>8 bit</strong>）</p>
<p>生存时间，相当于IPv4中的TTL。转发数据报的每台路由器讲对该字段内容 -1，如果跳转限制计数到0时，则丢弃该数据报</p>
</li>
<li><p><strong>源IP地址</strong>（Source Address，<strong>128 bit</strong>）</p>
</li>
<li><p><strong>目的IP地址</strong>（Destination Address，<strong>128 bit</strong>）</p>
</li>
<li><p><strong>数据</strong>（Data）</p>
</li>
</ul>
<h4 id="IPv6相较于IPv4的部分改变"><a href="#IPv6相较于IPv4的部分改变" class="headerlink" title="IPv6相较于IPv4的部分改变"></a>IPv6相较于IPv4的部分改变</h4><ul>
<li><strong>去除Checksum</strong>：加快了转发速度</li>
<li><strong>Options</strong>：依旧允许可选项，但是不放在头部，而是放在 Next Header 指出的位置上</li>
<li><strong>ICMPv6</strong>：ICMP的IPv6版本<ul>
<li>增加新的 type：比如“Packet Too Big”</li>
<li>包含<strong>多播组管理</strong></li>
</ul>
</li>
</ul>
<h4 id="IPv6地址"><a href="#IPv6地址" class="headerlink" title="IPv6地址"></a>IPv6地址</h4><ul>
<li><p>三种类型：<strong>单播</strong>（unicast）、<strong>多播</strong>（multicast）、<strong>任意播</strong>（anycast）</p>
</li>
<li><p><strong>冒号划分的十六进制</strong>（128 bit）</p>
<p>eg.  <code>68E6:8C64:FFFF:FFFF:0:1180:960A:FFFF</code></p>
</li>
<li><p><strong>0的压缩</strong></p>
<p>用双冒号<code>::</code>表示一组0或多组连续的0，但只能出现一次。</p>
<ul>
<li><code>FF05:0:0:0:0:0:0:B3</code> = <code>FF05::B3</code></li>
<li><code>0:0:0:0:0:0:128.10.2.1</code> = <code>::128.10.2.1</code>（IPv4和IPv6兼容的IP）</li>
<li><code>12AB:0:0:CD30:0:0:0:0</code> = <code>12AB::CD30:0:0:0:0</code> = <code>12AB:0:0:CD30::</code>（如果出现两个多个0，随意压一个都行）</li>
</ul>
</li>
</ul>
<h4 id="单播（Unicast-address）"><a href="#单播（Unicast-address）" class="headerlink" title="单播（Unicast address）"></a>单播（Unicast address）</h4><p>单播的地址格式（一共 128 bit）：</p>
<ul>
<li><p><strong>全球路由前缀</strong>（Global routing prefix，<strong>48 bit</strong>）</p>
<p>前3位为<code>001</code>，分配给公司和组织。</p>
</li>
<li><p><strong>子网ID</strong>（Subnet ID，<strong>16 bit</strong>）</p>
<p>如果是小公司，只需要1个子网的话，全设为0</p>
</li>
<li><p><strong>接口ID</strong>（Interface ID，<strong>64 bit</strong>）</p>
<p>基于 EUI-64</p>
</li>
</ul>
<h3 id="IPv4到IPv6的迁移"><a href="#IPv4到IPv6的迁移" class="headerlink" title="IPv4到IPv6的迁移"></a>IPv4到IPv6的迁移</h3><ul>
<li>现在的网络既有IPv4，也有IPv6。世界上的所有网从IPv4到IPv6需要很长的转换时间。</li>
<li>两种IPv4到IPv6的迁移<ul>
<li><strong>双栈</strong>（Dual Stack）：一些路由器可以兼容IPv4和IPv6</li>
<li><strong>隧道</strong>（Tunneling）：当IPv6穿过IPv4的路由器上时，将IPv6作为载荷承载在IPv4上</li>
</ul>
</li>
</ul>
<h4 id="双栈（Dual-Stack）"><a href="#双栈（Dual-Stack）" class="headerlink" title="双栈（Dual Stack）"></a>双栈（Dual Stack）</h4><ul>
<li>早期的设计</li>
<li>一些路由器有双栈（IPv4 &amp; IPv6），可以翻译这两种格式</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Dual-Stack.png" style="zoom:33%;" /></p>
<h4 id="隧道（Tunneling）"><a href="#隧道（Tunneling）" class="headerlink" title="隧道（Tunneling）"></a>隧道（Tunneling）</h4><p>&emsp;&emsp;当IPv6穿过IPv4的路由器上时，将IPv6作为载荷承载在IPv4上。就是像一个连接两个IPv6路由器的IPv4隧道</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Tunneling.png" style="zoom:50%;" /></p>
<h1 id="链路层（Link-Layer）"><a href="#链路层（Link-Layer）" class="headerlink" title="链路层（Link Layer）"></a>链路层（Link Layer）</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><p>保证<strong>帧</strong>流的透明传输</p>
<p><strong>链路层服务：</strong></p>
<ul>
<li><p><strong>成帧</strong>（Framing）、<strong>接入链路</strong>（link access）</p>
<ul>
<li><p>将来自上级的数据报分装成帧，加上header、trailer</p>
</li>
<li><p>完成共享媒体的信道连接</p>
</li>
<li>物理地址，用来 indentify 源/目的，在帧头中</li>
</ul>
</li>
<li><p>可靠交付（Reliable delivery）</p>
<ul>
<li>可靠数据传输协议（rdt）</li>
<li>在可靠的传输情况下很少应用，一般应用在高错误概率的链路传输中</li>
</ul>
</li>
<li><p>流量控制（Flow Control）</p>
<ul>
<li>协调发送方和接收方</li>
</ul>
</li>
<li><p>差错检测（Error Detection）</p>
</li>
<li><p>差错纠正（Error Correction）</p>
</li>
</ul>
<h2 id="成帧（Framing）"><a href="#成帧（Framing）" class="headerlink" title="成帧（Framing）"></a>成帧（Framing）</h2><p>&emsp;&emsp;主要考虑帧的界定，即如何将前一帧和后一帧分开。</p>
<h3 id="字符计数法（Character-count-method）"><a href="#字符计数法（Character-count-method）" class="headerlink" title="字符计数法（Character count method）"></a>字符计数法（Character count method）</h3><p>&emsp;&emsp;在每帧的前面添加 Counting header（本帧长度） </p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Character-count-method.png" style="zoom:33%;" /></p>
<h3 id="基于字符的首尾界定法（First-and-tail-bound-method-based-on-character）"><a href="#基于字符的首尾界定法（First-and-tail-bound-method-based-on-character）" class="headerlink" title="基于字符的首尾界定法（First and tail bound method based on character）"></a>基于字符的首尾界定法（First and tail bound method based on character）</h3><p>&emsp;&emsp;设定两个ASCII——SOH、EOT，SOH为标注开始的字符，EOT为标注结尾的字符。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Framing-First-and-tail.png" style="zoom:33%;" /></p>
<p>&emsp;&emsp;如果中间的数据部分也有SOH或EOT，则加入转义字符 EOT 标识。类似于C语言中的<code>\</code>的作用。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_EOT.png" style="zoom:33%;" /></p>
<h3 id="基于bit的首尾界定法（First-and-tail-bound-method-based-on-bit）"><a href="#基于bit的首尾界定法（First-and-tail-bound-method-based-on-bit）" class="headerlink" title="基于bit的首尾界定法（First and tail bound method based on bit）"></a>基于bit的首尾界定法（First and tail bound method based on bit）</h3><p>&emsp;&emsp;与基于字符的首尾界定法的思路相似，但开始和结束的标志为<code>01111110</code></p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Framing-First-and-tail-bit.png" style="zoom:33%;" /></p>
<p>&emsp;&emsp;为防止中间的数据部分也有<code>01111110</code>导致提前结束</p>
<ul>
<li>发送方：每5个<code>1</code>后插入一个<code>0</code></li>
<li>接收方：每5个<code>1</code>后删除一个<code>0</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_insert0.png" style="zoom:33%;" /></p>
<h3 id="物理层违逆码法（Pysical-layer-coding-violation-method）"><a href="#物理层违逆码法（Pysical-layer-coding-violation-method）" class="headerlink" title="物理层违逆码法（Pysical layer coding violation method）"></a>物理层违逆码法（Pysical layer coding violation method）</h3><p>比如在曼切斯特编码中，如果</p>
<ul>
<li>高低表示<code>1</code></li>
<li>低高表示<code>0</code></li>
<li>那么 低低/高高 就可以用来表示开始和结束</li>
</ul>
<p>&emsp;&emsp;违逆码只能应用在物理层，因为违逆码无法储存。</p>
<h2 id="差错检测（Error-Detection）"><a href="#差错检测（Error-Detection）" class="headerlink" title="差错检测（Error Detection）"></a>差错检测（Error Detection）</h2><p>&emsp;&emsp;通过增加<strong>冗余位（EDC）</strong>来检测差错。</p>
<p>&emsp;&emsp;差错检测不是100%可靠的。</p>
<ul>
<li>可能会漏掉一些错误，但是概率很小</li>
<li><p>更大的EDC检错能力更强</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Error-detection.png" style="zoom:50%;" /></p>
</li>
</ul>
<h3 id="奇偶校验（Parity-Checking）"><a href="#奇偶校验（Parity-Checking）" class="headerlink" title="奇偶校验（Parity Checking）"></a>奇偶校验（Parity Checking）</h3><ul>
<li><p><strong>单个奇偶校验位</strong>（Single Bit Parity）</p>
<p>&emsp;&emsp;分为奇校验和偶校验，EDC长度为1 bit。</p>
<p>如发送一个长为$d$ bit 的信息时，加EDC一共$d+1$ bit。</p>
<ul>
<li>偶校验中，则EDC需使这$d+1$ bit 中有偶数个<code>1</code>（即如果发送的信息有偶数个<code>1</code>，则EDC为<code>0</code>；奇数个<code>1</code>，则EDC为<code>1</code>）</li>
<li>奇校验中，则EDC需使这$d+1$ bit 中有奇数个<code>1</code>（即如果发送的信息有偶数个<code>1</code>，则EDC为<code>1</code>；奇数个<code>1</code>，则EDC为<code>0</code>）</li>
</ul>
<p>&emsp;&emsp;下图采用偶校验，信息D中共有9个<code>1</code>，所以偶校验位为<code>1</code>。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_One-bit-even-parity.png" style="zoom:50%;" /></p>
<p>&emsp;&emsp;奇偶校验只能检测出奇数个错误的情况。但由于现在传输的准确率很高，就算出错，大概率也就出 1 bit 的错误，所以使用简单的奇偶校验也能检测出大部分错误。</p>
</li>
<li><p><strong>二维奇偶校验</strong>（two-dimensional parity）</p>
<p>&emsp;&emsp;将$D$中的$d$ bit 划分成$i$行、$j$列，计算每行和每列的奇偶校验值，产生$i+j+1$个奇偶比特，即ECD长度为$i+j+1$ bit。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Two-dimensional-even-parity.png" style="zoom:50%;" /></p>
<p>&emsp;&emsp;二维奇偶校验不仅可以检测错误，还可以利用奇偶校验差错的行和列的索引找出错误的比特位，进行纠错。</p>
</li>
</ul>
<h3 id="CRC校验（Cyclic-Redundancy-Check）"><a href="#CRC校验（Cyclic-Redundancy-Check）" class="headerlink" title="CRC校验（Cyclic Redundancy Check）"></a>CRC校验（Cyclic Redundancy Check）</h3><p>&emsp;&emsp;CRC（Cyclic Redundancy Check），循环冗余检测。</p>
<p>思路：发送信息$D$，设置一个生成多项式，利用冗余位$R$，将$D+R$凑成生成多项式的整数倍，在接收方如果无法整除，则出差错。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_CRC.png" style="zoom:50%;" /></p>
<ul>
<li><p>生成多项式$G$和CRC比特位数</p>
<p>&emsp;&emsp;设置一个$r+1$ bit 的生成多项式，先将生成多项式$G(x)$化为二进制数$G$，最高位必须为$1$。</p>
<p>&emsp;&emsp;比如下面，三次项和常数项系数为$1$，则二进制数$G$的第四位和第一位为$1$</p>
<script type="math/tex; mode=display">
G(x)=x^3+1\ ,\quad G=1001</script><p>&emsp;&emsp;生成多项式$G$为$r+1$ bit，则CRC冗余位为$r$ bit。如此才能保证能把$D+R$凑成$G$的整数。</p>
</li>
<li><p>计算CRC冗余位$R$</p>
<p>&emsp;&emsp;增加$R$的目的是实现：</p>
<script type="math/tex; mode=display">
D\times 2^r \oplus R = nG</script><p>先将信息$D$乘以$2^r$，即左移$r$ bit，后面补<code>0</code>。再将移位后的$D\times 2^r$除$G$，但是中间步骤不用减，而用异或。比如</p>
<script type="math/tex; mode=display">
1001-1101=0100</script><p>&emsp;&emsp;信息$D$为<code>101110</code>，生成多项式$G(x)=x^3+1$。此时$r=3$，先在$D$后补$3$个<code>0</code>，得<code>101110000</code>，再除以$G=1001$</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_CRC-calculation.png" style="zoom:50%;" /></p>
<p>得到的余数<code>011</code>则为CRC冗余位$R$。</p>
<p>&emsp;&emsp;发送方发送信息$D$和冗余位$R$的拼接，即<code>101110011</code>。</p>
</li>
<li><p>接收方检错</p>
<p>&emsp;&emsp;接收方收到发送方发来的<code>101110011</code>后，将其除以生成多项式$G$ <code>1001</code>。如果整除则未检测到差错，否则检测到差错。</p>
</li>
</ul>
<h2 id="多路访问链路和协议（Multiple-Access-Links-and-Protocols）"><a href="#多路访问链路和协议（Multiple-Access-Links-and-Protocols）" class="headerlink" title="多路访问链路和协议（Multiple Access Links and Protocols）"></a>多路访问链路和协议（Multiple Access Links and Protocols）</h2><p>链路的两种类型：</p>
<ul>
<li><p>点对点链路（point-to-point link）</p>
<p>&emsp;&emsp;由链路一端的单个发送方和链路另一端的单个接收方组成。</p>
</li>
<li><p><strong>广播链路</strong>（broadcast link）</p>
<p>&emsp;&emsp;多个发送方和接收方，单一的、共享的信道。</p>
<p>&emsp;&emsp;<strong>多路访问协议</strong>（Multiple access protocol），规范结点在共享的广播信道上的传输行为。</p>
</li>
</ul>
<p>多路访问协议分类：</p>
<ul>
<li><strong>信道划分协议</strong>（channel partitioning protocol）<ul>
<li>静态</li>
<li>将信道平分给各节点</li>
<li>优点：公平、相互不干扰</li>
<li>缺点：闲置占有带宽</li>
</ul>
</li>
<li><strong>随机接入协议</strong>（random access protocol）<ul>
<li>动态</li>
<li>独占信道</li>
<li>允许冲突，并能从冲突中恢复</li>
</ul>
</li>
<li><strong>轮流协议</strong>（taking-turns protocol）<ul>
<li>上两种的结合</li>
<li>紧密协调共享访问以避免冲突</li>
</ul>
</li>
</ul>
<p>多路访问协议的目标：高效、公平、简单、分布式</p>
<h3 id="信道划分协议（Channel-Partitioning-protocols）"><a href="#信道划分协议（Channel-Partitioning-protocols）" class="headerlink" title="信道划分协议（Channel Partitioning protocols）"></a>信道划分协议（Channel Partitioning protocols）</h3><h4 id="时分多路复用（TDMA）"><a href="#时分多路复用（TDMA）" class="headerlink" title="时分多路复用（TDMA）"></a>时分多路复用（TDMA）</h4><p>&emsp;&emsp;TDM将时间划分为时间帧（frame），并进一步划分每个时间帧为$N$个时隙（slot），链路中的每条连接专用一个时隙。</p>
<p>&emsp;&emsp;详见 <a href="https://gy23333.github.io/2020/03/16/《计算机网络-自顶向下方法》笔记/#时分多路复用（TDM）">时分多路复用（TDM）</a>。</p>
<h4 id="频分多路复用（FDMA）"><a href="#频分多路复用（FDMA）" class="headerlink" title="频分多路复用（FDMA）"></a>频分多路复用（FDMA）</h4><p>&emsp;&emsp;链路中的每条连接专用一个频段。</p>
<p> &emsp;&emsp;详见 <a href="https://gy23333.github.io/2020/03/16/《计算机网络-自顶向下方法》笔记/#时分多路复用（TDM）">时分多路复用（FDM）</a> 。</p>
<h4 id="码分多址（CDMA）"><a href="#码分多址（CDMA）" class="headerlink" title="码分多址（CDMA）"></a>码分多址（CDMA）</h4><p> &emsp;&emsp;详见 <a href="[https://gy23333.github.io/2020/03/16/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0/#%E7%A0%81%E5%88%86%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%88Code-division-multiplexing%EF%BC%8CCDM%EF%BC%89](https://gy23333.github.io/2020/03/16/《计算机网络-自顶向下方法》笔记/#码分多路复用（Code-division-multiplexing，CDM）">码分多路复用（Code division multiplexing，CDM）</a>) 。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_CDMA.png" style="zoom:50%;" /></p>
<h3 id="随机接入协议（Random-Access-protocols）"><a href="#随机接入协议（Random-Access-protocols）" class="headerlink" title="随机接入协议（Random Access protocols）"></a>随机接入协议（Random Access protocols）</h3><ul>
<li>结点传输pkt时，占有信道全部带宽，结点间无优先级</li>
<li>存在多个传输结点 =&gt; 碰撞</li>
<li>随机接入协议明确了：<ul>
<li>如何检测碰撞</li>
<li>如何从碰撞中恢复</li>
</ul>
</li>
<li>常用的随机接入协议<ul>
<li>ALOHA</li>
<li>Slotted ALOHA</li>
<li>CSMA 和 CSMA/CD</li>
</ul>
</li>
</ul>
<h4 id="纯ALOHA（Pure-ALOHA）"><a href="#纯ALOHA（Pure-ALOHA）" class="headerlink" title="纯ALOHA（Pure ALOHA）"></a>纯ALOHA（Pure ALOHA）</h4><ul>
<li>非时隙、简单、完全分散</li>
<li>最早的ALOHA，目前已经不再使用</li>
<li>帧长一定 =&gt; 帧传输时间一定</li>
<li>当一帧首次到达（从网络层传下来），结点立即将该帧完整传输进广播信道</li>
<li>如果发送碰撞，则该结点<ul>
<li>有$p$的概率，将立即以重传该帧</li>
<li>有$1-p$的概率，等待一个帧传输时间，再以$p$的概率判断是否重传</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Pure-ALOHA.png" style="zoom:50%;" /></p>
<p>&emsp;&emsp;假设一帧在$t_0$处开始传输，则在$[t_0-1,t_0+1]$，其他结点如有传输，发生碰撞，则易损时间区长度为$2\tau$（$tau$为一帧的传输时间）。</p>
<p>&emsp;&emsp;一个结点发送成功，则需要本结点发送、其他结点在$[t_0-1,t_0]$和$[t_0,t_0+1]$不发送。一个给定结点成功传送的概率为</p>
<script type="math/tex; mode=display">
\begin{split} 
  P(success\ by\ given\ node)=&P(node\ transmits)\times\\
    & P(no\ other\ node\ transmits\ in\ [t_0-1,t_0])\times\\
    & P(no\ other\ node\ transmits\ in\ [t_0,t_0+1])\\
    =&p\times (1-p)^{N-1}\times (1-p)^{N-1}\\
    =&p\times (1-p)^{2(N-1)}
 \end{split}</script><p>则有$N$个结点，任意一个结点成功传送的概率为</p>
<script type="math/tex; mode=display">
S=Np(1-p)^{2(N-1)}</script><p>如此，求得纯ALOHA的最大效率为$1/(2e)\approx 0.18$（改变$p$，使$S$最大化）。</p>
<h4 id="时隙ALOHA（Slotted-ALOHA）"><a href="#时隙ALOHA（Slotted-ALOHA）" class="headerlink" title="时隙ALOHA（Slotted ALOHA）"></a>时隙ALOHA（Slotted ALOHA）</h4><ul>
<li>时间被划分成长度相等的时隙（slot）</li>
<li>结点只在时隙起点开始传输帧</li>
<li>如果碰撞，在下一时隙的开始以$p$的概率重传，直至成功。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Slotted-ALOHA.png" style="zoom:50%;" /></p>
<p>&emsp;&emsp;假设一帧在$t_0$处开始传输，则在本时隙中，其他结点如有传输，发生碰撞，则易损时间区长度为$\tau$（$\tau$为一帧的传输时间）。</p>
<p>&emsp;&emsp;一个给定结点成功传送的概率为</p>
<script type="math/tex; mode=display">
S=p(1-p)^{N-1}</script><p>&emsp;&emsp;如果有$N$个活跃结点，任意一个结点成功传送的概率为</p>
<script type="math/tex; mode=display">
S=Np(1-p)^{N-1}</script><p>如此，求得时隙ALOHA的最大效率为$1/e\approx 0.37$（改变$p$，使$S$最大化）。即在有大量结点有帧要传输时，最多$37%$的时隙做有用的工作，信道传输速率不是$R$ bps，而是$0.37R$ bps。</p>
<p>&emsp;&emsp;时隙ALOHA的最大效率是纯ALOHA的两倍。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_ALOHA-Compare.png" style="zoom: 33%;" /></p>
<h4 id="CSMA：载波侦听多路访问"><a href="#CSMA：载波侦听多路访问" class="headerlink" title="CSMA：载波侦听多路访问"></a>CSMA：载波侦听多路访问</h4><p>&emsp;&emsp;载波侦听多路访问（CSMA，Carrier Sense Multiple Access），一个结点在传输前先侦听信道。</p>
<ul>
<li><p>如果侦听到<strong>信道空闲</strong>，则传输帧</p>
</li>
<li><p>如果侦听到<strong>信道正忙</strong>，则推迟传输。再传输方式分为坚持型和非坚持型：</p>
<ul>
<li><strong>坚持型CSMA</strong>（Persisitent CSMA）：一直坚持监听，直到信道空闲时，立即以概率$p$重试（可能导致不稳定）。其中<strong>1-坚持型CSMA</strong>的$p=1$，即立即重试。</li>
<li><strong>非坚持型CSMA</strong>（Non-Persisitent CSMA）：不再监听，等待一个随机的时间之后再进行监听。</li>
</ul>
</li>
<li><p>CSMA依旧会发生<strong>碰撞</strong></p>
<p>&emsp;&emsp;只要共享信道，那么碰撞就是不可避免的，即使CSMA有侦听。</p>
<p>&emsp;&emsp;比如下图中，B结点在$t_0$时传输帧，但是帧的传输是需要一定时间的，这就导致在$t_1$时，D结点侦听判断信道空闲，传输帧。两信号发生碰撞。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_CSMA-Collision.png" style="zoom: 40%;" /></p>
<p>&emsp;&emsp;如此，整个帧传输时间被浪费了。可以看出，广播信道的端到端<strong>信道传播时延</strong>（distance and propagation delay）（信号从一个结点到另一个结点的传播时间）在决定性能上起关键作用。</p>
</li>
</ul>
<h4 id="CSMA-CD：具有碰撞检测的载波侦听多路访问"><a href="#CSMA-CD：具有碰撞检测的载波侦听多路访问" class="headerlink" title="CSMA/CD：具有碰撞检测的载波侦听多路访问"></a>CSMA/CD：具有碰撞检测的载波侦听多路访问</h4><ul>
<li>碰撞要在短时间内检测出来（最好在一个争用期内）</li>
<li>一旦检测到碰撞立即停止传输，以减少信道的浪费</li>
<li>采样坚持型或非坚持型重传</li>
<li>碰撞检测<ul>
<li>有线网络检测碰撞比较简单：如阈值法、过零法等等</li>
<li>无线网络检测碰撞比较困难</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;如下图，当B结点和D结点检测到碰撞时，立即停止继续发送。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_CSMA%3ACD.png" style="zoom: 40%;" /></p>
<p><strong>争用期</strong>：以太网的端到端往返时间$2\tau$</p>
<p>&emsp;&emsp;A结点给B结点发送帧流，最坏情况就是在即将发送到B结点时，发生碰撞，返回碰撞信息，最大用时即为$2\tau$。</p>
<p><strong>最短帧</strong>：最短帧长度为$2\tau R$（$R$为信道速率）</p>
<p>&emsp;&emsp;和上述同样的最坏情况中，从A结点发送帧，到碰撞信号返回到A结点花费$2\tau$的时间，在此期间A结点不能停止帧的发送，所以最短帧的长度为$2\tau R$。</p>
<p>&emsp;&emsp;如此可以最大利用网络效率，而且不会产生二义型。如果发送完了这个帧，没有发生碰撞，则发生成功。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_CSMA%3ACD1.png" style="zoom:50%;" /></p>
<p><strong>CSMA/CD 效率</strong></p>
<p>&emsp;&emsp;CSMA/CD 效率：当有大量的活跃结点，且每个结点有大量的帧要发送时，帧在信道中无碰撞地传输的那部分时间在长期运行时间中所占的份额。</p>
<script type="math/tex; mode=display">
efficiency = \frac 1{1+t_{prop}/t_{trans}}</script><p>其中，$t_{prop}$为两结点之间的最大传播时间；</p>
<p>&emsp;&emsp;&emsp;$t_{trans}$为传输一个最大长度的帧的时间。</p>
<p>效率趋近1，则需</p>
<ul>
<li>$t_{prop}$ -&gt; 0</li>
<li>或，$t_{trans}$ -&gt; $\infty$</li>
</ul>
<p>&emsp;&emsp;CSMA/CD 比 ALOHA 简单、便宜、分布式。</p>
<h3 id="轮流协议（Taking-Turns-protocol）"><a href="#轮流协议（Taking-Turns-protocol）" class="headerlink" title="轮流协议（Taking-Turns protocol）"></a>轮流协议（Taking-Turns protocol）</h3><h4 id="轮询协议（Polling-protocol）"><a href="#轮询协议（Polling-protocol）" class="headerlink" title="轮询协议（Polling protocol）"></a>轮询协议（Polling protocol）</h4><ul>
<li><p>有一个主结点</p>
</li>
<li><p>主结点以循环的方式轮询每个结点</p>
</li>
<li><p>主结点先向一个结点发送报文，告诉能够传输的帧的最多的数量，这个结点传输完帧后，主机点再发给下一个结点报文，循环轮询。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Polling-protocol.png" style="zoom:30%;" /></p>
</li>
<li><p>缺点：</p>
<ul>
<li>主结点需先给结点发送报文，增加开销</li>
<li>轮询时延，不及时</li>
<li>如果主结点出故障，则整个网络无法工作</li>
</ul>
</li>
</ul>
<h4 id="令牌传递协议（Token-Passing-protocol）"><a href="#令牌传递协议（Token-Passing-protocol）" class="headerlink" title="令牌传递协议（Token-Passing protocol）"></a>令牌传递协议（Token-Passing protocol）</h4><ul>
<li><p><strong>令牌</strong>（token）在结点之间以某种固定次序进行交换</p>
</li>
<li><p>结点只有在拿到令牌时，才能发送帧</p>
</li>
<li><p>受控的，不会发生碰撞</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Token-Passing-protocol.png" style="zoom:30%;" /></p>
</li>
<li><p>缺点：</p>
<ul>
<li>令牌开销</li>
<li>时延</li>
<li>令牌环会故障</li>
</ul>
</li>
</ul>
<h2 id="局域网技术"><a href="#局域网技术" class="headerlink" title="局域网技术"></a>局域网技术</h2><h3 id="局域网模型"><a href="#局域网模型" class="headerlink" title="局域网模型"></a>局域网模型</h3><p>&emsp;&emsp;局域网模型中，<strong>数据链路层</strong>分为LLC子层和MAC子层。</p>
<ul>
<li><strong>逻辑链路控制层</strong>（Logical Link Control，<strong>LLC</strong>）：为上层（网络层）提供连接环境</li>
<li><strong>媒体接入层</strong>（Media Access Control，<strong>MAC</strong>）：为下层（物理层）提供媒体接入</li>
</ul>
<h3 id="局域网地址和ARP"><a href="#局域网地址和ARP" class="headerlink" title="局域网地址和ARP"></a>局域网地址和ARP</h3><h4 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h4><ul>
<li><p>可以叫<strong>MAC 地址</strong>、<strong>LAN地址</strong>、<strong>物理地址</strong></p>
</li>
<li><p>用于从一个接口到另一个物理连接的接口（同一网络）获取数据报</p>
</li>
<li><p>MAC地址长度：$48$ bit / $6$ byte</p>
</li>
<li><p>与硬件有关，一个网卡（适配器）对应一个MAC地址</p>
</li>
<li><p>例如：<code>1A-2F-BB-76-09-AD</code></p>
</li>
<li><p>与局域网相连的每个接口都有唯一的MAC地址</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_MAC-address.png" style="zoom:50%;" /></p>
</li>
<li><p>MAC地址由IEEE分配</p>
</li>
<li><p>IEEE给公司固定MAC地址的前$24$ bit，后$24$ bit由公司保证每个适配器MAC地址的唯一性</p>
</li>
<li><p>IP地址和MAC地址的关系：IP地址就像是一个邮件地址，解决在哪上网的问题；MAC地址像身份证，解决谁在上网的问题</p>
<ul>
<li>IP地址<strong>层次结构</strong>，主机移动，主机的IP地址也改变</li>
<li>MAC地址<strong>扁平寻址结构</strong>，不会因为位置改变MAC地址</li>
</ul>
</li>
</ul>
<h4 id="ARP：地址解析协议"><a href="#ARP：地址解析协议" class="headerlink" title="ARP：地址解析协议"></a>ARP：地址解析协议</h4><p>&emsp;&emsp;ARP（Address Resolution Protocol），地址解析协议</p>
<ul>
<li><p>局域网中的每个IP结点（主机、路由器）都有ARP表</p>
</li>
<li><p><strong>ARP表</strong>：局域网结点的IP地址和MAC地址的对应关系</p>
<ul>
<li>每行的结构：<code>&lt;IP address; MAC address; TTL&gt;</code></li>
<li><code>TTL</code>：存活时间，过TTL的时间要丢弃这一行数据</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_APR.png" style="zoom:50%;" /></p>
</li>
</ul>
<h5 id="同一子网内的地址解析"><a href="#同一子网内的地址解析" class="headerlink" title="同一子网内的地址解析"></a>同一子网内的地址解析</h5><p>&emsp;&emsp;A想要发送数据报给B，但是B的MAC地址没有记录在A的ARP表中。</p>
<ul>
<li>A发送一个<strong>广播帧</strong>——查询ARP分组，包含B的IP地址<ul>
<li>目的MAC地址：<code>FF-FF-FF-FF-FF-FF</code></li>
<li>所有结点都会收到该ARP查询分组</li>
</ul>
</li>
<li>B接收到ARP分组，给A回复B的MAC地址<ul>
<li>给A的MAC地址<strong>单播</strong>帧——响应APR分组</li>
</ul>
</li>
<li>A在ARP表中缓存IP到MAC地址对，直至超时TTL</li>
</ul>
<p>&emsp;&emsp;ARP即插即用：ARP表自动建立，不需要系统管理员来配置</p>
<h5 id="不同子网的地址解析"><a href="#不同子网的地址解析" class="headerlink" title="不同子网的地址解析"></a>不同子网的地址解析</h5><p>&emsp;&emsp;不同子网的A和B通过路由器R发送数据报，A只知道B的IP地址，不知道B的MAC地址</p>
<ul>
<li>A创建IP报文（IP地址在整个传输过程中不改变）<ul>
<li>源IP地址：A的IP</li>
<li>目的IP地址：B的IP</li>
</ul>
</li>
<li>A创建数据帧，在IP报文的基础上，加上MAC地址<ul>
<li>源MAC地址：A的MAC</li>
<li>目的MAC地址：路由器R左端的MAC（路由器R左端与A在一个子网中）</li>
</ul>
</li>
<li>帧从A传到路由器R</li>
<li>路由器R接收帧，并从路由器R的数据链路层传到网络层，从数据帧拆成IP数据报</li>
<li>路由器R在IP报文的基础上，加上新的MAC地址段，传到数据链路层<ul>
<li>源MAC地址：路由器R右端的MAC（路由器R右端与B在一个子网中）</li>
<li>目的MAC地址：B的MAC</li>
</ul>
</li>
<li>帧从路由器R传到B，B接收到数据</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_ARP.gif" alt=""></p>
<h3 id="以太网（Enternet）"><a href="#以太网（Enternet）" class="headerlink" title="以太网（Enternet）"></a>以太网（Enternet）</h3><h4 id="以太网物理拓扑"><a href="#以太网物理拓扑" class="headerlink" title="以太网物理拓扑"></a>以太网物理拓扑</h4><ul>
<li><p><strong>总线型</strong></p>
<p>&emsp;&emsp;早期流行，所有的结点共用一条总线。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Ethernet-Bus.png" style="zoom:35%;" /></p>
</li>
<li><p><strong>星型</strong></p>
<p>&emsp;&emsp;以太网现在使用的拓扑结构，中间是交换机，所有结点和交换机的连接是唯一的，不会发生冲突。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Ethernet-Star.png" style="zoom:27%;" /></p>
</li>
</ul>
<h4 id="以太网帧结构"><a href="#以太网帧结构" class="headerlink" title="以太网帧结构"></a>以太网帧结构</h4><p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Ethernet-Frame-Structure.png" style="zoom:50%;" /></p>
<ul>
<li><p><strong>前导码</strong>（Preamble，<strong>7 byte</strong>）</p>
<p>7 bytes 的方波<code>10101010</code>，用于“唤醒”接收适配器，并将它们的时钟与发送方的时钟同步。</p>
</li>
<li><p><strong>帧开始符</strong>（Start of Frame Delimiter(SFD)，<strong>1 byte</strong>）</p>
<p><code>10101011</code>，用来警告接收适配器，要开始了。</p>
</li>
<li><p><strong>目的MAC地址</strong>（Destination address，<strong>6 byte</strong>）</p>
<p>目的适配器的MAC地址。</p>
</li>
<li><p><strong>源MAC地址</strong>（Source address，<strong>6 byte</strong>）</p>
<p>源适配器的MAC地址。</p>
</li>
<li><p><strong>类型</strong>（Type，<strong>2 byte</strong>）</p>
<p>上层的协议。比如，IP协议对应<code>0X0800</code>。</p>
</li>
<li><p><strong>数据</strong>（Data，<strong>46~1500 byte</strong>）</p>
<p>IP数据报。</p>
<ul>
<li><p>最小长度——46 byte</p>
<p>由$2\tau R$决定。IEEE 802.3中，$2\tau$为$51.2\mu s$，$R=10Mbps$，由此得到最小帧长度$64\ bytes$。再减去$18\ bytes$的其他部分，得到最小数据的长度$46\ bytes$。</p>
<p>详见<a href="https://gy23333.github.io/2020/03/16/《计算机网络-自顶向下方法》笔记/#CSMA-CD：具有碰撞检测的载波侦听多路访问">CSMA-C中的最短帧</a>。</p>
<p>小于最小长度得补充到46 byte。</p>
</li>
<li><p>最大长度——1500 byte</p>
<p>超过最大长度得分片。</p>
</li>
</ul>
</li>
<li><p><strong>帧校验序列</strong>（FCS，<strong>4 byte</strong>）</p>
<p>错误检测机制，比如CRC。</p>
</li>
</ul>
<h4 id="以太网技术"><a href="#以太网技术" class="headerlink" title="以太网技术"></a>以太网技术</h4><ul>
<li><strong>无连接</strong>：不需要握手</li>
<li><strong>不可靠</strong>：不需要发送ack或nack</li>
<li>以太网MAC协议：<strong>非时隙、1-坚持、二进制指数退避的CSMA/CD</strong></li>
</ul>
<h5 id="二进制指数退避CSMA-CD算法"><a href="#二进制指数退避CSMA-CD算法" class="headerlink" title="二进制指数退避CSMA/CD算法"></a>二进制指数退避CSMA/CD算法</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">A: <span class="comment">//A事件</span></span><br><span class="line">sense channel, <span class="keyword">if</span> idle <span class="comment">//如果侦听信道空闲</span></span><br><span class="line">then &#123;</span><br><span class="line">  transmit <span class="keyword">and</span> monitor the channel; <span class="comment">//传输并监听信道（监听是否有其他站点在传输）</span></span><br><span class="line">  <span class="keyword">if</span> detect another transmission <span class="comment">//如果监听到其他站点在传输</span></span><br><span class="line">    then &#123;</span><br><span class="line">      <span class="built_in">abort</span> <span class="keyword">and</span> send jam signal; <span class="comment">//停止并发送jam信号（将冲突信号发送给其他站点）</span></span><br><span class="line">      update <span class="meta"># collisions; <span class="comment">//更新冲突次数（冲突次数+1）</span></span></span><br><span class="line">      <span class="built_in">delay</span> as required by exponential backoff algorithm; <span class="comment">//调用二进制指数退避算法来延时</span></span><br><span class="line">      <span class="keyword">goto</span> A <span class="comment">//重新执行A事件</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;done with the frame; <span class="built_in">set</span> collisions to zero&#125; <span class="comment">//如果在传输的过程中没监听到其他站点在传输，则完成帧的传输，并将冲突次数清零</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;wait until ongoing transmission is over <span class="keyword">and</span> <span class="keyword">goto</span> A&#125; <span class="comment">//如果侦听信道在忙，则继续侦听，直至信道空闲，再发送（1-坚持）；如果是非坚持，则等待一个随机的时间之后再进行监听</span></span><br></pre></td></tr></table></figure>
<p><strong>Jam Signal</strong>：长$48\ bits$，保证每个其他的发送方意识到冲突</p>
<h5 id="二进制指数退避算法（Binary-Exponential-Backoff-Algorithm）"><a href="#二进制指数退避算法（Binary-Exponential-Backoff-Algorithm）" class="headerlink" title="二进制指数退避算法（Binary Exponential Backoff Algorithm）"></a>二进制指数退避算法（Binary Exponential Backoff Algorithm）</h5><p>&emsp;&emsp;一旦检测到冲突，为降低再冲突的概率，需要等待一个随机时间，二进制指数退避算法即解决时延时间的问题。</p>
<p>&emsp;&emsp;时延的时间为端到端的往返时间$2\tau$的整数倍，即$2\tau \times n$（$n$为整数）。$k$为冲突次数collisions。</p>
<ol>
<li>初始的冲突次数$k=0$；</li>
<li>每冲突一次，则$k=k+1$；</li>
<li>如果$k&lt;10$，$n$从$[0, 2^k)$中随机选择一个整数（注意⚠️：右边为开区间），则延时$2\tau \times n$的时间；</li>
<li>如果$k\geq 10$，则$n$从${0,1,2,3,…,1023}$中随机选择一个，延时$2\tau \times n$的时间。（$k$在$10$之后就不再增加时延的选择范围，防止延时过长）</li>
</ol>
<h5 id="802-3以太网标准"><a href="#802-3以太网标准" class="headerlink" title="802.3以太网标准"></a>802.3以太网标准</h5><p>不同的以太网标准有：</p>
<ul>
<li>相同的MAC协议和帧格式</li>
<li>不同的速度：$2/ Mbps$、$10\ Mbps$、$100\ Mbps$等等</li>
<li>不同的物理层媒体：光纤、铜线</li>
</ul>
<p>&emsp;&emsp;下图为$100\ Mbps$以太网标准，其中100代表$100\ Mbps，TX、T2、T4代表媒体为不同的铜线，FX、SX、BX代表媒体为不同的光纤。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Ethernet-standards.png" style="zoom:50%;" /></p>
<h3 id="交换机（Switch）"><a href="#交换机（Switch）" class="headerlink" title="交换机（Switch）"></a>交换机（Switch）</h3><h4 id="集线器（Hub）"><a href="#集线器（Hub）" class="headerlink" title="集线器（Hub）"></a>集线器（Hub）</h4><ul>
<li>物理层设备：相当于工作在bit 层的传话筒，将接收到的bit从一个接口传到其他的所有接口</li>
<li>层级结构</li>
<li>每个连接的LAN称为LAN网段</li>
<li>集线器不会隔离冲突域</li>
<li>集线器的优点<ul>
<li>简单便宜</li>
<li>如果一个集线器发生故障，则局域网的其他部分将继续运行</li>
<li>扩展节点对之间的最大距离（每个集线器100m）</li>
</ul>
</li>
<li>集线器的缺点<ul>
<li>未隔离冲突域，导致最大吞吐量没有增加（多层吞吐量与单段吞吐量相同）</li>
<li>单独的LAN限制对相同冲突域中的结点数以及允许的总地理覆盖范围进行了限制</li>
<li>无法连接不同的以太网类型（例如10BaseT和100baseT）</li>
</ul>
</li>
<li>由于上述缺陷，如今大部分集线器已被交换机取代</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_hub.png" style="zoom: 33%;" /></p>
<h4 id="以太网交换机概述"><a href="#以太网交换机概述" class="headerlink" title="以太网交换机概述"></a>以太网交换机概述</h4><ul>
<li>交换机，也可以叫网桥</li>
<li>链路层设备<ul>
<li>存储、转发以太网帧</li>
<li>检查传入的帧的MAC地址，有选择地将帧转发到一个或多个传出链路，使用CSMA / CD访问段<ul>
<li>收到的帧与发送的结点在同一网段，则丢弃该帧</li>
<li>收到的帧的目的MAC地址在转发表里，且与发送的结点不在同一网段，则向目的地址所对应端口转发该帧</li>
<li>收到的帧的目的MAC地址不在转发表里，则泛洪</li>
</ul>
</li>
</ul>
</li>
<li>透明：主机不知道交换机的存在</li>
<li>即插即用，自学习（不需要配置交换机）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_switch1.png" style="zoom: 33%;" /></p>
<ul>
<li>主机有专用的、直接的到交换机的连接</li>
<li>交换机缓存pkt</li>
<li>每个输入链路都使用以太网协议，但是没有冲突</li>
<li>全双工</li>
<li>每个链路都是自己的冲突域</li>
<li>A至A’和B至B’可以同时传输而不会发生冲突</li>
</ul>
<h4 id="交换机自学习"><a href="#交换机自学习" class="headerlink" title="交换机自学习"></a>交换机自学习</h4><ul>
<li>每个交换机都有一张<strong>交换表</strong>作为转发表，交换表的每行数据为<code>&lt;MAC address, interface, TTL&gt;</code>，即MAC地址、通向该MAC地址的接口、存活时间。</li>
<li>交换机表初始为空</li>
<li>交换机每接收到一个帧，就记录一条数据（发送结点的数据）</li>
<li>过了TTL，则删掉该条数据</li>
</ul>
<h4 id="交换机转发与过滤"><a href="#交换机转发与过滤" class="headerlink" title="交换机转发与过滤"></a>交换机转发与过滤</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">when frame received at <span class="keyword">switch</span>: <span class="comment">//交换机接收到帧</span></span><br><span class="line">  <span class="number">1.</span> record incoming link, MAC address of sending host <span class="comment">//在交换表中记录发送方的传入接口、MAC地址</span></span><br><span class="line">  <span class="number">2.</span> index <span class="keyword">switch</span> table <span class="keyword">using</span> MAC destination address <span class="comment">//在交换表中查找目的MAC地址</span></span><br><span class="line">  <span class="number">3.</span> <span class="keyword">if</span> entry found <span class="keyword">for</span> destination <span class="comment">//如果在交换表找到了该目的MAC地址</span></span><br><span class="line">     then &#123;</span><br><span class="line">        <span class="keyword">if</span> destination on segment from which frame arrived then drop frame <span class="comment">//如果目的与发送方在同一网段，则丢弃该帧</span></span><br><span class="line">        <span class="keyword">else</span> forward frame on interface indicated by entry  <span class="comment">//如果不在同一网段，则转发帧到相应接口</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> flood <span class="comment">//如果在交换表找到不到该目的MAC地址，则泛洪（转发到除发送方所在接口以外的所有接口）</span></span><br></pre></td></tr></table></figure>
<h4 id="交换机-vs-路由器"><a href="#交换机-vs-路由器" class="headerlink" title="交换机 vs 路由器"></a>交换机 vs 路由器</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>路由器</th>
<th>交换机</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储转发</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>所在层</td>
<td>网络层设备（检查网络层头部）</td>
<td>链路层设备（检查链路层头部）</td>
</tr>
<tr>
<td>转发表</td>
<td>使用路由算法，IP地址</td>
<td>使用泛洪，自学习，MAC地址</td>
</tr>
</tbody>
</table>
</div>
<h3 id="VLAN：虚拟局域网"><a href="#VLAN：虚拟局域网" class="headerlink" title="VLAN：虚拟局域网"></a>VLAN：虚拟局域网</h3><p>&emsp;&emsp;交换机以太网存在缺点：缺乏广播隔离，导致易产生广播风暴。</p>
<p>&emsp;&emsp;为解决上述问题，采用虚拟局域网VLAN。</p>
<p>&emsp;&emsp;VLAN：在单个LAN内，将支持VLAN功能的交换机配置为多个虚拟LAN。</p>
<h4 id="基于端口的VLAN"><a href="#基于端口的VLAN" class="headerlink" title="基于端口的VLAN"></a>基于端口的VLAN</h4><p>&emsp;&emsp;将单个LAN基于端口划分为多个VLAN。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_VLAN.png" style="zoom: 50%;" /></p>
<ul>
<li>流量隔离：帧只能在本VLAN内往返（VLAN相当于一个真实的局域网，将功能限制在链路层，只能传帧）</li>
<li>VLAN之间的转发：通过路由完成（就像使用单独的交换机一样）</li>
<li>动态成员资格：端口可以在VLAN之间动态分配</li>
</ul>
<h4 id="跨多个交换机的VLAN"><a href="#跨多个交换机的VLAN" class="headerlink" title="跨多个交换机的VLAN"></a>跨多个交换机的VLAN</h4><ul>
<li><p>最早采用实体线相连，后采用中继端口。</p>
</li>
<li><p><strong>中继端口</strong>（trunk port）：也可以叫共享端口，在多个物理交换机上定义的VLAN之间传送帧。</p>
<p>下图中，a为实体线相连，b为中继端口连。</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_Connecting-two-VLAN.png" style="zoom: 50%;" /></p>
</li>
<li><p>802.1q：原802.1帧未带有VLAN标识，所以802.1q协议为中继端口之间转发的帧添加/删除了其他报头字段</p>
<p><img src="https://raw.githubusercontent.com/GY23333/imgs/master/Network_VLAN-frame.png" style="zoom: 50%;" /></p>
<ul>
<li>增加了$4\ byte$</li>
<li>前$2\ byte$为协议标识</li>
<li>后$2\ byte$中，前$12\ bit$为VLAN的ID，后$3\ bit$为优先级</li>
<li>由于位数改变，CRC需重算</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
